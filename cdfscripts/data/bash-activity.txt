0 :: ASSERT(valid_mfn(gmfn)if(unlikely(GUEST_PAGING_LEVELS==3&&level==3))returnflags;
0 :: ASSERT(((_p)->u.inuse.type_info&PGT_type_mask)==(_t))
1 :: ASSERT(pg->u.sh.type==SH_type_l2_32_shadow||pg->u.sh.head);
5 :: ASSERT(spin_is_locked(&iommu->lock));
4 :: ASSERT(page->nr_validated_ptes);
10 :: ASSERT((result==-1)||(result>=16));
10 :: ASSERT(sh_mfn_is_a_page_table(gmfn));
2 :: ASSERT((page->shadow_flags&(SHF_L4_64|SHF_L3_64|SHF_L2_64|SHF_L1_64))==0);
2 :: ASSERT(stack!=0);
9 :: ASSERT((htab_raddr&(htab_bytes-1))==0);
12 :: ASSERT(v->arch.hvm_vmx.launch_cpu==smp_processor_id());
14 :: ASSERT((l1e_get_flags(_nl1e)&L1_DISALLOW_MASK)==0);
9 :: ASSERT(IMPLY(inf->status&EXTRA_AWARE,extraq_on(d,EXTRA_UTIL_Q)));
27 :: ASSERT(buffer_mach);
2 :: ASSERT(((tlbflush_clock+1)&TLBCLOCK_EPOCH_MASK)==0);
10 :: ASSERT(spin_is_locked(&d->mm.shadow_lock));
3 :: ASSERT(next_prime->evt>next->evt);
0 :: ASSERT(p1->p_tracecred!=NULL,("ktracevnodewithnocred"));
1 :: ASSERT(!pgp->us.obj->pool->persistent);
4 :: ASSERT(p2m_locked_by_me(p2md));
2 :: ASSERT(pcpu.apic_id!=BAD_APICID);
1 :: ASSERT((unsignedlong)pg-FRAMETABLE_VIRT_START<FRAMETABLE_VIRT_END);
3 :: ASSERT(ivrs_mappings!=NULL);
1 :: ASSERT((obj!=NULL)&&((objnew==obj)||(objfound==obj))&&(objnew!=objfound));
2 :: ASSERT(obj->pgp_count==0);
2 :: ASSERT(mfn_to_page(_sl4mfn)->u.sh.type==SH_type_l4_64_shadow);
10 :: ASSERT(pg);
3 :: ASSERT(mfn_valid(mfn_x(gw->l1mfn)));
0 :: ASSERT((fd==-1&&(flags==(MAP_SHARED|MAP_ANON)||flags==(MAP_PRIVATE|MAP_ANON)));||(fd!=-1&&flags==MAP_SHARED));||(fd!=-1&&flags==MAP_SHARED));
4 :: ASSERT(!start);
4 :: ASSERT(!(aiocbp->aio_nbytes&(dev->sector_size-1)));
2 :: ASSERT(regs==guest_cpu_user_regs());
4 :: ASSERT(ALIGN((unsignedlong)ioc->pdir_base,4*1024)==(unsignedlong)ioc->pdir_base);
3 :: ASSERT(!paging_mode_external(v->domain));
7 :: ASSERT(*addr==(u32)*addr);
10 :: ASSERT(mfn_to_shadow_page(_sl2mfn)->type==SH_type_l2_32_shadow);
7 :: ASSERT((_d)->arch.shadow.locker==current->processor);
7 :: ASSERT(sh_mfn_is_a_page_table(mfn));
5 :: ASSERT(!shadow_mode_external(v->domain));
2 :: ASSERT(d->arch.shadow2_total_pages==0);
4 :: ASSERT(shadow2_mode_external(d));
2 :: ASSERT(order<=SHADOW2_MAX_ORDER);
4 :: ASSERT(!d->arch.physmap_built);
9 :: ASSERT(action->ack_type!=ACKTYPE_NONE);
3 :: ASSERT(!__task_on_queue(v));
5 :: ASSERT(!virq_is_global(virq));
2 :: ASSERT(buffer[index+0]==0x0f&&(buffer[index+1]&0xFD)==0x21);
12 :: ASSERT(msg->shmem_ref!=-ENOSPC);
5 :: ASSERT(shadow_mode_translate(v->domain));
22 :: ASSERT((x&PGT_count_mask)!=0);
3 :: ASSERT(!list_empty(&schedule_data[this_cpu].runqueue));
0 :: ASSERT(t==SH_type_fl1_32_shadow||t==SH_type_fl1_pae_shadow||t==SH_type_fl1_64_shadow||t==SH_type_monitor_table||switch(t)caseSH_type_l1_32_shadow:caseSH_type_fl1_32_shadow:SHADOW_INTERNAL_NAME(sh_destroy_l1_shadow,2,2)(v,smfn);
0 :: ASSERT((_p)->u.inuse.domain==(_d))frame_table[mfn].type_and_flags);
2 :: ASSERT(nestedp2m_locked_by_me(_domain));
1 :: ASSERT(is_idle_vcpu(current));
3 :: ASSERT(i==1);
1 :: ASSERT(rc<count);
2 :: ASSERT(((objnew==obj)||(objfound==obj))&&(objnew!=objfound));
2 :: ASSERT(obj->tree_root.rnode==NULL);
0 :: ASSERT(_x->sentinel!=~_y##_SENTINEL);ASSERT(_x->sentinel==_y##_SENTINEL);
7 :: ASSERT(!(pg[i].count_info&PGC_offlined));
3 :: ASSERT(!l1_table_offset(v));
16 :: ASSERT(spin_is_locked(&irq_desc[irq].lock));
2 :: ASSERT(source_pfn<start_info.nr_pages);
4 :: ASSERT(next>=0);
0 :: ASSERT(mbox->reader!=mbox->writer);ASSERT(FS_RING_FREE_REQUESTS(&import->ring,idx));
4 :: ASSERT(!(*ar&_SEGMENT_DPL));
2 :: ASSERT(req_nr_frames<=max_nr_grant_frames);
6 :: ASSERT(action->ack_type==ACKTYPE_LAPIC_EOI);
49 :: ASSERT(0);
2 :: ASSERT(schedule_data[cpu].context_switch_in_progress);
11 :: ASSERT(act->pin&(GNTPIN_hstw_mask|GNTPIN_hstr_mask));
7 :: ASSERT(act->pin&(GNTPIN_devw_mask|GNTPIN_devr_mask));
6 :: ASSERT(info->ring_ref!=-ENOSPC);
10 :: ASSERT(vm_buffer);
176 :: ASSERT(!shadow_mode_refcounts(d));
49 :: ASSERT(__task_on_queue(d));
8 :: ASSERT(gpfn&&!(gpfn&~PGT_mfn_mask));
25 :: ASSERT(i*PAGE_SIZE>=req->length);
6 :: ASSERT(!allocated_in_map(first_page+i));
0 :: ASSERT(t==SH_type_fl1_32_shadow||t==SH_type_fl1_pae_shadow||t==SH_type_fl1_64_shadow||t==SH_type_monitor_table||switch(t)caseSH_type_l1_32_shadow:caseSH_type_fl1_32_shadow:SHADOW_INTERNAL_NAME(sh_destroy_l1_shadow,2,2)(v,smfn)
2 :: ASSERT(valid_mfn(gmfn)&&(sh2_mfn_is_a_page_table(gmfn)||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask)==0)));
0 :: ASSERT(d==page_get_owner(mfn_to_page(pagetable_get_pfn(page=list_entry(list_ent,structpfn_info,list);
1 :: ASSERT(list_empty(&vreq->next));
2 :: ASSERT(rtn!=NULL);
2 :: ASSERT(is_viridian_domain(current->domain));
2 :: ASSERT(!(aiocbp->aio_offset&(dev->info.sector_size-1)));
3 :: ASSERT((page->u.inuse.type_info&PGT_type_mask)!=PGT_writable_page||(page->u.inuse.type_info&PGT_count_mask)==0||v->domain->is_shutting_down);
6 :: ASSERT(t==SH_type_l3_shadow);
0 :: ASSERT((pg->count_info&PGC_SH_type_mask)<PGC_SH_max_shadow);
2 :: ASSERT(guest_l3e_get_flags(gl3e[3])&_PAGE_PRESENT);
2 :: ASSERT(ft==ft_demand_read||ft==ft_demand_write);
6 :: ASSERT(index<MACHPHYS_MBYTES>>1);
16 :: ASSERT(v->processor==smp_processor_id());
2 :: ASSERT(!allocated_in_map(virt_to_pfn(head)));
28 :: ASSERT((x&PGT_validated)||
10 :: ASSERT(ridblock_owner[i]==d);
19 :: ASSERT(crit_count[cpu]>=0);
40 :: ASSERT(spin_is_locked(&m->shadow_lock));
0 :: ASSERT((mfn_to_page(smfn)->count_info&PGC_SH_type_mask)==PGC_SH_l3_pae_shadow);
27 :: ASSERT(virt_to_machine(MMAP_VADDR(pending_idx,i))==buffer_mach+i<<PAGE_SHIFT);
0 :: ASSERT(vm_map_pmap(&l->l_proc->p_vmspace->vm_map)!=ci->ci_pmap||ci->ci_tlbstate!=TLBSTATE_VALID);KD
0 :: ASSERT((sizeof(structpfn_info)<<20)<=add_to_domain_alloc_list(dom0_memory_end,max_page<<PAGE_SHIFT);--a/xen/include/asm-x86/page.hTueJul2714:55:172004+0000++b/xen/include/asm-x86/page.hTueJul2719:37:362004+0000--a/xen/include/xen/mm.hTueJul2714:55:172004+0000++b/xen/include/xen/mm.hTueJul2719:37:362004+0000/*page_alloc.c*/
4 :: ASSERT(per_cpu(vector_irq,cpu)[old_vector]==irq);
20 :: ASSERT(!p2m_is_nestedp2m(p2m));
1 :: ASSERT(pagetable_get_pfn(p2m_get_pagetable(hostp2m))!=0);
1 :: ASSERT(pfp_size<=PAGE_SIZE);
2 :: ASSERT(guest_kernel_mode(v,regs));
3 :: ASSERT(vhd_type_dynamic(&s->vhd));
3 :: ASSERT(sp->u.sh.type!=SH_type_l2_32_shadow);
0 :: ASSERT(l2e_get_pfn(l2e)!=INVALID_MFN||!p2m_is_ram(p2mt));/sizeof(l1_pgentry_t));
4 :: ASSERT(!(initial_images_start&~PAGE_MASK));
30 :: ASSERT((size<=sizeof(mask))&&(size>0));
10 :: ASSERT((ACPI_PHYSICAL_ADDRESS+acpi_sz)<=0xF0000);
1 :: ASSERT(mfn_valid(*sl3mfn));
2 :: ASSERT(sp->type>0);
3 :: ASSERT((page->shadow_flags&(SHF_L2H_PAE|SHF_L2_PAE|SHF_L1_PAE))==0);
6 :: ASSERT(shadow_type!=PGC_SH_none);
2 :: ASSERT(size+(((unsignedlong)new_gp)&~PAGE_MASK)<=PAGE_SIZE);
2 :: ASSERT(shadow_type!=PGC_SH2_p2m_table);
4 :: ASSERT(m1mfn_info);
4 :: ASSERT(hypercall_table!=NULL);
7 :: ASSERT(cur);
4 :: ASSERT(pagetable_val(v->arch.monitor_table));
9 :: ASSERT(current->domain==(_d));
6 :: ASSERT(score);
11 :: ASSERT(spin_is_locked(lock));
4 :: ASSERT(__on_net_schedule_list(vif));
22 :: ASSERT(r_time>=ctx_allow);
0 :: ASSERT(test_bit(old_vector,desc->arch.used_vectors));||(cfg->used_vectors==irq_used_vectors));
2 :: ASSERT(bus!=-1||devfn==-1);
2 :: ASSERT(nv->nv_n2vmcx!=NULL);
2 :: ASSERT(p2!=NULL);
5 :: ASSERT(gpfn!=SHARED_M2P_ENTRY);
1 :: ASSERT(pfn_to_pdx(epfn)<=(DIRECTMAP_SIZE>>PAGE_SHIFT)&&(pfn_to_pdx(epfn)<=FRAMETABLE_SIZE/sizeof(structpage_info)));
1 :: ASSERT(pgp==pgpdel);
2 :: ASSERT(pgp->obj->pool->client->eph_count>=0);
3 :: ASSERT(sizeof(grant_entry_t)==8);
4 :: ASSERT((_d)->arch.paging.shadow.locker==current->processor);
2 :: ASSERT(avail[zone][node]>=request);
0 :: ASSERT(t==PGC_SH_l2_shadow||t==PGC_SH_l2h_pae_shadow);==PGC_SH_monitor_table);
0 :: ASSERT((mfn_to_page(mmfn)->count_info&PGC_SH_type_mask);==PGC_SH_monitor_table);
0 :: ASSERT(t==PGC_SH2_l2_shadow||t==PGC_SH2_l2h_pae_shadow);==PGC_SH2_monitor_table);
18 :: ASSERT(v->arch.cr3==0);
4 :: ASSERT(shadow2_mode_log_dirty(d));
4 :: ASSERT((pte->bits.v==0));
11 :: ASSERT(sp>0);
0 :: ASSERT(shadow_mode_external(d));ASSERT(pagetable_get_pfn(v->arch.monitor_table));
6 :: ASSERT(d==page_get_owner(&frame_table[pagetable_val(d->arch.phys_table)>>PAGE_SHIFT]));
11 :: ASSERT(new_modes);
36 :: ASSERT(gpfn==(gpfn&PGT_mfn_mask));
5 :: ASSERT(ed->arch.arch_vmx.vmcs);
5 :: ASSERT(((_p)->count_info&PGC_count_mask)!=0);
54 :: ASSERT(current->domain==IDLE_DOMAIN_ID);
3 :: ASSERT((x&PGT_validated)||test_bit(DF_DYING,&page_get_owner(page)->flags));
0 :: ASSERT(i<mp_ncpus,("mp_ncpusandactualcpusareoutofwhack"));K
1 :: ASSERT(!test_bit(vector,ret));
1 :: ASSERT(l3e_get_flags(l3_ro_mpt[l3_table_offset(HIRO_COMPAT_MPT_VIRT_START)])&_PAGE_PRESENT);
4 :: ASSERT(rc<=0);
0 :: ASSERT(mfn_valid(gmfn);&&(sh_mfn_is_a_page_table(gmfn);||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask);==0)));
6 :: ASSERT(t==SH_type_l4_shadow);
2 :: ASSERT(sp->type!=SH_type_l2_32_shadow);
0 :: ASSERT((pg->count_info&PGC_SH_type_mask)!=PGC_SH_l2_pae_shadow);
0 :: ASSERT((mfn_to_page(_sl1mfn)->count_info&PGC_SH_type_mask)==PGC_SH_l1_shadow||(mfn_to_page(_sl1mfn)->count_info&PGC_SH_type_mask)==PGC_SH_fl1_shadow);
6 :: ASSERT(__va>=IOREMAP_VIRT_START);
6 :: ASSERT(ep&&!(((unsignedlong)ep)&((sizeof*ep)-1)));
4 :: ASSERT(papr_hcalls!=NULL);
2 :: ASSERT(cmd->direction==SCHED_INFO_PUT);
2 :: ASSERT(reg==decode_dest_reg(prefix,buffer[index+2]));
12 :: ASSERT(vlapic!=NULL);
9 :: ASSERT(d->processor>=0);
7 :: ASSERT(entry_get_flags(gle)&_PAGE_PRESENT);
6 :: ASSERT(!page_get_owner(&frame_table[v->arch.monitor_shadow_ref]));
8 :: ASSERT(offset<size);
9 :: ASSERT(mpt_order<=MAX_ORDER);
17 :: ASSERT(type&&(type<PGT_l4_page_table));
9 :: ASSERT(!(frame_table[smfn].u.inuse.type_info&PGT_pinned));
15 :: ASSERT(gmfn);
151 :: ASSERT(spin_is_locked(&d->arch.shadow_lock));
6 :: ASSERT(ent->next->prev==ent);
5 :: ASSERT(free_pfns!=0);
9 :: ASSERT(r_time!=0);
0 :: ASSERT(!(mfn_to_page(gmfn)->shadow_flags&SHF_page_type_maskSHADOW_PRINTK("d=%d,v=%dn",v->domain->domain_id,v->vcpu_id);
0 :: ASSERT(extratime=1,slice=0)#attempttodisableextratimewithoutsettingsliceextratime="0"opts="%s-e%s"%(domain.getName(),extratime)(status,output)=traceCommand("xmsched-sedf%s"%(opts))#weshouldseethisoutputfromxmeyecatcher="Failedtosetsedfparameters"#checkforfailureifoutput.find(eyecatcher)>=0:FAIL("sched-sedfletmedisableextratimewithoutanon-zeroslice")#Stopthedomain(niceshutdown)domain.stop()++b/tools/xm-test/tests/sedf/Makefile.amTueMar1413:50:352006-0700TESTS=01_sedf_period_slice_pos.test02_sedf_period_lower_neg.test03_sedf_slice_lower_neg.test04_sedf_slice_upper_neg.test05_sedf_extratime_pos.test06_sedf_extratime_disable_neg.test++b/xen/MakefileTueMar1413:50:352006-0700exportXEN_EXTRAVERSION=-unstable++b/xen/Rules.mkTueMar1413:50:352006-0700ifneq($(debug)$(verbose),nn)++b/xen/arch/ia64/Rules.mkTueMar1413:50:352006-0700CFLAGS+=-nostdinc-fno-builtin-fno-common-fno-strict-aliasing++b/xen/arch/ia64/vmx/vmx_hypercall.cTueMar1413:50:352006-0700#include<xen/guest_access.h>VCPU*vcpu=current;#
0 :: ASSERT((buffer_ma&(XBD_SECTOR_SIZE-1))==0,("XENbuffermustbesectoraligned"));K
0 :: ASSERT(((_p)->u.inuse.type_info&PGT_count_mask)!=0)voidpropagate_page_fault(unsignedlongaddr,u16error_code);
0 :: ASSERT(virt_to_machine(MMAP_VADDR(pending_idx,i))==buffer_mach+i<<PAGE_SHIFT);K
1 :: ASSERT(consumer_is_xen(lchn));
4 :: ASSERT(!test_bit(vector,desc->arch.used_vectors));
2 :: ASSERT(nv->nv_n2vmcx_pa!=VMCX_EADDR);
1 :: ASSERT(t->status==TIMER_STATUS_invalid);
2 :: ASSERT(tmh_dedup_enabled());
6 :: ASSERT(i==0);
2 :: ASSERT(!((unsignedlong)va&~PAGE_MASK));
3 :: ASSERT(mfn_valid(mfn_x(gw->l3mfn)));
4 :: ASSERT(n==1||(stride==0&&increment==1));
2 :: ASSERT(v->vcpu_info_mfn==INVALID_MFN);
3 :: ASSERT(m!=0);
3 :: ASSERT(res_ptr<res_end);
4 :: ASSERT((len==4)&&(offset>=0)&&(offset<=APIC_TDCR));
29 :: ASSERT(count);
4 :: ASSERT(blkif->pending_list[idx].count==0);
26 :: ASSERT(list_ent!=&d->page_list);
11 :: ASSERT(VALID_M2P(gmfn));
7 :: ASSERT(!test_bit(ARCH_VMX_IO_WAIT,&v->arch.arch_vmx.flags));
7 :: ASSERT(is_idle_task(v->domain));
5 :: ASSERT((frame_table[smfn].u.inuse.type_info&PGT_pinned));
5 :: ASSERT(1);
1 :: ASSERT(l4e_get_flags(idle_pg_table[l4_table_offset(RO_MPT_VIRT_START)])&_PAGE_PRESENT);
0 :: ASSERT(page_get_owner(_p)==(_d))externvoidshadow_l2_normal_pt_update(unsignedlongpa,unsignedlonggpte);
1 :: ASSERT(shr_locked_by_me());
1 :: ASSERT(v->arch.hvm_svm.vmcb!=NULL);
1 :: ASSERT(vcpu_nestedhvm(v).nv_vvmcx!=NULL);
3 :: ASSERT(v->arch.xsave_area);
1 :: ASSERT(paging_mode_shadow(d));
1 :: ASSERT(pagetable_get_pfn(p2m_get_pagetable(p2m_get_hostp2m(d)))!=0);
2 :: ASSERT(g_info->apic_id!=BAD_APICID);
1 :: ASSERT(bat_locked(s)&&
11 :: ASSERT(obj!=NULL);
3 :: ASSERT(x->u.sh.type<=15);
4 :: ASSERT((page->count_info&~PGC_xen_heap)==0);
4 :: ASSERT(!list_empty(&d->arch.paging.shadow.freelists[order]));
10 :: ASSERT(d->arch.paging.shadow.dirty_bitmap==NULL);
20 :: ASSERT(tn<HPET_TIMER_NUM);
4 :: ASSERT(x->type<=15);
5 :: ASSERT(!test_bit(type,&page->shadow_flags));
2 :: ASSERT((res==0)||(res==SHADOW_SET_CHANGED));
0 :: ASSERT(!list_empty(&d->arch.shadow2.freelists[SHADOW2_MAX_ORDER]));
2 :: ASSERT((_d)->arch.shadow2_locker==-1);
2 :: ASSERT(d->arch.shadow2_hash_walking==0);
4 :: ASSERT(((pg[i].u.inuse.type_info&PGT_count_mask)==0)||
6 :: ASSERT(shadow_enabled);
37 :: ASSERT(zone<NR_ZONES);
0 :: ASSERT(__task_on_runqueue(RUNLIST(prev)));
4 :: ASSERT((!writeable)||(page_type_count(page)!=0));
0 :: ASSERT(valid_mfn(gmfn)&&(sh_mfn_is_a_page_table(gmfn)||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask)==0)));
0 :: ASSERT(virt_to_mfn(MMAP_VADDR(pending_idx,i))==((buffer_mach>>PAGE_SHIFT)+i))
0 :: ASSERT(trunc_page(addr)==addr,("localAPICnotalignedonapageboundary"));K
0 :: ASSERT((!writeable)||((page_type_count(page)!=0)&&((page->flags&PG_type_mask)==PGT_writeable_page)));((page_type_count(page)!=0)&&(((page_type_count(page)&~REFCNT_PIN_BIT)!=0)&&
1 :: ASSERT(pgp_lookup_in_obj(pgp->us.obj,pgp->index)==NULL);
2 :: ASSERT(firstbyte<256);
2 :: ASSERT(mfn_valid(mfn_x(*mfn)));
2 :: ASSERT(rc<n);
2 :: ASSERT(mfn_to_shadow_page(_sl2mfn)->u.sh.type==SH_type_l2_32_shadow);
3 :: ASSERT(sp->u.sh.type!=SH_type_l2h_pae_shadow);
20 :: ASSERT(spin_is_locked(&irq_desc[vector].lock));
3 :: ASSERT(!(rc&SHADOW_SET_FLUSH));
3 :: ASSERT(tmp_base==__vsa_base);
2 :: ASSERT(sector>=seg_start&&sector+nr_secs<=seg_end);
2 :: ASSERT(mfn_valid(*sl2mfn));
6 :: ASSERT(!(all&&fast));
7 :: ASSERT((_d)->arch.shadow.locker==-1);
5 :: ASSERT(shadow_remove_write_access(v,gmfn,0,0)==0);
2 :: ASSERT(!shadow2_mode_external(v->domain));
2 :: ASSERT(valid_mfn(shadow_l4e_get_mfn(*sl4e)));
3 :: ASSERT(mfn_x(sh2_gfn_to_mfn(d,gfn))==mfn);
2 :: ASSERT((pg->count_info&PGC_SH2_type_mask)>0);
4 :: ASSERT(x->t||((x==head)&&(x->next==NULL)));
4 :: ASSERT(len==4&&offset>0&&offset<=APIC_TDCR);
9 :: ASSERT(desc->status&IRQ_DISABLED);
6 :: ASSERT((l1e_get_flags(pte)&(_PAGE_RW|_PAGE_PRESENT))==_PAGE_PRESENT);
28 :: ASSERT(cache!=NULL);
8 :: ASSERT(!page_get_owner(&frame_table[ed->arch.monitor_shadow_ref]));
17 :: ASSERT(pfn_valid(mfn));
18 :: ASSERT(!(gpfn&~PGT_mfn_mask));
17 :: ASSERT(pagetable_val(ed->arch.monitor_table));
7 :: ASSERT(inf->time_slept+CPU_SVT(cpu)>inf->avt+io_warp);
4 :: ASSERT(rid<rp->max_event_channel);
7 :: ASSERT(rp!=NULL);
10 :: ASSERT(skb->skb_type==SKB_ZERO_COPY);
0 :: ASSERT(((_p)->count_info&PGC_count_mask)!=0)
2 :: ASSERT(!nv->nv_vmexit_pending);
6 :: ASSERT(pgp->us.obj!=NULL);
1 :: ASSERT(pg->u.sh.type==SH_type_l1_32_shadow||pg->u.sh.type==SH_type_fl1_32_shadow||pg->u.sh.type==SH_type_l2_32_shadow);
1 :: ASSERT(cpumask_weight(cmd->mask)==1);
7 :: ASSERT(i==target);
2 :: ASSERT(vmce&&vmce->mci_ctl);
7 :: ASSERT(p2m_is_shared(ot));
2 :: ASSERT(offset!=DD_BLK_UNUSED);
1 :: ASSERT(objnode->obj!=NULL);
4 :: ASSERT(!(addr&(~PAGE_MASK_4K)));
4 :: ASSERT(flags==(MAP_SHARED|MAP_ANON)||flags==(MAP_PRIVATE|MAP_ANON));
2 :: ASSERT(l4e_get_flags(l4e[linear_slot])&_PAGE_PRESENT);
1 :: ASSERT(l4e!=NULL);
5 :: ASSERT((va<XEN_VIRT_END)||(va>=DIRECTMAP_VIRT_START));
5 :: ASSERT(sh_remove_write_access(v,gmfn,0,0)==0);
4 :: ASSERT(sh_type_is_pinnable(v,sp->type));
20 :: ASSERT(gfn<(RO_MPT_VIRT_END-RO_MPT_VIRT_START)/sizeof(l1_pgentry_t));
2 :: ASSERT((__va>=IOREMAP_VIRT_START)&&(__va<=(IOREMAP_VIRT_END-1)));
2 :: ASSERT((mfn_to_page(_sl1mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_l1_shadow||(mfn_to_page(_sl1mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_fl1_shadow);
4 :: ASSERT(shadow2_mode_translate(d));
10 :: ASSERT(!shadow2_mode_refcounts(d));
8 :: ASSERT(action->ack_type==ACKTYPE_UNMASK);
1 :: ASSERT((diff==0)||(!VM86_MODE(r)&&RING_0(r)));
0 :: ASSERT(l2e_get_flags(l2e)&_PAGE_PRESENT);ASSERT(v->arch.shadow_vtable);
6 :: ASSERT(s&&target);
6 :: ASSERT(page==NULL);
6 :: ASSERT(end_xt>now);
18 :: ASSERT(IMPLY(extraq_on(d,EXTRA_UTIL_Q)||extraq_on(d,EXTRA_PEN_Q),sedf_runnable(d)));
13 :: ASSERT(l1e_get_flags(gpte)&_PAGE_RW);
10 :: ASSERT((page->flags&PG_domain_mask)==p->domain);
3 :: ASSERT(!active_ac_timer(timer));
13 :: ASSERT(page_type_count(page)!=0);
0 :: ASSERT(id!=0,("alloc_rx_buffers:foundfreereceiveindexof0n"))
2 :: ASSERT(wqv->esp==0);
5 :: ASSERT(nv->nv_vvmcx!=NULL);
2 :: ASSERT(!mfn_valid(smfn)||mfn_to_page(smfn)->u.sh.head);
4 :: ASSERT(p2m_locked_by_me(p2m_get_hostp2m(d)));
3 :: ASSERT(!(s&((1<<L2_PAGETABLE_SHIFT)-1)));
3 :: ASSERT(dirty_vram->sl1ma[i]==sl1ma);
1 :: ASSERT(bm->blk==s->bat.pbw_blk);
3 :: ASSERT(pgp_lookup_in_obj(pgp->obj,pgp->index)==NULL);
12 :: ASSERT(table!=NULL);
5 :: ASSERT(offset==0);
3 :: ASSERT(type!=SH_type_p2m_table);
3 :: ASSERT(size>0);
19 :: ASSERT(mfn_valid(_mfn(mfn)));
26 :: ASSERT(node>=0);
0 :: ASSERT((pg->count_info&PGC_SH_type_mask)>0);
6 :: ASSERT((r&SHADOW2_SET_FLUSH)==0);
2 :: ASSERT(test_bit(type>>PGC_SH2_type_shift,&page->shadow2_flags));
7 :: ASSERT(list_ent==&d->page_list);
3 :: ASSERT((virq>=0)&&(virq<NR_VIRQS));
2 :: ASSERT(runstate->state=RUNSTATE_running);
9 :: ASSERT(d->vcpu[i]->sched_priv!=NULL);
8 :: ASSERT((page->type_count!=0)&&(page->tot_count!=0));
0 :: ASSERT(cluster_id<=APIC_MAX_INTRACLUSTER_ID,return(EINVAL);K
0 :: ASSERT(sc->sc_net_idx->tx_req_prod==*//*TX_RING_ADD(sc->sc_net_idx->tx_resp_prod,sc->sc_tx_entries));*/
1 :: ASSERT(vcpu_nestedhvm(v).nv_vmswitch_in_progress);
5 :: ASSERT(ret!=GUEST_TABLE_POD_PAGE||i!=target);
7 :: ASSERT(!(virt_to_page(rawbuf)->count_info&PGC_allocated));
3 :: ASSERT(ret!=-EEXIST);
2 :: ASSERT(global_eph_count>=0);
2 :: ASSERT((align&(align-1))==0);
0 :: ASSERT(d->arch.p2m->alloc_page);/sizeof(l1_pgentry_t));/sizeof(l1_pgentry_t));
24 :: ASSERT(isairq<NR_ISAIRQS);
14 :: ASSERT(typecode<=HVM_SAVE_CODE_MAX);
13 :: ASSERT(spin_is_locked(&d->arch.hvm_domain.irq_lock));
4 :: ASSERT(mfn_to_shadow_page(mmfn)->type==SH_type_monitor_table);
7 :: ASSERT((vendor_id==0x8086)&&(device_id==0x7010));
0 :: ASSERT(ep&&!(((unsignedlong)ep)&((sizeof*ep)-1)));&&(sh_mfn_is_a_page_table(gmfn);||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask);==0)));
23 :: ASSERT(l4e_get_flags(l4e[0])&_PAGE_PRESENT);
9 :: ASSERT(*mfn==INVALID_MFN);
0 :: ASSERT(HVM_DOMAIN(v));ASSERT(pagetable_get_pfn(d->vcpu[0]->arch.monitor_table));
8 :: ASSERT(l1e_get_flags(l1e)&_PAGE_PRESENT);
6 :: ASSERT(shadow_mode_translate(ed->domain));
4 :: ASSERT(sl2e&_PAGE_PRESENT);
2 :: ASSERT((inf->latency<ULONG_MAX)&&(inf->slice_orig<ULONG_MAX));
8 :: ASSERT(prev->ed_sched_priv!=NULL);
14 :: ASSERT(gpte&_PAGE_RW);
46 :: ASSERT(e->tot_pages<=e->max_pages);
3 :: ASSERT(next->processor==current->processor);
0 :: ASSERT(id!=0,("alloc_rx_buffers:foundfreereceiveindexof0xn_rx_mcl[i].args[0]=(unsignedlong)mtod(m_new,vm_offset_t);K
0 :: ASSERT(!(trig==INTR_TRIGGER_CONFORM||pol==INTR_POLARITY_CONFORM),("%s:Conformingtriggerorpolaritytrig==INTR_TRIGGER_EDGE?"edge":"level");K
2 :: ASSERT(cpumask_test_cpu(nxt,&per_cpu(cpu_core_map,cpu)));
2 :: ASSERT(test_bit(old_vector,cfg->used_vectors));
1 :: ASSERT((_ptr>>2)==val);
5 :: ASSERT(irq==pirq->arch.irq);
2 :: ASSERT(memblk_is_inuse(mb),returnNULL);
4 :: ASSERT(!sh_page_has_multiple_shadows(mfn_to_page(gmfn)));
2 :: ASSERT(page_is_out_of_sync(pg));
2 :: ASSERT(l4e_get_flags(ml4e[linear_slot])&_PAGE_PRESENT);
4 :: ASSERT(op_size==BYTE||op_size==WORD||op_size==LONG);
2 :: ASSERT(v->arch.shadow.mode!=NULL);
3 :: ASSERT(vaddr);
3 :: ASSERT(writable_pagetable_in_sync(d));
0 :: ASSERT(tabmfn!=0);ASSERT(pagetable_get_pfn(d->vcpu[0]->arch.monitor_table));
3 :: ASSERT(buffer[0]==0x0f&&(buffer[1]&0xFD)==0x21);
5 :: ASSERT(!cpu_isset(cpu,next->vcpu_dirty_cpumask));
9 :: ASSERT(!test_bit(ARCH_VMX_IO_WAIT,&d->arch.arch_vmx.flags));
10 :: ASSERT(curinf->deadl_abs>now);
4 :: ASSERT(shadow_mode_external(ed->domain));
16 :: ASSERT(frame_table[gmfn].count_info&PGC_page_table);
5 :: ASSERT(ed->thread.arch_vmx.vmcs);
118 :: ASSERT(!local_irq_is_enabled());
26 :: ASSERT(a->pfn<0x00100000);
12 :: ASSERT(DOMAIN_OKAY(page->flags));
0 :: ASSERT((icrlo&APIC_ICRLO_RESV_MASK)==0,("%s:reservedbitssetinICRLOregister",__func__));K
1 :: ASSERT(nestedhvm_enabled(v->domain)&&nestedhvm_vcpu_in_guestmode(v));
2 :: ASSERT(list_empty(&ce->gfns));
4 :: ASSERT(page_is_ram_type(page_to_mfn(pg),RAM_TYPE_CONVENTIONAL));
2 :: ASSERT(mfn_to_shadow_page(_sl2mfn)->u.sh.type==SH_type_l2_pae_shadow||mfn_to_shadow_page(_sl2mfn)->u.sh.type==SH_type_l2h_pae_shadow);
7 :: ASSERT(!l2_table_offset(va));
6 :: ASSERT(_raw_spin_is_locked(lock));
5 :: ASSERT(rmrr->base_address<rmrr->end_address);
2 :: ASSERT(d->is_dying==DOMDYING_dying);
1 :: ASSERT(mfn_valid(pmfn));
2 :: ASSERT(mfn_to_shadow_page(_sl2mfn)->type==SH_type_l2_64_shadow);
0 :: ASSERT(t==PGC_SH_fl1_32_shadow||t==PGC_SH_fl1_pae_shadow||t==PGC_SH_fl1_64_shadow||t==PGC_SH_monitor_table||(page_get_owner(mfn_to_page(_mfn(pg->u.inuse.type_info)));
0 :: ASSERT(t==PGC_SH2_fl1_32_shadow||t==PGC_SH2_fl1_pae_shadow||t==PGC_SH2_fl1_64_shadow||t==PGC_SH2_monitor_table||(page_get_owner(mfn_to_page(_mfn(pg->u.inuse.type_info)));==v->domain));
6 :: ASSERT(!peoi[sp].ready);
4 :: ASSERT(p->dir==IOREQ_WRITE);
5 :: ASSERT((diff==0)||(!vm86_mode(r)&&(r->cs==__HYPERVISOR_CS)));
1 :: ASSERT((diff==0)||(!VM86_MODE(r)&&(r->cs==__HYPERVISOR_CS)));
10 :: ASSERT(!(atomic_read(&d->refcnt)&DOMAIN_DESTROYED));
0 :: ASSERT(d!=dom0);==buffer_mach+i<<PAGE_SHIFT);==((buffer_mach>>PAGE_SHIFT)+i));
23 :: ASSERT(mmfn_info!=NULL);
4 :: ASSERT(x&PGT_validated);
4 :: ASSERT(nr_psegs<=BLKIF_MAX_SEGMENTS_PER_REQUEST*2);
11 :: ASSERT(page_nr<max_page);
0 :: ASSERT(object->type==OBJT_DEVICE,("pmap_object_init_pt:non-deviceobject"));K
2 :: ASSERT(ns_vmcb!=NULL);
3 :: ASSERT(cpu_isset(old_cpu,timer_valid_cpumask));
1 :: ASSERT(tze_len<=PAGE_SIZE);
1 :: ASSERT(trap<=VCPU_TRAP_LAST);
2 :: ASSERT(offset>=MEMBLK_HEADER_SIZE,continue);
2 :: ASSERT((page->count_info&(PGC_allocated|PGC_count_mask))==0);
10 :: ASSERT(irq<=15);
0 :: ASSERT(spin_is_locked(vpic_lock(s->pics_state)));
0 :: ASSERT((mfn_to_page(_sl2mfn)->count_info&PGC_SH_type_mask)==PGC_SH_l2_32_shadow);
1 :: ASSERT((page->shadow_flags&(SHF_L3_PAE|SHF_L2_PAE|SHF_L1_PAE))==0);
10 :: ASSERT(image_len<rma_sz);
10 :: ASSERT(atomic_read(&v->pausecnt)!=0);
0 :: ASSERT((diff!=0)||vm86_mode(r)||((r->cs&3)>=GUEST_KERNEL_RPL)||(r->cs==0)||hvm_guest(current));ASSERT(hcb->ht==THASH_TLB);
19 :: ASSERT(vmcb->eventinj.fields.v==0);
4 :: ASSERT(d==page_get_owner(mfn_to_page(pagetable_get_pfn(d->arch.phys_table))));
4 :: ASSERT(iopm);
3 :: ASSERT(!pagetable_get_phys(d->arch.phys_table));
12 :: ASSERT(!shadow_lock_is_acquired(_d));
15 :: ASSERT(__shadow_status(d,gpfn,PGT_snapshot));
16 :: ASSERT(shadow_mode_enabled(d));
7 :: ASSERT(pending!=0);
15 :: ASSERT(gpfn!=0);
6 :: ASSERT(LAST_VTB(cpu)>=0);
5 :: ASSERT(prev_inf->time_slept>=prev_inf->vtb);
2 :: ASSERT(!d->has_cpu);
0 :: ASSERT(mfn_valid(gmfn)==0)))
6 :: ASSERT(virt_to_mfn(MMAP_VADDR(pending_idx,i))==((buffer_mach>>PAGE_SHIFT)+i));
0 :: ASSERT(VM_PAGE_TO_PHYS(m)==(pmap->pm_pdpt[i]&PG_FRAME),("pmap_release:gotwrongptdpage"));K
1 :: ASSERT(cpu<nr_cpu_ids);
4 :: ASSERT(nestedhvm_vcpu_in_guestmode(v));
9 :: ASSERT(is_hvm_domain(d)&&d->arch.hvm_domain.hap_enabled);
1 :: ASSERT(!guest_handle_is_null(cnt_uop));
1 :: ASSERT(tmp.op==VHD_OP_DATA_READ||
3 :: ASSERT(mfn_valid(sl1mfn));
2 :: ASSERT(mbox->reader==mbox->writer);
3 :: ASSERT(tb_init_done);
3 :: ASSERT(size<=DMA_CHUNK_SIZE);
2 :: ASSERT((e&~PAGE_MASK)==0);
4 :: ASSERT(d->is_shutdown);
10 :: ASSERT(v->arch.paging.mode);
6 :: ASSERT(v->arch.shadow.mode);
2 :: ASSERT(v->arch.shadow2!=NULL);
10 :: ASSERT((dst-rma)+(ulong)firmware_image_size<eomem);
2 :: ASSERT(vmcb->eventinj.v==0);
7 :: ASSERT(va<FIXADDR_START);
4 :: ASSERT(pagetable_get_paddr(ed->arch.monitor_table));
15 :: ASSERT(d->grant_table->active!=NULL);
28 :: ASSERT(active_cons!=active_prod);
3 :: ASSERT(prev!=NULL);
4 :: ASSERT(memguard_is_guarded(ch));
1 :: ASSERT(!cpumask_empty(&cpus)&&cpumask_test_cpu(cpu,&cpus));
4 :: ASSERT(v->domain==d);
1 :: ASSERT(h.next->list.prev==PAGE_LIST_NULL);
7 :: ASSERT(is_epte_superpage(epte));
1 :: ASSERT(!(level>2&&(l1e_get_flags(*p)&_PAGE_PRESENT)&&(l1e_get_flags(*p)&_PAGE_PSE)));
9 :: ASSERT(!p2m_is_valid(t)||mfn+i==mfn_x(mfn_return));
1 :: ASSERT(test_vhd_flag(tx->status,VHD_FLAG_TX_LIVE));
3 :: ASSERT(s->bat.pbw_blk==blk);
5 :: ASSERT(pgp->size!=-1);
2 :: ASSERT(guest_l2e_get_flags(gw->l2e)&_PAGE_PSE);
5 :: ASSERT(!(type&~PGT_type_mask));
2 :: ASSERT(t==PGC_SH2_l2_shadow||t==PGC_SH2_l2h_pae_shadow);
3 :: ASSERT(!(mfn_to_page(smfn)->u.inuse.type_info&PGT_pinned));
4 :: ASSERT((pfn_to_page(smfn)->u.inuse.type_info&PGT_pinned));
19 :: ASSERT(tabpfn!=0);
6 :: ASSERT(pagetable_get_paddr(d->arch.phys_table));
13 :: ASSERT(a->smfn_and_flags&PSH_pfn_mask);
42 :: ASSERT(d->sched_priv!=NULL);
6 :: ASSERT(crit_checking_disabled[cpu]>=0);
0 :: ASSERT(((pg[i].u.inuse.type_info&PGT_count_mask)==0)||shadow_lock(d);
0 :: ASSERT((flags&(M_NOWAIT|M_WAITOK))==M_NOWAIT||(flags&(M_NOWAIT|M_WAITOK))==M_WAITOK,("pmap_allocpte:flagsisneitherM_NOWAITnorM_WAITOK"));K
1 :: ASSERT(nv->nv_n1vmcx!=NULL);
0 :: ASSERT(!cpu_online(old_cpu)&&cpu_online(new_cpu));ASSERT(FS_RING_FREE_REQUESTS(&import->ring,idx));ASSERT(FS_RING_FREE_REQUESTS(&import->ring,idx));
1 :: ASSERT(h.tail->list.next==PAGE_LIST_NULL);
4 :: ASSERT(smp_processor_id()!=0);
1 :: ASSERT(spin_is_locked(per_cpu(schedule_data,v->processor).schedule_lock));
1 :: ASSERT(key_table[key]==NULL);
1 :: ASSERT(i<count);
1 :: ASSERT(i<VHD_CACHE_SIZE);
18 :: ASSERT(spin_is_locked(&d->evtchn_lock));
4 :: ASSERT(dev->coherent_dma_mask);
3 :: ASSERT(off<ioc->pdir_size);
3 :: ASSERT(pages_needed);
3 :: ASSERT(zone_hi<NR_ZONES);
5 :: ASSERT(virt_to_maddr(&v->arch.paging.shadow.l3table)<=0xffffffe0ULL);
5 :: ASSERT((_d)->arch.p2m.locker==-1);
0 :: ASSERT(l4e_get_flags(l4e[0])&_PAGE_PRESENT);&&(sh_mfn_is_a_page_table(gmfn);||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask);==0)));
23 :: ASSERT(shadow_lock_is_acquired(v->domain));
2 :: ASSERT((mfn_to_page(_sl3mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_l3_pae_shadow);
5 :: ASSERT(page_get_owner(page)==d);
10 :: ASSERT(!in_irq()&&local_irq_is_enabled());
4 :: ASSERT(pagetable_get_paddr(ed->arch.monitor_table)==0);
7 :: ASSERT(max_mode);
39 :: ASSERT(ed!=current);
3 :: ASSERT(m->shadow_extras_count==0);
6 :: ASSERT((page->flags&PG_type_mask)==PGT_gdt_page);
4 :: ASSERT(paging_mode_log_dirty(d));
5 :: ASSERT(!in_atomic());
1 :: ASSERT(pg->list.next!=PAGE_LIST_NULL);
1 :: ASSERT(handler_num);
1 :: ASSERT(timer->status>=TIMER_STATUS_inactive);
2 :: ASSERT(sizeof(grant_entry_v1_t)==8);
4 :: ASSERT(ret!=GUEST_TABLE_POD_PAGE||i!=walk_level);
1 :: ASSERT(!page_state_is(&pg[i],offlined));
4 :: ASSERT(bm&&bitmap_valid(bm));
2 :: ASSERT((obj!=NULL)&&(pgp!=NULL)&&(pgp->index!=-1));
90 :: ASSERT(spin_is_locked(&pcidevs_lock));
3 :: ASSERT(spin_is_locked(&irq_desc[domain_irq_to_vector(d,mirq)].lock));
2 :: ASSERT(offset>=((*reps-1)*bytes_per_rep));
4 :: ASSERT(FSIF_NR_READ_GNTS==FSIF_NR_WRITE_GNTS);
2 :: ASSERT(irqs_disabled());
6 :: ASSERT(x>=0);
3 :: ASSERT((result&mask)<(src&mask));
4 :: ASSERT(GUEST_PAGING_LEVELS>3||level!=3);
0 :: ASSERT(t==PGC_SH_l3_shadow);
2 :: ASSERT(v->arch.hvm_vcpu.hw_cr3==virt_to_maddr(v->arch.hvm_vcpu.hvm_lowmem_l3tab));
13 :: ASSERT(l3e_get_flags(l3e[3])&_PAGE_PRESENT);
2 :: ASSERT((page->shadow2_flags&(SH2F_L3_PAE|SH2F_L2_PAE|SH2F_L1_PAE))==0);
5 :: ASSERT(dir==IOREQ_READ||dir==IOREQ_WRITE);
0 :: ASSERT(ridblock_owner[i]==d);ASSERT(hcb->ht==THASH_VHPT);ASSERT(hcb->ht==THASH_VTLB);ASSERT(hcb->hash_sz%sizeof(thash_data_t)==0);ASSERT(hcb->ht==THASH_VHPT);ASSERT(hcb->ht==THASH_VTLB);ASSERT(hcb->hash_sz%sizeof(thash_data_t)==0);
6 :: ASSERT(ed->domain->id==IDLE_DOMAIN_ID);
18 :: ASSERT(l2e_get_flags(sl2e)&_PAGE_PRESENT);
44 :: ASSERT(d->grant_table!=NULL);
9 :: ASSERT(cur_sdom!=NULL);
8 :: ASSERT(sdom->domain!=IDLE_DOMAIN_ID);
68 :: ASSERT(p!=NULL);
0 :: ASSERT((page->u.inuse.type_info&PGT_type_mask)!=PGT_writable_page||(page->u.inuse.type_info&PGT_count_mask)==0clear_bit(type,&page->shadow_flags);
0 :: ASSERT(d==page_get_owner(&frame_table[pagetable_val(d->arch.phys_table)>>PAGE_SHIFT]));K
0 :: ASSERT(((_p)->u.inuse.type_info&PGT_count_mask)!=0)diff-r2d50ee7a068d-r5f0125b2f3a9xen/include/asm-x86/shadow.hexternvoidvmx_shadow_clear_state(structdomain*);--a/xen/include/asm-x86/shadow.hMonMar1422:10:102005+0000++b/xen/include/asm-x86/shadow.hTueMar1512:31:322005+0000
0 :: ASSERT((_p)->u.inuse.domain==(_d))diff-r9975cd31ac46-r613602e2d771xen/include/asm-x86/page.hdiff-r9975cd31ac46-r613602e2d771xen/include/xen/mm.h#ifndef__XEN_MM_H__unsignedlongbitmap_start,unsignedlongmax_pages);
2 :: ASSERT(!cpumask_test_cpu(nxt,&per_cpu(cpu_core_map,cpu)));
1 :: ASSERT(xsave_cntxt_size>=XSTATE_AREA_MIN_SIZE);
2 :: ASSERT(boot_cpu_has(X86_FEATURE_TSC_RELIABLE));
3 :: ASSERT(n1vmcb!=NULL);
1 :: ASSERT(pgp->us.obj->pgp_count>=0);
2 :: ASSERT(mfn_to_page(sl1mfn)->u.sh.head);
1 :: ASSERT(timer->status==TIMER_STATUS_inactive);
4 :: ASSERT((cpu!=0)&&cpu_online(0));
4 :: ASSERT(page_make_private(d,page)==0);
1 :: ASSERT(order==0);
1 :: ASSERT(j);
6 :: ASSERT(spin_is_locked(&irq_desc[domain_pirq_to_irq(d,mirq)].lock));
2 :: ASSERT(bm&&test_vhd_flag(bm->status,VHD_FLAG_BM_READ_PENDING));
4 :: ASSERT(size<tmh_mempool_maxalloc);
2 :: ASSERT(pgp_del==pgp);
5 :: ASSERT(mfn_is_out_of_sync(gmfn));
2 :: ASSERT(x>0);
6 :: ASSERT(mfn_valid(d->arch.paging.log_dirty.top));
3 :: ASSERT((opnd_sel&~3)==regs->error_code);
6 :: ASSERT(current->processor==cpu);
0 :: ASSERT((mfn_to_page(_sl4mfn)->count_info&PGC_SH_type_mask)==PGC_SH_l4_64_shadow);
2 :: ASSERT(l1e_get_pfn(cache->l1tab[idx])==mfn);
0 :: ASSERT(d->arch.shadow2.dirty_bitmap!=NULL);
2 :: ASSERT((_d)->arch.shadow2_locker==current->processor);
36 :: ASSERT(page_get_owner(pg)==d);
10 :: ASSERT(spin_is_locked(&per_cpu(schedule_data,v->processor).schedule_lock));
11 :: ASSERT(xl<sizeof(xen));
18 :: ASSERT(action->ack_type==ACKTYPE_EOI);
24 :: ASSERT(l1e_get_pfn(p2m[gpfn])==mfn);
10 :: ASSERT(pfn_valid(smfn));
76 :: ASSERT(ref!=-ENOSPC);
4 :: ASSERT(rchn[rid].flags==(ECF_INUSE|ECF_CONNECTED|lid));
0 :: ASSERT(shadow_mode_write_l1(d)||shadow_mode_write_all(d)||shadow_mode_wr_pt_pte(d));K
0 :: ASSERT(id!=0,("alloc_rx_buffers:foundfreereceiveindexof0n"));K
0 :: ASSERT((dest&~(APIC_ID_MASK>>APIC_ID_SHIFT))==0,("%s:invaliddestfield",__func__));K
0 :: ASSERT((_p)->u.inuse.domain==(_d))diff-r9711b428cf6a-r1e13ae874e9cxen/include/asm-x86/page.hdiff-r9711b428cf6a-r1e13ae874e9cxen/include/xen/mm.h#ifndef__XEN_MM_H__voidinit_page_allocator(unsignedlongmin,unsignedlongmax);
0 :: ASSERT(((void*)ch->next<(void*)&_end)||memguard_is_guarded(ch->next))
3 :: ASSERT(p2m->set_entry);
1 :: ASSERT(svm->ns_gif==0);
2 :: ASSERT(pgp->us.obj->pool->client!=NULL);
2 :: ASSERT(vmce);
2 :: ASSERT(pfp_len==tze_len);
1 :: ASSERT(cmem_mempool!=NULL);
11 :: ASSERT(ecap_queued_inval(iommu->ecap)&&iommu_qinval);
6 :: ASSERT(spin_is_locked(&heap_lock));
25 :: ASSERT(mfn_valid(omfn));
0 :: ASSERT(t==SH_type_fl1_32_shadow||t==SH_type_fl1_pae_shadow||t==SH_type_fl1_64_shadow||t==SH_type_monitor_table||==v->domain));&&(sh_mfn_is_a_page_table(gmfn);||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask);==0)));
4 :: ASSERT(prev);
7 :: ASSERT(test_bit(type,&page->shadow_flags));
0 :: ASSERT((pg->count_info&PGC_SH_type_mask)!=PGC_SH_l3_pae_shadow);
2 :: ASSERT(v->arch.shadow2);
2 :: ASSERT(!mmio||!(shadow_l1e_get_flags(sl1e)&_PAGE_PRESENT));
2 :: ASSERT(valid_mfn(shadow_l3e_get_mfn(*sl3e)));
6 :: ASSERT(map!=NULL);
2 :: ASSERT((pg->count_info&PGC_SH2_type_mask)!=PGC_SH2_l2_32_shadow);
4 :: ASSERT(msrpm);
8 :: ASSERT(cpus_empty(n->vcpu_dirty_cpumask));
32 :: ASSERT((pa&~(PADDR_MASK&PAGE_MASK))==0);
12 :: ASSERT(tmp_base!=__vsa_base);
15 :: ASSERT(d==page_get_owner(&frame_table[pagetable_get_pfn(d->arch.phys_table)]));
4 :: ASSERT(shadow_mode(d));
6 :: ASSERT(pagetable_val(m->monitor_table));
12 :: ASSERT(prev_inf->time_slept>=LAST_VTB(cpu));
3 :: ASSERT(__on_net_schedule_list(netif));
4 :: ASSERT(rings!=NULL);
4 :: ASSERT((target==2&&hvm_hap_has_1gb(d))||(target==1&&hvm_hap_has_2mb(d))||(target==0));
2 :: ASSERT(size<PAGE_SIZE);
2 :: ASSERT(pgp->obj->pgp_count>=0);
2 :: ASSERT(mfn_to_shadow_page(_sl1mfn)->u.sh.type==SH_type_l1_shadow||mfn_to_shadow_page(_sl1mfn)->u.sh.type==SH_type_fl1_shadow);
7 :: ASSERT(page!=NULL);
3 :: ASSERT(dpci);
2 :: ASSERT((v==current)||spin_is_locked(&d->arch.vmx_platform.ioreq.lock));
2 :: ASSERT((delivery_mode==dest_Fixed)||(delivery_mode==dest_LowestPrio));
4 :: ASSERT((_d)->arch.paging.hap.locker==current->processor);
5 :: ASSERT(!list_empty(&d->arch.paging.shadow.freelists[SHADOW_MAX_ORDER]));
4 :: ASSERT(mfn_to_shadow_page(_sl3mfn)->type==SH_type_l3_64_shadow);
3 :: ASSERT(virt_to_maddr(&v->arch.shadow.l3table)<=0xffffffe0ULL);
0 :: ASSERT(t==PGC_SH_l4_shadow);
22 :: ASSERT(d->arch.shadow.hash_table);
2 :: ASSERT((mfn_to_page(_sl4mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_l4_64_shadow);
4 :: ASSERT(callbacks[x->t]!=NULL);
3 :: ASSERT(alignment!=3);
42 :: ASSERT(d!=current->domain);
4 :: ASSERT(page_to_mfn(gpage)!=0);
3 :: ASSERT(!pending_lapic_eoi[cpu][sp-1].ready_to_end);
10 :: ASSERT((x&PGT_validated)||test_bit(_DOMF_dying,&page_get_owner(page)->domain_flags));
37 :: ASSERT(mfn_valid(mfn));
5 :: ASSERT(inst_len<=MAX_INST_LEN);
11 :: ASSERT(d->arch.pmt);
19 :: ASSERT(VM_ASSIST(d,VMASST_TYPE_writable_pagetables)||shadow_mode_write_all(d));
5 :: ASSERT(!shadow_mode_enabled(ed->domain));
5 :: ASSERT((p==NULL)||!in_irq());
4 :: ASSERT(((void*)ch->pprev<(void*)&_end)||memguard_is_guarded(ch->pprev));
2 :: ASSERT(((_p)->count_and_flags&PGC_count_mask)!=0);
0 :: ASSERT(args->bus<=mptable_maxbusid,("bus%distoobig",args->bus));n",K
0 :: ASSERT(lapics[apic_id].la_present,("%s:APIC%udoesn'texist",__func__,apic_id));K
0 :: ASSERT((cfg->used_vectors==NULL);||(cfg->used_vectors==irq_used_vectors));
7 :: ASSERT(test_bit(vector,cfg->used_vectors));
2 :: ASSERT(l->locker==-1);
2 :: ASSERT(rc==0);
2 :: ASSERT(mfn_valid(sh_ctxt->mfn1));
13 :: ASSERT(mfn_valid(mfn)||!p2m_is_ram(*t));
3 :: ASSERT(ioc->pdir_base[off]>>63);
6 :: ASSERT(d->arch.paging.shadow.hash_walking==0);
9 :: ASSERT(((vaddr&~PAGE_MASK)+bytes)<=PAGE_SIZE);
2 :: ASSERT(sp->mbz==0);
2 :: ASSERT(sp->type!=SH_type_l4_64_shadow);
2 :: ASSERT(shadow_l3e_get_flags(shadow_l3e[3])&_PAGE_PRESENT);
7 :: ASSERT(port_is_valid(ld,lport));
2 :: ASSERT(((l1va=d->arch.ptwr[PTWR_PT_INACTIVE].l1va)==0)||(l1_linear_offset(l1va)!=l1_linear_offset(addr)));
2 :: ASSERT(((irq_guest_action_t*)desc->action)->ack_type==ACKTYPE_UNMASK);
4 :: ASSERT(l3_backptr!=PGT_va_unknown);
29 :: ASSERT(sedf_runnable(ret.task));
11 :: ASSERT(l2e_get_flags(gl2e)&_PAGE_PRESENT);
4 :: ASSERT(!pagetable_val(d->arch.phys_table));
25 :: ASSERT(purb->actual_length<=pending_req->nr_pages*PAGE_SIZE);
16 :: ASSERT(d!=NULL);
9 :: ASSERT(allocated_in_map(first_page+i));
0 :: ASSERT((((unsignedlong)va)>=MAPCACHE_VIRT_START)&&(((unsignedlong)va)<=MAPCACHE_VIRT_END))
0 :: ASSERT(p1->p_tracecred!=NULL,("ktracevnodewithnocred"));K
0 :: ASSERT((vector&~APIC_VECTOR_MASK)==0,("%s:invalidvector%d",__func__,vector));K
0 :: ASSERT(page_get_owner(_p)==(_d))externvoidshadow_l2_normal_pt_update(unsignedlongpa,unsignedlonggpde);
2 :: ASSERT((unsignedlong)v!=0xfffff000);
1 :: ASSERT(!get_bitmap(s,blk));
2 :: ASSERT(bat_entry(s,blk)==DD_BLK_UNUSED);
0 :: ASSERT(rw_is_locked(&pcidevs_lock));
2 :: ASSERT(spin_is_locked(&bus2bridge_lock));
3 :: ASSERT(l1e_get_flags(*p2m_entry)&_PAGE_PRESENT);
2 :: ASSERT(d->arch.vmx_platform.ioreq.va!=NULL);
4 :: ASSERT(l2e!=NULL);
22 :: ASSERT(spin_is_locked(&pit->lock));
6 :: ASSERT(instr==INSTR_CMP||instr==INSTR_SUB);
2 :: ASSERT(info->busy.req==req);
3 :: ASSERT(d->arch.paging.shadow.total_pages==0);
0 :: ASSERT(ok);
0 :: ASSERT((mfn_to_page(_sl3mfn)->count_info&PGC_SH_type_mask)==PGC_SH_l3_pae_shadow);
0 :: ASSERT(d->arch.shadow2.dirty_bitmap==NULL);
2 :: ASSERT(v->arch.guest_table.pfn==d->arch.phys_table.pfn);
5 :: ASSERT(!pending_eoi[cpu][sp].ready);
0 :: ASSERT(d->vcpu[i]->sched_priv!=NULL);&&(inf->slice_orig<ULONG_MAX));&&(inf->slice_orig<ULONG_MAX));&&(inf->slice_orig<ULONG_MAX));
3 :: ASSERT(runstate->state==RUNSTATE_running);
0 :: ASSERT(cpus_empty(next->vcpu_dirty_cpumask));&&(EDOM_INFO(p)->slice_orig<ULONG_MAX));&&(EDOM_INFO(p)->slice_orig<ULONG_MAX));
2 :: ASSERT(info->grant_id!=-ENOSPC);
34 :: ASSERT(VALID_M2P(gpfn));
14 :: ASSERT(!(entry->writable_pl1e&(sizeof(l1_pgentry_t)-1)));
4 :: ASSERT(l2_pgentry_val(hl2e)&_PAGE_PRESENT);
11 :: ASSERT(debugtrace_buf[debugtrace_bytes-1]==0);
0 :: ASSERT(page_get_owner(_p)==(_d));
9 :: ASSERT(l2_pgentry_val(l2e)&_PAGE_PRESENT);
0 :: ASSERT(VM_PAGE_TO_PHYS(m)==(pmap->pm_pdpt[i]&PG_FRAME),("pmap_release:gotwrongptdpage"));
3 :: ASSERT(mfn_x(r_mfn)==mfn_x(mfn));
5 :: ASSERT(pgp->us.obj->pool!=NULL);
21 :: ASSERT(p2m);
2 :: ASSERT((table!=NULL)&&(offset<INTREMAP_ENTRIES));
1 :: ASSERT(va-DIRECTMAP_VIRT_START<DIRECTMAP_VIRT_END);
2 :: ASSERT(pod_target>p2md->pod.count);
3 :: ASSERT(!(b->size&1));
2 :: ASSERT(!(aiocbp->aio_nbytes&(dev->info.sector_size-1)));
4 :: ASSERT(next<2*data_size);
4 :: ASSERT(extra_word<=TRACE_EXTRA_MAX);
4 :: ASSERT(pt->vcpu==v);
3 :: ASSERT(0==(size&~iovp_mask));
3 :: ASSERT((v==current)||spin_is_locked(&d->arch.hvm_domain.ioreq.lock));
5 :: ASSERT(!next->is_running);
5 :: ASSERT(hap_locked_by_me(v->domain));
6 :: ASSERT(!guest_op||shadow_locked_by_me(v->domain));
0 :: ASSERT(t==PGC_SH_l2_shadow||t==PGC_SH_l2h_pae_shadow);
6 :: ASSERT(valid_mfn(smfn));
4 :: ASSERT((mfn_to_page(_sl2mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_l2_32_shadow);
2 :: ASSERT(!guest_op||shadow2_lock_is_acquired(v->domain));
3 :: ASSERT(regs->eax<=0xFFFF);
9 :: ASSERT(l1e_get_pfn(cache->l1tab[idx])==pfn);
7 :: ASSERT(!test_bit(ARCH_VMX_CONTIG_MEM,&v->arch.arch_vmx.flags));
0 :: ASSERT(virt_to_mfn(MMAP_VADDR(pending_idx,i));==((buffer_mach>>PAGE_SHIFT)+i));
39 :: ASSERT(stype&&!(stype&~PGT_type_mask));
16 :: ASSERT(ptbase_mfn);
29 :: ASSERT(d->arch.shadow_dirty_bitmap!=NULL);
7 :: ASSERT(tlbflush_clock==0);
3 :: ASSERT((_pfn)->u.inuse.count_info==PGC_always_set);
3 :: ASSERT(t->cpu==cpu);
4 :: ASSERT((ranfor>0));
0 :: ASSERT((_p)->u.inuse.domain==(_d))e,d,pfn,(l1v&_PAGE_RW)?GNTTAB_MAP_RW:GNTTAB_MAP_RO);K
0 :: ASSERT(iommu->mmio_base);ASSERT(order==0||order==9||order==18);ASSERT(order==0||order==9||order==18);ASSERT(order==0||order==9||order==18);ASSERT(order==0||order==9||order==18);
1 :: ASSERT(!cpumask_test_cpu(nxt,per_cpu(cpu_core_mask,cpu)));
2 :: ASSERT(test_bit(vector,desc->arch.used_vectors));
1 :: ASSERT(!list_empty(lru_list));
1 :: ASSERT(page_list_empty(&p2m->pod.single));
1 :: ASSERT(!(mfn_to_page(mfn)->count_info&PGC_allocated));
2 :: ASSERT((val<=(LONG_MAX>>2))&&(val>=(LONG_MIN>>2)));
1 :: ASSERT(timer->status<=TIMER_STATUS_in_list);
2 :: ASSERT(ch==per_cpu(cpu_bc_channel,cpu));
1 :: ASSERT(!tx->closed);
1 :: ASSERT(sl->client!=old_client);
2 :: ASSERT(mfn_to_page(_sl2mfn)->u.sh.type==SH_type_l2_32_shadow);
3 :: ASSERT(!(mfn&(L1_PAGETABLE_ENTRIES-1)));
2 :: ASSERT(l1e_get_pfn(dcache->l1tab[hashent->idx])==hashent->mfn);
3 :: ASSERT(!list_empty(&d->arch.paging.hap.freelist));
6 :: ASSERT(mfn_to_shadow_page(_sl2mfn)->type==SH_type_l2_64_shadow||mfn_to_shadow_page(_sl2mfn)->type==SH_type_l2h_64_shadow);
9 :: ASSERT(is_hvm_vcpu(v));
25 :: ASSERT(shadow_type!=SH_type_none);
4 :: ASSERT(!cpu_isset(nxt,cpus));
9 :: ASSERT(bytes<=sizeof(unsignedlong));
4 :: ASSERT(sl3e!=NULL);
13 :: ASSERT(pagetable_get_pfn(d->arch.phys_table)!=0);
2 :: ASSERT(!d->arch.shadow2_hash_table);
2 :: ASSERT(free_head[x]->pprev==&free_head[x]);
7 :: ASSERT((type&PGT_va_mask)!=(x&PGT_va_mask));
3 :: ASSERT((mfn_to_page(smfn)->u.inuse.type_info&PGT_pinned));
119 :: ASSERT(vmcb);
0 :: ASSERT(is_idle_domain(v->domain));&&(EDOM_INFO(p)->slice_orig<ULONG_MAX));&&(EDOM_INFO(p)->slice_orig<ULONG_MAX));
4 :: ASSERT(!(pfn_to_page(smfn)->u.inuse.type_info&PGT_pinned));
7 :: ASSERT(pfn_is_ram(mfn));
0 :: ASSERT(((_p)->u.inuse.count_info&PGC_count_mask)!=0);
25 :: ASSERT(prev->sched_priv!=NULL);
0 :: ASSERT(mfn_valid(gmfn)==0)));/*Wedon'tshadowPAEl3s*/
0 :: ASSERT(((vm_offset_t)pmap->pm_pdpt&((NPGPTD*sizeof(pdpt_entry_t))-1))==0,("pmap_pinit:pdptmisaligned"));K
0 :: ASSERT(boot_cpu_id==PCPU_GET(apic_id),("BSP'sAPICIDdoesn'tmatchboot_cpu_id"));K
0 :: ASSERT(!lapics[apic_id].la_present,("duplicatelocalAPIC%u",apic_id));K
1 :: ASSERT(cpumask_weight(&dirty_mask)<=1);
1 :: ASSERT(cpumask_empty(action->cpu_eoi_map));
2 :: ASSERT(!paging_locked_by_me(v->domain));
19 :: ASSERT(paging_locked_by_me(d));
5 :: ASSERT(pirq==pirq_info(d,domain_irq_to_pirq(d,irq)));
2 :: ASSERT(h.tail->u.sh.type==SH_type_l2_32_shadow);
1 :: ASSERT(mfn_to_page(sl4mfn)->u.sh.head);
15 :: ASSERT(is_epte_superpage(ept_entry));
1 :: ASSERT(sp<(NR_DYNAMIC_VECTORS-1));
4 :: ASSERT(gfn!=SHARED_M2P_ENTRY);
1 :: ASSERT(vreq->secs_pending==0);
2 :: ASSERT(bm&&bitmap_valid(bm)&&bitmap_locked(bm));
4 :: ASSERT(list_empty(&pgp->client_eph_pages));
2 :: ASSERT(mfn_valid(mfn_x(top_mfn)));
2 :: ASSERT(rc==-EINVAL);
3 :: ASSERT(do_locking||shadow_locked_by_me(v->domain));
1 :: ASSERT(b2<bytes);
0 :: ASSERT(mfn_valid(mfn)||!p2m_is_ram(*t));/sizeof(l1_pgentry_t));
17 :: ASSERT((mfn&~(PADDR_MASK>>PAGE_SHIFT))==0);
6 :: ASSERT(spin_is_locked(&d->arch.hvm_domain.irq.lock));
18 :: ASSERT(!test_bit(ARCH_HVM_IO_WAIT,&v->arch.hvm_vcpu.ioflags));
5 :: ASSERT(l1e_get_pfn(cache->l1tab[hashent->idx])==hashent->pfn);
11 :: ASSERT(phystab);
19 :: ASSERT(!d->arch.shadow_dirty_bitmap);
12 :: ASSERT(!page_out_of_sync(page));
3 :: ASSERT((cfg->used_vectors==NULL)||(cfg->used_vectors==irq_used_vectors));
0 :: ASSERT(!(trig==INTR_TRIGGER_CONFORM||pol==INTR_POLARITY_CONFORM),("%s:Conformingtriggerorpolarityn",__func__));K
0 :: ASSERT(vm_map_pmap(&l->l_proc->p_vmspace->vm_map)!=pmap_kernel());K
0 :: ASSERT((_p)->u.inuse.domain==(_d))diff-r9711b428cf6a-r1e13ae874e9cxen/include/asm-x86/page.hdiff-r9711b428cf6a-r1e13ae874e9cxen/include/xen/mm.h#ifndef__XEN_MM_H__unsignedlongbitmap_start,unsignedlongmax_pages);
1 :: ASSERT(access_w||access_r||access_x);
1 :: ASSERT(gvmcb!=NULL);
2 :: ASSERT(xsave_cntxt_size>=XSAVE_AREA_MIN_SIZE);
1 :: ASSERT(pfp_len<=PAGE_SIZE);
4 :: ASSERT(pod_target>=p2md->pod.count);
2 :: ASSERT(opnd_sel);
3 :: ASSERT(v->arch.paging.shadow.guest_vtable);
3 :: ASSERT(0==(byte_cnt&~iovp_mask));
3 :: ASSERT(0!=mask);
8 :: ASSERT(paging_mode_translate(d));
2 :: ASSERT(sp->type<SH_type_max_shadow);
0 :: ASSERT(sh_l1e_is_mmio(sl1e));
23 :: ASSERT(spin_is_locked(&s->lock));
6 :: ASSERT(!list_empty(&d->arch.shadow.freelists[SHADOW_MAX_ORDER]));
9 :: ASSERT(sizeof(l2_pgentry_t)==sizeof(shadow_l2e_t));
5 :: ASSERT(sl1e!=NULL);
9 :: ASSERT(x);/*Wecan'thavehittheend,sinceourtargetis
28 :: ASSERT(p2m_entry);
21 :: ASSERT(shadow2_lock_is_acquired(v->domain));
2 :: ASSERT(!test_bit(type>>PGC_SH2_type_shift,&page->shadow2_flags));
4 :: ASSERT(parea!=NULL);
4 :: ASSERT((htab_addr&((1UL<<log_htab_size)-1))==0);
4 :: ASSERT(smfn!=0);
8 :: ASSERT(curinf->deadl_abs>=now);
6 :: ASSERT(flags&GPFN_IO_MASK);
12 :: ASSERT(spin_is_locked(&platform_timer_lock));
24 :: ASSERT(va<(void*)MAPCACHE_VIRT_END);
25 :: ASSERT((void*)MAPCACHE_VIRT_START<=va);
3 :: ASSERT(shadow_mode_translate(rd));
5 :: ASSERT((sizeof(structpfn_info)<<20)>
19 :: ASSERT(B->next==0);
8 :: ASSERT(skb->len<=PAGE_SIZE);
0 :: ASSERT(t==SH_type_fl1_32_shadow||t==SH_type_fl1_pae_shadow||t==SH_type_fl1_64_shadow||t==SH_type_monitor_table||==v->domain));/*Thedown-shiftsherearesothattheswitchstatementisonnice*smallnumbersthatthecompilerwillenjoy*/switch(t>>PGC_SH_type_shift){#ifCONFIG_PAGING_LEVELS==2casePGC_SH_l1_32_shadow>>PGC_SH_type_shift:casePGC_SH_fl1_32_shadow>>PGC_SH_type_shift:
0 :: ASSERT(cpu_apic_ids[cpu]!=-1,("IPItonon-existentCPU%d",cpu));K
1 :: ASSERT(vvmcb!=NULL);
1 :: ASSERT(mfn_to_page(sl2mfn)->u.sh.head);
1 :: ASSERT(len2<=PAGE_SIZE);
3 :: ASSERT(svc==CSCHED_VCPU(per_cpu(schedule_data,svc->vcpu->processor).curr));
6 :: ASSERT(hvm_irq_dpci);
3 :: ASSERT((status==not_parsed)&&(smp_processor_id()==0));
20 :: ASSERT(spin_is_locked(&h->lock));
19 :: ASSERT(d->is_dying);
7 :: ASSERT(!cpus_empty(cpus)&&cpu_isset(cpu,cpus));
27 :: ASSERT(mfn_valid(gmfn));
3 :: ASSERT(!(x&PGT_pae_xen_l2));
3 :: ASSERT(pagetable_get_pfn(v->arch.guest_table)==mfn_x(gmfn));
2 :: ASSERT(valid_mfn(shadow_l2e_get_mfn(*sl2e)));
2 :: ASSERT(d->arch.shadow_dirty_bitmap==NULL);
5 :: ASSERT((sp==0)||(peoi[sp-1].vector<vector));
4 :: ASSERT((type&PGT_va_mask)!=PGT_va_mutable);
2 :: ASSERT(cpu_online(cpu));
2 :: ASSERT((u32)tsc_elapsed64==tsc_elapsed64);
4 :: ASSERT(x->pfn||((x==head)&&(x->next==NULL)));
2 :: ASSERT((page_type_count(page)&~REFCNT_PIN_BIT)!=0);
22 :: ASSERT(p->state==TASK_DYING);
0 :: ASSERT((x&PGT_validated)||ia64_fph_enable();
6 :: ASSERT(paging_locked_by_me(v->domain));
5 :: ASSERT(p2m->domain->arch.paging.alloc_page);
8 :: ASSERT(d);
5 :: ASSERT(total_avail_pages>=0);
2 :: ASSERT((long)obj->objnode_count==0);
2 :: ASSERT(rtn->slots[i]==NULL);
10 :: ASSERT(bytes_to_wrap==calc_bytes_to_wrap(buf));
3 :: ASSERT((_d)->arch.paging.log_dirty.locker==-1);
6 :: ASSERT(paging_mode_external(v->domain));
18 :: ASSERT(d->arch.paging.shadow.hash_table);
3 :: ASSERT(mfn_valid(*sl1mfn));
0 :: ASSERT(valid_mfn(gmfn);&&(sh2_mfn_is_a_page_table(gmfn);||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask);==0)));
2 :: ASSERT(current->domain->domain_id==IDLE_DOMAIN_ID);
10 :: ASSERT(cpus_empty(action->cpu_eoi_map));
8 :: ASSERT(cpus_subset(cpumask,cpu_online_map));
36 :: ASSERT(spin_is_locked(&d->big_lock));
3 :: ASSERT(pagetable_get_phys(d->arch.phys_table));
9 :: ASSERT(!extraq_on(d,EXTRA_UTIL_Q));
18 :: ASSERT(IMPLY(extraq_on(d,EXTRA_UTIL_Q)||extraq_on(d,EXTRA_PEN_Q),
5 :: ASSERT(smfn&&!(smfn&~PGT_mfn_mask));
7 :: ASSERT(!(old_sl2e&_PAGE_PRESENT));
28 :: ASSERT(pending_list[idx].count==0);
0 :: ASSERT(((_p)->u.inuse.type_info&PGT_count_mask)!=0);
2 :: ASSERT((dirty_vram->sl1ma[i]&PAGE_MASK)==(sl1ma&PAGE_MASK));
1 :: ASSERT(((long)ptr&0x3)==0x2);
2 :: ASSERT(cpu_has_svm_nrips);
1 :: ASSERT(ns_viomap!=NULL);
2 :: ASSERT(shr_lock.locker==current->processor);
1 :: ASSERT(l3e_get_flags(l3_ro_mpt[l3_table_offset(va)])&_PAGE_PRESENT);
4 :: ASSERT(list_empty(&pgp->global_eph_pages));
2 :: ASSERT(mfn_to_page(_sl3mfn)->u.sh.type==SH_type_l3_64_shadow);
3 :: ASSERT(sp);
5 :: ASSERT(spin_is_locked(&viosapic->lock));
3 :: ASSERT(t<=31);
9 :: ASSERT(d->is_shutting_down);
5 :: ASSERT(cpu_isset(nxt,cpu_core_map[cpu]));
7 :: ASSERT((ft==ft_prefetch));
0 :: ASSERT(!guest_op||shadow_lock_is_acquired(v->domain));&&(sh_mfn_is_a_page_table(gmfn);||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask);==0)));
30 :: ASSERT(shadow_mode_write_all(d)||shadow_mode_wr_pt_pte(d));
10 :: ASSERT(page);
4 :: ASSERT(root_pgentry_val(idle_pg_table[1])==0);
12 :: ASSERT(head->next==NULL);
28 :: ASSERT((pg[i].u.inuse.type_info&PGT_count_mask)==0);
41 :: ASSERT(d!=current);
1 :: ASSERT(tmh_mempool!=NULL);
5 :: ASSERT((pi==NULL)||IS_VALID_PAGE(pi));
4 :: ASSERT(va>=DIRECTMAP_VIRT_START&&va<DIRECTMAP_VIRT_END);
3 :: ASSERT(callbacks[x->u.sh.type]!=NULL);
5 :: ASSERT(spin_is_locked(&console_lock));
2 :: ASSERT(l1e_get_pfn(dcache->l1tab[idx])==mfn);
2 :: ASSERT(t==SH_type_l2_shadow||t==SH_type_l2h_shadow);
26 :: ASSERT((v==current)||!vcpu_runnable(v));
3 :: ASSERT(d->arch.shadow.total_pages==0);
2 :: ASSERT(sh2_mfn_is_a_page_table(gmfn));
2 :: ASSERT(test_bit(v->vcpu_id,&info->vcpus));
2 :: ASSERT(sizeof(l4_pgentry_t)==sizeof(shadow_l4e_t));
2 :: ASSERT((mfn_to_page(_sl3mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_l3_64_shadow);
3 :: ASSERT(!(pair[0].l2&(1<<PAGE_SHIFT)));
35 :: ASSERT(tab[offset]&_PAGE_PRESENT);
2 :: ASSERT(page_get_owner(&pg[i])==NULL);
9 :: ASSERT(key_table[key].u.irq_handler==NULL);
28 :: ASSERT((_p&~PAGE_MASK)==0);
44 :: ASSERT(__task_on_runqueue(prev));
0 :: ASSERT(((_p)->u.inuse.type_info&PGT_count_mask)!=0)diff-rdff04529e881-r4ff298f651dexen/include/asm-x86/shadow.hexternvoidvmx_shadow_clear_state(structdomain*);
2 :: ASSERT(spin_is_locked(&ir_ctrl->iremap_lock));
1 :: ASSERT(test_vhd_flag(s->bat.status,
1 :: ASSERT(req->treq.secs==0);
5 :: ASSERT(prot==(PROT_READ|PROT_WRITE));
15 :: ASSERT(ioc);
6 :: ASSERT(svc->sdom!=NULL);
6 :: ASSERT(spin_is_locked(&vioapic_domain(vioapic)->arch.hvm_domain.irq.lock));
11 :: ASSERT(order<=SHADOW_MAX_ORDER);
2 :: ASSERT(sh2_mfn_is_a_page_table(mfn));
20 :: ASSERT(sl2e!=NULL);
20 :: ASSERT(test_bit(_DOMF_dying,&d->domain_flags));
0 :: ASSERT(pagetable_get_pfn(d->vcpu[0]->arch.monitor_table));ASSERT(pagetable_get_pfn(v->arch.monitor_table));
4 :: ASSERT(percpu_info[cpu].foreign==NULL);
4 :: ASSERT(offset<=size);
8 :: ASSERT(l2e_get_flags(gpde)&_PAGE_PRESENT);
9 :: ASSERT(!d->arch.shadow_ht);
6 :: ASSERT(pfn_is_ram(gmfn));
37 :: ASSERT((inf->period<ULONG_MAX)&&(inf->slice_orig<ULONG_MAX));
0 :: ASSERT(sched[i].buffer_offset==purb->iso_frame_desc[i].offset);==buffer_mach+i<<PAGE_SHIFT);
76 :: ASSERT(s);
0 :: ASSERT(ep&&!(((unsignedlong)ep)&((sizeof*ep)-1)));&&(sh_mfn_is_a_page_table(gmfn)||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask)
5 :: ASSERT(opt_allow_superpage);
2 :: ASSERT(p1!=NULL);
2 :: ASSERT(client==NULL);
8 :: ASSERT(sh_type_is_pinnable(v,sp->u.sh.type));
4 :: ASSERT(!(page->u.inuse.type_info&(PGT_count_mask|PGT_validated|PGT_partial)));
4 :: ASSERT(pt->source!=0);
3 :: ASSERT(byte_cnt>0);
2 :: ASSERT((s&~PAGE_MASK)==0);
7 :: ASSERT(va>=XEN_VIRT_START);
6 :: ASSERT(blkif->pending_list[idx].secs_pending==0);
0 :: ASSERT((__va>=IOREMAP_VIRT_START)&&(__va<IOREMAP_VIRT_END));
0 :: ASSERT(l4e_get_flags(l4e[0])&_PAGE_PRESENT);&&(sh2_mfn_is_a_page_table(gmfn);||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask);==0)));
11 :: ASSERT(d==current->domain);
10 :: ASSERT(*ofh_tree==0xdeadbeef00000000);
6 :: ASSERT(!test_bit(irq,d->pirq_mask)||(action->ack_type!=ACKTYPE_NONE));
2 :: ASSERT((diff!=0)||vm86_mode(r)||((r->cs&3)>=GUEST_KERNEL_RPL)||(r->cs==0)||hvm_guest(current));
5 :: ASSERT(m3mfn_info);
9 :: ASSERT(!page_get_owner(mfn_to_page(v->arch.monitor_shadow_ref)));
5 :: ASSERT(guest_l2e_get_flags(gl2e)&_PAGE_PRESENT);
18 :: ASSERT(shadow_mode_enabled(v->domain));
6 :: ASSERT(root_get_value(idle_pg_table[1])==0);
8 :: ASSERT(!pagetable_val(ed->arch.monitor_table));
4 :: ASSERT((p!=NULL)||!in_irq());
6 :: ASSERT(ent->prev->next==ent);
5 :: ASSERT(!__task_on_runqueue(p));
0 :: ASSERT((sizeof(structpfn_info)<<20)<=(FRAMETABLE_VIRT_END-FRAMETABLE_VIRT_START));K
1 :: ASSERT(tmh->domain->is_dying);
7 :: ASSERT(MSI_IRQ(irq));
1 :: ASSERT(!strncmp(nodename,"/local/domain/",14));
7 :: ASSERT(!d->arch.paging.shadow.hash_table);
14 :: ASSERT(hvm_sr_handlers[typecode].load==NULL);
8 :: ASSERT(ea==(u32)ea);
1 :: ASSERT(spin_is_locked(&vpic->lock));
5 :: ASSERT(phys_to_nid(page_to_maddr(pg))==node);
3 :: ASSERT(test_bit(type>>PGC_SH_type_shift,&page->shadow_flags));
2 :: ASSERT(sc->op==DOM0_SHADOW_CONTROL_OP_PEEK);
2 :: ASSERT(shadow2_remove_write_access(v,gmfn,0,0)==0);
8 :: ASSERT(desc->status&IRQ_GUEST);
3 :: ASSERT(reg==decode_dest_reg(buffer[2]));
0 :: ASSERT(l1e_get_pfn(cache->l1tab[hashent->idx])==hashent->pfn);&&(EDOM_INFO(p)->slice_orig<ULONG_MAX));&&(EDOM_INFO(p)->slice_orig<ULONG_MAX));
2 :: ASSERT(page_get_owner(&frame_table[ed->arch.monitor_shadow_ref])==NULL);
5 :: ASSERT(s&(PSH_shadowed|PSH_hl2));
4 :: ASSERT(d->arch.shadow_mode);
16 :: ASSERT(d->arch.shadow_extras_count==0);
38 :: ASSERT(gpfn);
11 :: ASSERT(((_p)->type_and_flags&PGT_type_mask)==(_t));
0 :: ASSERT(va>=XEN_VIRT_START)*in__virt_to_maddr()**Soasacompromisepre-allocatethemwhenxenboots.*Thisfunctionmustbecalledfromwithinstart_xen()when*itisvalidtouse_xmalloc()*//*shadowI/Opermissionbitmaps*/if(boot_cpu_data.x86_vendor==X86_VENDOR_INTEL){/*Sameformatashvm_io_bitmap*/shadow_io_bitmap[0]=_xmalloc(IOBITMAP_VMX_SIZE,PAGE_SIZE);
0 :: ASSERT(lapics[apic_id].la_present,("%s:missingAPIC%u",__func__,apic_id));K
8 :: ASSERT(!mfn_valid(mfn)||p2mt!=p2m_mmio_direct);
4 :: ASSERT(index<EPT_PAGETABLE_ENTRIES);
2 :: ASSERT(cpu_isset(new_cpu,timer_valid_cpumask));
1 :: ASSERT(tmh_tze_enabled());
2 :: ASSERT(!(l3e_get_flags(l3_ro_mpt[l3_table_offset(va)])&_PAGE_PSE));
3 :: ASSERT(order==0||ret==GUEST_TABLE_NORMAL_PAGE);
2 :: ASSERT(client->eph_count>=0);
4 :: ASSERT(pages>0);
2 :: ASSERT(!(mfn_to_page(gmfn)->shadow_flags&SHF_page_type_mask&~SHF_L1_ANY));
4 :: ASSERT(!(length&~PAGE_MASK));
6 :: ASSERT(d->arch.paging.log_dirty.allocs==0);
7 :: ASSERT(mfn_valid(gw->l1mfn));
3 :: ASSERT(startsg->length<=DMA_CHUNK_SIZE);
11 :: ASSERT(d->arch.paging.hap.p2m_pages==0);
15 :: ASSERT(d->arch.paging.shadow.dirty_bitmap!=NULL);
6 :: ASSERT(!(r&SHADOW_SET_ERROR));
0 :: ASSERT(t==SH_type_l1_shadow||t==SH_type_fl1_shadow);==PGC_SH_monitor_table);
0 :: ASSERT(v->arch.shadow.action_log);
3 :: ASSERT(shadow_type!=PGC_SH_p2m_table);
2 :: ASSERT(ptr_sl1e);
3 :: ASSERT(valid_mfn(*sl3mfn));
2 :: ASSERT(shadow2_mode_external(v->domain));
4 :: ASSERT(shadow_type!=PGC_SH2_none);
2 :: ASSERT(result==-1||result>=16);
8 :: ASSERT((dst-rma)+image_len<eomem);
3 :: ASSERT(!pending_lapic_eoi[cpu][sp].ready_to_end);
6 :: ASSERT(mfn_to_page(gmfn)->count_info&PGC_page_table);
4 :: ASSERT(tsc_elapsed32!=0);
2 :: ASSERT((_pfn)->count_info==PGC_always_set);
30 :: ASSERT(live<9999);
14 :: ASSERT(prev_inf!=NULL);
0 :: ASSERT((_p)->u.domain==(_d));
2 :: ASSERT(!test_bit(vector,desc->chip_data->used_vectors));
1 :: ASSERT(!pool->init_region);
3 :: ASSERT(sp->u.sh.type!=SH_type_l4_64_shadow);
3 :: ASSERT(t->status==TIMER_STATUS_inactive);
8 :: ASSERT(len>0);
0 :: ASSERT(v->arch.guest_table.pfn==d->arch.paging.shadow.unpaged_pagetable.pfn);
6 :: ASSERT(v->arch.paging.shadow.guest_vtable==NULL);
8 :: ASSERT(this_cpu(mc_state).flags==0);
5 :: ASSERT(lchn->consumer_is_xen);
4 :: ASSERT(log_htab_size<=SDR1_HTABSIZE_MAX);
1 :: ASSERT((diff!=0)||VM86_MODE(r)||!RING_0(r)||HVM_DOMAIN(current));
0 :: ASSERT(d==page_get_owner(mfn_to_page(pagetable_get_pfn(d->arch.phys_table))));ASSERT(v->arch.shadow_vtable);
4 :: ASSERT(opcode[0]<=15);
6 :: ASSERT(pfn_is_ram(smfn));
2 :: ASSERT(test_bit(_PGC_always_set,&page->count_info));
2 :: ASSERT(__task_on_runqueue(d));
5 :: ASSERT(next_prime->evt>=next->evt);
0 :: ASSERT(pg->u.sh.type==SH_type_l1_32_shadow||pg->u.sh.type==SH_type_fl1_32_shadow||pg->u.sh.type==SH_type_l2_32_shadow);*anddoingsotriggersthe
3 :: ASSERT((fd==-1&&(flags==(MAP_SHARED|MAP_ANON)||flags==(MAP_PRIVATE|MAP_ANON)))||(fd!=-1&&flags==MAP_SHARED));
0 :: ASSERT(page_get_owner(_p)==(_d))voidmemguard_guard_stack(void*p);
0 :: ASSERT((_p)->u.domain==(_d))void*memguard_init(void*heap_start)
1 :: ASSERT(nv->nv_n1vmcx_pa!=VMCX_EADDR);
6 :: ASSERT(pod_target>=p2m->pod.count);
2 :: ASSERT(i!=handler_num);
6 :: ASSERT((page->u.inuse.type_info&(PGT_count_mask|PGT_validated|PGT_partial))==1);
4 :: ASSERT(gla_validity==EPT_GLA_VALIDITY_MATCH);
5 :: ASSERT(!shadow_op||shadow_locked_by_me(d));
6 :: ASSERT(order<=shadow_max_order(d));
7 :: ASSERT(to_pci_dev(dev)->dma_mask);
7 :: ASSERT(shadow_type<SH_type_unused);
4 :: ASSERT(callbacks[x->type]!=NULL);
6 :: ASSERT(mfn_to_shadow_page(_sl2mfn)->type==SH_type_l2_pae_shadow||mfn_to_shadow_page(_sl2mfn)->type==SH_type_l2h_pae_shadow);
11 :: ASSERT((vendor_id==0x8086)&&(device_id==0x7113));
4 :: ASSERT(!cpus_empty(cpus));
0 :: ASSERT((mfn_to_page(_sl2mfn)->count_info&PGC_SH_type_mask)==PGC_SH_l2_pae_shadow||(mfn_to_page(_sl2mfn)->count_info&PGC_SH_type_mask)==PGC_SH_l2h_pae_shadow);
0 :: ASSERT((pg->count_info&PGC_SH_type_mask)!=PGC_SH_l4_64_shadow);
2 :: ASSERT((mfn_to_page(_sl2mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_l2_64_shadow);
2 :: ASSERT(d->arch.shadow2_p2m_pages==0);
5 :: ASSERT(hsa);
6 :: ASSERT(d==page_get_owner(pfn_to_page(pagetable_get_pfn(d->arch.phys_table))));
0 :: ASSERT(vpd);ASSERT(hcb->ht==THASH_VHPT);ASSERT(hcb->ht==THASH_VTLB);ASSERT(hcb->hash_sz%sizeof(thash_data_t)==0);
21 :: ASSERT(EQ(sedf_runnable(d),__task_on_queue(d)));
4 :: ASSERT(l1_pgentry_val(nl1e)&_PAGE_PRESENT);
0 :: ASSERT((WEIGHT_PERIOD<ULONG_MAX);
9 :: ASSERT(shadow_mode_translate(current->domain));
10 :: ASSERT(!(atomic_read(&d->refcnt)&DOMAIN_DESTRUCTED));
3 :: ASSERT(r_time>0);
0 :: ASSERT(extratime=1,slice=0)#attempttodisableextratimewithoutsettingsliceextratime="0"opts="%s-e%s"%(domain.getName(),extratime)(status,output)=traceCommand("xmsched-sedf%s"%(opts))#weshouldseethisoutputfromxmeyecatcher="Failedtosetsedfparameters"#checkforfailureifoutput.find(eyecatcher)>=0:FAIL("sched-sedfletmedisableextratimewithoutanon-zeroslice")#Stopthedomain(niceshutdown)domain.stop()++b/tools/xm-test/tests/sedf/Makefile.amTueMar1413:50:352006-0700TESTS=01_sedf_period_slice_pos.test02_sedf_period_lower_neg.test03_sedf_slice_lower_neg.test04_sedf_slice_upper_neg.test05_sedf_extratime_pos.test06_sedf_extratime_disable_neg.test++b/xen/MakefileTueMar1413:50:352006-0700exportXEN_EXTRAVERSION=-unstable++b/xen/Rules.mkTueMar1413:50:352006-0700ifneq($(debug)$(verbose),nn)++b/xen/arch/ia64/Rules.mkTueMar1413:50:352006-0700CFLAGS+=-nostdinc-fno-builtin-fno-common-fno-strict-aliasing++b/xen/arch/ia64/vmx/vmx_hypercall.cTueMar1413:50:352006-0700#include<xen/guest_access.h>u64r32,ret;
0 :: ASSERT(i,("nombufsprocessed"));K
1 :: ASSERT(spin_is_locked(&cpupool_lock));
3 :: ASSERT(!dev->msix_used_entries);
8 :: ASSERT(p2m->alloc_page);
2 :: ASSERT(shr_lock.locker==-1);
1 :: ASSERT(!req->next);
1 :: ASSERT(desc->msi_desc==entry);
1 :: ASSERT(!reverse);
5 :: ASSERT(spin_is_locked(&irq_desc[msi->vector].lock));
4 :: ASSERT(current==main_thread);
0 :: ASSERT(gfn<(RO_MPT_VIRT_END-RO_MPT_VIRT_START);/sizeof(l1_pgentry_t));
3 :: ASSERT(coalesced==filled);
3 :: ASSERT(d->arch.paging.hap.total_pages==0);
9 :: ASSERT(id==BUGFRAME_assert);
8 :: ASSERT(node<num_online_nodes());
2 :: ASSERT(rma_settings!=NULL);
0 :: ASSERT((mfn_to_page(smfn)->count_info&PGC_SH_type_mask);==PGC_SH_l3_pae_shadow);
2 :: ASSERT(current==v);
0 :: ASSERT((mfn_to_page(smfn)->count_info&PGC_SH2_type_mask);==PGC_SH2_l3_pae_shadow);
13 :: ASSERT(sl4e!=NULL);
2 :: ASSERT(order>=0);
12 :: ASSERT(regs);
10 :: ASSERT(!test_bit(_VCPUF_running,&next->vcpu_flags));
5 :: ASSERT(d->vcpu[vcpuid]==NULL);
15 :: ASSERT(pagetable_get_paddr(v->arch.monitor_table)==0);
3 :: ASSERT(d->exec_domain[i]->ed_sched_priv!=NULL);
24 :: ASSERT(pfn<(1u<<20));
9 :: ASSERT(PGT_base_page_table==PGT_l2_page_table);
2 :: ASSERT(mpl2e[PERDOMAIN_VIRT_START>>L2_PAGETABLE_SHIFT]);
41 :: ASSERT(nr_psegs<=(BLKIF_MAX_SEGMENTS_PER_REQUEST+1));
4 :: ASSERT(tx->status==RING_STATUS_OK);
0 :: ASSERT((cfg->used_vectors==NULL)ret=__assign_irq_vector(irq,cfg,TARGET_CPUS);
0 :: ASSERT(pmap_kextract((vm_offset_t)pmap->pm_pdpt)<(4ULL<<30),("pmap_pinit:pdptabove4g"));K
1 :: ASSERT(guest_l1e_get_flags(gw->l1e)&_PAGE_PRESENT);
1 :: ASSERT(spin_is_locked(&hd->mapping_lock)&&is_hvm_domain(d));
1 :: ASSERT(va<XEN_VIRT_END);
1 :: ASSERT(pool->shared_count==0);
3 :: ASSERT(lock->recurse_cnt<0xfu);
2 :: ASSERT((x&PGT_count_mask)==1);
3 :: ASSERT(nr<NR_SOFTIRQS);
14 :: ASSERT(p2m_locked_by_me(d->arch.p2m));
3 :: ASSERT((_p2m)->locker==-1);
2 :: ASSERT(l3e_get_flags(l3e[0])&_PAGE_PRESENT);
8 :: ASSERT(is_hvm_domain(d));
0 :: ASSERT((mfn_to_page(_sl2mfn)->count_info&PGC_SH_type_mask)==PGC_SH_l2_64_shadow);
2 :: ASSERT(op->cmd==XEN_DOMCTL_SCHEDOP_putinfo);
2 :: ASSERT(t==PGC_SH2_l1_shadow||t==PGC_SH2_fl1_shadow);
2 :: ASSERT(t==PGC_SH2_l4_shadow);
2 :: ASSERT(res==0||res==SHADOW2_SET_CHANGED);
4 :: ASSERT(l1e_get_pfn(*(l1_pgentry_t*)vaddr)==mfn_x(smfn));
4 :: ASSERT(gl2e&_PAGE_PRESENT);
13 :: ASSERT(flush_count++==0);
26 :: ASSERT((_p&PAGE_MASK)!=0);
15 :: ASSERT(entry->next->prev==entry);
3 :: ASSERT(mfn_valid(gmfn)&&(sh_mfn_is_a_page_table(gmfn)||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask)==0)));
0 :: ASSERT((_p)->u.domain==(_d))void*memguard_init(void*heap_start);
4 :: ASSERT(set_shared_p2m_entry(p2m,gfn,page_to_mfn(page))!=0);
3 :: ASSERT(x2apic_enabled);
3 :: ASSERT(cpu_isset(cpu,timer_valid_cpumask));
2 :: ASSERT(!(e&((1<<L2_PAGETABLE_SHIFT)-1)));
1 :: ASSERT((pi->count_info&~(PGC_allocated|1))==0);
6 :: ASSERT(pfp!=NULL);
3 :: ASSERT(prot==0);
3 :: ASSERT(dma_len<=DMA_CHUNK_SIZE);
3 :: ASSERT(d->arch.hvm_domain.ioreq.va!=NULL);
4 :: ASSERT(avail[node][zone]>=request);
0 :: ASSERT(t==SH_type_l2_shadow||t==SH_type_l2h_pae_shadow);==PGC_SH_monitor_table);
4 :: ASSERT(valid_mfn(*sl2mfn));
3 :: ASSERT(alignment==0);
5 :: ASSERT(spin_is_locked(&schedule_data[v->processor].schedule_lock));
5 :: ASSERT(VM_ASSIST(d,VMASST_TYPE_writable_pagetables));
24 :: ASSERT(!(l2e_get_flags(old_sl2e)&_PAGE_PRESENT));
10 :: ASSERT((psh_type==PGT_snapshot)||!mfn_out_of_sync(gmfn));
12 :: ASSERT(spin_is_locked(&current->mm.shadow_lock));
5 :: ASSERT(p->state!=TASK_DYING);
4 :: ASSERT((((page->flags&PG_type_mask)==PGT_writeable_page)&&(page_type_count(page)!=0))||(((page->flags&PG_type_mask)==PGT_none)&&(page_type_count(page)==0)));
0 :: ASSERT(((_p)->u.inuse.type_info&PGT_count_mask)!=0)voidaudit_domain(structdomain*d);
0 :: ASSERT((!writeable)||((page->flags&PG_type_mask)==PGT_writeable_page)&&((page->flags&PG_need_flush)==PG_need_flush)));
1 :: ASSERT(vcpu_nestedhvm(v).nv_vmexit_pending==0);
4 :: ASSERT(spin_is_locked(&ch->lock));
4 :: ASSERT(irq>0);
2 :: ASSERT(obj->pgp_count>=0);
5 :: ASSERT(spin_is_locked(&hd->mapping_lock));
8 :: ASSERT(!test_bit(irq,d->pirq_mask));
3 :: ASSERT((_d)->arch.paging.log_dirty.locker==current->processor);
3 :: ASSERT(bits_not_wanted);
6 :: ASSERT(va<DIRECTMAP_VIRT_END);
4 :: ASSERT((_d)->arch.paging.hap.locker==-1);
4 :: ASSERT(spin_is_locked(&vioapic_domain(vioapic)->arch.hvm_domain.irq_lock));
2 :: ASSERT(d->tot_pages==dom0_nrpages);
2 :: ASSERT(r&SHADOW2_SET_L3PAE_RECOPY);
4 :: ASSERT(smfn);
1 :: ASSERT((diff!=0)||VM86_MODE(r)||((r->cs&3)>=GUEST_KERNEL_RPL)||(r->cs==0)||HVM_DOMAIN(current));
5 :: ASSERT((page->u.inuse.type_info&PGT_type_mask)==PGT_l1_page_table);
5 :: ASSERT(hashent->pfn==pfn);
14 :: ASSERT(shadow_mode_write_l1(d)||shadow_mode_write_all(d)||shadow_mode_wr_pt_pte(d));
15 :: ASSERT(VALID_MFN(readonly_gmfn));
7 :: ASSERT(inf->time_slept+CPU_SVT(p->processor)>inf->avt+io_warp);
6 :: ASSERT((skb->data-skb->head)==(18+ETH_HLEN));
4 :: ASSERT((page->shadow_flags&(SHF_L4_64|SHF_L3_64|SHF_L2H_64|SHF_L2_64|SHF_L1_64))==0);
0 :: ASSERT(info->tables_nr<MAX_TABLES);/sizeof(l1_pgentry_t));/sizeof(l1_pgentry_t));
1 :: ASSERT(firstbyte!=NOT_SHAREABLE);
2 :: ASSERT(t->gt_version!=0);
1 :: ASSERT(tx->closed);
1 :: ASSERT(bat_locked(s)&&s->bat.pbw_blk==blk);
5 :: ASSERT(!v->fpu_dirtied);
10 :: ASSERT(zone_lo<=zone_hi);
22 :: ASSERT(isa_irq<=15);
5 :: ASSERT(!(type&~(PGT_type_mask|PGT_pae_xen_l2)));
2 :: ASSERT(d->tot_pages>=rma_nrpages);
0 :: ASSERT((pg->count_info&PGC_SH_type_mask)!=PGC_SH_l2_32_shadow);
3 :: ASSERT(d->arch.shadow.p2m_pages==0);
3 :: ASSERT(valid_mfn(_mfn(mfn)));
2 :: ASSERT((pg->count_info&PGC_SH2_type_mask)!=PGC_SH2_l3_pae_shadow);
8 :: ASSERT(pfn_to_page(gmfn)->count_info&PGC_page_table);
3 :: ASSERT(pagetable_get_phys(ed->arch.monitor_table)==0);
25 :: ASSERT((req->length>>PAGE_SHIFT)<=MMAP_PAGES_PER_REQUEST);
9 :: ASSERT(key_table[key].u.handler==NULL);
13 :: ASSERT(prev_einf!=NULL);
0 :: ASSERT(m<&vm_page_array[vm_page_array_size],pte_clear(pte);K
0 :: ASSERT((_p)->u.inuse.domain==(_d))frame_table[mfn].u.inuse.type_info);
10 :: ASSERT(p2m->domain);
1 :: ASSERT(va>=DIRECTMAP_VIRT_START);
2 :: ASSERT(mfn_to_page(_sl1mfn)->u.sh.type==SH_type_l1_shadow||mfn_to_page(_sl1mfn)->u.sh.type==SH_type_fl1_shadow);
54 :: ASSERT(spin_is_locked(&d->event_lock));
2 :: ASSERT(v->arch.hvm_vmx.host_cr0&X86_CR0_TS);
14 :: ASSERT(hvm_sr_handlers[typecode].save==NULL);
3 :: ASSERT((diff!=0)||vm86_mode(r)||((r->cs&3)>=GUEST_KERNEL_RPL(current->domain))||(r->cs==0)||is_hvm_vcpu(current));
4 :: ASSERT(mfn_to_shadow_page(_sl1mfn)->type==SH_type_l1_shadow||mfn_to_shadow_page(_sl1mfn)->type==SH_type_fl1_shadow);
1 :: ASSERT(pagetable_is_null(v->arch.shadow_table[i]));
3 :: ASSERT(!test_bit(type>>PGC_SH_type_shift,&page->shadow_flags));
4 :: ASSERT(info->foreign==NULL);
4 :: ASSERT(per_cpu(schedule_data,d->processor).curr);
0 :: ASSERT(pending_list[idx].count==0);ASSERT(hcb->ht==THASH_VHPT);ASSERT(hcb->ht==THASH_VTLB);ASSERT(hcb->hash_sz%sizeof(thash_data_t)==0);ASSERT(hcb->ht==THASH_VHPT);ASSERT(hcb->ht==THASH_VTLB);ASSERT(hcb->hash_sz%sizeof(thash_data_t)==0);ASSERT(hcb->ht==THASH_VHPT);ASSERT(hcb->ht==THASH_VTLB);ASSERT(hcb->hash_sz%sizeof(thash_data_t)==0);
10 :: ASSERT((page->u.inuse.type_info&PGT_type_mask)==PGT_writable_page);
47 :: ASSERT(flags==(GTF_accept_transfer|GTF_transfer_committed));
0 :: ASSERT((_p)->u.inuse.domain==(_d));
165 :: ASSERT(local_irq_is_enabled());
26 :: ASSERT((_l&~PAGE_MASK)==0);
26 :: ASSERT((_l&PAGE_MASK)!=0);
19 :: ASSERT(timer!=NULL);
0 :: ASSERT(t==PGC_SH_fl1_32_shadow||t==PGC_SH_fl1_pae_shadow||t==PGC_SH_fl1_64_shadow||t==PGC_SH_monitor_table||(page_get_owner(mfn_to_page(_mfn(pg->u.inuse.type_info)))==v->domain));
0 :: ASSERT(rx->id!=0,("xn_rxeof:foundfreereceiveindexof0n",rx->status);K
0 :: ASSERT((_p)->u.inuse.domain==(_d))diff-r9975cd31ac46-r613602e2d771xen/include/asm-x86/page.hdiff-r9975cd31ac46-r613602e2d771xen/include/xen/mm.h#ifndef__XEN_MM_H__voidinit_page_allocator(unsignedlongmin,unsignedlongmax);
2 :: ASSERT(spin_is_locked(per_cpu(schedule_data,cpu).schedule_lock));
2 :: ASSERT(len<=PAGE_SIZE);
2 :: ASSERT(v->domain->domain_id==d->domain_id);
4 :: ASSERT(is_shared(pool));
3 :: ASSERT(!(initial_images_base&~PAGE_MASK));
3 :: ASSERT(is_x86_user_segment(seg));
5 :: ASSERT(regs->eflags&X86_EFLAGS_IF);
4 :: ASSERT(!sh_mfn_is_a_page_table(gmfn));
4 :: ASSERT(sizeof(QCowHeader)+sizeof(QCowHeader_ext)<512);
2 :: ASSERT(t==SH_type_l2_shadow||t==SH_type_l2h_pae_shadow);
0 :: ASSERT(v->arch.shadow2.mode!=NULL);
5 :: ASSERT(htab_raddr!=0);
15 :: ASSERT(d->grant_table->shared!=NULL);
18 :: ASSERT(debugtrace_buf!=NULL);
2 :: ASSERT((sizeof(structpfn_info)<<20)>(FRAMETABLE_VIRT_END-FRAMETABLE_VIRT_START));
5 :: ASSERT(prev->state!=TASK_UNINTERRUPTIBLE);
8 :: ASSERT((page_type_count(page)!=0)&&(page_tot_count(page)!=0));
4 :: ASSERT(rchn[rid].target_dom==lp->domain);
0 :: ASSERT(lsect<=7,("XENdiskdriverdatacannotcrossapageboundary"));K
0 :: ASSERT(cpu_info[apic_id].cpu_present==0,("CPU%daddedtwice",apic_id));K
13 :: ASSERT(!is_idle_vcpu(v));
1 :: ASSERT(!p||p->u.sh.head);
5 :: ASSERT(paging_mode_translate(p2m->domain));
3 :: ASSERT(sp->u.sh.type<SH_type_max_shadow);
7 :: ASSERT(size==PAGE_SIZE);
11 :: ASSERT(shadow_type!=SH_type_p2m_table);
0 :: ASSERT(t==PGC_SH_l1_shadow||t==PGC_SH_fl1_shadow);
7 :: ASSERT(l1e_get_pfn(cache->l1tab[hashent->idx])==hashent->mfn);
3 :: ASSERT(valid_mfn(pmfn));
4 :: ASSERT(x->t<=15);
24 :: ASSERT(t);
8 :: ASSERT(l3e_get_flags(ml3e[3])&_PAGE_PRESENT);
6 :: ASSERT(l2_backptr!=PGT_va_mutable);
12 :: ASSERT(p!=n);
5 :: ASSERT(d->vcpu[vcpu]==NULL);
17 :: ASSERT(type==PGT_writable_page);
10 :: ASSERT(shadow_mode_translate(d)&&!shadow_mode_external(d));
4 :: ASSERT(d->arch.out_of_sync==NULL);
7 :: ASSERT(s&PSH_shadowed);
18 :: ASSERT(spfn_info);
0 :: ASSERT(vector>=APIC_IO_INTS&&vector!=IDT_SYSCALL&&vector<=APIC_IO_INTS+NUM_IO_INTS,("Vector%udoesnotmaptoanIRQline",vector));K
0 :: ASSERT(sc->sc_net_idx->tx_req_prod==*//*TX_RING_ADD(sc->sc_net_idx->tx_resp_prod,sc->sc_tx_entries));*/K
2 :: ASSERT(per_cpu(vector_irq,cpu)[cfg->old_vector]==irq);
1 :: ASSERT(v->domain==p2m->domain);
2 :: ASSERT(l->locker==current->processor);
10 :: ASSERT(!pirq->masked);
3 :: ASSERT(p&&p->u.sh.type==SH_type_l2_32_shadow);
2 :: ASSERT(len>0||tmem_va==NULL);
1 :: ASSERT(scale.mul_frac!=0);
7 :: ASSERT(ret==LZO_E_OK);
6 :: ASSERT(pgp->obj->pool->client!=NULL);
12 :: ASSERT(pgp->obj->pool!=NULL);
3 :: ASSERT((y&PGC_count_mask)!=0);
3 :: ASSERT(sp->u.sh.type!=SH_type_l2_pae_shadow);
8 :: ASSERT(mfn_valid(snpmfn));
1 :: ASSERT(!mfn_valid(sh_ctxt->mfn2));
3 :: ASSERT(v->arch.hvm_vmx.active_cpu==smp_processor_id());
5 :: ASSERT(!(initial_images_end&~PAGE_MASK));
5 :: ASSERT(d->arch.p2m.alloc_page);
0 :: ASSERT(t==SH_type_fl1_32_shadow||t==SH_type_fl1_pae_shadow||t==SH_type_fl1_64_shadow||t==SH_type_monitor_table||==v->domain));
7 :: ASSERT(d->arch.shadow.hash_walking==0);
2 :: ASSERT((pg->u.inuse.type_info&PGT_count_mask)==0);
3 :: ASSERT(l3_backptr!=PGT_va_mutable);
0 :: ASSERT(sched[i].buffer_offset==purb->iso_frame_desc[i].offset);==((buffer_mach>>PAGE_SHIFT)+i));
3 :: ASSERT(l2e_get_flags(gl2e)&_PAGE_RW);
14 :: ASSERT(pagetable_get_paddr(v->arch.monitor_table));
9 :: ASSERT(!extraq_on(d,EXTRA_PEN_Q));
14 :: ASSERT((gmfn&~PGT_mfn_mask)==0);
25 :: ASSERT(sched[i].buffer_offset==purb->iso_frame_desc[i].offset);
16 :: ASSERT(insn_len>=PATCH_LEN);
4 :: ASSERT(!list_empty(RUNQUEUE(cpu)));
8 :: ASSERT(nr_psegs<=MAX_BLK_SEGS*2);
7 :: ASSERT(!__on_blkdev_list(p));
8 :: ASSERT((page->flags&PG_type_mask)==PGT_ldt_page);
0 :: ASSERT((devfn!=PCI_ISA_DEVFN)||((vendor_id==0x8086)&&(device_id==0x7000)));&&(sh_mfn_is_a_page_table(gmfn)||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask)
3 :: ASSERT(sp->u.sh.head||(shadow_type>SH_type_max_shadow));
3 :: ASSERT(!nodemask_retry);
1 :: ASSERT(gt->gt_version!=0);
1 :: ASSERT(pt->source==PTSRC_isa);
1 :: ASSERT(test_vhd_flag(bm->status,VHD_FLAG_BM_WRITE_PENDING));
1 :: ASSERT(!bitmap_in_use(lru));
2 :: ASSERT(mfn_to_shadow_page(_sl3mfn)->u.sh.type==SH_type_l3_64_shadow);
5 :: ASSERT(d->dirty_vram->sl1ma[i]==sl1ma);
4 :: ASSERT(!((unsignedlong)data&~PAGE_MASK));
3 :: ASSERT(((u8*)pdir_start)[7]==0);
13 :: ASSERT(h->cur<=h->size);
2 :: ASSERT(level==1||!(ft&FETCH_TYPE_DEMAND));
0 :: ASSERT(r&SHADOW_SET_L3PAE_RECOPY);
0 :: ASSERT(v->arch.shadow2.mode);
2 :: ASSERT(((l1va=d->arch.ptwr[PTWR_PT_ACTIVE].l1va)==0)||(l1_linear_offset(l1va)!=l1_linear_offset(addr)));
4 :: ASSERT(opcode);
9 :: ASSERT(entry->writable_pl1e==-1);
12 :: ASSERT(mpfn_info);
4 :: ASSERT(sdom->id!=IDLE_DOMAIN_ID);
5 :: ASSERT(crit_count[cpu]==0);
5 :: ASSERT(next!=NULL);
0 :: ASSERT(rx->id!=0,("xn_rxeof:foundfreereceiveindexof0n"));K
2 :: ASSERT(lru_index>=0);
2 :: ASSERT(!nestedhvm_vcpu_in_guestmode(v));
1 :: ASSERT(list_empty(&pgp->us.client_eph_pages));
2 :: ASSERT(!mfn_to_page(next)->u.sh.head);
1 :: ASSERT(pool->obj_count>=0);
10 :: ASSERT(pool!=NULL);
3 :: ASSERT(!(sp->count_info&PGC_count_mask));
6 :: ASSERT(read_cr0()&X86_CR0_TS);
6 :: ASSERT(!list_empty(&d->arch.paging.hap.freelists));
12 :: ASSERT((r&SHADOW_SET_FLUSH)==0);
3 :: ASSERT(mfn_x(sh_gfn_to_mfn(d,gfn))==mfn);
2 :: ASSERT(t==PGC_SH2_l3_shadow);
2 :: ASSERT((pg->count_info&PGC_SH2_type_mask)<PGC_SH2_max_shadow);
4 :: ASSERT(d->arch.htab.shadow!=NULL);
9 :: ASSERT(sp<(NR_VECTORS-1));
8 :: ASSERT(schedule_data[d->processor].curr);
0 :: ASSERT((inf->period<ULONG_MAX);
18 :: ASSERT(d->grant_table->maptrack!=NULL);
19 :: ASSERT(shadow_mode_enabled(ed->domain));
0 :: ASSERT(virt_to_machine(MMAP_VADDR(pending_idx,i));==buffer_mach+i<<PAGE_SHIFT);
3 :: ASSERT((x&PGT_validated)||test_bit(DF_DYING,&page->u.inuse.domain->flags));
14 :: ASSERT(current->domain!=IDLE_DOMAIN_ID);
3 :: ASSERT(rx->status==RING_STATUS_OK);
12 :: ASSERT((WEIGHT_PERIOD<ULONG_MAX)&&(EDOM_INFO(p)->slice_orig<ULONG_MAX));
0 :: ASSERT(boot_cpu_id==-1,("CPU%dclaimstobeBSP,butCPU%dalreadyis",apic_id,boot_cpu_id));K
1 :: ASSERT(pdev!=NULL);
2 :: ASSERT(spin_is_locked(&hd->mapping_lock)&&pt_mfn);
1 :: ASSERT(mfn_to_page(sl3mfn)->u.sh.head);
2 :: ASSERT(len<=XENSTORE_PAYLOAD_MAX);
1 :: ASSERT(!test_vhd_flag(s->bat.status,VHD_FLAG_BAT_WRITE_STARTED));
2 :: ASSERT(mfn_to_shadow_page(_sl4mfn)->u.sh.type==SH_type_l4_64_shadow);
3 :: ASSERT(sp->u.sh.type>0);
2 :: ASSERT(q>(char*)p);
12 :: ASSERT(spin_is_locked(&d->arch.irq_lock));
1 :: ASSERT(((unsignedlong)addr&PAGE_MASK)==LDT_VIRT_START(v));
17 :: ASSERT(l1e_get_pfn(l1e)!=INVALID_MFN||!p2m_is_ram(p2mt));
3 :: ASSERT((*res_ptr&m)==m);
4 :: ASSERT(!active_timer(&v->periodic_timer));
0 :: ASSERT((diff!=0)||vm86_mode(r)||((r->cs&3)>=GUEST_KERNEL_RPL)||
6 :: ASSERT(mfn_to_shadow_page(_sl4mfn)->type==SH_type_l4_64_shadow);
0 :: ASSERT(spin_is_locked(vpic_lock(vpic)));
2 :: ASSERT((unsignedlong)sl3e%(4*sizeof(shadow_l3e_t))==0);
2 :: ASSERT((mfn_to_page(_sl2mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_l2_pae_shadow||(mfn_to_page(_sl2mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_l2h_pae_shadow);
15 :: ASSERT(r>0);
2 :: ASSERT(head->next->pprev==&head->next);
0 :: ASSERT(reg==decode_dest_reg(prefix,buffer[index+2]));ASSERT(pagetable_get_pfn(v->arch.monitor_table));
3 :: ASSERT(s2mfn);
6 :: ASSERT(inst_len);
4 :: ASSERT(is_idle_task(ed->domain));
2 :: ASSERT(d==page_get_owner(&frame_table[mfn]));
24 :: ASSERT(pfn!=INVALID_M2P_ENTRY);
4 :: ASSERT(gpde&_PAGE_PRESENT);
6 :: ASSERT(current->id==IDLE_DOMAIN_ID);
6 :: ASSERT(!list_empty(&schedule_data[cpu].runqueue));
17 :: ASSERT(l1_pgentry_val(l1e)&_PAGE_PRESENT);
0 :: ASSERT((flags&(M_NOWAIT|M_WAITOK))==M_NOWAIT||(flags&(M_NOWAIT|M_WAITOK))==M_WAITOK,("_pmap_allocpte:flagsisneitherM_NOWAITnorM_WAITOK"));K
4 :: ASSERT((((unsignedlong)va)>=MAPCACHE_VIRT_START)&&(((unsignedlong)va)<=MAPCACHE_VIRT_END));
1 :: ASSERT(p2m_is_nestedp2m(p2m));
3 :: ASSERT(n2vmcb!=NULL);
5 :: ASSERT(p2m->domain->arch.paging.free_page);
4 :: ASSERT(mfn_to_page(smfn)->u.sh.head);
0 :: ASSERT(l4e_get_flags(idle_pg_table[l4_table_offset(RO_MPT_VIRT_START)]);&_PAGE_PRESENT);
1 :: ASSERT(bm&&bitmap_valid(bm)&&
8 :: ASSERT(IS_VALID_PAGE(pi));
4 :: ASSERT(out_len==PAGE_SIZE);
8 :: ASSERT(obj->pool!=NULL);
4 :: ASSERT(rc<0);
4 :: ASSERT((val==NULL)||((dir==IOREQ_READ)&&!value_is_ptr));
3 :: ASSERT(vmcs==this_cpu(host_vmcs));
7 :: ASSERT(v->vcpu_id==0);
9 :: ASSERT((link<=3)&&(isa_irq<=15));
1 :: ASSERT(pagetable_is_null(v->arch.shadow_table[slot]));
0 :: ASSERT(d->tot_pages>0);
14 :: ASSERT(shadow_mode_log_dirty(d));
0 :: ASSERT(op->cmd==XEN_DOMCTL_SCHEDOP_getinfo);
5 :: ASSERT(d->max_pages==d->tot_pages);
14 :: ASSERT(!cpus_empty(cpumask));
0 :: ASSERT((x&PGT_validated)||test_bit(_DOMF_dying,&page_get_owner(page)->domain_flags));ASSERT(hcb->ht==THASH_TLB);
9 :: ASSERT(d->processor<NR_CPUS);
8 :: ASSERT(d->exec_domain[i]->sched_priv!=NULL);
9 :: ASSERT(d->arch.out_of_sync_extras_count==0);
2 :: ASSERT(timer->timer_list.next);
4 :: ASSERT(r_time>ctx_allow);
0 :: ASSERT(cluster<=APIC_MAX_CLUSTER,("%s:cluster%utoobig",__func__,cluster));K
2 :: ASSERT(mfn_to_page(next)->u.sh.type==pg->u.sh.type);
4 :: ASSERT(apic<nr_ioapics);
6 :: ASSERT(!test_bit(pirq,d->pirq_mask));
3 :: ASSERT(cpu_isset(nxt,per_cpu(cpu_core_map,cpu)));
2 :: ASSERT(bat_locked(s));
1 :: ASSERT(pfp);
7 :: ASSERT(ma<DIRECTMAP_VIRT_END-DIRECTMAP_VIRT_START);
3 :: ASSERT(p_data!=NULL);
0 :: ASSERT(!(*ar&_SEGMENT_DPL));/sizeof(l1_pgentry_t));
3 :: ASSERT((_p2m)->locker==current->processor);
2 :: ASSERT(!guest_op||shadow_locked_by_me(d));
6 :: ASSERT(d->arch.paging.log_dirty.bitmap!=NULL);
3 :: ASSERT(op==XENMEM_maximum_gpfn);
28 :: ASSERT(hap_locked_by_me(d));
0 :: ASSERT(t==PGC_SH_fl1_32_shadow||t==PGC_SH_fl1_pae_shadow||t==PGC_SH_fl1_64_shadow||t==PGC_SH_monitor_table||(page_get_owner(mfn_to_page(_mfn(pg->u.inuse.type_info)));==v->domain));
2 :: ASSERT(bk->refcount>0);
3 :: ASSERT(__task_on_queue(v));
9 :: ASSERT(virq_is_global(virq));
12 :: ASSERT(v->runstate.state!=new_state);
13 :: ASSERT(cpus_weight(dirty_mask)<=1);
2 :: ASSERT(spin_is_locked(&p->mm.shadow_lock));
208 :: ASSERT(!in_irq());
4 :: ASSERT(((void*)ch->next<(void*)&_end)||memguard_is_guarded(ch->next));
3 :: ASSERT(memguard_is_guarded(ct));
15 :: ASSERT(entry->prev->next==entry);
0 :: ASSERT((_p)->u.inuse.domain==(_d))rc=gnttab_try_map(e,d,page,l1v&_PAGE_RW);
1 :: ASSERT(!boot_cpu_has(X86_FEATURE_TSC_RELIABLE));
2 :: ASSERT(nv->nv_vmexit_pending==0);
17 :: ASSERT(p2m_locked_by_me(p2m));
1 :: ASSERT(pcd->pfp!=NULL);
2 :: ASSERT(!pgp->obj->pool->persistent);
1 :: ASSERT(tmh_page_list_pages==0);
2 :: ASSERT(!(mfn&((1UL<<(L3_PAGETABLE_SHIFT-PAGE_SHIFT))-1)));
4 :: ASSERT(hd->pgd_maddr!=0);
2 :: ASSERT(l3e_get_flags(ml3e[0])&_PAGE_PRESENT);
3 :: ASSERT(pdirp);
2 :: ASSERT(sp->type!=SH_type_l2_pae_shadow);
16 :: ASSERT(v!=current);
3 :: ASSERT((sp==0)||(pending_lapic_eoi[cpu][sp-1].vector<vector));
8 :: ASSERT(is_idle_vcpu(v));
0 :: ASSERT(shmem_ref!=-ENOSPC);==buffer_mach+i<<PAGE_SHIFT);
40 :: ASSERT(v!=NULL);
17 :: ASSERT(VALID_M2P(l2pfn));
34 :: ASSERT(shadow_mode_write_all(d));
4 :: ASSERT(pagetable_val(ed->arch.monitor_table)==0);
9 :: ASSERT(shadow_mode_translate(d)||gpfn);
10 :: ASSERT((x&PGT_validated)||test_bit(DF_DYING,&page_get_owner(page)->d_flags));
6 :: ASSERT((WEIGHT_PERIOD<ULONG_MAX)&&(DOM_INFO(p)->slice_orig<ULONG_MAX));
8 :: ASSERT((_pfn)->count_info==0);
13 :: ASSERT((page->flags&PG_domain_mask)==current->domain);
1 :: ASSERT((desc->arch.used_vectors==NULL)||(desc->arch.used_vectors==irq_used_vectors));
4 :: ASSERT(list_empty(&wqv->list));
1 :: ASSERT(pgp->pcd->pgp_ref_count==1||pgp->eviction_attempted);
4 :: ASSERT(set_shared_p2m_entry(d,gfn,page_to_mfn(page))!=0);
2 :: ASSERT(page_get_owner(page)==dom_cow);
4 :: ASSERT(bdf<ivrs_bdf_entries);
12 :: ASSERT(pgp!=NULL);
2 :: ASSERT(mfn_to_shadow_page(mmfn)->u.sh.type==SH_type_monitor_table);
6 :: ASSERT(!((unsignedlong)start&~PAGE_MASK));
5 :: ASSERT(x<data_size);
2 :: ASSERT(seg==x86_seg_cs);
6 :: ASSERT(!v->arch.hvm_vcpu.flag_dr_dirty);
6 :: ASSERT((extra_space/sizeof(u32))<=TRACE_EXTRA_MAX);
2 :: ASSERT(mfn!=INVALID_MFN);
6 :: ASSERT(pagetable_get_pfn(d->arch.phys_table)==0);
2 :: ASSERT((page->shadow2_flags&(SH2F_L4_64|SH2F_L3_64|SH2F_L2_64|SH2F_L1_64))==0);
3 :: ASSERT(current==idle_vcpu[smp_processor_id()]);
8 :: ASSERT(l2_backptr!=PGT_va_unknown);
9 :: ASSERT(s&&s->lapic_info[number]);
0 :: ASSERT(ref!=-ENOSPC);==buffer_mach+i<<PAGE_SHIFT);==((buffer_mach>>PAGE_SHIFT)+i));
4 :: ASSERT(ed->domain->domain_id==IDLE_DOMAIN_ID);
15 :: ASSERT(ret.time>0);
32 :: ASSERT(!extraq_on(d,i));
9 :: ASSERT(a->smfn);
8 :: ASSERT(d->exec_domain[vcpu]==NULL);
16 :: ASSERT(a->spfn_and_flags&PSH_pfn_mask);
54 :: ASSERT(inf!=NULL);
0 :: ASSERT(((_p)->type_and_flags&PGT_count_mask)!=0);
3 :: ASSERT(!list_empty(&schedule_data[smp_processor_id()].runqueue));
8 :: ASSERT((!writeable)||((page_type_count(page)!=0)&&((page->flags&PG_type_mask)==PGT_writeable_page)));
2 :: ASSERT(t==PGC_SH2_fl1_32_shadow||t==PGC_SH2_fl1_pae_shadow||t==PGC_SH2_fl1_64_shadow||t==PGC_SH2_monitor_table||(page_get_owner(mfn_to_page(_mfn(pg->u.inuse.type_info)))==v->domain));
0 :: ASSERT((x&PGT_validated)||test_bit(_DOMF_dying,&page_get_owner(page)->domain_flags));diff-rdc50cdd66c5c-r0ed4a312765btools/xm-test/tests/sedf/Makefile.am--a/tools/xm-test/tests/sedf/Makefile.amTueMar1413:10:212006-0700SUBDIRS=TESTS=01_sedf_multi_pos.testXFAIL_TESTS=diff-rdc50cdd66c5c-r0ed4a312765bxen/Makefile--a/xen/MakefileTueMar1413:10:212006-0700#Allotherplacesthisisstored(eg.compile.h)shouldbeautogenerated.exportXEN_VERSION=3exportXEN_SUBVERSION=0exportXEN_EXTRAVERSION=.0exportXEN_FULLVERSION=$(XEN_VERSION).$(XEN_SUBVERSION)$(XEN_EXTRAVERSION)exportBASEDIR:=$(CURDIR)diff-rdc50cdd66c5c-r0ed4a312765bxen/Rules.mk--a/xen/Rules.mkTueMar1413:10:212006-0700#'makeclean'beforerebuilding.#verbose?=ndebug?=nperfc?=nperfc_arrays?=ncrash_debug?=nCFLAGS+=-g-D__XEN__ifneq($(debug),y)CFLAGS+=-DNDEBUGifeq($(verbose),y)CFLAGS+=-DVERBOSEendifelseCFLAGS+=-DVERBOSEendifdiff-rdc50cdd66c5c-r0ed4a312765bxen/arch/ia64/Rules.mk--a/xen/arch/ia64/Rules.mkTueMar1413:10:212006-0700I$(BASEDIR)/include/asm-ia64/linux-nullI$(BASEDIR)/arch/ia64/linux-I$(BASEDIR)/arch/ia64/linux-xenCFLAGS:=-nostdinc-fno-builtin-fno-common-fno-strict-aliasing#CFLAGS+=-O3#-O3over-inlinesmakingdebuggingtough!CFLAGS+=-O2#butnooptimizationcausescompileerrors!#CFLAGS+=-iwithprefixinclude-Wall-DMONITOR_BASE=$(MONITOR_BASE)diff-rdc50cdd66c5c-r0ed4a312765bxen/arch/ia64/vmx/vmx_hypercall.c--a/xen/arch/ia64/vmx/vmx_hypercall.cTueMar1413:10:212006-0700#include<xen/config.h>#include<xen/errno.h>#include<asm/vmx_vcpu.h>#include<public/xen.h>#include<public/event_channel.h>#include<asm/vmmu.h>#include<asm/tlb.h>#
3 :: ASSERT(((page->u.inuse.type_info&PGT_va_mask)>>PGT_va_shift)<(PAGE_OFFSET>>L2_PAGETABLE_SHIFT));
0 :: ASSERT((desc->arch.used_vectors==NULL);||(desc->arch.used_vectors==irq_used_vectors));
1 :: ASSERT(list_empty(&pcd->pgp_list));
4 :: ASSERT(error!=-EBUSY);
1 :: ASSERT(l1e_get_flags(l2e_to_l1e(l2e)[l1_table_offset(sva)])&_PAGE_PRESENT);
2 :: ASSERT(IS_PAGE_ALIGNED(page_va));
7 :: ASSERT(obj->no_evict==0);
2 :: ASSERT((memory_size_mb&~0x7fff)==0);
1 :: ASSERT(tps64!=0);
1 :: ASSERT(l1e_get_pfn(l1e)!=INVALID_MFN||!p2m_is_ram(*t));
11 :: ASSERT(d->arch.paging.hap.p2m_pages>=0);
2 :: ASSERT(!test_bit(v->vcpu_id,&info->vcpus));
4 :: ASSERT(l4e_get_flags(ml4e[0])&_PAGE_PRESENT);
9 :: ASSERT(res==1);
8 :: ASSERT(d->arch.shadow2_hash_table);
8 :: ASSERT(port!=0);
8 :: ASSERT(next->runstate.state!=RUNSTATE_running);
20 :: ASSERT(pagetable_get_pfn(d->vcpu[0]->arch.monitor_table));
0 :: ASSERT(s<=e);ASSERT(pagetable_get_pfn(d->vcpu[0]->arch.monitor_table));ASSERT(pagetable_get_pfn(v->arch.monitor_table));ASSERT(v->arch.shadow_vtable);ASSERT(v->arch.shadow_vtable);ASSERT(pagetable_get_pfn(d->vcpu[0]->arch.monitor_table));ASSERT(pagetable_get_pfn(v->arch.monitor_table));
56 :: ASSERT(extraq_on(d,i));
2 :: ASSERT(d->arch.iobmp_mask);
17 :: ASSERT(mmfn_info);
14 :: ASSERT(sched==pending_req->sched);
26 :: ASSERT((a->pfn&0xf0000000)==0);
0 :: ASSERT((sizeof(structpfn_info)<<20)<=add_to_domain_alloc_list(dom0_memory_end,max_page<<PAGE_SHIFT);--a/xen/include/asm-x86/page.hTueJul2715:04:592004+0000++b/xen/include/asm-x86/page.hTueJul2719:37:432004+0000--a/xen/include/xen/mm.hTueJul2715:04:592004+0000++b/xen/include/xen/mm.hTueJul2719:37:432004+0000/*page_alloc.c*/
1 :: ASSERT(gpfn==gfn);
1 :: ASSERT(len1<=PAGE_SIZE);
3 :: ASSERT(ioapic_pin<MAX_IOAPIC_PIN_NUM);
5 :: ASSERT(sp->count_info==0);
4 :: ASSERT(l1e_get_flags(*p2m_entry)&(_PAGE_PRESENT|_PAGE_PSE));
3 :: ASSERT(mfn_valid(mfn_x(gw->l2mfn)));
2 :: ASSERT(d->arch.paging.log_dirty.bitmap==NULL);
7 :: ASSERT((id==BUGFRAME_bug)||(id==BUGFRAME_assert));
3 :: ASSERT(t==SH_type_l2_shadow);
10 :: ASSERT(spin_is_locked(&s->pics_state->lock));
1 :: ASSERT(hashent->mfn==mfn);
0 :: ASSERT((unsignedlong)sl3e%(4*sizeof(shadow_l3e_t))==0);==PGC_SH2_l3_pae_shadow);
2 :: ASSERT((pg->count_info&PGC_SH2_type_mask)!=PGC_SH2_l4_64_shadow);
10 :: ASSERT((dst-rma)+oftree_len<eomem);
26 :: ASSERT(page->count_info==0);
0 :: ASSERT(pagetable_get_pfn(d->vcpu[0]->arch.monitor_table));ASSERT(pagetable_get_pfn(d->vcpu[0]->arch.monitor_table));
3 :: ASSERT(v);
10 :: ASSERT(d->arch.ops->guest_paging_levels>=PAGING_L3);
7 :: ASSERT(pagetable_val(d->arch.phys_table));
22 :: ASSERT(!(d->arch.shadow_mode&~mode));
25 :: ASSERT(i<=MMAP_PAGES_PER_REQUEST);
15 :: ASSERT((sizeof(structpfn_info)<<20)<=(FRAMETABLE_VIRT_END-FRAMETABLE_VIRT_START));
0 :: ASSERT(args->vector==-1,args->bus,args->irq>>2,'A'+(args->irq&0x3),args->vector,vector));K
1 :: ASSERT(!(req->flags&MEM_EVENT_FLAG_VCPU_PAUSED));
2 :: ASSERT(seg!=-1||bus==-1);
4 :: ASSERT(pirq_dpci->flags&HVM_IRQ_DPCI_GUEST_MSI);
3 :: ASSERT(!cpu_isset(nxt,per_cpu(cpu_core_map,cpu)));
1 :: ASSERT(test_batmap(s,blk)||(bm&&bitmap_valid(bm)));
2 :: ASSERT(pgp->pfp==NULL);
2 :: ASSERT(desc);
4 :: ASSERT(x<=data_size);
10 :: ASSERT(IS_COMPAT(v->domain));
5 :: ASSERT(mfn_x(gfn_to_mfn(d,gfn))==mfn);
2 :: ASSERT(guest_l2e_get_flags(*gw->l2e)&_PAGE_PSE);
7 :: ASSERT(!d->arch.shadow.hash_table);
34 :: ASSERT(shadow2_lock_is_acquired(d));
88 :: ASSERT(v==current);
8 :: ASSERT(result==-1||result>16);
5 :: ASSERT((page->u.inuse.type_info&PGT_count_mask)!=0);
77 :: ASSERT(mfn_valid(smfn));
4 :: ASSERT(!page_get_owner(pfn_to_page(v->arch.monitor_shadow_ref)));
3 :: ASSERT(st_scale_f||st_scale_i);
6 :: ASSERT(m->monitor_table);
5 :: ASSERT(value);
11 :: ASSERT(next_prime_inf->evt>=next_inf->evt);
0 :: ASSERT((x&PGT_validated)||test_bit(DF_DYING,&page_get_owner(page)->d_flags))
2 :: ASSERT((x&PGT_validated)||test_bit(DF_DYING,&page->u.inuse.domain->d_flags));
0 :: ASSERT((opte&PG_FRAME)!=(KERNTEXTOFF-KERNBASE_LOCORE));/*KD
4 :: ASSERT(per_cpu(vector_irq,cpu)[vector]==irq);
7 :: ASSERT(!test_bit(vector,cfg->used_vectors));
1 :: ASSERT(pfn_to_pdx(ma>>PAGE_SHIFT)<(DIRECTMAP_SIZE>>PAGE_SHIFT));
1 :: ASSERT(nv->nv_vvmcxaddr!=VMCX_EADDR);
5 :: ASSERT(l3e_get_pfn(l3e)!=INVALID_MFN||!p2m_is_ram(p2mt));
1 :: ASSERT((info->cur+(1UL<<PAGETABLE_ORDER)<info->epfn)&&info->cur>=info->spfn);
0 :: ASSERT((dirty_vram->sl1ma[i]&PAGE_MASK);==(sl1ma&PAGE_MASK));
1 :: ASSERT(spin_is_locked(&iommu->register_lock));
2 :: ASSERT(mfn_to_shadow_page(_sl2mfn)->u.sh.type==SH_type_l2_64_shadow||mfn_to_shadow_page(_sl2mfn)->u.sh.type==SH_type_l2h_64_shadow);
1 :: ASSERT(num_online_cpus()==1);
3 :: ASSERT(is_pv_32on64_vcpu(v));
6 :: ASSERT((x&PGT_validated)||page_get_owner(page)->is_dying);
5 :: ASSERT(!cpu_isset(nxt,cpu_core_map[cpu]));
0 :: ASSERT(res==0||res==SHADOW_SET_CHANGED);
8 :: ASSERT(current==(v));
13 :: ASSERT(pagetable_get_pfn(v->arch.monitor_table)==0);
12 :: ASSERT(sflags!=-1);
2 :: ASSERT(shflags&(1u<<bit));
4 :: ASSERT(log_htab_size>=HTAB_MIN_LOG_SIZE);
4 :: ASSERT(sizeof(header)<512);
2 :: ASSERT(action->ack_type==ACKTYPE_MULTI);
11 :: ASSERT(!pagetable_get_paddr(v->arch.monitor_table));
8 :: ASSERT(!pagetable_get_paddr(d->arch.phys_table));
19 :: ASSERT(snapshot_mfn);
4 :: ASSERT(ret.time>now);
4 :: ASSERT(pagetable_val(current->arch.guest_table)==(gmfn<<PAGE_SHIFT));
33 :: ASSERT(!IS_INVALID_M2P_ENTRY(gpfn));
16 :: ASSERT(a->pfn<0x00100000UL);
3 :: ASSERT(m->shadow_dirty_bitmap!=NULL);
13 :: ASSERT(a->pfn);
0 :: ASSERT((diff!=0)||vm86_mode(r)||((r->cs&3)>=GUEST_KERNEL_RPL)||(r->cs==0)||is_hvm_vcpu(current));
1 :: ASSERT(cpumask_test_cpu(nxt,per_cpu(cpu_core_mask,cpu)));
1 :: ASSERT(d->processor<nr_cpu_ids);
1 :: ASSERT(page_list_empty(&p2m->pod.super));
2 :: ASSERT(len1==len2);
1 :: ASSERT(_atomic_read(_c)>=0);
2 :: ASSERT(((unsignedlong)p&(align-1))==0);
4 :: ASSERT(!aiocbp->aio_cb);
2 :: ASSERT(n<=BLKIF_MAX_SEGMENTS_PER_REQUEST);
2 :: ASSERT(vlapic_enabled(vcpu_vlapic(v)));
7 :: ASSERT(mfn_valid(gw->l2mfn));
3 :: ASSERT(this_cpu(host_vmcs)==NULL);
135 :: ASSERT(shadow_locked_by_me(d));
12 :: ASSERT(vpic_is_locked(vpic));
2 :: ASSERT(sp->type!=SH_type_l2h_pae_shadow);
13 :: ASSERT(test_bit(_PGC_page_table,&page->count_info));
5 :: ASSERT((sp==0)||(pending_eoi[cpu][sp-1].vector<vector));
4 :: ASSERT(read_cr3()==__pa(idle_pg_table));
7 :: ASSERT(prev->runstate.state==RUNSTATE_running);
3 :: ASSERT(pagetable_get_phys(ed->arch.monitor_table));
28 :: ASSERT(!__task_on_queue(d));
27 :: ASSERT(mfn);
27 :: ASSERT(purb->actual_length<=purb->transfer_buffer_length);
10 :: ASSERT(current->domain->id==IDLE_DOMAIN_ID);
2 :: ASSERT(((page->u.inuse.type_info&PGT_va_mask)>>
1 :: ASSERT(nr_iovecs==1);
15 :: ASSERT(((_p)->u.inuse.type_info&PGT_type_mask)==(_t));
22 :: ASSERT(m->shadow_dirty_bitmap);
22 :: ASSERT(!p->has_cpu);
0 :: ASSERT(pmap->pm_stats.resident_count==0,("pmap_release:pmapresidentcount%ld!=0",pmap->pm_stats.resident_count));K
0 :: ASSERT((sizeof(structpfn_info)<<20)<=add_to_domain_alloc_list(dom0_memory_end,max_page<<PAGE_SHIFT);
4 :: ASSERT(nestedhvm_enabled(v->domain));
1 :: ASSERT(cpumask_empty(n->vcpu_dirty_cpumask));
1 :: ASSERT(!bitmap_in_use(bm));
2 :: ASSERT(pgpfound==pgp);
2 :: ASSERT(poolid!=MAX_POOLS_PER_DOMAIN);
14 :: ASSERT(pgp->obj!=NULL);
2 :: ASSERT((page->count_info&PGC_count_mask)!=0);
2 :: ASSERT(mfn_to_page(_sl2mfn)->u.sh.type==SH_type_l2_64_shadow||mfn_to_page(_sl2mfn)->u.sh.type==SH_type_l2h_64_shadow);
13 :: ASSERT(spin_is_locked(&desc->lock));
4 :: ASSERT(fd==-1);
7 :: ASSERT((devfn!=PCI_ISA_DEVFN)||((vendor_id==0x8086)&&(device_id==0x7000)));
0 :: ASSERT(!sh_l1e_is_magic(sl1e));
6 :: ASSERT(node<num_nodes);
2 :: ASSERT(shadow2_mode_enabled(v->domain));
6 :: ASSERT(level<=GUEST_PAGING_LEVELS);
70 :: ASSERT(inst_len>0);
12 :: ASSERT(idx<MAPCACHE_ENTRIES);
6 :: ASSERT(shadow_lock_is_acquired(_d));
13 :: ASSERT(!sedf_runnable(d));
8 :: ASSERT((l1_pgentry_val(p2m[gpfn])>>PAGE_SHIFT)==mfn);
4 :: ASSERT(x->gpfn_and_flags||((x==head)&&(x->next==NULL)));
57 :: ASSERT(shadow_mode_translate(d));
3 :: ASSERT(!shadow_mode_external(d));
3 :: ASSERT(!ed->arch.monitor_table);
3 :: ASSERT(m->shadow_mode);
0 :: ASSERT(cold||td->td_ucred!=NULL,("kerneltrapdoesn'thaveucred"));K
4 :: ASSERT(d->arch.hvm_domain.irq.dpci);
6 :: ASSERT(pgp->pfp!=NULL);
4 :: ASSERT(pool->client!=NULL);
2 :: ASSERT(mfn_to_page(mmfn)->u.sh.type==SH_type_monitor_table);
7 :: ASSERT(is_viridian_domain(d));
4 :: ASSERT(level<CONFIG_PAGING_LEVELS);
4 :: ASSERT((_d)->arch.paging.shadow.locker==-1);
2 :: ASSERT(page_get_owner(page)==NULL);
2 :: ASSERT(v->arch.shadow2_action_log);
0 :: ASSERT((mfn_to_page(mmfn)->count_info&PGC_SH2_type_mask);==PGC_SH2_monitor_table);
8 :: ASSERT(valid_mfn(gmfn));
5 :: ASSERT(guest_l1e_get_flags(gpte)&_PAGE_RW);
4 :: ASSERT(dividend<divisor);
4 :: ASSERT(VALID_MFN(gmfn));
3 :: ASSERT(sercon_buffer);
2 :: ASSERT(next_prime_einf->evt>=next_einf->evt);
17 :: ASSERT(prev_inf->time_slept>=mcus*prev_inf->mcu_advance);
20 :: ASSERT(p->sched_priv!=NULL);
0 :: ASSERT((dest&~(APIC_ID_MASK>>APIC_ID_SHIFT))==0,("%s:invaliddestination0x%x",__func__,dest));K
1 :: ASSERT(regs!=NULL);
2 :: ASSERT(dir==IOREQ_READ);
9 :: ASSERT(sp->u.sh.head);
3 :: ASSERT(smp_processor_id()==0);
7 :: ASSERT(client!=NULL);
2 :: ASSERT(mfn_to_page(_sl2mfn)->u.sh.type==SH_type_l2_pae_shadow||mfn_to_page(_sl2mfn)->u.sh.type==SH_type_l2h_pae_shadow);
4 :: ASSERT(opt_allow_hugepage&&!(mfn&(L1_PAGETABLE_ENTRIES-1)));
7 :: ASSERT(mfn_valid(gw->l3mfn));
0 :: ASSERT(pagetable_get_pfn(v->arch.guest_table));
5 :: ASSERT((_d)->arch.p2m.locker==current->processor);
52 :: ASSERT(shadow_locked_by_me(v->domain));
5 :: ASSERT(shadow_type<16);
3 :: ASSERT((len==4)&&(offset>0)&&(offset<=APIC_TDCR));
10 :: ASSERT(regs->error_code&PFEC_page_present);
0 :: ASSERT((pg->count_info&PGC_SH_type_mask)!=PGC_SH_l2h_pae_shadow);
0 :: ASSERT((unsignedlong)sl3e%(4*sizeof(shadow_l3e_t))==0);==PGC_SH_l3_pae_shadow);
0 :: ASSERT((mfn_to_page(_sl3mfn)->count_info&PGC_SH_type_mask)==PGC_SH_l3_64_shadow);
0 :: ASSERT(shadow_mode_external(v->domain));
3 :: ASSERT(valid_mfn(*sl1mfn));
2 :: ASSERT(!((unsignedlong)d&(sizeof(shadow_l1e_t)-1)));
14 :: ASSERT(hashent->refcnt!=0);
107 :: ASSERT(!shadow_mode_enabled(d));
7 :: ASSERT(!a->next);
19 :: ASSERT(order<=MAX_ORDER);
5 :: ASSERT(current->id!=IDLE_DOMAIN_ID);
0 :: ASSERT(VM_ASSIST(d,VMASST_TYPE_writable_pagetables)||shadow_mode_write_all(d))
0 :: ASSERT(((_p)->u.inuse.type_info&PGT_count_mask)!=0)voidaudit_domain(structdomain*d);--a/xen/include/asm-x86/shadow.hTueMar1508:15:002005+0000++b/xen/include/asm-x86/shadow.hTueMar1510:12:392005+0000
0 :: ASSERT(page_get_owner(_p)==(_d))unsignedlongflags);
0 :: ASSERT((!writeable)||((page->flags&PG_type_mask)==PGT_writeable_page)&&((page->flags&PG_need_flush)==PG_need_flush)));(((page_type_count(page)&~REFCNT_PIN_BIT)!=0)&&((page_type_count(page)!=0)&&
4 :: ASSERT(MSI_IRQ(desc-irq_desc));
2 :: ASSERT((_domain)->arch.nested_p2m_locker==-1);
4 :: ASSERT(mig);
7 :: ASSERT(victim!=NULL);
1 :: ASSERT(!bitmap_locked(bm));
4 :: ASSERT(cpus_weight(cmd->mask)==1);
6 :: ASSERT(domain_is_locked(d));
3 :: ASSERT(id==DOMID_SELF);
4 :: ASSERT(!(aiocbp->aio_offset&(dev->sector_size-1)));
3 :: ASSERT(pv_32on64_vcpu(v));
8 :: ASSERT(irq<VIOAPIC_NUM_PINS);
2 :: ASSERT(!list_empty(&d->arch.shadow2_freelists[SHADOW2_MAX_ORDER]));
2 :: ASSERT((pg[i].count_info&~(PGC_allocated|1))==0);
10 :: ASSERT(hvm_guest(v));
5 :: ASSERT(m2mfn_info);
8 :: ASSERT(d==page_get_owner(pfn_to_page(pagetable_get_pfn(
221 :: ASSERT(shadow_lock_is_acquired(d));
10 :: ASSERT(___shadow_status(d,gpfn,stype)==0);
10 :: ASSERT((a->pfn&~PSH_hl2)<0x00100000UL);
5 :: ASSERT(current->domain->id!=IDLE_DOMAIN_ID);
54 :: ASSERT(skb->dev==dev);
3 :: ASSERT((!writeable)||((page_type_count(page)!=0)&&((page->flags&PG_type_mask)==PGT_writeable_page)&&((page->flags&PG_need_flush)==PG_need_flush)));
