x_val,y_added,y_removed,y_combined
0,434,415,849
table,198,198,396
!constructed,184,184,368
!entered,157,157,314
!empty(),139,139,278
mReserved <= mCapacity,115,115,230
isLive(),114,114,228
IsProxy(obj),102,102,204
JSVAL_IS_DOUBLE_IMPL(l),93,93,186
constructed,78,78,156
 stream ,77,70,147
isInList(),67,67,134
self,64,64,128
13 == Foo::numDestroyed,63,63,126
4 == Foo::numDestroyed,63,63,126
 stream && stream->cursor ,66,60,126
!(arenaAddr & ArenaMask),60,60,120
(uintptr_t(t) & 1) == 0,54,54,108
sp != NULL,49,49,98
str,46,46,92
(ptrBits & 0x7) == 0,46,46,92
obj,46,46,92
mLength <= mReserved,46,46,92
!v.usingInlineStorage(),46,46,92
thingSize % Cell::CellSize == 0,45,45,90
allocated(),45,45,90
refCnt > 0,44,44,88
!listElem->isInList(),44,44,88
type > JSVAL_TYPE_DOUBLE,44,44,88
uintptr_t(rangeStart) + length * sizeof(T) >= uintptr_t(rangeStart),44,44,88
other,44,44,88
slow != fast1,44,44,88
length <= size_t(-1) / sizeof(T),44,44,88
!(keyHash & sCollisionBit),44,44,88
slow != fast2,44,44,88
 border->start >= 0 ,44,40,84
"moz_static_assert, __LINE__",42,42,84
"detail::IsSupported<T>::value && detail::IsSupported<U>::value, ""This type is not supported by CheckedInt""",42,42,84
b == JS_TRUE || b == JS_FALSE,42,42,84
8 == Foo::numDestroyed,41,41,82
11 == Foo::numDestroyed,41,41,82
1 == Foo::numDestroyed,41,41,82
3 == Foo::numDestroyed,41,41,82
aBytes[aLength] == '\0',40,40,80
slot < JSCLASS_RESERVED_SLOTS(GetObjectClass(obj)),38,38,76
usingInlineStorage(),37,37,74
!CapacityHasExcessSpace<T>(newCap),37,37,74
isEmpty(),37,37,74
sizeof(HashNumber) == 4,37,37,74
!entered && i < mLength,36,36,72
!entered && !empty(),36,36,72
!p,36,36,72
dither <= SK_DitherValueMax565,35,35,70
!ra_used(ir),35,35,70
fPixels,35,35,70
(unsigned)x < fWidth && (unsigned)y < fHeight,35,35,70
sizeof(JSValueTag) == 4,33,33,66
!js(),33,33,66
isObject(),33,33,66
sizeof(JSValueType) == 1,33,33,66
 ( face->len_buildchar == 0 ) == ( face->buildchar == NULL ) ,33,30,63
count > 0,31,31,62
addr % Cell::CellSize == 0,30,30,60
!js::RootMethods<T>::poisoned(v),30,30,60
!IsPoisonedPtr<T>(v),30,30,60
g->gcstate != GCSfinalize && g->gcstate != GCSpause,30,30,60
Chunk::withinArenasRange(addr),30,30,60
FINALIZE_LIMIT <= 255,30,30,60
uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv,30,30,60
firstOffset <= ArenaSize,30,30,60
(first & ~ArenaMask) == arenaAddr,30,30,60
lastOffset < ArenaSize,30,30,60
dst != src,30,30,60
r <= a,28,28,56
fRefCnt > 0,28,28,56
g <= a,28,28,56
mLength + incr <= mCapacity,28,28,56
(s.fInvType & ~(SkMatrix::kTranslate_Mask | SkMatrix::kScale_Mask)) == 0,28,28,56
b <= a,28,28,56
ptr_align_4(fCurr),28,28,56
fCurr <= fStop,28,28,56
!isEmpty(),27,27,54
p.found(),27,27,54
name,26,25,51
irt_isnum(t) || irt_isint(t) || irt_isaddr(t),25,25,50
map + nent == flinks,25,25,50
sz == 4 || sz == 8,25,25,50
(unsigned)index < 9,25,25,50
(unsigned)index < fCount,25,25,50
sz != CTSIZE_INVALID,25,25,50
ret != Z_STREAM_ERROR,30,20,50
first,25,25,50
fImage != NULL,25,25,50
found() && rhs.found(),25,25,50
s.fInvType & SkMatrix::kAffine_Mask,24,24,48
aheader->getFirstFreeSpan().isSameNonEmptySpan(headSpan),24,24,48
JSID_IS_VOID(id),24,24,48
l == js_CheckForStringIndex(l),24,24,48
(s.fInvType & ~(SkMatrix::kTranslate_Mask | SkMatrix::kScale_Mask | SkMatrix::kAffine_Mask)) == 0,24,24,48
((size_t)atom & 0x7) == 0,24,24,48
!initialized(),24,24,48
s.fInvType & SkMatrix::kPerspective_Mask,24,24,48
"KeySize <= keyShift, ""KeySize too big""",23,23,46
mLength + 1 <= mReserved,23,23,46
sid.isEmpty(),23,23,46
"offsetof(JSClass, call) == offsetof(Class, call)",23,23,46
sizeof(jsid) == JS_BYTES_PER_WORD,23,23,46
mLength <= mCapacity,23,23,46
"offsetof(JSClass, convert) == offsetof(Class, convert)",23,23,46
(l.asBits >> JSVAL_TAG_SHIFT) <= JSVAL_SHIFTED_TAG_OBJECT,23,23,46
"offsetof(JSClass, hasInstance) == offsetof(Class, hasInstance)",23,23,46
tag != JSVAL_TAG_CLEAR,23,23,46
l.asBits <= JSVAL_SHIFTED_TAG_MAX_DOUBLE,23,23,46
(uintptr_t(&obj) & TYPE_MASK) == 0,23,23,46
(objBits >> JSVAL_TAG_SHIFT) == 0,23,23,46
"offsetof(JSClass, resolve) == offsetof(Class, resolve)",23,23,46
incr <= mLength,23,23,46
i < argc_,23,23,46
sid.isVoid(),23,23,46
"offsetof(JSClass, enumerate) == offsetof(Class, enumerate)",23,23,46
reserved() <= mCapacity,23,23,46
"offsetof(JSClass, delProperty) == offsetof(Class, delProperty)",23,23,46
"offsetof(JSClass, finalize) == offsetof(Class, finalize)",23,23,46
"offsetof(JSClass, name) == offsetof(Class, name)",23,23,46
mLength + incr > mCapacity,23,23,46
"offsetof(JSClass, checkAccess) == offsetof(Class, checkAccess)",23,23,46
"sid.isEmpty(), JSID_IS_EMPTY(id)",23,23,46
"offsetof(JSClass, trace) == offsetof(Class, trace)",23,23,46
(strBits >> JSVAL_TAG_SHIFT) == 0,23,23,46
"offsetof(JSClass, getProperty) == offsetof(Class, getProperty)",23,23,46
"sid.isVoid(), JSID_IS_VOID(id)",23,23,46
"offsetof(JSClass, addProperty) == offsetof(Class, addProperty)",23,23,46
mLength <= reserved(),23,23,46
(l.asBits & 0x8000000000000000LL) == 0,23,23,46
"offsetof(JSClass, construct) == offsetof(Class, construct)",23,23,46
"sid.isObject(), JSID_IS_OBJECT(id) && JSID_TO_OBJECT(id) == sid.toObject()",23,23,46
JSID_IS_SPECIAL(id),23,23,46
"offsetof(JSClass, setProperty) == offsetof(Class, setProperty)",23,23,46
"usingInlineStorage(), mCapacity == sInlineCapacity",23,23,46
(ptrBits & 1) == 0,23,23,46
"offsetof(JSClass, flags) == offsetof(Class, flags)",23,23,46
"moz_static_assert, __COUNTER__",23,23,46
mLength + needed <= mReserved,23,23,46
(l.asBits >> JSVAL_TAG_SHIFT) <= JSVAL_TAG_OBJECT,23,23,46
pos <= mLength,23,23,46
sizeof(JSClass) == sizeof(Class),23,23,46
!(expr),22,22,44
((sMaxInit * sInvMaxAlpha) >> 7) < sMaxCapacity,22,22,44
n <= 1,22,22,44
ptr >= other.ptr,22,22,44
(next == this) == (prev == this),22,22,44
mutationCount == p.mutationCount,22,22,44
9 == Foo::numDestroyed,22,22,44
!(p.keyHash & sCollisionBit),22,22,44
refCnt >= 0,22,22,44
5 == Foo::numDestroyed,22,22,44
sizeof(jsval_layout) == 8,22,22,44
rangeStart <= ptr,22,22,44
prev->next == cur,22,22,44
rangeStart == other.rangeStart,22,22,44
sizeof(JSValueTag) == sizeof(uint32_t),22,22,44
rangeStart <= rangeEnd,22,22,44
!entry->isRemoved(),22,22,44
statementDone,22,22,44
ptr <= rangeEnd,22,22,44
10 == Foo::numDestroyed,22,22,44
collisionBit == 0 || collisionBit == sCollisionBit,22,22,44
(sMaxCapacity * sizeof(Entry)) <= UINT32_MAX,22,22,44
!value,22,22,44
0 == Foo::numDestroyed,22,22,44
7 == Foo::numDestroyed,22,22,44
rangeEnd == other.rangeEnd,22,22,44
size_t(index > 0 ? index : -index) <= size_t(-1) / sizeof(T),22,22,44
(sMaxCapacity * sInvMaxAlpha) <= UINT32_MAX,22,22,44
(uint32_t)l.s.tag <= (uint32_t)JSVAL_TAG_OBJECT,22,22,44
!elem->isSentinel,22,22,44
rangeStart <= p.ptr,22,22,44
inc <= size_t(-1) / sizeof(T),22,22,44
isLiveHash(keyHash),22,22,44
f->refCount() == 1,22,22,44
6 == Foo::numDestroyed,22,22,44
p.ptr <= rangeEnd,22,22,44
((uint32_t)ptr & 1) == 0,22,22,44
sizeof(JSValueShiftedTag) == sizeof(uint64_t),22,22,44
cur->prev == prev,22,22,44
end >= begin,22,22,44
12 == Foo::numDestroyed,22,22,44
!dead,22,22,44
"detail::IsSupported<T>::value, ""This type is not supported by CheckedInt""",22,22,44
!p.found(),22,22,44
dec <= size_t(-1) / sizeof(T),22,22,44
"fBounds.contains(x, y)",22,22,44
count >= 0,21,21,42
!RootMethods<T>::poisoned(value),21,21,42
base != NULL,21,21,42
d <= SK_DitherValueMax565,21,21,42
add != NULL,24,18,42
a <= 0xF,21,21,42
 first != NULL ,22,20,42
head != NULL,24,18,42
el != NULL,24,18,42
node,21,20,41
u != 0,20,20,40
ci->top <= L->stack_last,20,20,40
!(ir->op2 & IRSLOAD_PARENT),20,20,40
"rset_test(as->freeset, gpr)",20,20,40
ofs % sizeof(Node) == 0,20,20,40
irt_isint(ir->t) || irt_isu32(ir->t),20,20,40
!JS::IsPoisonedPtr(l),20,20,40
IR(ir->op1)->o == IR_UREFC,20,20,40
JSVAL_IS_DOUBLE(v),20,20,40
isInt32(),20,20,40
!irt_ispri(ir->t),20,20,40
irt_isint(ir->t) && st == IRT_NUM,20,20,40
count > 0 && colors != NULL,20,20,40
p - page <= CALLBACK_MCODE_SIZE,20,20,40
L->stack_last - L->stack == L->stacksize - EXTRA_STACK - 1,20,20,40
irt_type(ir->t) != st,20,20,40
isLua(L->ci),20,20,40
ctype_isfield(ctf->info),20,20,40
"dest, src, count * sizeof(T)",20,20,40
isDouble(),20,20,40
*stack == this,20,20,40
string,20,20,40
initialized(),20,20,40
old >= g->totalbytes,20,20,40
bits < 32,19,19,38
slot < GetObjectSlotSpan(obj),19,19,38
MOZ_COUNT_ASSERT_ARGS(__VA_ARGS__),19,19,38
__VA_ARGS__,19,19,38
(expr),19,19,38
"MOZ_ASSERT_CHOOSE_HELPER(MOZ_COUNT_ASSERT_ARGS(__VA_ARGS__)), (__VA_ARGS__)",19,19,38
"(__VA_ARGS__, 2, 1, 0)",19,19,38
!IsScopeObject(obj),19,19,38
mux != NULL,18,18,36
(uint8_t)b == b,18,18,36
o,18,18,36
(uint8_t)a == a,18,18,36
tolerance > 0,18,18,36
begin() <= it && it < end(),18,18,36
!IsPoisonedPtr<T>(v.value),18,18,36
&obj != NULL,18,18,36
"dst >= src, (size_t) (dst - src) >= len",18,18,36
thing,18,18,36
"src >= dst, (size_t) (src - dst) >= len",18,18,36
!usedRval_,18,18,36
begin() <= p && p <= end(),18,18,36
cond,18,17,35
"sizeof(T) <= sizeof(void*), ""mozilla::ThreadLocal can't be used for types larger than "" ""a pointer""",17,17,34
JSID_IS_DEFAULT_XML_NAMESPACE(id) || JSID_IS_VOID(id),17,17,34
s.fInvKy == 0,16,16,32
ptr_ != UninitializedTag(),16,16,32
target,16,16,32
signbit == 0 || signbit == 1,16,16,32
info.prevp,15,15,30
ChunkPadSize < BytesPerArenaWithHeader,15,15,30
ArenaShift < 16,15,15,30
"sizeof(double) == sizeof(uint64_t), ""double must be 64 bits""",15,15,30
uvprev(uvnext(uv)) == uv && uvnext(uvprev(uv)) == uv,15,15,30
(last & ArenaMask) == ArenaMask,15,15,30
firstOffset <= ((lastOffset + 1) & ~size_t(1)),15,15,30
ArenaShift >= 8 + 1 + 1 + 1,15,15,30
!(lastOffset & 1),15,15,30
!(addr & ChunkMask),15,15,30
e->k == VVOID || e->k == VJMP,15,15,30
!markOverflow,15,15,30
(fins->op2 & IRCONV_TRUNC),15,15,30
sizeof(HeapSlot) == sizeof(Value),15,15,30
thingSize >= sizeof(FreeSpan),15,15,30
isgray(o),15,15,30
arenaAddr == next->arenaAddressUnchecked(),15,15,30
!js::GCMethods<T>::poisoned(newPtr),15,15,30
ptr - dec < ptr,15,15,30
"0 && ""Not implemented""",15,15,30
!hasDelayedMarking,15,15,30
!(addr & ArenaMask),15,15,30
last != uintptr_t(-1),15,15,30
color != BLACK,15,15,30
allocKind <= size_t(FINALIZE_LIMIT),15,15,30
"isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o)",15,15,30
ArenaBitmapBytes * ArenasPerChunk == sizeof(ChunkBitmap),15,15,30
first <= last,15,15,30
"isblack(o) && !isdead(g, o)",15,15,30
(ArenaSize - lastOffset) % thingSize == 0,15,15,30
irt_ispri(ir->t) || irt_isaddr(ir->t) || irt_isinteger(ir->t),15,15,30
bit < ArenaBitmapBits * ArenasPerChunk,15,15,30
capacity <= sMaxCapacity,15,15,30
last < next->first,15,15,30
tref_isnumber(tr),15,15,30
"(addr & ChunkMask) == offsetof(Chunk, info.next)",15,15,30
chunk != NULL,15,15,30
 (_CONDITION) ,15,15,30
beforeTail >= sizeof(FreeSpan) + Cell::CellSize,15,15,30
ptr + inc > ptr,15,15,30
"color, color < aheader->getThingSize() / Cell::CellSize",15,15,30
spanLengthWithoutOneThing % Cell::CellSize == 0,15,15,30
withinArenasRange(addr),15,15,30
irt_isguard(t) || !(ir->op2 & IRSLOAD_TYPECHECK),15,15,30
fs->bl == NULL,15,15,30
!allocatedDuringIncremental,15,15,30
spanLength % Cell::CellSize == 0,15,15,30
!(uintptr_t(aheader) & ArenaMask),15,15,30
last,15,15,30
ofs == 0,15,15,30
mStatementDone,15,15,30
"iswhite(o) && !isdead(g, o)",15,15,30
argv[i][0] == '-',15,15,30
fs->freereg == fs->nactvar,15,15,30
sizeof(HeapValue) == sizeof(Value),15,15,30
L->top - L->base == delta,15,15,30
!another->isEmpty(),15,15,30
bl->nactvar == fs->nactvar,15,15,30
arenaAddr + ArenaSize == next->first,15,15,30
thing == last,15,15,30
span->isWithinArena(arenaAddress()),15,15,30
start <= end,15,15,30
s == '[' || s == ']',15,15,30
first - 1 <= last,15,15,30
target < fs->pc,15,15,30
g->gc.state != GCSfinalize && g->gc.state != GCSpause,15,15,30
!irt_isnum(ir->t),15,15,30
reg == fs->freereg,15,15,30
!allocated(),15,15,30
iswhite(obj2gco(L1)),15,15,30
hasNext(),15,15,30
ArenaBitmapBits == ArenaBitmapWords * JS_BITS_PER_WORD,15,15,30
currIsNewline(ls),15,15,30
filename != NULL,15,15,30
irt_isint(ir->t) || irt_isu32(ir->t) || irt_isaddr(ir->t),15,15,30
"sizeof(a) == sizeof(uintptr_t), ""Strange pointer!""",15,15,30
next->first - 1 == next->last,15,15,30
js(),15,15,30
!(ir->op2 & IRXLOAD_UNALIGNED),15,15,30
sizeof(Chunk) == ChunkSize,15,15,30
false,16,13,29
dst,15,14,29
e,14,14,28
empty(),14,14,28
"mozilla::IsPointer<T>::value, ""js::NullPtr overload not valid for non-pointer types""",14,14,28
refCnt == detail::DEAD,14,14,28
"aSize >= sizeof(uintptr_t), ""poisoning this object has no effect""",14,14,28
"(uintptr_t)aPtr % sizeof(uintptr_t) == 0, ""bad alignment""",14,14,28
"sizeof(ValueAlignmentTester) == 16, ""JS::Value must be 16-byte-aligned""",14,14,28
"(DoubleExponentBits & DoubleSignificandBits) == 0, ""exponent bits don't overlap significand bits""",14,14,28
"(DoubleSignBit & DoubleSignificandBits) == 0, ""sign bit doesn't overlap significand bits""",14,14,28
c,14,14,28
"mozilla::IsPointer<T>::value, ""JS::NullPtr overload not valid for non-pointer types""",14,14,28
(int16_t)x == x,14,14,28
(mask & ~kAllMasks) == 0,14,14,28
count == 0 || array != NULL,14,14,28
source,14,14,28
SkAlign4(length) == length,14,14,28
(unsigned)srcScale <= 256,14,14,28
"(DoubleSignBit | DoubleExponentBits | DoubleSignificandBits) == ~uint64_t(0), ""all bits accounted for""",14,14,28
fRec && fCount > 0,14,14,28
"sizeof(LayoutAlignmentTester) == 16, ""jsval_layout must be 16-byte-aligned""",14,14,28
"(DoubleSignBit & DoubleExponentBits) == 0, ""sign bit doesn't overlap exponent bits""",14,14,28
"src >= dst, size_t(src - dst) >= nelem",14,14,28
&a && &b,14,14,28
(g >> (8 - SK_G16_BITS)) == SkGetPackedG16(src),14,14,28
(b >> (8 - SK_B16_BITS)) == SkGetPackedB16(src),14,14,28
expr,14,14,28
c == (uint16_t)c,14,14,28
"sizeof(MOZ_UTF16('A')) == 2, ""Is char literal 16 bits?""",14,14,28
fRec && fCount > idx,14,14,28
ptr_ != NULL,16,12,28
(r >> (8 - SK_R16_BITS)) == SkGetPackedR16(src),14,14,28
mLength + insLength <= mReserved,14,14,28
SkAlign4(size) == size,14,14,28
(unsigned)scale16 <= 16,14,14,28
(unsigned)y < (unsigned)fHeight,14,14,28
src == SkToU16(src),14,14,28
"sizeof(jsval_layout) == sizeof(JS::Value), ""jsval_layout and JS::Value must have identical layouts""",14,14,28
"sizeof(char16_t) == 2, ""Is char16_t type 16 bits?""",14,14,28
"sizeof(MOZ_UTF16("""")[0]) == 2, ""Is string char 16 bits?""",14,14,28
data != 0 || size == 0,14,14,28
"dst >= src, size_t(dst - src) >= nelem",14,14,28
(int16_t)y == y,14,14,28
sizeof(JSHashNumber) == 4,13,13,26
table == NULL,13,13,26
kind != JSTRACE_SHAPE,13,13,26
validEntry,13,13,26
(uintptr_t(ptr) & 0x1) == 0,13,13,26
"id == INTERNED_STRING_TO_JSID(NULL, (JSString*)atom)",13,13,26
tos < limit,12,12,24
"reason, __FILE__, __LINE__",12,12,24
!usingInlineStorage(),12,12,24
freeLists[i].isEmpty(),12,12,24
!(uintptr_t(l) & gc::ChunkMask),12,12,24
!aheader->hasFreeThings(),12,12,24
backgroundFinalizeState[i] == BFS_DONE,12,12,24
data != NULL,12,12,24
!stack,12,12,24
!hasCollision(),12,12,24
StackTagMask <= gc::Cell::CellMask,12,12,24
!(addr & StackTagMask),12,12,24
isDrained(),12,12,24
js_CheckForStringIndex(id) == id,12,12,24
!(uintptr_t(chunk) & gc::ChunkMask),12,12,24
isLiveHash(hn),12,12,24
nextTos <= limit,12,12,24
mLength + length <= mReserved,12,12,24
(int)max >= 0,12,12,24
(XY >> 16) < (unsigned)s.fBitmap->height() && (XY & 0xFFFF) < (unsigned)s.fBitmap->width(),12,12,24
data_size != NULL,12,12,24
this->isComplex(),12,12,24
array <= end,12,12,24
refCnt == -0xdead,12,12,24
tree != NULL,12,12,24
sweeping(),12,12,24
!sweeping(),12,12,24
StackTagMask >= uintptr_t(LastTag),12,12,24
backgroundFinalizeState[i] == BFS_DONE || backgroundFinalizeState[i] == BFS_JUST_FINISHED,12,12,24
!(uintptr_t(k) & gc::ChunkMask),12,12,24
stack == ballast,12,12,24
s < STAT_LIMIT,12,12,24
JSID_IS_DEFAULT_XML_NAMESPACE(id),12,12,24
(l.asBits >> 32) == 0,12,12,24
"sid.isDefaultXMLNamespace(), JSID_IS_DEFAULT_XML_NAMESPACE(id)",12,12,24
color == gc::BLACK,12,12,24
br != NULL,12,12,24
freeLists[kind].isEmpty(),12,12,24
s.fDoFilter,12,12,24
b != 0,12,12,24
sid.isDefaultXMLNamespace(),12,12,24
sp != 0,11,11,22
!RootMethods<T>::poisoned(ptr),11,11,22
fRefCnt == 1,11,11,22
index + count <= fCount,11,11,22
fReserve == 0 && fCount == 0,11,11,22
b > 0,11,11,22
a > 0,11,11,22
 cmap->code_to_sid != NULL ,11,10,21
 ( decoder->len_buildchar == 0 ) == ( decoder->buildchar == NULL ) ,11,10,21
 face && face->bdffont ,11,10,21
 num_args >= 0 ,11,10,21
 snode->count <= FTC_SBIT_ITEMS_PER_NODE ,11,10,21
 known_othersubr_result_cnt == 0 || unknown_othersubr_result_cnt == 0 ,11,10,21
 stream && stream->cursor == 0 ,11,10,21
 FT_Outline_Check( outline ) == 0 ,11,10,21
 FT_ABS( point->out_dir ) == major_dir && point->in_dir != point->out_dir ,11,10,21
 axis_count <= T1_MAX_MM_AXIS ,11,10,21
 block == NULL ,11,10,21
 scaling ,11,10,21
 cmap->indices != NULL ,11,10,21
 globals->metrics[nn]->clazz == clazz ,11,10,21
 state->free_ent < state->prefix_size ,11,10,21
 list->num_nodes == 0 ,11,10,21
 (FT_UInt)( char_code - FTC_CMAP_NODE( node )->first ) < FTC_CMAP_INDICES_MAX ,11,10,21
 first == node ,11,10,21
 point <= end_point && ( point->flags & touch_flag ) != 0 ,11,10,21
 encoding->code_first <= encoding->code_last ,11,10,21
 flag != NULL ,11,10,21
 **acur == '{' ,11,10,21
 left->start >= 0 ,11,10,21
 prev == node ,11,10,21
pc != -1,10,10,20
"last, ""This tree must contain the element being removed.""",10,10,20
delta == (int8_t)delta,10,10,20
ptr,10,10,20
JSVAL_IS_STRING(v),10,10,20
"minimum, Comparator::compare(*minimum, *node) < 0",10,10,20
!this->usedRval_,10,10,20
last == root,10,10,20
"e1->u.s.info == GETARG_B(getcode(fs, e2))-1",10,10,20
ir->o == IR_KINT || ir->o == IR_KGC || ir->o == IR_KPTR || ir->o == IR_KKPTR || ir->o == IR_KNULL,10,10,20
T* ptr,10,10,20
JSVAL_IS_OBJECT_OR_NULL_IMPL(JSVAL_TO_IMPL(v)),10,10,20
"JSContext *cx, JSObject *proxy, jsid id",10,10,20
!*parentPointer,10,10,20
parent->right == node,10,10,20
ttisfunction(ci->func),10,10,20
!isblack(o) && uv->v != &uv->u.value,10,10,20
"!contains(*v), ""Duplicate elements are not allowed.""",10,10,20
iswhite(obj2gco(htab)),10,10,20
iscollectable(t1),10,10,20
ttisstring(rb),10,10,20
"t >= 0 || -(t + 1) != T((1ULL << (CHAR_BIT * sizeof(T) - 1)) - 1), ""You can't negate the smallest possible negative integer!""",10,10,20
f->upvalues[i] == name,10,10,20
isString(),10,10,20
"dst < src, PointerRangeSize(static_cast<const volatile T*>(dst), src) >= nelem",10,10,20
e1->f == NO_JUMP,10,10,20
L->top == L->ci->top || luaG_checkopenop(i),10,10,20
g->rootgc == obj2gco(L),10,10,20
GET_OPCODE(*((L->ci)->savedpc - 1)) == OP_CALL,10,10,20
ctype_hassize(ct->info),10,10,20
"!node->parent, node == root",10,10,20
target - p >= -128,10,10,20
ttisnil(gval(mp)),10,10,20
J->baseslot > 1,10,10,20
sizeof(Value) == 8,10,10,20
getBMode(o) != OpArgN || b == 0,10,10,20
ir->o == IR_TNEW || ir->o == IR_TDUP || ir->o == IR_CNEW || ir->o == IR_CNEWI,10,10,20
!ttisnil(gkey(n)),10,10,20
uint32_t(int32_t(ui)) == ui,10,10,20
i < Length,10,10,20
n >= 0 && n < 32,10,10,20
J->baseslot == 1,10,10,20
bit < js::gc::ChunkMarkBitmapBits,10,10,20
g->gcstate != GCSpause && g->gcstate != GCSpropagate,10,10,20
!js::GCMethods<T>::poisoned(v),10,10,20
pc >= proto_bc(J->pt) && pc < proto_bc(J->pt) + J->pt->sizebc,10,10,20
ttype(gkey(n)) != LUA_TDEADKEY || ttisnil(gval(n)),10,10,20
!ttisstring(p1) && !ttisnumber(p1),10,10,20
bsz > 0 && bsz <= 8*ctype_bitcsz(info),10,10,20
"dst < src, PointerRangeSize(static_cast<const T*>(dst), src) >= 1",10,10,20
old >= g->gc.total,10,10,20
L->nCcalls == L->baseCcalls,10,10,20
lexstate.fs == NULL,10,10,20
g->totalbytes == sizeof(LG),10,10,20
IsPowerOfTwo(alignment),10,10,20
n == 2 || n == 4,10,10,20
k,10,10,20
"sp == NULL, script_ != NULL",10,10,20
L->ci->top <= L->stack_last,10,10,20
getOpMode(o) == iABx || getOpMode(o) == iAsBx,10,10,20
k != 0,10,10,20
isNumber(),10,10,20
ir->o == IR_CONV && ir->op2 == IRCONV_NUM_INT,10,10,20
bl.breaklist == NO_JUMP,10,10,20
(nsize == 0) == (block == NULL),10,10,20
getCMode(o) != OpArgN || c == 0,10,10,20
iswhite(obj2gco(cl)),10,10,20
sizeof(JSWhyMagic) <= 4,10,10,20
(osize == 0) == (block == NULL),10,10,20
"root, ""No min to remove!""",10,10,20
*narray/2 <= na && na <= *narray,10,10,20
L->errfunc == 0,10,10,20
tostore != 0,10,10,20
node == root,10,10,20
"GETARG_A(getcode(fs,&e)) == fs->nactvar",10,10,20
"(detail::IsInBounds<From, To>(from))",10,10,20
"_type != Type::ARRAY && _type != Type::DICTIONARY, """"",10,10,20
allow != RSET_EMPTY,10,10,20
asT(),10,10,20
cl->l.nupvalues == cl->l.p->nups,10,10,20
"traceref(J, bc_d(*pc)) == T",10,10,20
"src < dst, PointerRangeSize(src, static_cast<const volatile T*>(dst)) >= nelem",10,10,20
!irt_isnil(irkey->t),10,10,20
ttisstring(KBx(i)),10,10,20
isFinite(),10,10,20
sz == CTSIZE_PTR,10,10,20
"src < dst, PointerRangeSize(src, static_cast<const T*>(dst)) >= nelem",10,10,20
!root,10,10,20
"!isdead(g, curr) || testbit(curr->gch.marked, FIXEDBIT)",10,10,20
"Comparator::compare(*leftMaximum, *node) < 0",10,10,20
f->k == VNONRELOC,10,10,20
!IsPoisonedPtr(str),10,10,20
cc.v.k == VVOID || cc.tostore > 0,10,10,20
node->right->parent == node,10,10,20
pos < 8*ctype_bitcsz(info),10,10,20
!allowed(),10,10,20
getCMode(o) == OpArgN,10,10,20
"rset_test(as->freeset, fpr)",10,10,20
"src < dst, PointerRangeSize(src, static_cast<const T*>(dst)) >= 1",10,10,20
"T(double(t)) == t, ""value creation would be lossy""",10,10,20
!isLive(),10,10,20
isObjectOrNull(),10,10,20
asUintptr() + inc * sizeof(T) >= asUintptr(),10,10,20
i < mLength,10,10,20
len != 0,10,10,20
cts->L,10,10,20
!irt_isfp(ir->t),10,10,20
GETARG_C(i) - 1 == LUA_MULTRET,10,10,20
"isMagic(), data.s.payload.why == why",10,10,20
"!IsNaN(d), ""NaN does not have a sign""",10,10,20
ttisnil(gval(n)),10,10,20
js::CurrentThreadCanAccessRuntime(runtime_),10,10,20
ir->o == IR_HIOP,10,10,20
L1->openupval == NULL,10,10,20
ttype(t1) == ttype(t2),10,10,20
isdigit(ls->current),10,10,20
!bl->isbreakable || !bl->upval,10,10,20
GET_OPCODE(*pc) == OP_MOVE,10,10,20
"rset_test(as->freeset, gpr+1)",10,10,20
!isDouble(),10,10,20
"rset_test(as->freeset, r)",10,10,20
!iswhite(obj2gco(g->mainthread)),10,10,20
p->is_vararg & VARARG_HASARG,10,10,20
isGCThing(),10,10,20
"cast_int(h%newsize) == lmod(h, newsize)",10,10,20
ls->lookahead.token == TK_EOS,10,10,20
ctype_isbitfield(info),10,10,20
base == L->base && L->base == L->ci->base,10,10,20
ls->fs->f->maxstacksize >= ls->fs->freereg && ls->fs->freereg >= ls->fs->nactvar,10,10,20
G(L)->tmudata == NULL,10,10,20
strlen(luaX_tokens[i])+1 <= TOKEN_LEN,10,10,20
!IsPoisonedPtr(&obj),10,10,20
"Comparator::compare(v, *last) == 0",10,10,20
e1->t == NO_JUMP,10,10,20
"luaO_rawequalObj(&fs->f->k[cast_int(nvalue(idx))], v)",10,10,20
g->strt.nuse == 0,10,10,20
ttisstring(&p->k[g]),10,10,20
g->gcstate == GCSsweepstring || g->gcstate == GCSsweep,10,10,20
second,10,10,20
funcstate.f->nups == 0,10,10,20
JSVAL_IS_BOOLEAN(v),10,10,20
id == 0,10,10,20
s->size == CTSIZE_PTR,10,10,20
*stack == reinterpret_cast<Rooted<void*>*>(this),10,10,20
"(uintptr_t(ptr) % sizeof(T)) == 0, ""Unaligned pointer!""",10,10,20
!currIsNewline(ls),10,10,20
js::IsInRequest(cx),10,10,20
L->status == LUA_YIELD,10,10,20
ir->o == IR_STRREF,10,10,20
"token == cast(unsigned char, token)",10,10,20
js::GetObjectClass(&v.toObject()) == &js::FunctionClass,10,10,20
wordIndex < length,10,10,20
tref_isfunc(tr),10,10,20
!tvisint(key),10,10,20
"dst < src, PointerRangeSize(static_cast<const T*>(dst), src) >= nelem",10,10,20
"JSContext *cx, JSObject *obj, jsid id",10,10,20
isMarkable(),10,10,20
JSVAL_IS_GCTHING(v),10,10,20
((delta + 0x02000000) >> 26) == 0,10,10,20
!js::GCMethods<T>::poisoned(value),10,10,20
"root, !root->parent",10,10,20
newCapacity <= sMaxCapacity,10,10,20
ttype(&o->gch) != LUA_TTABLE,10,10,20
startpc >= proto_bc(pt) && startpc < proto_bc(pt) + pt->sizebc,10,10,20
ra_hasreg(r),10,10,20
"testbit(h->marked, VALUEWEAKBIT) || testbit(h->marked, KEYWEAKBIT)",10,10,20
n != 0,10,10,20
asUintptr() - dec * sizeof(T) <= asUintptr(),10,10,20
node->left->parent == node,10,10,20
!L->allowhook,10,10,20
r != t,10,10,20
e->k == VNONRELOC,10,10,20
event <= TM_EQ,10,10,20
((delta + 0x8000) >> 16) == 0,10,10,20
"isdead(g, curr) || deadmask == bitmask(SFIXEDBIT)",10,10,20
bitNumber < 32,10,10,20
(ir+1)->o == IR_HIOP,10,10,20
"lua_getinfo(L, ""lS"", ar)",10,10,20
base <= L->top && L->top <= L->stack + L->stacksize,10,10,20
nret == fs->freereg - first,10,10,20
dest != NO_JUMP,10,10,20
IsArray(),10,10,20
gco2th(o) != L && gco2th(o) != G(L)->mainthread,10,10,20
getOpMode(o) == iABC,10,10,20
JSVAL_IS_DOUBLE_IMPL(data),10,10,20
sFreeKey == 0,10,10,20
ra_hasreg(r) && !ra_hasspill(ir->s),10,10,20
funcstate.prev == NULL,10,10,20
n != dummynode,10,10,20
isMagic(),10,10,20
JSVAL_IS_INT(v),10,10,20
ci == L->base_ci && firstArg > L->base,10,10,20
"mIsValid, ""Invalid checked integer (division by zero or integer overflow)""",10,10,20
GET_OPCODE(*((ci-1)->savedpc - 1)) == OP_CALL || GET_OPCODE(*((ci-1)->savedpc - 1)) == OP_TAILCALL,10,10,20
r != d,10,10,20
isBoolean(),10,10,20
dest,10,10,20
p->v != &p->u.value,10,10,20
ci->top <= l->stack_last,10,10,20
LJ_DUALNUM || !irt_isint(t) || (ir->op2 & (IRSLOAD_CONVERT|IRSLOAD_FRAME)),10,10,20
L->top == L->base + clvalue(func)->l.p->maxstacksize,10,10,20
!LJ_SOFTFP,10,10,20
luaG_checkcode(f),10,10,20
testTMode(GET_OPCODE(*pc)) && GET_OPCODE(*pc) != OP_TESTSET && GET_OPCODE(*pc) != OP_TEST,10,10,20
v->k == VLOCAL || v->k == VUPVAL,10,10,20
src,10,10,20
!(fun->flags & JS_FUNCTION_INTERPRETED_BIT),10,10,20
!(irt_isint64(ir->t) || (st == IRT_I64 || st == IRT_U64)),10,10,20
!JS::IsPoisonedPtr(k),10,10,20
(LJ_SOFTFP ? 0 : irt_isnum(ir->t)) || irt_isint(ir->t) || irt_isaddr(ir->t),10,10,20
ctype_isinteger(ctt->info) && ctt->size <= 4,10,10,20
"(IsBaseOf<SupportsWeakPtrBase<T, WeakReference>, T>::value), ""T must derive from SupportsWeakPtrBase<T, WeakReference>""",9,9,18
sizeof(JSBool) == 4,9,9,18
N == 0,9,9,18
significand & detail::DoubleSignificandBits,9,9,18
!js::RootMethods<T>::poisoned(value),9,9,18
chars[length] = '\0',9,9,18
"tl::IsRelocatableHeapType<T>::result, ""Set element type must be relocatable""",9,9,18
code_lengths != NULL,9,9,18
(significand & ~detail::DoubleSignificandBits) == 0,9,9,18
wpi_list,9,9,18
"tl::IsRelocatableHeapType<Value>::result, ""Value type must be relocatable""",9,9,18
"false, reason",9,9,18
!js::RootMethods<T>::poisoned(ptr),9,9,18
len > 0,9,9,18
"(IsBaseOf<RefCounted<T>, T>::value), ""T must derive from RefCounted<T>""",9,9,18
"!usingInlineStorage(), !CapacityHasExcessSpace<T>(mCapacity)",9,9,18
IsNaN(pun.d),9,9,18
(byteDestPtr < byteSrcPtr && byteDestPtr + count <= byteSrcPtr) || (byteSrcPtr < byteDestPtr && byteSrcPtr + count <= byteDestPtr),9,9,18
p->last_y + y_pos + num_lines_out < p->output->height,9,9,18
"tl::IsRelocatableHeapType<Key>::result, ""Key type must be relocatable""",9,9,18
wpi,9,9,18
hasDelayedMarking,8,8,16
fType == SkType_Array,8,8,16
sizeof(uint32)==4,8,8,16
(unsigned)y <= 0xF,8,8,16
-1 != a.fHashIndex && -1 != b.fHashIndex,8,8,16
"_reference > 0, ""reference count should greater than 0""",8,8,16
"validateChildRelations(b, true)",8,8,16
allocatedDuringIncremental,8,8,16
(n) != 0,8,8,16
3 == kInverseEvenOdd_PathFill,8,8,16
(int)max >= 0 && is_pow2(max + 1),8,8,16
s.fDoFilter == false,8,8,16
fType != SkType_MemberProperty && fType != SkType_MemberFunction,8,8,16
row,8,8,16
storageSize >= sizeof(classname),8,8,16
index > 0,8,8,16
"validateChildRelations(d, true)",8,8,16
!js::IsPoisonedPtr(l),8,8,16
2 == kInverseWinding_PathFill,8,8,16
COND,8,8,16
! isOpenGLAttached(),8,8,16
1 == kEvenOdd_PathFill,8,8,16
(unsigned)x <= 0xF,8,8,16
kind >= 0 && unsigned(kind) < FINALIZE_LIMIT,8,8,16
"validateChildRelations(s, true)",8,8,16
p,8,8,16
fObj != NULL,8,8,16
pOut != pIn,8,8,16
0 == kWinding_PathFill,8,8,16
4 == kHairLine_PathFill,8,8,16
 i>= 0 && i < _size ,8,8,16
5 == kPathFillCount,8,8,16
SkToU8(alpha) == alpha,7,7,14
clipRgn && !clipRgn->isEmpty(),7,7,14
(unsigned)scale <= 0x10,7,7,14
SkGetPackedB16(a) + SkGetPackedB16(b) <= SK_B16_MASK,7,7,14
utf8,7,7,14
(unsigned)(b) <= SK_B16_MASK,7,7,14
fColorTable,7,7,14
bitCount > 0 && bitCount <= 32,7,7,14
fCount <= fReserve,7,7,14
"this->findEntry(tag, NULL) == NULL",7,7,14
count,7,7,14
n >= -32768 && n <= 32767,7,7,14
this->isEmpty() == fBounds.isEmpty(),7,7,14
this->is32(),7,7,14
this->isFixed(),7,7,14
kUnknown_Mask == mask || (mask & kAllMasks) == mask,7,7,14
SkGetPackedR16(a) + SkGetPackedR16(b) <= SK_R16_MASK,7,7,14
b <= SK_B16_MASK,7,7,14
fMutex != NULL,7,7,14
rec,7,7,14
left < right && top < bottom,7,7,14
src == NULL || fArray == NULL || src + count <= fArray || fArray + oldCount <= src,7,7,14
index <= fCount,7,7,14
(unsigned)(a) <= SK_A32_MASK,7,7,14
srcA == (src32 & 0xFF),7,7,14
a,7,7,14
fConfig == kIndex8_Config,7,7,14
fConfig == kARGB_8888_Config,7,7,14
fCount <= kSlotCount,7,7,14
!a.isEmpty() && !b.isEmpty(),7,7,14
f16BitCacheLockCount > 0,7,7,14
sign == 0 || sign == -1,7,7,14
reserve > fCount,7,7,14
width > 0 && height > 0,7,7,14
value > 0,7,7,14
component <= 255,7,7,14
"!iscollectable(obj) || ((ttype(obj) == (obj)->value.gc->gch.tt) && !isdead(g, (obj)->value.gc))",7,7,14
(unsigned)(g) <= SK_G32_MASK,7,7,14
fFormat == kBW_Format,7,7,14
(int)cond == 0 || (int)cond == 1,7,7,14
fCount > 0 && fRec,7,7,14
t >= 0 && t <= SK_Scalar1,7,7,14
tag,7,7,14
fChecksum == SkDescriptor::ComputeChecksum(this),7,7,14
index < fCount,7,7,14
(unsigned)row < 3,7,7,14
max >= 0,7,7,14
(mask & kAllMasks) == mask,7,7,14
(unsigned)(r) <= SK_R16_MASK,7,7,14
a <= 255 && r <= 255 && g <= 255 && b <= 255,7,7,14
fColors != NULL && (unsigned)index < fCount,7,7,14
SkAlign4(offset) == offset,7,7,14
x >= (-2 << 16) && x <= (2 << 16) - 1,7,7,14
fConfig == kA1_Config,7,7,14
(unsigned)(b) <= SK_B32_MASK,7,7,14
g <= SK_G16_MASK,7,7,14
1 == fRefCnt,7,7,14
r <= SK_R16_MASK,7,7,14
(fReserve == 0 && fArray == NULL) || (fReserve > 0 && fArray != NULL),7,7,14
!clipRect.isEmpty(),7,7,14
alpha <= 255,7,7,14
result,7,7,14
src || count == 0,7,7,14
i >= 0,8,6,14
value == (uint16_t)value,7,7,14
a <= 32767,7,7,14
extra,7,7,14
hi == tmp.getFixed(),7,7,14
shift > 0 && shift <= 8,7,7,14
scale <= 16,7,7,14
b <= 0xF,7,7,14
(unsigned)scale256 <= 256,7,7,14
entryCount >= 0,7,7,14
r <= 0xF,7,7,14
!overloaded(),7,7,14
(unsigned)aa <= 255,7,7,14
f == NULL || dynamic_cast<To>(f) != NULL,8,6,14
canvas,7,7,14
uIndex < count(),7,7,14
fFormat != kBW_Format,7,7,14
n>0,7,7,14
array_ != NULL,8,6,14
IsObject(),7,7,14
(x << 10 >> 10) == x,7,7,14
fTotalCount == 0,7,7,14
fData == (ArrayT*)fArray,7,7,14
code >= baseGlyphCount,7,7,14
(unsigned)(g) <= SK_G16_MASK,7,7,14
ptr < stop,7,7,14
ptr_align_4(data),7,7,14
(unsigned)(r) <= SK_R32_MASK,7,7,14
sub <= kSubMask,7,7,14
&src,7,7,14
fConfig == kA8_Config || fConfig == kIndex8_Config,7,7,14
fConfig == kRGB_565_Config || fConfig == kARGB_4444_Config,7,7,14
g <= 0xF,7,7,14
nib <= 0xF,7,7,14
"SK_ARRAY_COUNT(kStdFakeBoldInterpKeys) == SK_ARRAY_COUNT(kStdFakeBoldInterpValues), mismatched_array_size",7,7,14
SkToS16(x) == x,7,7,14
min <= max,7,7,14
b <= 32767,7,7,14
&r,7,7,14
SkGetPackedG16(a) + SkGetPackedG16(b) <= SK_G16_MASK,7,7,14
fLeft < fRight && fTop < fBottom,7,7,14
code <= kCodeMask,7,7,14
value != 0,7,7,14
offset <= this->size(),7,7,14
!iscollectable(obj) || (ttype(obj) == (obj)->value.gc->gch.tt),7,7,14
chunk,6,6,12
!IsWPI(kChunks[idx].id),6,6,12
wpi->img_ != NULL,6,6,12
s == 0,6,6,12
k >= 1,6,6,12
max > 0,6,6,12
s != NULL,6,6,12
JSVAL_IS_MAGIC_IMPL(l),6,6,12
dst == data + size,6,6,12
chunk_list,6,6,12
hdr != NULL,6,6,12
sizeof(uint64)==8,6,6,12
wpi != NULL,6,6,12
step >= 4,6,6,12
params != NULL,6,6,12
sp->tbuflen >= npixels,6,6,12
A,6,6,12
(uint64_t)data_size == (uint64_t)width * height,6,6,12
dec->status_ != VP8_STATUS_OK,6,6,12
hdr,6,6,12
substring,6,6,12
p->mode == kLiteral,6,6,12
fFormat == kHorizontalLCD_Format || fFormat == kVerticalLCD_Format,6,6,12
idec->is_lossless_,6,6,12
start != NULL,6,6,12
dec->ready_,6,6,12
node != NULL,6,6,12
"index>=0 && index < count(), ""index out of range in getObjectAtIndex()""",6,5,11
ref >= J->cur.nk && ref < J->cur.nins,5,5,10
sizeof(uint16)==2,5,5,10
&k != &HashPolicy::getKey(this->cur->t),5,5,10
offset != 0,5,5,10
INT_FITS_IN_JSID(i),5,5,10
ra_iskref(ref) || (ref >= as->T->nk && ref < as->T->nins),5,5,10
"js::detail::IdMatchesAtom(id, atom)",5,5,10
irt_is64(ir->t) || irt_isint(ir->t) || irt_isu32(ir->t) || irt_isaddr(ir->t),5,5,10
fmt == STRSCAN_ERROR,5,5,10
ir->o == IR_CARG,5,5,10
(int)BC_LOOP + 2 == (int)BC_JLOOP,5,5,10
((int)IR_LT^3) == (int)IR_GT,5,5,10
ir->o != IR_KSLOT,5,5,10
tif->tif_flags&TIFF_BIGTIFF,5,5,10
!irt_ispri(t),5,5,10
!iswhite(obj2gco(mainthread(g))),5,5,10
!LJ_64 || t != IRT_LIGHTUD,5,5,10
sp >= nc->stack+2,5,5,10
!tvisint(&n->key),5,5,10
ir->o != IR_TNEW || irt_isnil(fins->t),5,5,10
((intptr_t)target & 15) == 0,5,5,10
fs->nactvar == nparams,5,5,10
"sp == nullptr, script_ != nullptr",5,5,10
(int)BC_FUNCF + 2 == (int)BC_JFUNCF,5,5,10
ta != tb,5,5,10
"sizeof(PrimType) == sizeof(T), ""Selection of PrimitiveIntrinsics was wrong""",5,5,10
id > 0 && id < cts->top,5,5,10
(int)IR_XLOAD + IRDELTA_L2S == (int)IR_XSTORE,5,5,10
ctype_hassize(info) || ctype_isfunc(info),5,5,10
irt_isnum(irkey->t) || irt_isgcv(irkey->t),5,5,10
checkptr32(p),5,5,10
bsz == 1,5,5,10
"!usingInlineStorage(), !detail::CapacityHasExcessSpace<T>(mCapacity)",5,5,10
op == BC_FUNCF,5,5,10
(uintptr_t)name >= VARNAME__MAX,5,5,10
(reinterpret_cast<uintptr_t>(newPtr) & flagsMask) == 0,5,5,10
(pt->flags & PROTO_CHILD),5,5,10
(int)BC_ITERL + 2 == (int)BC_JITERL,5,5,10
"IsBaseOf<AtomicRefCounted, T>::value, ""T must derive from AtomicRefCounted<T>""",5,5,10
o->gch.gct == ~LJ_TTAB,5,5,10
dsize == ssize,5,5,10
ls->fs->framesize >= ls->fs->freereg && ls->fs->freereg >= ls->fs->nactvar,5,5,10
irt_isint(J->scev.t),5,5,10
expr_isnumk(e),5,5,10
!ctype_isref(ct->info),5,5,10
J->state == LJ_TRACE_IDLE,5,5,10
IR(strref)->o == IR_STRREF,5,5,10
"!rset_test(as->freeset, down) && rset_test(as->freeset, up)",5,5,10
"offsetof(GChead, gclist) == offsetof(GCtrace, gclist)",5,5,10
((int)BC_ISEQP^1) == (int)BC_ISNEP,5,5,10
bc_isret(bc_op(ins[-1])),5,5,10
(int)BC_ISGT-(int)BC_ISLT == (int)OPR_GT-(int)OPR_LT,5,5,10
(int)BC_SUBVV-(int)BC_ADDVV == (int)OPR_SUB-(int)OPR_ADD,5,5,10
refb->o == IR_AREF,5,5,10
!ctype_isbool(dinfo) || dsize == 1 || dsize == 4,5,5,10
fn->c.gct == ~LJ_TFUNC,5,5,10
!tvisnil(&n->key),5,5,10
g->totalbytes >= g->estimate,5,5,10
__COUNTER__,5,5,10
bc_op(*J->pc) == BC_FORL || bc_op(*J->pc) == BC_ITERL || bc_op(*J->pc) == BC_LOOP || bc_op(*J->pc) == BC_FUNCF,5,5,10
!irt_isint(t) || (ir->op2 & (IRSLOAD_CONVERT|IRSLOAD_FRAME)),5,5,10
(uintptr_t)p < (uintptr_t)0x80000000,5,5,10
ctype_isinteger(cta->info) && n == 2,5,5,10
__LINE__,5,5,10
(J2G(J)->hookmask & HOOK_GC) == 0,5,5,10
irt_isgcv(ir->t),5,5,10
frame_isvarg(J->L->base-1),5,5,10
JSID_IS_INT(id),5,5,10
irb->op2 == IRFL_TAB_ARRAY,5,5,10
bc_a(ilp->ins) == freg && bc_op(ilp->ins) == (narr > 256 ? BC_TSETV : BC_TSETB),5,5,10
begin() <= it,5,5,10
"sizeof(MutableHandle<T>) == sizeof(T *), ""MutableHandle must be binary compatible with T*.""",5,5,10
(significand & ~FloatSignificandBits) == 0,5,5,10
cp->depth == 0,5,5,10
s != 0,5,5,10
bc_op(*fori) == BC_FORI || bc_op(*fori) == BC_JFORI,5,5,10
dest != NO_JMP,5,5,10
lj_char_isdigit(ls->current),5,5,10
irt_isstr(fins->t),5,5,10
MOZ_DOUBLE_IS_NaN(pun.d),5,5,10
!frame_isc(frame),5,5,10
"(IsBaseOf<SupportsWeakPtr<T>, T>::value), ""T must derive from SupportsWeakPtr<T>""",5,5,10
ctype_isvlarray(ct->info),5,5,10
!js::GCMethods<T>::poisoned(ptr),5,5,10
ls->current == BCDUMP_HEAD1,5,5,10
op < BC__MAX,5,5,10
"offsetof(GChead, env) == offsetof(GCudata, env)",5,5,10
!tvisnil(&key),5,5,10
ir->o == IR_NOP || IR(ir->prev)->o == ir->o,5,5,10
p[1] == MIPSI_NOP,5,5,10
ix->idxchain != 0,5,5,10
CCALL_NUM_GPR <= CCALL_MAX_GPR,5,5,10
T != NULL && J->exitno < T->nsnap,5,5,10
fs.prev == NULL,5,5,10
d->size == 4,5,5,10
group[exitno / EXITSTUBS_PER_GROUP] != NULL,5,5,10
IR(ir->op1)->o != IR_CARG,5,5,10
sizeof(Node) == 24,5,5,10
(int)BC_FUNCF + 1 == (int)BC_IFUNCF,5,5,10
ctype_isvoid(info),5,5,10
!(rcl[i] & CCALL_RCL_MEM),5,5,10
irt_isaddr(kt),5,5,10
ir_kptr(fleft) == niltvg(J2G(J)),5,5,10
J->cur.nk == J->irbotlim,5,5,10
"name == NAME_BREAK || lj_tab_getstr(fs->kt, name) != NULL",5,5,10
ra_noreg(irr->r),5,5,10
T->root != 0,5,5,10
significand & DoubleSignificandBits,5,5,10
(byteDestPtr <= byteSrcPtr && byteDestPtr + count <= byteSrcPtr) || (byteSrcPtr <= byteDestPtr && byteSrcPtr + count <= byteDestPtr),5,5,10
tref_iscdata(ix->key),5,5,10
lo > 0 && (ex10 & 1) == 0,5,5,10
st == IRT_NUM && irt_isint(ir->t),5,5,10
itype2irt(tv) == irt_type(fins->t),5,5,10
ir->o <= IR_NE,5,5,10
((uintptr_t)mxp ^ (uintptr_t)(void *)lj_vm_exit_handler)>>28 == 0,5,5,10
checki16(CFRAME_SIZE+spadj),5,5,10
!(ctype_isrefarray(ctr->info) || ctype_isstruct(ctr->info)),5,5,10
fmt == STRSCAN_ERROR || fmt == STRSCAN_NUM || fmt == STRSCAN_INT,5,5,10
"sizeof(Handle<T>) == sizeof(T *), ""Handle must be binary compatible with T*.""",5,5,10
st == IRT_NUM || st == IRT_FLOAT,5,5,10
other.notableStrings.empty(),5,5,10
"offsetof(GChead, metatable) == offsetof(GCudata, metatable)",5,5,10
op == BC_ITERL || op == BC_LOOP || bc_isret(op),5,5,10
J->needsplit >= split_needsplit(J),5,5,10
gcref(L->openupval) == NULL,5,5,10
(flagsToSet & ~flagsMask) == 0,5,5,10
(int)IRT_GUARD == (int)IRM_W,5,5,10
"body->v, ""Body's velocity is invalid.""",5,5,10
(osz == 0) == (p == NULL),5,5,10
"lj_obj_equal(tv, &tvk)",5,5,10
d->size == CTSIZE_PTR,5,5,10
js::GetObjectClass(&v.toObject()) == js::FunctionClassPtr,5,5,10
GG_NUM_ASMFF == FF_NUM_ASMFUNC,5,5,10
L != NULL,5,5,10
irs->o == IR_ASTORE || irs->o == IR_HSTORE || irs->o == IR_FSTORE,5,5,10
"false, ""MOZ_ASSUME_UNREACHABLE("" __VA_ARGS__ "")""",5,5,10
"ir_kptr(ir) == gcrefp(tv->gcr, void)",5,5,10
(char *)cd - p < 65536,5,5,10
irc->o == IR_CONV && irc->op2 == IRCONV_NUM_INT,5,5,10
ls->lookahead == TK_eof,5,5,10
(int)BC_CALLMT + 1 == (int)BC_CALLT,5,5,10
gct == ~LJ_TFUNC || gct == ~LJ_TTAB || gct == ~LJ_TTHREAD || gct == ~LJ_TPROTO,5,5,10
(int)BC_FUNCV + 1 == (int)BC_IFUNCV,5,5,10
J->base[ra] != 0,5,5,10
ra_noreg(ir->r),5,5,10
(int)BC_ISLE-(int)BC_ISLT == (int)OPR_LE-(int)OPR_LT,5,5,10
((int)IR_EQ^1) == (int)IR_NE,5,5,10
(int64_t)x >= 0,5,5,10
(MSize)(tvref(L->maxstack)-oldst)==L->stacksize-LJ_STACK_EXTRA-1,5,5,10
ctype_isstruct(cinfo) || ctype_isenum(cinfo),5,5,10
bc_isret(bc_op(*J->pc)),5,5,10
notableStrings.empty(),5,5,10
irt_isaddr(ir->t) || (LJ_DUALNUM && irt_isinteger(ir->t)),5,5,10
ctx->sb.n == 5,5,5,10
(int)BC_ISGE-(int)BC_ISLT == (int)OPR_GE-(int)OPR_LT,5,5,10
irt_istab(taba->t) && irt_istab(tabb->t),5,5,10
ofs >= -4095 && ofs <= 4095,5,5,10
"!tvisgcv(o) || ((~itype(o) == gcval(o)->gch.gct) && !isdead(G(L), gcval(o)))",5,5,10
s > delta ? (J->slot[s-delta] & TREF_FRAME) : (s == delta),5,5,10
!tvisgcv(tv) || (~itype(tv) == gcval(tv)->gch.gct),5,5,10
(int)BC_DIVVV-(int)BC_ADDVV == (int)OPR_DIV-(int)OPR_ADD,5,5,10
!irt_isnil(ir->t),5,5,10
szs == 4,5,5,10
(int)IR_HLOAD + IRDELTA_L2S == (int)IR_HSTORE,5,5,10
"(FloatExponentBits & FloatSignificandBits) == 0, ""exponent bits don't overlap significand bits""",5,5,10
(flag & ~flagsMask) == 0,5,5,10
!ctype_isattrib(dinfo) && !ctype_isattrib(sinfo),5,5,10
bc_op(pc[-1]) == BC_ITERC,5,5,10
next < last,5,5,10
irt_isnil(ir->t),5,5,10
ctype_ispointer(s->info) || ctype_isfield(s->info),5,5,10
((ir-1)->op2 & IRCONV_TRUNC),5,5,10
szins != 0,5,5,10
dt == IRT_I64 || dt == IRT_U64,5,5,10
((ir-1)->op2 & IRCONV_SRCMASK) == IRT_I64,5,5,10
fn->l.nupvalues <= funcproto(fn)->sizeuv,5,5,10
"IsBaseOf<SupportsWeakPtrBase<T, WeakReference>, T>::value, ""T must derive from SupportsWeakPtrBase<T, WeakReference>""",5,5,10
((int)BC_ISLT^3) == (int)BC_ISGT,5,5,10
sz != 0,5,5,10
"(MOZ_DOUBLE_SIGN_BIT & MOZ_DOUBLE_EXPONENT_BITS) == 0, ""sign bit doesn't overlap exponent bits""",5,5,10
ctype_bitbsz(info) == 1,5,5,10
(int)BC_RETM + 1 == (int)BC_RET,5,5,10
hasmm,5,5,10
"(MOZ_DOUBLE_EXPONENT_BITS & MOZ_DOUBLE_SIGNIFICAND_BITS) == 0, ""exponent bits don't overlap significand bits""",5,5,10
"rset_test(as->freeset, r) || r == RID_TMP",5,5,10
(pt->flags & PROTO_VARARG),5,5,10
tref_isnumber_str(tr[i]),5,5,10
o->gch.gct != ~LJ_TTAB,5,5,10
checkptr32(tv),5,5,10
f == (MSize)(1 + J->framedepth),5,5,10
"!isdead(g, o) || (o->gch.marked & LJ_GC_FIXED)",5,5,10
(nsz == 0) == (p == NULL),5,5,10
ls->p + ls->n == ls->sb.buf + ls->sb.n,5,5,10
irk->op2 == IRFL_TAB_META,5,5,10
(int)BC_IST-(int)BC_ISTC == (int)BC_ISF-(int)BC_ISFC,5,5,10
ofs >= -1020 && ofs <= 1020 && (ofs&3) == 0,5,5,10
*psentinel == J->cur.snapmap[J->cur.snap[0].nent],5,5,10
tok < CTOK_FIRSTDECL,5,5,10
CCALL_NUM_FPR <= CCALL_MAX_FPR,5,5,10
!hasmm,5,5,10
tabV(&n->val) == t,5,5,10
mc != NULL,5,5,10
gcref(ct->name) == NULL,5,5,10
!ctype_isinteger(sinfo) || (1u<<lj_fls(ssize)) == ssize,5,5,10
max > inputSize,5,5,10
ctype_isfield(fct->info),5,5,10
mxp < as->mctop,5,5,10
tvisnum(tv) && tvisnan(tv),5,5,10
irt_type(IR(ref+1)->t) == IRT_SOFTFP,5,5,10
"(FloatSignBit & FloatExponentBits) == 0, ""sign bit doesn't overlap exponent bits""",5,5,10
n <= CCI_NARGS_MAX,5,5,10
J->cur.nsnapmap <= J->sizesnapmap,5,5,10
"sizeof(T) == sizeof(TenuredHeap<T>), ""TenuredHeap<T> must be binary compatible with T.""",5,5,10
(iof->type & IOFILE_TYPE_MASK) == IOFILE_TYPE_STDF,5,5,10
mm == MM_le,5,5,10
(void *)(intptr_t)i32ptr(ptr) == ptr,5,5,10
((int)IR_LE^1) == (int)IR_GT,5,5,10
chars[length] == '\0',5,5,10
needsBarrier_,5,5,10
itype2irt(tv) == tref_type(tr),5,5,10
idx < pt->sizeuv,5,5,10
kt->asize == t->asize && kt->hmask == t->hmask,5,5,10
traceno != G2J(g)->cur.traceno,5,5,10
delta >= 0 && delta < 65536,5,5,10
"i == (ptrdiff_t)J->cur.traceno || traceref(J, i) == NULL",5,5,10
fn == ir_kfunc(ir),5,5,10
(int)BC_FUNCV + 2 == (int)BC_JFUNCV,5,5,10
ir->o == IR_AREF,5,5,10
(int)BC_FORL + 1 == (int)BC_IFORL,5,5,10
g->gc.state == GCSfinalize || g->gc.state == GCSpause,5,5,10
SNAP_CONT == TREF_CONT,5,5,10
idx < 8,5,5,10
cstart != NULL,5,5,10
ctype_ispointer(d->info) || ctype_isfield(d->info),5,5,10
MEMBERVARIABLE,6,4,10
op == OPR_NE || op == OPR_EQ || op == OPR_LT || op == OPR_GE || op == OPR_LE || op == OPR_GT,5,5,10
irt_isgcv(irkey->t),5,5,10
!ctype_isnum(dinfo) || dsize > 0,5,5,10
(int)IR_ULOAD + IRDELTA_L2S == (int)IR_USTORE,5,5,10
(refa->o==IR_HREF || refa->o==IR_HREFK || refa->o==IR_NEWREF) && (refb->o==IR_HREF || refb->o==IR_HREFK || refb->o==IR_NEWREF),5,5,10
op == BC_CAT,5,5,10
J->slot[fins->op1] != 0,5,5,10
nk <= REF_BIAS && nins >= REF_BIAS && nins < 65536,5,5,10
sp->in_buffer_togo>0,5,5,10
(int)BC_MULVV-(int)BC_ADDVV == (int)OPR_MUL-(int)OPR_ADD,5,5,10
other.prev->next == &other,5,5,10
ls->fs == NULL,5,5,10
ir->o <= IR_NE || ir->o == IR_MIN || ir->o == IR_MAX,5,5,10
var->k == VINDEXED,5,5,10
e1->t == NO_JMP,5,5,10
op == BC_UNM || op == BC_LEN,5,5,10
J->baseslot == 1 || (J->slot[J->baseslot-1] & TREF_FRAME),5,5,10
irs->o == IR_ASTORE || irs->o == IR_HSTORE || irs->o == IR_FSTORE || irs->o == IR_XSTORE,5,5,10
i < REF_BIAS,5,5,10
((delta + 0x00800000) >> 24) == 0,5,5,10
fn->c.gct == ~LJ_TFUNC || fn->c.gct == ~LJ_TTHREAD,5,5,10
tp == BCDUMP_KGC_CHILD,5,5,10
J->baseslot >= 1,5,5,10
sz == 8 && ir->o == IR_CONV && ir->op2 == IRCONV_NUM_INT,5,5,10
cmd != NULL,5,5,10
g->strnum == 0,5,5,10
!(irt_isfloat(ir->t) && irref_isk(ref)),5,5,10
(int)FF_next == FF_next_N,5,5,10
fmt == STRSCAN_I64 || fmt == STRSCAN_U64 || fmt == STRSCAN_IMAG,5,5,10
ir->o == IR_TNEW || ir->o == IR_TDUP || ir->o == IR_CNEW,5,5,10
op1 == 0,5,5,10
op == BC_ITERL,5,5,10
(((uintptr_t)a+len-1) & (LJ_PAGESIZE-1)) <= LJ_PAGESIZE-4,5,5,10
ir->op2 == IRFL_CDATA_INT64,5,5,10
checki16(ofs),5,5,10
(len & (step-1)) == 0,5,5,10
bc_op(*pc) == BC_JFORI,5,5,10
ir->o == IR_HREF || ir->o == IR_NEWREF || ir->o == IR_UREFO || ir->o == IR_KKPTR,5,5,10
"isdead(g, o) || ow == LJ_GC_SFIXED",5,5,10
"sizeof(From) == sizeof(To), ""To and From must have the same size""",5,5,10
ls->fs != NULL || ls->token == TK_eof,5,5,10
!(ir->op2 & IRSLOAD_CONVERT),5,5,10
((int)BC_ISEQV^1) == (int)BC_ISNEV,5,5,10
!(LJ_32 && irt_isint64(ir->t)),5,5,10
iswhite(obj2gco(fn)),5,5,10
irt_isguard(ir->t) || !(ir->op2 & IRSLOAD_TYPECHECK),5,5,10
expr_isstrk(e) || e->k == VGLOBAL,5,5,10
JSID_IS_STRING(id),5,5,10
(flagsToUnset & ~flagsMask) == 0,5,5,10
ref == DROPFOLD,5,5,10
ret == Z_STREAM_END,6,4,10
"offsetof(GChead, env) == offsetof(GCfuncL, env)",5,5,10
(down < RID_MAX_GPR) == (up < RID_MAX_GPR),5,5,10
pt->sizeuv == 0,5,5,10
((int)BC_ISLT^1) == (int)BC_ISGE,5,5,10
p < pe,5,5,10
(J->slot[s+1] & TREF_FRAME),5,5,10
ctype_isfunc(ct->info) || ctype_isextern(ct->info),5,5,10
((int)CT_STRUCT & (int)CT_ARRAY) == CT_STRUCT,5,5,10
gcref(g->gc.root) == obj2gco(L),5,5,10
i >= REF_BIAS ? op2 < i : op2 > i,5,5,10
J->parent != 0 && J->cur.root != 0,5,5,10
delta == (int32_t)delta,5,5,10
irt_isint(J->scev.t) && ir->o == IR_SLOAD,5,5,10
delta >= 0 && delta < 256,5,5,10
sizeof(jsid) == sizeof(void*),5,5,10
st == IRT_INT || (LJ_32 && LJ_HASFFI && (st == IRT_U32 || st == IRT_FLOAT)),5,5,10
(ctype_hassize(ct->info) ? ct->size : CTSIZE_PTR) == sz,5,5,10
(ir->o == IR_SLOAD && (ir->op2 & IRSLOAD_PARENT)) || (LJ_SOFTFP && ir->o == IR_HIOP) || ir->o == IR_PVAL,5,5,10
bc_op(pc[(ptrdiff_t)rc-BCBIAS_J]) == BC_JFORL,5,5,10
!tvismzero(&n->key),5,5,10
"!IsLvalueReference<T>::value, ""misuse of Forward detected! try the other overload""",5,5,10
bc_op(pc[-1]) == BC_JMP,5,5,10
"offsetof(GChead, gclist) == offsetof(GCtab, gclist)",5,5,10
e->k == VLOCAL || e->k == VUPVAL,5,5,10
"offsetof(GChead, metatable) == offsetof(GCtab, metatable)",5,5,10
tvisnumber(&tv[FORL_IDX]) && tvisnumber(&tv[FORL_STOP]) && tvisnumber(&tv[FORL_STEP]),5,5,10
!(ctype_isvoid(ct->info) || ctype_isstruct(ct->info) || ctype_isbitfield(ct->info)),5,5,10
op2 == 0,5,5,10
tt != LUA_TNIL || tvisnil(o),5,5,10
J->baseslot >= 1 && J->baseslot < LJ_MAX_JSLOTS,5,5,10
i >= REF_BIAS ? op1 < i : op1 > i,5,5,10
bc_op(*ip) == BC_JMP || bc_op(*ip) == BC_UCLO,5,5,10
(int)BC_ITERL + 1 == (int)BC_IITERL,5,5,10
!ctype_isbool(sinfo) || ssize == 1 || ssize == 4,5,5,10
"rset_test(RSET_GPREVEN, r)",5,5,10
irt_isnum(ir->t) || irt_ispri(ir->t) || irt_isaddr(ir->t) || (LJ_DUALNUM && irt_isint(ir->t)),5,5,10
((int)CT_PTR & (int)CT_ARRAY) == CT_PTR,5,5,10
(sizeof(GCtab) & 7) == 0,5,5,10
!irt_isi8(ir->t),5,5,10
SNAP_FRAME == TREF_FRAME,5,5,10
!irt_isint64(ir->t) && !(st == IRT_I64 || st == IRT_U64),5,5,10
irs->o == IR_XSTORE && T->ir[irs->op1].o == IR_ADD,5,5,10
irt_is64(ir->t) || irt_isint(ir->t) || irt_isu32(ir->t) || irt_isaddr(ir->t) || irt_isu8(ir->t),5,5,10
tvisnil(&n->val),5,5,10
frame <= tvref(L->maxstack) && (!nextframe || nextframe <= tvref(L->maxstack)),5,5,10
(int)BC_ISEQV+1 == (int)BC_ISNEV,5,5,10
ctype_isarray(ct->info) || ctype_isstruct(ct->info),5,5,10
((int)IR_LT^1) == (int)IR_GE,5,5,10
fmt == STRSCAN_ERROR || fmt == STRSCAN_NUM,5,5,10
"N == 0, ""still need to implement this for N != 0""",5,5,10
"ctype_child(cts, cct)->size == 4",5,5,10
!irt_isfp(ir->t) && !(st == IRT_NUM || st == IRT_FLOAT),5,5,10
tvisnum(o),5,5,10
op2 >= nk,5,5,10
"offsetof(GChead, gclist) == offsetof(GCproto, gclist)",5,5,10
(int)IR_FLOAD + IRDELTA_L2S == (int)IR_FSTORE,5,5,10
"((size_t)JSID_BITS(id) & JSID_TYPE_MASK) == JSID_TYPE_VOID, JSID_BITS(id) == JSID_TYPE_VOID",5,5,10
!(LJ_32 && (irt_isint64(ir->t) || st64)),5,5,10
fins->o != IR_CONV || (fins->op2&IRCONV_CONVMASK) != IRCONV_TOBIT,5,5,10
!ctype_isnum(sinfo) || ssize > 0,5,5,10
!detail::CapacityHasExcessSpace<T>(newCap),5,5,10
"!rset_test(as->freeset, r)",5,5,10
tref_isk(key) && slot == (IRRef)(IRRef1)slot,5,5,10
J->framedepth == depth,5,5,10
(int)BC_MODVV-(int)BC_ADDVV == (int)OPR_MOD-(int)OPR_ADD,5,5,10
cont == lj_cont_condf || cont == lj_cont_condt,5,5,10
"(MOZ_DOUBLE_SIGN_BIT | MOZ_DOUBLE_EXPONENT_BITS | MOZ_DOUBLE_SIGNIFICAND_BITS) == ~(uint64_t)0, ""all bits accounted for""",5,5,10
freenode >= nodebase && freenode <= nodebase+t->hmask+1,5,5,10
nslots < LJ_MAX_JSLOTS,5,5,10
id == CTID_COMPLEX_DOUBLE,5,5,10
freenode != &G(L)->nilnode,5,5,10
"sizeof(float) == sizeof(uint32_t), ""float must be 32bits""",5,5,10
"sizeof(T) == 4 || (sizeof(uintptr_t) == 8 && sizeof(T) == 8), ""mozilla/Atomics.h only supports 32-bit and pointer-sized types""",5,5,10
"(uintptr_t)name < VARNAME__MAX || lj_tab_getstr(fs->kt, name) != NULL",5,5,10
"(MOZ_DOUBLE_SIGN_BIT & MOZ_DOUBLE_SIGNIFICAND_BITS) == 0, ""sign bit doesn't overlap significand bits""",5,5,10
op1 >= nk,5,5,10
"!MOZ_DOUBLE_IS_NaN(d), ""NaN does not have a sign""",5,5,10
irt_isnum(fleft->t),5,5,10
((int)BC_ISEQS^1) == (int)BC_ISNES,5,5,10
strref(vg->name) != NAME_BREAK,5,5,10
JSID_IS_OBJECT(id),5,5,10
IsFloatNaN(f),5,5,10
!isblack(o) && !uv->closed && uvval(uv) != &uv->tv,5,5,10
!GCMethods<T>::poisoned(value),5,5,10
regsp_used(rs),5,5,10
ctx->objsize < sizeof(GDBJITobj),5,5,10
((JIT_F_OPT_FOLD|JIT_F_OPT_FWD|JIT_F_OPT_CSE|JIT_F_OPT_DSE) | JIT_F_OPT_DEFAULT) == JIT_F_OPT_DEFAULT,5,5,10
ir->prev >= nk,5,5,10
length == info.length,5,5,10
hbits != 0,5,5,10
cf != NULL,5,5,10
ctype_hassize(ct->info) || ctype_isfunc(ct->info) || ctype_isextern(ct->info),5,5,10
"(FloatSignBit & FloatSignificandBits) == 0, ""sign bit doesn't overlap significand bits""",5,5,10
"!isdead(J2G(J), o)",5,5,10
begin() <= p,5,5,10
js::GCMethods<T>::needsPostBarrier(ptr),5,5,10
MIPSI_NOP == 0,5,5,10
gola_isgoto(vg),5,5,10
(significand & ~MOZ_DOUBLE_SIGNIFICAND_BITS) == 0,5,5,10
ir->o == IR_FLOAD || ir->o == IR_FREF,5,5,10
(int)BC_LOOP + 1 == (int)BC_ILOOP,5,5,10
irt_isinteger(ir->t) || irt_isnum(ir->t),5,5,10
!p->closed && uvval(p) != &p->tv,5,5,10
sp >= nc->stack+1,5,5,10
"char16_t(-1) > char16_t(0), ""Is char16_t type unsigned?""",5,5,10
pc <= pt->sizebc,5,5,10
sz == 1 || sz == 2 || sz == 4 || sz == 8,5,5,10
"IsBaseOf<RefCounted, T>::value, ""T must derive from RefCounted<T>""",5,5,10
!irt_isnil(kt),5,5,10
"sizeof(T) == sizeof(Heap<T>), ""Heap<T> must be binary compatible with T.""",5,5,10
expr_isstrk(key),5,5,10
ctype_hassize(d->info) && !ctype_isvoid(d->info),5,5,10
i >= REF_BIAS ? ir->prev < i : ir->prev > i,5,5,10
p <= end(),5,5,10
tvispri(o),5,5,10
"(FloatSignBit | FloatExponentBits | FloatSignificandBits) == ~uint32_t(0), ""all bits accounted for""",5,5,10
g->gc.total == sizeof(GG_State),5,5,10
(int)BC_FORL + 2 == (int)BC_JFORL,5,5,10
gcref(g->jit_L) == NULL,5,5,10
p >= (uint8_t *)cdataptr(cd) && p + szs <= (uint8_t *)cdataptr(cd) + sz,5,5,10
irt_isinteger(t) || irt_isnum(t),5,5,10
((int)IR_LT^4) == (int)IR_ULT,5,5,10
sp == nc->stack+1,5,5,10
checkptr32(o),5,5,10
!ctype_isinteger(dinfo) || (1u<<lj_fls(dsize)) == dsize,5,5,10
op == BC_ISEQP,5,5,10
significand & MOZ_DOUBLE_SIGNIFICAND_BITS,5,5,10
!ctype_isenum(dinfo) && !ctype_isenum(sinfo),5,5,10
L != mainthread(g),5,5,10
cp->p != NULL,5,5,10
val == 0,5,5,10
hook_active(g),5,5,10
"body->f, ""Body's force is invalid.""",5,5,10
"body->p, ""Body's position is invalid.""",5,5,10
iro->o == IR_KINT || iro->o == IR_KINT64,5,5,10
tref_iscdata(tr) && cd->ctypeid == CTID_CTYPEID,5,5,10
delta >= 0,5,5,10
(int)BC_CALLT-(int)BC_CALL == (int)BC_CALLMT-(int)BC_CALLM,5,5,10
i == 0,5,5,10
T->root == 0 && pt != NULL,5,5,10
"offsetof(GChead, gclist) == offsetof(GCfuncL, gclist)",5,5,10
(t->marked & LJ_GC_WEAK),5,5,10
t <= IRT_NUM,5,5,10
((int)BC_ISEQN^1) == (int)BC_ISNEN,5,5,10
((int)BC_ISLE^1) == (int)BC_ISGT,5,5,10
n < snap->nent,5,5,10
ctype_type(info) <= CT_MAYCONVERT,5,5,10
ofs >= -255 && ofs <= 255,5,5,10
ct->size == CTSIZE_PTR,5,5,10
t->hmask != 0,5,5,10
"offsetof(GChead, gclist) == offsetof(lua_State, gclist)",5,5,10
significand & FloatSignificandBits,5,5,10
ra_hasreg(pbase),5,5,10
ir->o == IR_EQ || ir->o == IR_NE,5,5,10
IsNaN(d),5,5,10
it < end(),5,5,10
&obj != nullptr,5,5,10
"x <= (size_t(1) << (sizeof(size_t) * CHAR_BIT - 1)), ""can't round up -- will overflow!""",5,5,10
irt_ispri(ir->t) || irt_isaddr(ir->t) || (LJ_DUALNUM && irt_isinteger(ir->t)),5,5,10
"offsetof(Node, val) == 0",5,5,10
J->pt != NULL,5,5,10
expr_isnumk(e1) || e1->k == VNONRELOC,5,5,10
LJ_GC_BLACK == 0x04,5,5,10
(significand & ~DoubleSignificandBits) == 0,5,5,10
tp <= BCDUMP_KTAB_TRUE,5,5,10
irt_t(ir->t) == tref_t(tr),5,5,10
e1->f == NO_JMP,5,5,10
"e->k != VNONRELOC || ra < fs->nactvar || rc < ra || (bcreg_free(fs, rc),1)",5,5,10
mm <= MM_FAST,5,5,10
o < L->top,5,5,10
J->baseslot > cbase+1,5,5,10
tvisnumber(expr_numtv(e)),5,5,10
irref_isk(ref),5,5,10
(MSize)fright->i <= str->len,5,5,10
other.next->prev == &other,5,5,10
"e1->u.s.info == bc_b(*bcptr(fs, e2))-1",5,5,10
obj != nullptr,5,5,10
((size_t)obj & JSID_TYPE_MASK) == 0,5,5,10
J->base[dst+i] != 0,5,5,10
"_strKey[0] == '\0', ""Should not call this function for string dictionary""",5,4,9
"indexOne >=0 && indexOne < count() && indexTwo >= 0 && indexTwo < count(), ""Invalid indices""",5,4,9
msg,5,4,9
"_strKey[0] != '\0', ""Should not call this function for integer dictionary""",5,4,9
"dynamic_cast<__type__>(*__arr__), ""element type is wrong!""",5,4,9
index > 0 && index <= fMatrixCount,4,4,8
"!""looks like you passed an SkScalar into SkIntToScalar""",4,4,8
clip.fRight <= srcMask.fBounds.fRight,4,4,8
(int)kIDC_BlendCoeff == (int)SkXfermode::kIDC_Coeff,4,4,8
IsFunctionProxy(obj),4,4,8
kLCD16_Format == fFormat,4,4,8
storage != NULL,4,4,8
(uintptr_t(cell) & 0x3) == 0,4,4,8
sizeof(sp->stream.avail_in)==4,4,4,8
fType == SkType_MemberFunction,4,4,8
sizeof(GrGLIRect) == 4*sizeof(GrGLint),4,4,8
sizeof(double)==8,4,4,8
count<0x20000000,4,4,8
full_runs >= 0,4,4,8
"getShaderProgram(), ""No shader program set for this node""",4,4,8
(int)kSC_BlendCoeff == (int)SkXfermode::kSC_Coeff,4,4,8
pattern,4,4,8
artist,4,4,8
mask_rowBytes != 0,4,4,8
other.ptr_ != UninitializedTag(),4,4,8
"validateChildRelations(n->fChildren[kLeft_Child], true)",4,4,8
fType == SkOperand2::kString,4,4,8
(int)SkPath::kMove_Verb == (int)kMove_PathCmd,4,4,8
inplen > 0,4,4,8
0 == sizeof(GrStencilOp)%4,4,4,8
sizeof(T) == sizeof(int32_t),4,4,8
sizeof(SkPoint) == sizeof(GrPoint),4,4,8
pos <= top,4,4,8
"is_whitespace_normalized(""abc def ghi "", 1)",4,4,8
"!table.match(*this->cur, k)",4,4,8
!js::IsPoisonedPtr(k),4,4,8
fType == SkType_Drawable,4,4,8
(int)GrSamplerState::kMirror_WrapMode == (int)SkShader::kMirror_TileMode,4,4,8
(mask & kORableMasks) == mask,4,4,8
NULL == fPrev && NULL == fNext,4,4,8
((value) == SkRegion::kRunTypeSentinel) == isSentinel,4,4,8
sizeof(GrStencilSettings) == 4*sizeof(GrStencilOp) + 2*sizeof(GrStencilFunc) + 6*sizeof(unsigned int),4,4,8
paint.getAlpha() == 0xFF,4,4,8
height != 0,4,4,8
bitmap_rowBytes != 0,4,4,8
(int)kSA_BlendCoeff == (int)SkXfermode::kSA_Coeff,4,4,8
other != UninitializedTag(),4,4,8
(int)kISA_BlendCoeff == (int)SkXfermode::kISA_Coeff,4,4,8
(int)kDC_BlendCoeff == (int)SkXfermode::kDC_Coeff,4,4,8
s.fInvType <= (SkMatrix::kTranslate_Mask | SkMatrix::kScale_Mask),4,4,8
!auxNextLink && !allocatedDuringIncremental,4,4,8
(int)SkPath::kCubic_Verb == (int)kCubic_PathCmd,4,4,8
fType == SkOperand2::kObject,4,4,8
fTrackDisplayable.find(displayable) < 0,4,4,8
alphaScale <= 256,4,4,8
"!areOverlappingRegions(newdata, datalen, dataptr_ + length_, datalen)",4,4,8
(int)kZero_BlendCoeff == (int)SkXfermode::kZero_Coeff,4,4,8
"pOut != pIn && ""You have tried to self-assign!!""",4,4,8
"fType == SkType_Int || fType == SkType_Boolean || SkDisplayType::IsEnum(maker, fType)",4,4,8
"validateChildRelations(s->fChildren[kLeft_Child], true)",4,4,8
(int)SkPath::kQuad_Verb == (int)kQuadratic_PathCmd,4,4,8
"isGCEnabled(), !InNoGCScope()",4,4,8
(int)kIDA_BlendCoeff == (int)SkXfermode::kIDA_Coeff,4,4,8
fTrackString.find(string) < 0,4,4,8
(int)kDA_BlendCoeff == (int)SkXfermode::kDA_Coeff,4,4,8
fNext->fPrev == this,4,4,8
count >= SkRegion::kRectRegionRuns,4,4,8
fType == SkType_Displayable,4,4,8
(int)SkPath::kDone_Verb == (int)kEnd_PathCmd,4,4,8
sizeof(StageBitfield)*8 >= kNumStages,4,4,8
sizeof(float)==4,4,4,8
cc%rowlen == 0,4,4,8
"offsetof(SkPoint,fX) == offsetof(GrPoint,fX)",4,4,8
0 == size || dst != NULL,4,4,8
"validateChildRelations(n, false)",4,4,8
"0 && ""Invalid matrix mode specified""",4,4,8
fType == SkOperand2::kArray,4,4,8
"validateChildRelations(n, true)",4,4,8
sizeof(uint8)==1,4,4,8
fType == SkType_Float,4,4,8
0 == sizeof(GrStencilFunc)%4,4,4,8
8 * sizeof(int) >= kNumStages,4,4,8
fPrev && fNext,4,4,8
fRuns[0] > 0,4,4,8
(int)SkPath::kLine_Verb == (int)kLine_PathCmd,4,4,8
predicate,4,4,8
"validateChildRelations(n->fChildren[kRight_Child], true)",4,4,8
(int)kOne_BlendCoeff == (int)SkXfermode::kOne_Coeff,4,4,8
fFirstY <= fLastY,4,4,8
index > 0 && index <= fPictureCount,4,4,8
(int)kISC_BlendCoeff == (int)SkXfermode::kISC_Coeff,4,4,8
 sizeof(AllocatedType) * objectPerAllocation >= sizeof(AllocatedType *) ,4,4,8
left_mask != 0,4,4,8
fType == SkOperand2::kScalar,4,4,8
!InNoGCScope(),4,4,8
(int)GrSamplerState::kClamp_WrapMode == (int)SkShader::kClamp_TileMode,4,4,8
kLCD32_Format == fFormat,4,4,8
layout,4,4,8
(uint16_t)sec == sec,4,4,8
!auxNextLink && !hasDelayedMarking,4,4,8
(base >= 2) && (base <= 36),4,4,8
(int)GrSamplerState::kRepeat_WrapMode ==( int)SkShader::kRepeat_TileMode,4,4,8
*xx < (unsigned)s.fBitmap->width(),4,4,8
"object != nullptr, ""The object should not be nullptr""",6,2,8
(unsigned)xy[0] < (unsigned)s.fBitmap->height(),4,4,8
count<0x40000000,4,4,8
sizeof(sp->stream.avail_out)==4,4,4,8
left_edge >= 0,4,4,8
fTrackArray.find(array) < 0,4,4,8
fFirstY < clip.fBottom,4,4,8
this->getFlags() & SkShader::kHasSpan16_Flag,4,4,8
fType == SkType_String,4,4,8
!assert,4,4,8
rite_edge > left_edge,4,4,8
 _size >= count ,4,4,8
 object != 0 ,4,4,8
"std::is_convertible<T, Object*>::value, ""Invalid Type for cocos2d::Vector<T>!""",4,4,8
"pMat1 != pMat2 && ""You are comparing the same thing!""",4,4,8
!RootMethods<T>::poisoned(*ptr),4,4,8
"1 && ""Invalid matrix mode specified""",4,4,8
 objectsPerPage >= 16 ,4,4,8
sizeof(int32)==4,4,4,8
fType == SkOperand2::kS32,4,4,8
"offsetof(SkPoint,fY) == offsetof(GrPoint,fY)",4,4,8
(int)SkPath::kClose_Verb == (int)kClose_PathCmd,4,4,8
fType == SkType_MSec,4,4,8
(uint16_t)pri == pri,4,4,8
SkAbs32(d) <= tolerance,4,4,8
"std::is_convertible<V, Object*>::value, ""Invalid Type for cocos2d::Map<K, V>!""",4,4,8
fType == SkType_MemberProperty,4,4,8
!(fun->flags & 0x4000),4,4,8
"validateChildRelations(s->fChildren[kRight_Child], true)",4,4,8
fPrev->fNext == this,4,4,8
fType == SkType_MemberProperty || fType == SkType_Array,4,4,8
SkAbs32(fWinding) == 1,4,4,8
index > 0 && index <= fPaintCount,4,4,8
tag < kSkTagListCount,4,4,8
kHighVertexLayoutBit < ((uint64_t)1 << 8*sizeof(GrVertexLayout)),4,4,8
::runtime::FileSendComplete_RESULTTYPE_IsValid(value),4,3,7
::runtime::FileSendProtos_VerifyMode_IsValid(value),4,3,7
::runtime::FileSendProtos_CompressType_IsValid(value),4,3,7
(del)->prev != NULL,4,3,7
id == WEBP_CHUNK_FRAME || id == WEBP_CHUNK_TILE || id == WEBP_CHUNK_IMAGE,3,3,6
dec->layer_data_size_ > 0,3,3,6
u_lines_in == v_lines_in,3,3,6
"stack->item_count && ""Cannot pop an empty stack""",3,3,6
trimmed_length >= 2,3,3,6
sizeof(JSValueShiftedTag) == sizeof(uint64),3,3,6
(uint32)l.s.tag <= (uint32)JSVAL_TAG_OBJECT,3,3,6
enc != NULL && pic != NULL && pic->a != NULL,3,3,6
wpi->header_ != NULL,3,3,6
value <= MAX_ALLOWED_CODE_LENGTH,3,3,6
num_htree_groups <= 0x10000,3,3,6
psize > 0,3,3,6
x_offset < MAX_POSITION_OFFSET,3,3,6
length < 0xfffffff8u,3,3,6
wpi_chunk_ptr != NULL,3,3,6
err == WEBP_MUX_OK,3,3,6
!(delta_y & 1),3,3,6
io->crop_left < io->crop_right,3,3,6
pic != NULL && pic->argb != NULL,3,3,6
fabs(length) > kmEpsilon,3,3,6
sizeof(int8)==1,3,3,6
width > 0,3,3,6
width > 0 && height > 0 && stride >= width,3,3,6
ptr - dec <= ptr,3,3,6
codes != NULL,3,3,6
chunk->tag_ != NIL_TAG,3,3,6
size == (uint32_t)size,3,3,6
data_size < MAX_CHUNK_PAYLOAD,3,3,6
frame_tile_chunk != NULL,3,3,6
inv_q_level[num_levels - 1] == max_s,3,3,6
sizeof(int16)==2,3,3,6
size <= MAX_CHUNK_PAYLOAD,3,3,6
row_start < row_end,3,3,6
!ok || (worker->status_ == OK),3,3,6
pixel_index == xsize * ysize,3,3,6
dec->next_transform_ <= NUM_TRANSFORMS,3,3,6
br && br->buf_,3,3,6
width != NULL && height != NULL,3,3,6
mid <= max && mid >= min,3,3,6
p->argb_or_distance < (1U << MAX_COLOR_CACHE_BITS),3,3,6
tokens != NULL,3,3,6
sizeof(int64)==8,3,3,6
wpi != NULL && wpi->img_ != NULL,3,3,6
(uint64_t)(w * h) == (uint64_t)w * h,3,3,6
 _initialized ,3,3,6
br != NULL && br->buf_ != NULL,3,3,6
"initialized && ""Cannot Pop empty matrix stack""",3,3,6
dec,3,3,6
refs != NULL,3,3,6
(cc%(4*stride))==0,3,3,6
value >= 0 || max - value > 0,3,3,6
dec->thread_ctx_.filter_row_,3,3,6
sizeof(header) == ALPHA_HEADER_LEN,3,3,6
io != NULL,3,3,6
key <= (~0U >> cc->hash_shift_),3,3,6
width <= MAX_CANVAS_SIZE && height <= MAX_CANVAS_SIZE,3,3,6
histo_bits > 0,3,3,6
n_bits >= 0,3,3,6
out != NULL,3,3,6
width >= 1 && height >= 1,3,3,6
ccolor_transform_bits >= 2,3,3,6
xsize > 0,3,3,6
idx != IDX_NIL,3,3,6
!RootMethods<T>::poisoned(v),3,3,6
len == maxlen,3,3,6
"0 && ""Invalid plane index""",3,3,6
histogram_bits <= MAX_HUFFMAN_BITS,3,3,6
children - node == (int)(children - node),3,3,6
"!!(cond), (msg)",3,3,6
dec->alpha_data_size_ == 0,3,3,6
sizeof(JSValueTag) == sizeof(uint32),3,3,6
height > 0,3,3,6
dec->output_ != NULL,3,3,6
mem->mode_ == MEM_MODE_APPEND,3,3,6
bw->nb_bits_ >= 0,3,3,6
riff_size != NULL,3,3,6
mem->part0_buf_ == NULL,3,3,6
pic->a_stride >= width,3,3,6
method <= ALPHA_LOSSLESS_COMPRESSION,3,3,6
htree_group != NULL,3,3,6
sizeof(js::HashNumber) == 4,3,3,6
dst != NULL,3,3,6
type_ == TYPE_LENGTH_DELIMITED,3,3,6
mem->mode_ == MEM_MODE_MAP,3,3,6
pic->width >= 1 && pic->height >= 1,3,3,6
n_bits <= 25,3,3,6
symbols != NULL,3,3,6
(tif->tif_flags&TIFF_NOREADRAW)==0,3,3,6
data != NULL && output != NULL,3,3,6
(cc%(2*stride))==0,3,3,6
headers != NULL,3,3,6
image_chunk != NULL,3,3,6
pred_bits >= 2,3,3,6
filter >= 0 && filter < WEBP_FILTER_LAST,3,3,6
output != NULL && output_size != NULL,3,3,6
(tif->tif_flags&TIFF_BUFFERMMAP)==0,3,3,6
buf != NULL,3,3,6
enc->has_alpha_,3,3,6
src != NULL && dst != NULL,3,3,6
nargv != NULL,3,3,6
stride >= width * bpp,3,3,6
alpha_size != NULL,3,3,6
psize <= mem->part0_size_,3,3,6
headers.data_size >= headers.offset,3,3,6
(yuv_size & ALIGN_MASK) == 0,3,3,6
id != WEBP_CHUNK_IMAGE || nth == 1,3,3,6
p->scaler_u.y_accum == p->scaler_v.y_accum,3,3,6
enc->use_layer_,3,3,6
features != NULL,3,3,6
tag == kChunks[IDX_FRAME].tag || tag == kChunks[IDX_TILE].tag,3,3,6
tokens <= ending_token,3,3,6
"js_static_assert, __COUNTER__",3,3,6
meta_index < hdr->num_htree_groups_,3,3,6
histogram_image->size == 1,3,3,6
((uint32)ptr & 1) == 0,3,3,6
val < (1 << 24),3,3,6
uIndex <= count(),3,3,6
huff_codes != NULL,3,3,6
width * (uint64_t)height < MAX_IMAGE_AREA,3,3,6
expn > 0.,3,3,6
filter >= WEBP_FILTER_NONE && filter <= WEBP_FILTER_FAST,3,3,6
in->size <= out->size,3,3,6
chunk_size != NULL,3,3,6
is_level0,3,3,6
p->mode == kCopy,3,3,6
"!is_whitespace_normalized(""abc def ghi "", 0)",3,3,6
tree_size_orig <= (1 << (tree_depth_limit - 1)),3,3,6
idx < (1 << MAX_COLOR_CACHE_BITS),3,3,6
y_start < y_end,3,3,6
(uint64_t)(data - headers->data) < MAX_CHUNK_PAYLOAD,3,3,6
images->img_ != NULL,3,3,6
dec->rescaler_memory == NULL,3,3,6
(ptrBits >> JSVAL_TAG_SHIFT) == 0,3,3,6
!(io->mb_y & 1),3,3,6
cc != NULL,3,3,6
histogram_bits >= MIN_HUFFMAN_BITS,3,3,6
OJPEG_BUFFER>=2,3,3,6
last_part >= 0,3,3,6
tc != NULL,3,3,6
codepoint <= 0x10FFFF,3,3,6
method >= ALPHA_NO_COMPRESSION,3,3,6
code_lengths_size > 0,3,3,6
!idec->is_lossless_,3,3,6
bpp > 0,3,3,6
nb <= total,3,3,6
color_cache != NULL,3,3,6
row_end <= transform->ysize_,3,3,6
p->mode == kCacheIdx,3,3,6
pic->width <= MAX_CANVAS_SIZE && pic->height <= MAX_CANVAS_SIZE,3,3,6
headers->offset == headers->data_size - data_size,3,3,6
worker->status_ <= OK,3,3,6
mem->end_ <= mem->buf_size_,3,3,6
len < 0xfffffff8u,3,3,6
mem->mode_ == expected,3,3,6
IsVP8XNeeded(enc),3,3,6
mem,3,3,6
inv_q_level[0] == min_s,3,3,6
ptr + inc >= ptr,3,3,6
(int)error < VP8_ENC_ERROR_LAST,3,3,6
val < (1 << 16),3,3,6
worker->status_ == OK,3,3,6
width < WEBP_MAX_DIMENSION && height < WEBP_MAX_DIMENSION,3,3,6
in != NULL,3,3,6
o->field_passcount==0,3,3,6
idec,3,3,6
hash_bits > 0,3,3,6
dec->last_out_row_ <= output->height,3,3,6
idx == IDX_FRAME || idx == IDX_TILE,3,3,6
alpha_data != NULL,3,3,6
width > 0 && height > 0 && duration > 0,3,3,6
"body->rot, ""Body's rotation vector is invalid.""",3,3,6
data == NULL,3,3,6
tag == kChunks[IDX_VP8].tag || tag == kChunks[IDX_VP8L].tag,3,3,6
m_ptr && i >= 0,3,3,6
found_vp8x != NULL,3,3,6
idx >= 0,3,3,6
vp8_size == (uint32_t)vp8_size,3,3,6
y_offset < MAX_POSITION_OFFSET,3,3,6
idec->mem_.start_ <= idec->mem_.end_,3,3,6
is_lossless != NULL,3,3,6
buf->u_stride == buf->v_stride,3,3,6
data,3,3,6
dec->last_row_ <= dec->height_,3,3,6
worker->status_ == NOT_OK,3,3,6
(int)error >= VP8_ENC_OK,3,3,6
dec->width_ <= final_width,3,3,6
riff_size == (uint32_t)riff_size,3,3,6
chunk_size == (uint32_t)chunk_size,3,3,6
mem->start_ <= mem->end_,3,3,6
code_length <= MAX_ALLOWED_CODE_LENGTH,3,3,6
size <= refs->max_size,3,3,6
palette_size >= 1,3,3,6
!IsRootingUnnecessaryForContext(cx),3,3,6
strm.avail_in == 0,3,2,5
ret != Z_STREAM_ERROR && ret != Z_DATA_ERROR && ret != Z_NEED_DICT,3,2,5
"false, ""AngleProject does not implement glUnmapBufferOES""",2,2,4
type_ == TYPE_VARINT,2,2,4
sp->encodepfunc != NULL,2,2,4
*(long*)node->_private == (long) 0x81726354,2,2,4
sp->libjpeg_session_active!=0,2,2,4
Base::level_stack_.GetSize() >= sizeof(typename Base::Level),2,2,4
"std::is_convertible<T, Ref*>::value, ""Invalid Type for cocos2d::Vector<T>!""",4,0,4
format,2,2,4
"false, ""AngleProject does not implement glDeleteVertexArraysOES""",2,2,4
"body->rot, ""Internal error: Body's rotation vector is invalid.""",2,2,4
 tv->count == 1 ,2,2,4
"_type == Type::ARRAY, """"",2,2,4
ostr != NULL,2,2,4
"false, ""AngleProject does not implement glGenVertexArraysOES""",2,2,4
"_referenceCount > 0, ""reference count should greater than 0""",2,2,4
"cond, msg",2,2,4
"false, ""AngleProject does not implement glMapBufferOES""",2,2,4
delimiters,2,2,4
cc>0,2,2,4
(cc%stride)==0,2,2,4
"index >= 0 && index < count(), ""Invalid index!""",2,2,4
sp->cinfo.comm.is_decompressor,2,2,4
type == kObjectType || type == kArrayType,2,2,4
count<0x80000000,2,2,4
!sp->cinfo.comm.is_decompressor,2,2,4
"type, obj",2,2,4
"std::is_convertible<V, Ref*>::value, ""Invalid Type for cocos2d::Map<K, V>!""",4,0,4
level_stack_.GetSize() >= sizeof(Level),2,2,4
type_ == TYPE_FIXED32,2,2,4
o->field_readcount==1,2,2,4
datetime,2,2,4
runner != NULL,2,2,4
"_type == Type::DICTIONARY, """"",2,2,4
type_ == TYPE_GROUP,2,2,4
rowsize > 0,2,2,4
nullptr != v,3,1,4
node->_private != NULL,2,2,4
scheme == COMPRESSION_JPEG,2,2,4
nargv0 != NULL,2,2,4
IsString(),2,2,4
type == kStringType,2,2,4
"false, ""AngleProject does not implement glBindVertexArrayOES""",2,2,4
type_ == TYPE_FIXED64,2,2,4
(cc%(bps*stride))==0,2,2,4
Function,2,2,4
FALSE,2,2,4
sp->decodepfunc != NULL,2,2,4
"proxy, ""Native object should be added!""",2,1,3
"0 && ""already stop""",2,1,3
"false, ""not supported type""",2,1,3
"position >= _data.begin() && position < _data.end(), ""Invalid position!""",2,1,3
"position != _data.cend(), ""Invalid iterator!""",2,1,3
"value.isObject(), ""the element in Vector isn't a native object.""",2,1,3
"p, ""Native object not found!""",2,1,3
(cc % 3) == 0,1,1,2
"!is_whitespace_normalized("" "", 0)",1,1,2
n<65536,1,1,2
255>=8+sp->samples_per_pixel_per_plane*3,1,1,2
flags_ & kIntFlag,1,1,2
flags_ & kUint64Flag,1,1,2
options != NULL,1,1,2
pa != 0,1,1,2
"__builtin_types_compatible_p(typeof(obj), type *)",1,1,2
scheme == COMPRESSION_PIXARLOG,1,1,2
nbits <= BITS_MAX,1,1,2
"sizeof(uint64) == sizeof(unsigned long long), sizeof_uint64_is_not_sizeof_long_long",1,1,2
::google::protobuf::FieldOptions_CType_IsValid(value),1,1,2
stream.Peek() == 't',1,1,2
sp->subsampling_convert_ycbcrbuf==0,1,1,2
 scheme == COMPRESSION_LZMA ,1,1,2
"sizeof(int64) == sizeof(long long), sizeof_int64_is_not_sizeof_long_long",1,1,2
GetSize() >= count * sizeof(T),1,1,2
td->td_planarconfig == PLANARCONFIG_CONTIG,1,1,2
OJPEG_BUFFER>=6,1,1,2
!Empty(),1,1,2
"!is_whitespace_normalized(""\n"", 0)",1,1,2
sp->vgetparent != NULL,1,1,2
stream.Peek() == '{',1,1,2
occ >= codep->length,1,1,2
(cc & 7) == 0,1,1,2
sizeof(char)==1,1,1,2
 length < 9 ,1,1,2
sp->state == ZSTATE_INIT_ENCODE,1,1,2
"_type == Type::BOOLEAN, """"",1,1,2
(uint64)n<=sp->in_buffer_file_togo,1,1,2
sp->sos_end[0].log!=0,1,1,2
suite != NULL,1,1,2
o->field_passcount==1,1,1,2
(flags_ & kUint64Flag) != 0,1,1,2
sp->decodetile != NULL,1,1,2
te->runlen == 64*(span>>6),1,1,2
::google::protobuf::FieldDescriptorProto_Type_IsValid(value),1,1,2
(cc0%rowsize)==0,1,1,2
n <= 308,1,1,2
tc->next_tcase == NULL,1,1,2
sp->subsampling_convert_ycbcrimage==0,1,1,2
"_ptr, ""Attempt to dereference a null pointer!""",2,0,2
td->td_photometric == PHOTOMETRIC_LOGLUV,1,1,2
sp->state == ZSTATE_INIT_DECODE,1,1,2
IsBool(),1,1,2
block_size < AllocatorBase::kDefaultAlignment || 0 == ((intptr_t)block & (AllocatorBase::kDefaultAlignment - 1)),2,0,2
data_.o.size > 0,1,1,2
!(parseFlags & kParseInsituFlag),1,1,2
(occ0%rowsize)==0,1,1,2
o->field_type==TIFF_ASCII,1,1,2
sp->state == LSTATE_INIT_ENCODE,1,1,2
(cc & 1) == 0,1,1,2
*pa <= 0xFFFFFFFFUL,1,1,2
occ >= len,1,1,2
x == lastx,1,1,2
sp->vsetparent != 0,1,1,2
"idx1>=0 && idx2>=2, ""invalid object index""",1,1,2
name.IsString(),1,1,2
index < data_.a.size,1,1,2
"position >= _data.begin() && position < _data.end(), """"",1,1,2
 restart ,1,1,2
newBuffer != 0,1,1,2
sp->dec_codetab != NULL,1,1,2
pitch <= 2*kmPI,1,1,2
"!is_whitespace_normalized(""\r"", 1)",1,1,2
n<=OJPEG_BUFFER,1,1,2
"_data.size(), ""no objects added""",1,1,2
"is_whitespace_normalized(""abc"", 1)",1,1,2
(uint64)nextdir32==nextdir,1,1,2
"!is_whitespace_normalized(""\t"", 1)",1,1,2
"!is_whitespace_normalized(""\n"", 1)",1,1,2
dir[m].tdir_tag!=tag,1,1,2
size > sizeof(ChunkHeader),1,1,2
"_type == Type::INTEGER, """"",1,1,2
sp->enc_hashtab != NULL,1,1,2
sp->in_buffer_togo==0,1,1,2
datalength<0x80000000UL,1,1,2
yaw <= 2*kmPI,1,1,2
fip->field_writecount==TIFF_VARIABLE2,1,1,2
GetSize() >= sizeof(T),1,1,2
IsNumber(),1,1,2
"_type == Type::DOUBLE, """"",1,1,2
scheme==COMPRESSION_OJPEG,1,1,2
scheme == COMPRESSION_JBIG,1,1,2
td->td_nstrips > 0,1,1,2
img->Bitdepth16To8==NULL,1,1,2
roll <= 2*kmPI,1,1,2
link->name != NULL,1,1,2
link != NULL,1,1,2
!level_stack_.template Top<Level>()->inArray,1,1,2
o->field_readcount==TIFF_VARIABLE,1,1,2
!Base::level_stack_.template Top<typename Base::Level>()->inArray,1,1,2
stream.Peek() == 'f',1,1,2
nullptr != _pages,1,1,2
"is_whitespace_normalized(""abc"", 0)",1,1,2
dst_ != 0,1,1,2
stream.Peek() == 'n',1,1,2
level_stack_.template Top<Level>()->inArray,1,1,2
new_tests != NULL,1,1,2
::google::protobuf::FileOptions_OptimizeMode_IsValid(value),1,1,2
((uintptr_t)buffer & 3) == 0,1,1,2
flags_ & kUintFlag,1,1,2
255>=6+sp->samples_per_pixel_per_plane*2,1,1,2
s>0,1,1,2
type <= kNumberType,1,1,2
this != &rhs,1,1,2
fip->field_readcount == TIFF_VARIABLE || fip->field_readcount == TIFF_VARIABLE2,1,1,2
sp->subsamplingcorrect==0,1,1,2
n==2,1,1,2
length <= 0xFFFFFFFF,1,1,2
ret >= 1,1,1,2
sp->plane_sample_offset==0,1,1,2
OJPEG_BUFFER>=2+6+sp->samples_per_pixel_per_plane*2,1,1,2
buffer != 0,1,1,2
sp->subsamplingcorrect_done==0,1,1,2
o->field_type==TIFF_SHORT,1,1,2
typeProxy,1,1,2
sp->readheader_done==0,1,1,2
stream.Peek() == '[',1,1,2
s<3,1,1,2
" condition, error_msg ",1,1,2
"_type == Type::INT_KEY_DICT, """"",1,1,2
"_type == Type::STRING, """"",1,1,2
o->field_type==TIFF_LONG,1,1,2
Base::level_stack_.template Top<typename Base::Level>()->inArray,1,1,2
flags_ & kInt64Flag,1,1,2
na<ndir,1,1,2
stack_.GetSize() == sizeof(ValueType),1,1,2
fp_ != 0,1,1,2
expected != NULL,1,1,2
sp->state == LSTATE_INIT_DECODE,1,1,2
sizeof(tmsize_t)==sizeof(void*),1,1,2
data_.o.members != 0,1,1,2
(cc & 3) == 0,1,1,2
"_type == Type::FLOAT, """"",1,1,2
sp->out_state<=ososEoi,1,1,2
x,1,1,2
"!is_whitespace_normalized(""\t"", 0)",1,1,2
long_options != NULL,1,1,2
(toff_t)tif->tif_size==n,1,1,2
sp->decoderow != NULL,1,1,2
((uintptr_t)originalPtr & 3) == 0,1,1,2
td->td_photometric == PHOTOMETRIC_LOGL,1,1,2
"index >= 0 && index <= count(), ""Invalid index!""",1,1,2
n.a16==256,1,1,2
indentChar == ' ' || indentChar == '\t' || indentChar == '\n' || indentChar == '\r',1,1,2
"is_whitespace_normalized(""abc def ghi"", 0)",1,1,2
o->field_readcount==TIFF_VARIABLE2,1,1,2
m<0x80000000UL,1,1,2
sp->encodetile != NULL,1,1,2
OJPEG_BUFFER>=2+8+sp->samples_per_pixel_per_plane*3,1,1,2
tif->tif_data != 0,1,1,2
::runtime::FileSendComplete_RESULT_IsValid(value),1,1,2
"index>=0 && index < count(), ""index out of range in objectAtIndex()""",1,1,2
o->field_type==TIFF_UNDEFINED,1,1,2
img->UaToAa==NULL,1,1,2
sp->vsetparent != NULL,1,1,2
scheme == COMPRESSION_LZW,1,1,2
codepoint < 0xD800 || codepoint > 0xDFFF,1,1,2
n.a16==1,1,1,2
sp->sos_end[s].log==0,1,1,2
"index1 >=0 && index1 < count() && index2 >= 0 && index2 < count(), ""Invalid indices""",1,1,2
"is_whitespace_normalized("" "", 1)",1,1,2
::google::protobuf::FieldDescriptorProto_Label_IsValid(value),1,1,2
scheme == COMPRESSION_SGILOG24 || scheme == COMPRESSION_SGILOG,1,1,2
sp->encoderow != NULL,1,1,2
 (scheme == COMPRESSION_DEFLATE) || (scheme == COMPRESSION_ADOBE_DEFLATE),1,1,2
stack_capacity_ > 0,1,1,2
"!is_whitespace_normalized(""abc\t def"", 1)",1,1,2
XXH32_SIZEOFSTATE >= sizeof(struct XXH_state32_t),1,1,2
"!is_whitespace_normalized(""\r"", 0)",1,1,2
value>=0.0,1,1,2
0 == size || block_size == size,1,0,1
_allocated > 0,1,0,1
"getGLProgram(), ""No shader program set for this node""",1,0,1
nullptr != address,1,0,1
point,1,0,1
"index1 >=0 && index1 < size() && index2 >= 0 && index2 < size(), ""Invalid indices""",1,0,1
"object != nullptr, ""Object is nullptr!""",1,0,1
block_size == size,1,0,1
"idx1>=0 && idx2>=0, ""invalid object index""",1,0,1
"sizeof(uintptr_t) <= kDefaultAlignment, ""pointer size must be smaller than default alignment""",1,0,1
"std::is_base_of<Ref, typename std::remove_const<T>::type>::value, ""T must be derived from Ref""",1,0,1
true == owns(block),1,0,1
"!_data.empty() && index >=0 && index < size(), ""Invalid index!""",1,0,1
"!_data.empty(), ""no objects added""",1,0,1
"index >= 0 && index <= size(), ""Invalid index!""",1,0,1
"__gl_error_code == GL_NO_ERROR, ""Error""",1,0,1
adjusted_size < AllocatorBase::kDefaultAlignment || 0 == ((intptr_t)address & (AllocatorBase::kDefaultAlignment - 1)),1,0,1
"sizeof(x) == 0, ""Unsupported argument type""",1,0,1
block,1,0,1
" index >= 0 && index < size(), ""index out of range in getObjectAtIndex()""",1,0,1
"index >= 0 && index < size(), ""Invalid index!""",1,0,1
