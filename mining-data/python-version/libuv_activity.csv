x_val,y_added,y_removed,y_combined
r == 0,1180,269,1449
status == 0,173,78,251
"0 && ""implement me""",116,116,232
0,108,73,181
r != -1,87,77,164
r == -1,49,46,95
close_cb_called == 1,73,17,90
req != NULL,52,23,75
handle != NULL,57,18,75
r >= 0,66,4,70
"0 == uv_ip4_addr(""127.0.0.1"", TEST_PORT, &addr)",49,1,50
!r,33,15,48
handle->fd >= 0,23,23,46
stream->fd >= 0,23,23,46
0 == uv_run(loop),23,23,46
tcp->fd >= 0,21,21,42
close_cb_called == 2,35,5,40
status == -1,19,18,37
req,21,16,37
exit_cb_called == 1,33,3,36
r == UV_EINVAL,36,0,36
!(handle->flags & UV_HANDLE_CLOSED),24,12,36
"0 == uv_run(loop, UV_RUN_DEFAULT)",34,1,35
buf.len > 0,17,17,34
req.result != -1,17,17,34
handle->_.fd >= 0,16,16,32
!(req->flags & UV_REQ_PENDING),16,16,32
req->result == 0,28,2,30
req->result != -1,14,14,28
"0 == uv_run(uv_default_loop(), UV_RUN_DEFAULT)",28,0,28
close_cb_called == 0,24,3,27
!err,14,13,27
open_req1.result != -1,12,12,24
close_req.result != -1,11,11,22
uv_last_error(uv_default_loop()).code == UV_EINVAL,11,11,22
"0 == uv_ip4_addr(""0.0.0.0"", TEST_PORT, &addr)",19,3,22
req.result == 0,22,0,22
connect_cb_called == 1,21,1,22
err == 0,17,2,19
handle->type == UV_TCP,12,7,19
req.result >= 0,19,0,19
fd >= 0,12,7,19
uv_last_error().code == UV_EOF,9,9,18
tcp->write_queue_size == 0,9,8,17
dent.type == UV_DIRENT_FILE,9,8,17
stream->type == UV_TCP || stream->type == UV_NAMED_PIPE,9,8,17
open_req1.result >= 0,17,0,17
handle->type == UV_NAMED_PIPE,12,5,17
timer->type == UV_TIMER,8,8,16
close_req.result == 0,16,0,16
nread == 4,12,4,16
"0 && ""unreachable""",8,8,16
handle->write_queue_size == 0,8,8,16
loop->cf_loop != NULL,8,8,16
uv_last_error().code == UV_EINVAL,8,8,16
UV_OK == err.code,8,8,16
handle->type == UV_TIMER,9,6,15
0 == uv_thread_join(&thread),15,0,15
stream->write_queue_size == 0,8,7,15
req == &connect_req,13,2,15
loop != NULL,11,4,15
nread == UV_EOF,14,1,15
stream->io_watcher.fd >= 0,7,7,14
buf.base,7,7,14
!(req->flags & OIO_REQ_PENDING),7,7,14
uv_last_error().code == UV_EADDRNOTAVAIL,7,7,14
data != NULL,7,6,13
close_cb_called == 3,11,2,13
r == 1,9,4,13
!ev_is_active(&stream->read_watcher),6,6,12
!ev_is_active(&handle->read_watcher),6,6,12
term_signal == 0,8,4,12
suggested_size <= sizeof slab,6,6,12
sznum >= 0,6,6,12
addr != NULL,10,2,12
uv__stream_fd(stream) >= 0,9,3,12
tcp->write_watcher.data == tcp,6,6,12
ngx_queue_empty(&tcp->write_completed_queue),6,6,12
state != NULL,7,5,12
uv_last_error(uv_default_loop()).code == UV_EOF,6,6,12
req.result == -1,6,6,12
handle->write_watcher.data == handle,6,6,12
uv_last_error().code == UV_EADDRINUSE,6,6,12
h->connecting,6,6,12
err.code == UV_OK,6,6,12
stream->write_watcher.data == stream,6,6,12
watcher == &stream->read_watcher || watcher == &stream->write_watcher,6,6,12
req->result == -1,6,6,12
shutdown_cb_called == 1,12,0,12
r == UV_EBADF,12,0,12
revents == EV_READ,6,6,12
stream->write_watcher.cb == uv__stream_io,6,6,12
oio_last_error().code == OIO_EOF,6,6,12
stream->read_watcher.cb == uv__stream_io,6,6,12
handle->flags & UV_HANDLE_READING,8,3,11
"strcmp(buf, test_buf) == 0",11,0,11
"0 && ""unexpected error""",9,2,11
alloc_cb,6,5,11
handle->type == UV_UDP,7,4,11
result.code == UV_OK,5,5,10
!(stream->flags & UV_CLOSING),6,4,10
n == 0,6,4,10
!flags,5,5,10
write_cb_called == 1,8,2,10
*size > strlen(symlink),5,5,10
handle->flags & UV_CLOSING,6,4,10
pipe_fname != NULL,5,5,10
write_req.result != -1,5,5,10
name_len > 0,6,4,10
completed_pingers == 1,7,3,10
0 == status,10,0,10
"(loop_done = EVBREAK_RECURSE, 1)",5,5,10
loop->watchers != NULL,9,1,10
!(handle->flags & UV_HANDLE_CLOSING),5,5,10
*size > (strlen(symlink) + 1 + strlen(temp_buffer)),5,5,10
ngx_queue_empty(&loop->watcher_queue),5,5,10
req->write_index < req->bufcnt,5,5,10
"(loop_done = EVBREAK_CANCEL, 1)",5,5,10
r != 0,10,0,10
handle->read_watcher.data == handle,5,5,10
!(handle->flags & OIO_HANDLE_CLOSED),5,5,10
"0 == uv_thread_create(&thread, worker, &wc)",10,0,10
n == 0 || n == -1,5,4,9
dent.type == UV_DIRENT_FILE || dent.type == UV_DIRENT_UNKNOWN,5,4,9
dent.type == UV_DIRENT_UNKNOWN,5,4,9
q != NULL,5,4,9
read_req.result != -1,5,4,9
suggested_size <= sizeof(slab),9,0,9
r == UV_EBUSY,6,3,9
!(handle->flags & UV_HANDLE_READ_PENDING),7,2,9
arg != NULL,4,4,8
watcher == &tcp->read_watcher || watcher == &tcp->write_watcher,4,4,8
!ev_is_active(&handle->write_watcher),4,4,8
w == &handle->read_watcher || w == &handle->write_watcher,4,4,8
uv_last_error().code == UV_EFAULT,4,4,8
err.code == 0,4,4,8
"offsetof (eio_dirent, score)",4,4,8
0 == uv_run(uv_default_loop()),4,4,8
!uv_is_closing((uv_handle_t*) &timer),4,4,8
ares__is_list_empty(&(channel->all_queries)),4,4,8
pinger->buf.base[i] == PING[pinger->state],4,4,8
uv_last_error(loop).code == UV_ENOENT,4,4,8
tcp->type == UV_TCP,4,4,8
ngx_queue_empty(&tcp->write_queue),4,4,8
handle->flags & UV_HANDLE_CLOSING,4,4,8
flags == 0,7,1,8
tcp->read_watcher.cb == uv__tcp_io,4,4,8
ares__is_list_empty(&(channel->queries_by_qid[i])),4,4,8
handle->accept_socket == INVALID_SOCKET,4,4,8
"uv_flag_is_set(handle, UV_CLOSING)",4,4,8
idles_1_active == 0,4,4,8
ngx_queue_empty(&stream->write_completed_queue),4,4,8
"0 == uv_run(uv_default_loop(), UV_RUN_ONCE)",8,0,8
tcp->write_watcher.cb == uv__tcp_io,4,4,8
q,4,4,8
revents == EV_IDLE,4,4,8
sizeof(uv_buf_t) == sizeof(struct iovec),5,3,8
timeouts == 0,4,4,8
(uv_udp_t*)(handle) == &server || (uv_udp_t*)(handle) == &client,8,0,8
nread > 0,7,1,8
"(status == 1) && ""poll() on pipe read end failed""",4,4,8
"offsetof (eio_dirent, inode)",4,4,8
ev_is_pending(&handle->next_watcher),4,4,8
buf.base != NULL,7,1,8
write_cb_count == 1,4,4,8
watcher == &handle->read_watcher || watcher == &handle->write_watcher,4,4,8
!ev_is_active(&tcp->read_watcher),4,4,8
handle->socket == INVALID_SOCKET,4,4,8
handle->handle != INVALID_HANDLE_VALUE,5,3,8
watcher == &handle->next_watcher,4,4,8
handle->flags & UV_HANDLE_LISTENING,5,3,8
req->fs_type == UV_FS_OPEN,7,1,8
!(handle->flags & UV_CLOSED),5,3,8
"!uv_flag_is_set((uv_handle_t*)tcp, UV_CLOSING)",4,4,8
addr == NULL,8,0,8
sock != INVALID_SOCKET,8,0,8
ares__is_list_empty(&(channel->queries_by_timeout[i])),4,4,8
!(req->_.flags & OL_REQ_PENDING),4,4,8
tcp->read_watcher.data == tcp,4,4,8
uv_is_writable((uv_stream_t*)&channel),4,3,7
cur_ptr + addrinfo_ptr->ai_addrlen <= alloc_ptr + addrinfo_len,4,3,7
0 == uv_loop_init(&loop),7,0,7
r == 2,5,2,7
r > 0,7,0,7
backlog > 0,4,3,7
buf[len - 1] != 0,6,1,7
pipe->type == UV_NAMED_PIPE,4,3,7
(uv_stream_t*)&tcp_server == server,5,2,7
handle != INVALID_HANDLE_VALUE,5,2,7
timeout != -1,6,1,7
conn,5,2,7
uv_is_readable((uv_stream_t*)&channel),4,3,7
0 == close(fd),7,0,7
len > 0,6,1,7
timer_cb_called == 1,6,1,7
curr != NULL,4,3,7
1 == timer_cb_called,7,0,7
idle_2_is_active == 0,4,3,7
nread >= 0,6,1,7
handle == &fs_event,6,1,7
0 == uv_mutex_init(&wc.mutex),7,0,7
"0 && ""EAGAIN on uv__accept(pipefd)""",3,4,7
n <= MAXIMUM_WAIT_OBJECTS,4,3,7
w->fd >= 0,6,1,7
prev != NULL,4,3,7
"0 == uv_timer_init(loop, &timer_handle)",7,0,7
0 == (events & ~(UV__IO_READ | UV__IO_WRITE)),3,3,6
!ev_is_active(&((uv_async_t*)handle)->async_watcher),3,3,6
"(""libev: inactive fd watcher on anfd list"", ev_active (w) == 1)",3,3,6
0 == (events & ~(UV__POLLIN | UV__POLLOUT | UV__POLLRDHUP)),3,3,6
!uv_is_active((uv_handle_t*) &timer),3,3,6
req->pipeHandle == INVALID_HANDLE_VALUE,4,2,6
((uv_stream_t*)handle)->fd == -1,3,3,6
!ev_is_active(&stream->write_watcher),3,3,6
"(""libev: ev_io_start called with negative fd"", fd >= 0)",3,3,6
!ev_is_active(&((uv_idle_t*)handle)->idle_watcher),3,3,6
"memcmp(""PING"", buf->base, nread) == 0",4,2,6
"(""libev: multiple event bases not supported when not compiled with EV_MULTIPLICITY"", !ev_x_cur)",3,3,6
ares_bynamecallbacks == 1,3,3,6
handle == &prepare_handle,4,2,6
uv_last_error(uv_default_loop()).code == UV_EADDRINUSE,3,3,6
options.stdin_stream,3,3,6
diff >= base,3,3,6
"(""libev: pending watcher not on pending queue"", pendings [ABSPRI (w)][w->pending - 1].w == w)",3,3,6
"(""libev: fd >= FD_SETSIZE passed to fd_set-based select backend"", fd < FD_SETSIZE)",3,3,6
ev_is_pending(&handle->read_watcher),3,3,6
!readdir_req.ptr,3,3,6
ngx_queue_empty(&handle->write_queue),3,3,6
0 == close(fd[1]),5,1,6
handle->shutdown_req,3,3,6
sv_send_cb_called == 0,6,0,6
stdout_pipe[1] >= 0,3,3,6
"(""libev: ev_loop recursion during release detected"", loop_done != EVBREAK_RECURSE)",3,3,6
req.result == UV_ENOENT,6,0,6
options.file != NULL,4,2,6
!uv_is_active((uv_handle_t*)handle),3,3,6
"(""libev: poll() returned illegal result, broken BSD kernel?"", p < polls + pollcnt)",3,3,6
revents == EV_TIMER,3,3,6
handle->accept_socket != INVALID_SOCKET,3,3,6
stderr_pipe[1] >= 0,3,3,6
req->path,6,0,6
path != NULL,4,2,6
wc.worker_barrier_wait_rval == 0,3,3,6
sv_send_cb_called == 1,6,0,6
periodicmax >= periodiccnt,3,3,6
pw != NULL,6,0,6
after_write_called == 7,4,2,6
timeout >= -1,5,1,6
0 == (events & ~(UV__POLLIN | UV__POLLOUT)),3,3,6
req->fs_type == UV_FS_READDIR,3,3,6
pendingmax [i] >= pendingcnt [i],3,3,6
uv_last_error(loop).code == UV_EINVAL,3,3,6
"h && ""When an ares socket is closed we should have a handle for it""",3,3,6
options.stderr_stream,3,3,6
!(req->flags & OL_REQ_PENDING),3,3,6
"(""libev: a signal must not be attached to two different loops"", !signals [w->signum - 1].loop || signals [w->signum - 1].loop == loop)",3,3,6
"(""libev: heap at cache mismatch"", ANHE_at (heap [i]) == ev_at (ANHE_w (heap [i])))",3,3,6
"(""libev: ev_periodic reschedule callback returned time in the past"", ev_at (w) >= ev_rt_now)",3,3,6
idlemax [i] >= idlecnt [i],3,3,6
"(""libev: ev_io_start called with illegal event mask"", !(w->events & ~(EV__IOFDSET | EV_READ | EV_WRITE)))",3,3,6
req == &readdir_req,3,3,6
"(""cannot add requests to IO::AIO::GRP after the group finished"", grp->int1 != 2)",3,3,6
write_req.result >= 0,6,0,6
&process->child_watcher == watcher,3,3,6
"(""libev: ev_periodic_start called with negative interval value"", w->interval >= 0.)",3,3,6
"(""libev: ev_timer_start called with negative timer repeat value"", w->repeat >= 0.)",3,3,6
iov,3,3,6
uv_last_error(uv_default_loop()).code == UV_EADDRNOTAVAIL,3,3,6
uv_ares_handles_empty(loop),3,3,6
checkmax >= checkcnt,3,3,6
"(""libev: active index mismatch in heap"", ev_active (ANHE_w (heap [i])) == i)",3,3,6
uv_is_active((uv_handle_t*)handle),3,3,6
readdir_req.result == 2,3,3,6
oio_last_error().code == OIO_EADDRNOTAVAIL,3,3,6
"(""unable to allocate worker thread data"", wrk)",3,3,6
forkmax >= forkcnt,3,3,6
"(""libev: internal periodic heap corruption"", ANHE_w (periodics [active]) == (WT)w)",3,3,6
req->data == handle,3,3,6
handle->write_queue_size > 0,3,3,6
"(""libev: loop to be embedded is not embeddable"", backend & ev_embeddable_backends ())",3,3,6
"(handle->type == UV_TCP || handle->type == UV_NAMED_PIPE) && ""uv_write (unix) does not yet support other types of streams""",3,3,6
"(""libev: PORT_SOURCE_FD must not be zero"", PORT_SOURCE_FD)",3,3,6
preparemax >= preparecnt,3,3,6
addr.sin_family == AF_INET,3,3,6
revents & (EV_READ | EV_WRITE),3,3,6
anfdmax >= 0,3,3,6
!ev_is_active(&((uv_timer_t*)handle)->timer_watcher),3,3,6
uv_last_error(loop).code == UV_EOF,3,3,6
"(""libev: heap condition violated"", i == HEAP0 || ANHE_at (heap [HPARENT (i)]) <= ANHE_at (heap [i]))",3,3,6
revents & EV_CHILD,3,3,6
exit_status == 1,4,2,6
!uv_write_queue_head(stream),3,3,6
5 == r,4,2,6
"(""libev: watcher has invalid priority"", ABSPRI (w) >= 0 && ABSPRI (w) < NUMPRI)",3,3,6
parameter != NULL,3,3,6
uv_handle_ares->type == UV_ARES_TASK,3,3,6
1 == uv_pipe_pending_count(pipe),5,1,6
"(""libev: fd mismatch between watcher and anfd"", ((ev_io *)w)->fd == i)",3,3,6
0 == uv_fs_event_stop(handle),4,2,6
uv_handle_ares->h_event != WSA_INVALID_EVENT,3,3,6
timeout > 0,5,1,6
readdir_cb_count == 1,3,3,6
handle == &check_handle,4,2,6
options.stdout_stream,3,3,6
"0 == uv_ip4_addr(""127.0.0.1"", TEST_PORT, &server_addr)",6,0,6
uv_last_error(stream->loop).code == UV_EOF,3,3,6
stdin_pipe[0] >= 0,3,3,6
nread == -1,3,3,6
"(""libev: only socket fds supported in this configuration"", ioctlsocket (handle, FIONREAD, &arg) == 0)",3,3,6
handle == &timer,5,1,6
handle,5,1,6
!ev_is_active(&((uv_prepare_t*)handle)->prepare_watcher),3,3,6
"(""libev: ev_signal_start called with illegal signal number"", w->signum > 0 && w->signum < EV_NSIG)",3,3,6
iovcnt > 0,3,3,6
read2_cb_called == 1,3,3,6
"(""libev: internal timer heap corruption"", ANHE_w (timers [active]) == (WT)w)",3,3,6
uv_last_error(uv_default_loop()).code == UV_ENOTSUP,4,2,6
handle == &timer_handle,5,1,6
req->retcode == 0,5,1,6
"(""libev: active index mismatch"", ev_active (ws [cnt]) == cnt + 1)",3,3,6
"(""libev: negative ev_timer repeat value found while processing timers"", w->repeat > 0.)",3,3,6
sizeof (eio_dirent) * 8 < 256,3,3,6
nread > 0 && buf.base && pending != UV_UNKNOWN_HANDLE,3,3,6
req.ptr == NULL,6,0,6
idleall >= 0,3,3,6
timermax >= timercnt,3,3,6
"(""libev: child watchers are only supported in the default loop"", loop == ev_default_loop_ptr)",3,3,6
n >= len,3,3,6
fdchangemax >= fdchangecnt,3,3,6
!handle->loop,3,3,6
"0 && ""fail_cb called""",5,1,6
!ev_is_active(&((uv_check_t*)handle)->check_watcher),3,3,6
handle->accept_reqs[0].pipeHandle != INVALID_HANDLE_VALUE,3,3,6
slnum >= 0,3,3,6
readdir_req.ptr,3,3,6
!ngx_queue_empty(&stream->write_queue),3,3,6
"!memcmp(""PING"", buf.base, nread)",3,3,6
activecnt >= -1,3,3,6
uv_handle_ares->data != NULL,3,3,6
stream->alloc_cb,3,3,6
CHAR_BIT == 8,3,3,6
pipe->pipe_fname != NULL,3,3,6
polls [idx].fd == fd,3,3,6
stream->write_watcher.fd == stream->fd,3,3,6
"(""libev: negative fd in fdchanges"", fdchanges [i] >= 0)",3,3,6
"(pfd.revents & POLLHUP) == POLLHUP && ""no POLLHUP on pipe read end""",3,3,6
"memcmp(""hello\n"", buf.base, nread) == 0",3,3,6
getaddrinfo_callbacks == 1,3,3,6
pending == UV_TCP,5,1,6
cleanupmax >= cleanupcnt,3,3,6
seen > written,3,3,6
"memcmp(readdir_req.ptr, ""file1\0file2\0"", 12) == 0 || memcmp(readdir_req.ptr, ""file2\0file1\0"", 12) == 0",3,3,6
"0 == uv_spawn(uv_default_loop(), &process, options)",4,2,6
stream->accepted_fd < 0,3,3,6
asyncmax >= asynccnt,3,3,6
w->pevents != 0,5,1,6
"(""libev: ev_io_stop called with illegal fd (must stay constant after start!)"", w->fd >= 0 && w->fd < anfdmax)",3,3,6
handle == (uv_handle_t*) &timer,3,2,5
rc == ARES_SUCCESS,2,3,5
cur_ptr <= alloc_ptr + addrinfo_len,3,2,5
"0 && ""Unexpected flags""",3,2,5
handle == (uv_handle_t*)&prepare_1_handle,3,2,5
r == UV_EADDRINUSE,5,0,5
"strcmp(""hello world\n"", output) == 0",4,1,5
NUM_PINGS == pinger->pongs,3,2,5
incoming->wrstate == c_stop,5,0,5
handle == &prepare_2_handle,3,2,5
numcpus != 0,3,2,5
server->loop == client->loop,3,2,5
(size_t)n >= len,3,2,5
handle == (uv_handle_t*)&idle_2_handle,3,2,5
req->type == UV_WAKEUP,3,2,5
read_req.result >= 0,5,0,5
handle->type == UV_ASYNC,3,2,5
container->data.stream != NULL,3,2,5
stream->shutdown_req,3,2,5
handle == (uv_handle_t*)&check_handle,3,2,5
numcpus != (unsigned int) -1,3,2,5
exit_status == 0,4,1,5
got_eagain(),4,1,5
req->handle == stream,3,2,5
tcp != NULL,4,1,5
pending == ctx.expected_type,3,2,5
status == UV_ECANCELED,5,0,5
cur_ptr + name_len <= alloc_ptr + addrinfo_len,3,2,5
(events & ~(UV_READABLE | UV_WRITABLE)) == 0,3,2,5
handle == &prepare_1_handle,3,2,5
stream->write_queue_size >= len,3,2,5
open_cb_count == 1,5,0,5
errno == EAGAIN || errno == EWOULDBLOCK,3,2,5
QUEUE_EMPTY(&loop->watcher_queue),5,0,5
handle == (uv_handle_t*)&prepare_2_handle,3,2,5
w != NULL,3,2,5
handle == server,3,2,5
"sscanf(buf, ""cpu%u "", &n) == 1 && n == num",3,2,5
"(stream->type == UV_TCP || stream->type == UV_NAMED_PIPE) && ""uv_shutdown (unix) only supports uv_handle_t right now""",3,2,5
r == sizeof(test_buf),5,0,5
"0 == uv_spawn(uv_default_loop(), &process, &options)",4,1,5
size > 0,3,2,5
incoming->rdstate == c_stop,5,0,5
write_cb_called == 0,3,2,5
0 == uv_cond_init(&wc.cond),5,0,5
"1 == write(fd[1], """", 1)",5,0,5
"0 == fcntl(fd[0], F_SETFL, O_NONBLOCK)",3,2,5
w->fd < (int) loop->nwatchers,4,1,5
req.result == sizeof(test_buf),5,0,5
cur_ptr + addrinfo_struct_len <= alloc_ptr + addrinfo_len,3,2,5
"filename == NULL || strncmp(filename, file_prefix_in_subdir, sizeof(file_prefix_in_subdir) - 1) == 0",3,2,5
wc.posted == 1,3,2,5
outgoing->rdstate == c_stop,5,0,5
server != NULL,3,2,5
!(handle->flags & (UV_CLOSING | UV_CLOSED)),5,0,5
outgoing->wrstate == c_stop,5,0,5
uv__timer_repeating(timer),3,2,5
req == &shutdown_req,5,0,5
handle == &idle_2_handle,3,2,5
uv__timer_active(timer),3,2,5
handle->write_watcher.fd == handle->fd,2,2,4
"memcmp(""PING"", buf.base, nread) == 0",2,2,4
"0 == uv_pipe_open(&pipe_handle, fd[0])",4,0,4
paths != NULL,2,2,4
req == &write_req,3,1,4
timer_cb_called == 0,4,0,4
stream->read2_cb,2,2,4
uv_last_error(uv_default_loop()).code == UV_EBADF,2,2,4
cb,2,2,4
"strcmp((char*)req->ptr + strlen((const char*)req->ptr) + 1, ""file2"") == 0",2,2,4
!(((uv_handle_t*)stream)->flags & UV_CLOSING),2,2,4
server == (uv_stream_t*) &tcp_server,3,1,4
"ACCESS_ONCE(CFRunLoopRef, loop->cf_loop) != NULL",2,2,4
clock_ticks != (unsigned long) -1,3,1,4
tcp->shutdown_req,2,2,4
*iargs == bynamecallbacksig,2,2,4
create_cb_count == 1,4,0,4
uv_ares_handles_empty(),2,2,4
uv_last_error(req->handle->loop).code == UV_EINTR,2,2,4
watcher == &uv_eio_poller,2,2,4
req->handle == handle,2,2,4
handle->write_queue_size >= req->queued_bytes,2,2,4
req.statbuf.st_atim.tv_nsec == 0,2,2,4
repeat >= 0,2,2,4
query->server == whichserver,2,2,4
addr->sa_family == AF_INET,3,1,4
clock_ticks != 0,3,1,4
addr.sin6_family == AF_INET6,2,2,4
"0 == uv_tcp_init(loop, &client_handle)",4,0,4
prev == NULL,2,2,4
!uv_write_queue_head(tcp),2,2,4
!ngx_queue_empty(&handle->write_queue) || !ngx_queue_empty(&handle->write_completed_queue),2,2,4
handle->type == OIO_PREPARE,2,2,4
handle == &async1_handle,2,2,4
sock >= 0,4,0,4
tcp->accepted_fd < 0,2,2,4
handle->read_line_buffer.len > 0,2,2,4
req->handle == (uv_handle_t*)tcp,2,2,4
nread == 0,3,1,4
!ngx_queue_empty(&handle->_.read_reqs) || (nread < 0 && errno == EAGAIN),2,2,4
handle->next_watcher.data == handle,2,2,4
!ev_is_active(&((uv_process_t*)handle)->child_watcher),2,2,4
!ev_is_active(&((uv_udp_t*)handle)->write_watcher),2,2,4
handle->connection->handle != INVALID_HANDLE_VALUE,2,2,4
((uv_udp_t*)handle)->fd == -1,2,2,4
!uv_ares_handles_empty(),2,2,4
"0 && ""Queued writes are not supported""",2,2,4
watcher == &ares_data.timer,2,2,4
!ev_is_active(watcher),2,2,4
"0 == uv_run(&loop, UV_RUN_DEFAULT)",4,0,4
req->pipeHandle != INVALID_HANDLE_VALUE,3,1,4
!uv_is_active(handle),2,2,4
"0 == uv_tcp_connect(&connect_req, &tcp_handle, addr, connect_cb)",2,2,4
handle->read_line_buffer.base != NULL,2,2,4
size == nbytes,2,2,4
main_loop == loop,2,2,4
1 == check_cb_called,4,0,4
last_slash,2,2,4
domain == AF_INET || domain == AF_INET6,2,2,4
"memcmp(""hello world\n"", buf.base, nread) == 0",2,2,4
loop,3,1,4
finished_consumers == MAX_CONSUMERS,2,2,4
tcp->write_watcher.fd == tcp->fd,2,2,4
UV_TTY == uv_guess_handle(0),2,2,4
!(h->flags & UV__HANDLE_CLOSING),2,2,4
tcp->write_queue_size >= len,2,2,4
uv_is_active((uv_handle_t*) &timer),2,2,4
"!uv_flag_is_set(handle, UV_CLOSING)",2,2,4
1 == r,2,2,4
"!uv__io_active(&handle->io_watcher, UV__IO_READ|UV__IO_WRITE)",2,2,4
WSAGetLastError() == WSAEWOULDBLOCK,4,0,4
handle->read_watcher.cb == uv__tcp_io,2,2,4
uv_last_error(uv_default_loop()).code == UV_ECONNREFUSED,2,2,4
"!memcmp(""PONG"", buf.base, nread)",2,2,4
req->result > 0,2,2,4
uv_last_error().code == UV_EINTR,2,2,4
!timed_out,4,0,4
"strcmp(dent.name, ""file1"") == 0 || strcmp(dent.name, ""file2"") == 0",4,0,4
ares_byaddrcallbacks == 1,2,2,4
*name == '\0',2,2,4
!ev_is_active(&handle->idle_watcher),2,2,4
uv_last_error().code == UV_EAGAIN,2,2,4
dent,4,0,4
uv_last_error(req->handle->loop).code == UV_ECANCELED,2,2,4
sinum >= 0,2,2,4
handle->write_queue_size >= len,2,2,4
uv_refs_ == 0,2,2,4
ngx_queue_empty(&stream->write_queue),2,2,4
"strcmp(buffer, ""new title"") == 0",2,2,4
0 == uv_is_closing((uv_handle_t*) &timer),4,0,4
!ngx_queue_empty(&handle->write_queue),2,2,4
UV_TTY == uv_guess_handle(ttyin_fd),3,1,4
uv_last_error().code == UV_ECONNREFUSED,2,2,4
fs_event_cb_called == 1,3,1,4
fd != INVALID_FD,4,0,4
idle_cb_called == 1,3,1,4
ev == loop->ev,2,2,4
server == NULL,2,2,4
ev_is_active(&(handle->_.read_watcher)),2,2,4
ip[2] == '0',2,2,4
"memeq(dst, ""A"", 2)",2,2,4
req.errorno == UV_ENOENT,2,2,4
"0 && ""should not have been called""",3,1,4
"close_cb_called == 1 && ""oio_close_cb must be called exactly once""",2,2,4
state == STATE_THREAD_CLOSE,2,2,4
stream->type == UV_TCP || stream->type == UV_NAMED_PIPE || stream->type == UV_TTY,3,1,4
open_cb_count == 0,4,0,4
!uv_ares_handles_empty(loop),2,2,4
status == UV_ENOENT,4,0,4
accept_req->socket != INVALID_SOCKET,2,2,4
"!memcmp(buf.base, EXPECTED, nread)",2,2,4
handle->type == OIO_CHECK,2,2,4
"setenv(""ENV_TEST"", ""testval"", 1) == 0",2,2,4
err.code == UV_EOF,2,2,4
"0 == uv_timer_init(loop, &ci.timer_handle)",4,0,4
!(events & ~(EV_READ|EV_WRITE)),2,2,4
handle->read_watcher.cb == oio__tcp_io,2,2,4
buf.base[i] == PING[pinger->state],2,2,4
!ev_is_active(&tcp->write_watcher),2,2,4
handle->type == UV_IDLE,2,2,4
tcp->next_watcher.data == tcp,2,2,4
req.statbuf.st_mtim.tv_nsec == 0,2,2,4
"0 == uv_tcp_connect(&connect_req, &tcp_handle, &addr, connect_cb)",2,2,4
0 < start_time,3,1,4
req.statbuf.st_atim.tv_sec == atime,2,2,4
handle->accepted_socket == INVALID_SOCKET,2,2,4
handle->accepted_fd < 0,2,2,4
uv_last_error(uv_default_loop()).code == UV_EAGAIN,2,2,4
req->errorno == UV_EPERM,2,2,4
!stream->blocking,2,2,4
handle == (uv_handle_t*)&server,2,2,4
ev_is_active(&handle->write_watcher),2,2,4
signum <= ctx->nqueues,2,2,4
ip[0] == '0',2,2,4
conns != NULL,2,2,4
"strcmp(""hello world\n"", output) == 0 || strcmp(""hello world\r\n"", output) == 0",2,2,4
ip[1] == '.',2,2,4
!uv__is_active(handle),2,2,4
buf->base > 0x100,2,2,4
ares__is_list_empty(&server->queries_to_server),2,2,4
!ev_is_active(&handle->async_watcher),2,2,4
"oio_flag_is_set(handle, OIO_CLOSING)",2,2,4
(unsigned) fd < loop->nwatchers,3,1,4
!ev_is_pending(watcher),2,2,4
sv_recv_cb_called == 1,3,1,4
"!uv_flag_is_set((uv_handle_t*)stream, UV_CLOSING)",2,2,4
fs_event_cb_called == 0,4,0,4
"!uv_flag_is_set(handle, UV_CLOSED)",2,2,4
send_cb_called == 1,4,0,4
uv_last_error(uv_default_loop()).code == UV_EFAULT,2,2,4
connect_req != NULL,3,1,4
r == 0 || uv_last_error(loop).code == UV_EEXIST,2,2,4
handle->flags & OIO_HANDLE_CLOSING,2,2,4
!ngx_queue_empty(&tcp->write_queue),2,2,4
read_req.result == 0,4,0,4
req->thread_id == uv_thread_self(),2,2,4
!ev_is_active(&((uv_stream_t*)handle)->read_watcher),2,2,4
fs_event_cb_called == 2 * fs_event_file_count,2,2,4
handle->flags & UV__HANDLE_CLOSING,4,0,4
-1 == uv_sem_trywait(&sem),2,2,4
handle->reqs_pending == 0,2,2,4
"0 == uv_fs_mkdir(loop, reqs + n++, ""/"", 0, fail_cb)",2,2,4
s->st_mtim.tv_nsec == 0,3,1,4
write_cb_count == 2,4,0,4
!ev_is_active(&((uv_stream_t*)handle)->write_watcher),2,2,4
signum > 0,2,2,4
rename_req.result != -1,2,2,4
"0 == uv_udp_send(&s->send_req, &s->udp_handle, bufs, ARRAY_SIZE(bufs), s->addr, send_cb)",2,2,4
!uv_is_closing((uv_handle_t*)&channel),2,2,4
uv_loop_close(loop) == 0,2,2,4
s->st_atim.tv_nsec == 0,3,1,4
watcher == &req->timer,2,2,4
loop == handle->loop,2,2,4
handle->type == UV_CHECK,2,2,4
uv_last_error(uv_default_loop()).code == UV_ENOENT,2,2,4
fs_event_created == fs_event_file_count,2,2,4
!uv_ares_handles_empty(handle->loop),2,2,4
handle->write_watcher.cb == uv__tcp_io,2,2,4
"0 == uv_udp_send(&s->send_req, &s->udp_handle, bufs, ARRAY_SIZE(bufs), &s->addr, send_cb)",2,2,4
p,2,2,4
handle == &ctx.channel,2,2,4
!(options.flags & ~(UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS | UV_PROCESS_DETACHED | UV_PROCESS_SETGID | UV_PROCESS_SETUID)),2,2,4
data->socket != INVALID_SOCKET,2,2,4
handle == &server,2,2,4
req->ptr,3,1,4
"0 == uv_tcp_init(loop, &server_handle)",4,0,4
"!oio_flag_is_set(handle, OIO_CLOSING)",2,2,4
!uv_is_closing((uv_handle_t*) req->handle),2,2,4
0 == uv_rwlock_tryrdlock(&rwlock),4,0,4
!ev_is_active(&((uv_udp_t*)handle)->read_watcher),2,2,4
watcher == &loop->uv_eio_done_poll_notifier,2,2,4
EV_TIMER & revents,2,2,4
client.send_queue_size == 0,4,0,4
handle->connection,2,2,4
!uv__io_active(&handle->read_watcher),2,2,4
sendreq->data_storage == NULL,2,2,4
"0 == uv_tcp_bind(&server_handle, (const struct sockaddr*) &addr)",2,2,4
!(options.flags & ~(UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS | UV_PROCESS_SETGID | UV_PROCESS_SETUID)),4,0,4
ev_is_active(&handle->read_watcher),2,2,4
ares__is_list_empty(&list_head),2,2,4
*iargs == byaddrcallbacksig,2,2,4
handle->type == OIO_IDLE,2,2,4
"nested == 0 && ""oio_close_cb must be called from a fresh stack""",2,2,4
req->cb,2,2,4
watcher == &(watcher->loop->uv_eio_poller),2,2,4
!uv__io_active(&handle->write_watcher),2,2,4
watcher == &uv_eio_want_poll_notifier,2,2,4
ttyin_fd >= 0,3,1,4
term_signal == 15,2,2,4
pipe->flags & UV_HANDLE_CONNECTION,4,0,4
"!uv__io_active(&handle->io_watcher, UV__POLLIN | UV__POLLOUT)",2,2,4
"0 == uv_pipe_init(uv_default_loop(), &pipe_handle, 0)",4,0,4
"0 == uv_timer_init(uv_default_loop(), &timer_handle)",4,0,4
!ev_is_active(&handle->check_watcher),2,2,4
req.statbuf.st_mtim.tv_sec == mtime,2,2,4
"strstr(msg, dlerror_desc) != NULL",2,2,4
handle->write_watcher.cb == oio__tcp_io,2,2,4
watcher == &loop->timer,2,2,4
n == sizeof(val),3,1,4
curr == NULL,2,2,4
write_cb_called == NUM_WRITE_REQS,3,1,4
!uv__io_active(&((uv_stream_t*)handle)->write_watcher),2,2,4
bufcnt > 0,2,2,4
"0 == uv_timer_start(&ci.timer_handle, timer_cb, 10, 0)",4,0,4
watcher == &loop->uv_eio_want_poll_notifier,2,2,4
"0 && ""should never be called""",3,1,4
client->type == server->type,2,2,4
!uv__io_active(&((uv_stream_t*)handle)->read_watcher),2,2,4
readdir_cb_count == 0,2,2,4
handle->type == UV_PREPARE,2,2,4
tcp->alloc_cb,2,2,4
UV_EBUSY == uv_rwlock_trywrlock(&rwlock),4,0,4
oio_last_error().code == OIO_EFAULT,2,2,4
!(options.flags & ~(UV_PROCESS_DETACHED | UV_PROCESS_SETGID | UV_PROCESS_SETUID | UV_PROCESS_WINDOWS_HIDE | UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS)),2,2,4
tcp_client.write_queue_size == 0,2,2,4
!ev_is_active(&handle->prepare_watcher),2,2,4
knp->data_type == KSTAT_DATA_UINT64,4,0,4
watcher == &uv_eio_done_poll_notifier,2,2,4
"strcmp(uv_strerror(e), ""Unknown error"") == 0",2,2,4
"strcmp(filename, ""watch_file"") == 0",2,1,3
"filename == NULL || strcmp(filename, ""file1"") == 0",2,1,3
idle_2_is_active,2,1,3
buf[len] == '\0',3,0,3
total_mem > free_mem,2,1,3
handle->type == UV_TTY,3,0,3
"strcmp(buffer, title) == 0",2,1,3
UV_NAMED_PIPE == uv_guess_handle(0),2,1,3
req->handle->write_queue_size == 0,2,1,3
"0 == uv_recv_buffer_size(handle, &value)",3,0,3
0 == timer_cb_called,3,0,3
0 == uv_is_active((uv_handle_t*) &timer),3,0,3
check_cb_called == 0,3,0,3
0 == (events & ~(POLLIN | POLLOUT | UV__POLLRDHUP)),3,0,3
send_bytes > 0,3,0,3
1 == uv_is_closing(handle),3,0,3
"strcmp(filename, ""file2"") == 0",2,1,3
connection_accepted == 1,2,1,3
called_connect_cb == 1,3,0,3
r == ARES_SUCCESS,2,1,3
UV_TTY == uv_guess_handle(ttyout_fd),2,1,3
req->fs_type == UV_FS_SCANDIR,3,0,3
uv__has_active_reqs(loop),2,1,3
sc.ncalls == NSIGNALS,3,0,3
handle == &repeat_2,2,1,3
process,2,1,3
didTimeout == FALSE,2,1,3
msg != NULL,3,0,3
last != '/',2,1,3
(handle)->activecnt >= 0,2,1,3
0 == uv_loop_init(loop),3,0,3
sockfd >= 0,2,1,3
((uv_shutdown_t*) req)->handle->type == UV_NAMED_PIPE,2,1,3
pwd.homedir[len - 1] != '\\',2,1,3
"0 == uv_tcp_bind(&server_handle, (const struct sockaddr*) &addr, 0)",3,0,3
stream != NULL,3,0,3
UV_NAMED_PIPE == uv_guess_handle(1),2,1,3
result == 0,3,0,3
scandir_cb_count == 1,3,0,3
0 == uv_loop_close(loop),3,0,3
pinger != NULL,3,0,3
op == UV__EPOLL_CTL_ADD,2,1,3
handle->recv_cb != NULL,2,1,3
write_cb_called > 0,2,1,3
nested == 0,2,1,3
c->posted == 0,2,1,3
i < CONCURRENT_COUNT,2,1,3
close_cb_calls == 0,3,0,3
"strcmp(filename, ""file1"") == 0",2,1,3
0 == uv_is_closing((uv_handle_t*) &channel),3,0,3
close_cb_called == 5,2,1,3
on_pipe_read_called == 0,2,1,3
mode == (PIPE_READMODE_BYTE | PIPE_WAIT),2,1,3
1 == uv_is_readable((uv_stream_t*) &channel),3,0,3
rename_cb_count == 1,3,0,3
server.send_queue_size == 0,3,0,3
"0 && ""unsupported address family""",2,1,3
uv_is_closing(handle),2,1,3
0 == uv_is_active((uv_handle_t*) &process),3,0,3
result,2,1,3
pwd.shell == NULL,3,0,3
NULL == uv_key_get(&tls_key),3,0,3
read_cb_called == 1,3,0,3
flags >= 0,2,1,3
req->result >= 0,3,0,3
0 == pipe(fd),3,0,3
r == UV_ENOENT,3,0,3
pinger_on_connect_count == 0,3,0,3
1 == (wc.main_barrier_wait_rval ^ wc.worker_barrier_wait_rval),3,0,3
on_pipe_read_called == 1,2,1,3
"events != 0 || FD_ISSET(s->int_fd, &sread)",1,2,3
"0 == uv_ip6_addr(""::1"", TEST_PORT, &addr)",3,0,3
status == UV_ECONNREFUSED,3,0,3
r == TRUE,2,1,3
q != &state->fsevent_handles,2,1,3
!(fdopt.data.stream->flags & UV_HANDLE_CONNECTION),2,1,3
handle->type == UV_POLL,3,0,3
client != NULL,2,1,3
uv_is_readable(&channel),1,2,3
!(fdopt.data.stream->flags & UV_HANDLE_PIPESERVER),2,1,3
"0 != memcmp(prev, &zero_statbuf, sizeof(zero_statbuf))",3,0,3
"0 == uv_async_init(uv_default_loop(), &ctx->main_async, main_async_cb)",2,1,3
r == 4,2,1,3
exit_cb_called == 0,3,0,3
pipe->flags & UV_HANDLE_READ_PENDING,2,1,3
read_count == 3,3,0,3
handle == &repeat_1,2,1,3
"(stream->type == UV_TCP || stream->type == UV_NAMED_PIPE || stream->type == UV_TTY) && ""uv_write (unix) does not yet support other types of streams""",2,1,3
last != '\\',2,1,3
((struct stat*)req.ptr)->st_size == strlen(test_dir),1,2,3
result == WAIT_OBJECT_0,2,1,3
"memcmp(req->path, ""test_dir\0"", 9) == 0",3,0,3
"memcmp(buf, TEST_PIPENAME, len) == 0",3,0,3
uv_is_writable(&channel),1,2,3
"0 == uv_tcp_connect(&connect_req, &client_handle, addr, connect_cb)",2,1,3
cl_recv_cb_called == 1,3,0,3
events == UV_RENAME,2,1,3
req->handle == (uv_stream_t*)&tcp_handle,2,1,3
"sscanf(buf, ""cpu%u "", &n) == 1",1,2,3
0 == uv_mutex_init(&mutex),2,1,3
curr->realpath != NULL,2,1,3
tc.ncalls == NSIGNALS,3,0,3
1 == uv_is_active((uv_handle_t*) handle),3,0,3
ARRAY_SIZE(sockets) == send_cb_called,2,1,3
"0 == uv_barrier_init(&wc.barrier, 2)",3,0,3
"!""unknown EAI_* error code""",2,1,3
r == target_len,2,1,3
(handle)->activecnt > 0,2,1,3
nread > 0 && buf->base && pending != UV_UNKNOWN_HANDLE,3,0,3
!(handle->flags & UV__HANDLE_CLOSING),3,0,3
"0 == uv_tcp_bind(&server_handle, addr)",2,1,3
1 == uv_is_writable((uv_stream_t*) &channel),3,0,3
pwd.homedir[len - 1] != '/',2,1,3
handle->flags & UV_HANDLE_TTY_READABLE,3,0,3
handle->alloc_cb != NULL,2,1,3
uv_last_error(uv_default_loop()).code == UV_ENOTSOCK || uv_last_error(uv_default_loop()).code == UV_ECONNREFUSED,2,1,3
ref != NULL,2,1,3
"0 == uv_timer_init(uv_default_loop(), &timer)",3,0,3
0 == uv_loop_close(&loop),3,0,3
0 != events,3,0,3
UV_UNKNOWN_HANDLE == uv_guess_handle(-1),2,1,3
"0 == uv_check_start(&check_handle, check_cb)",3,0,3
0 == uv_tty_reset_mode(),3,0,3
nread == 1,3,0,3
"0 == uv_tcp_connect(&connect_req, &tcp_handle, (const struct sockaddr*) &addr, connect_cb)",2,1,3
scandir_req.result == 2,3,0,3
fd > STDERR_FILENO,2,1,3
cl_recv_cb_called == 0,3,0,3
"0 == uv_timer_start(&timer_handle, timer_cb, 50, 0)",3,0,3
pipeHandle != INVALID_HANDLE_VALUE,2,1,3
0 == uv_is_active((uv_handle_t*) handle),3,0,3
nbufs > 0,3,0,3
pending == UV_NAMED_PIPE || pending == UV_TCP,2,1,3
name,1,2,3
status < 0,3,0,3
fdopt.data.stream->type == UV_NAMED_PIPE,2,1,3
exit_status == 127,2,1,3
iface_index == addr.sin6_scope_id,2,1,3
!uv_loop_alive(uv_default_loop()),3,0,3
r == UV_ENOENT || r == UV_EACCES,3,0,3
"UV_EINVAL == uv_tty_init(&loop, &tty, fd, 1)",3,0,3
read_cb_count == 2,2,1,3
fd != -1,3,0,3
pipe == &ctx.channel,2,1,3
!scandir_req.ptr,3,0,3
"0 == uv_tcp_connect(&connect_req, &client_handle, (const struct sockaddr*) &addr, connect_cb)",3,0,3
handle == (uv_handle_t*)&tcp_handle,2,1,3
ttyout_fd >= 0,2,1,3
getsocknamecount == 2,2,1,3
handle->reqs_pending > 0,2,1,3
scandir_req.ptr,3,0,3
connection_cb_called == 1,3,0,3
req == &scandir_req,3,0,3
"0 != memcmp(curr, &zero_statbuf, sizeof(zero_statbuf))",3,0,3
w->pevents == UV__POLLIN,1,1,2
"0 == uv_check_init(uv_default_loop(), &check_handle)",2,0,2
uv_last_error(handle->loop).code == UV_ECANCELED,1,1,2
s->st_atim.tv_sec == t.st_atime,2,0,2
700 <= uv_now() - start_time,1,1,2
"-1 == uv_fs_readlink(loop, &req, ""no_such_file"", NULL)",1,1,2
ngx_queue_empty(&loop->pending_queue),1,1,2
"0 == uv_tcp_connect(&ctx->connect_req, handle, &listen_addr, cl_connect_cb)",1,1,2
"close_cb_called && ""oio_close_cb must be called exactly once""",1,1,2
"0 == uv_async_init(loop, &ctx->async_handle, sv_async_cb)",1,1,2
"memeq(dst, ""B"", 2)",1,1,2
s->st_blksize == t.st_blksize,1,1,2
buf.base[0] == 'Q',1,1,2
"0 == memcmp(&buf, prev, sizeof(buf))",1,1,2
"0 == uv_tcp_connect(&ctx->connect_req, handle, listen_addr, cl_connect_cb)",1,1,2
0 == uv_thread_join(&pthread),1,1,2
pipeHandle,1,1,2
accept_cb_called == 2,1,1,2
w->pevents == UV__IO_READ,1,1,2
read_sockets < TARGET_CONNECTIONS,1,1,2
"0 == uv_tcp_init(tcp->loop, &incoming)",2,0,2
ev_is_active(&tcp->write_watcher),1,1,2
stream == (uv_stream_t*) &tcp_incoming[0],1,1,2
"!uv__io_active(&stream->io_watcher, UV__IO_READ)",1,1,2
"0 == uv_timer_init(uv_default_loop(), &tiny_timer)",2,0,2
"handle->type == UV_TCP && ""uv_shutdown (unix) only supports uv_tcp_t right now""",1,1,2
pipe->ipc_pid != -1,1,1,2
nread < 0,1,1,2
ftruncate_req.result != -1,1,1,2
err.code == UV_EAGAIN,1,1,2
"0 == uv_fs_write(loop, reqs + n++, 0, NULL, 0, 0, fail_cb)",1,1,2
scandir_cb_count == 0,2,0,2
0 == uv_thread_join(threads + 1),2,0,2
r == UV_ENOTSUP,2,0,2
"""ol_close error"" && e == 0",1,1,2
!handle->accept_reqs,1,1,2
s->st_ctim.tv_nsec == 0,2,0,2
dummy_cb_count == 1,2,0,2
"0 == uv_tcp_init(uv_default_loop(), &client)",2,0,2
uv_default_loop()->counters.timer_init == ++timer_init_prev,1,1,2
read_eof_cb_called > 0,1,1,2
handle->fd == -1,1,1,2
req->fs_type == UV_FS_CHOWN,2,0,2
"!uv__io_active(&stream->io_watcher, UV__POLLOUT) || !ngx_queue_empty(&stream->write_completed_queue) || !ngx_queue_empty(&stream->write_queue) || stream->shutdown_req != NULL || stream->connect_req != NULL",1,1,2
"uv_inet_pton(AF_INET6, ADDR ""%en1"", &addr).code != UV_OK",1,1,2
"0 == uv_fs_open(loop, reqs + n++, ""/"", 0, 0, fail_cb)",1,1,2
tcp->write_queue_size > 0,1,1,2
buffer != NULL,2,0,2
process->child_stdio_buffer == NULL,1,1,2
!ev_is_active(&handle->timer_watcher),1,1,2
r == sizeof msg || (r == -1 && errno != EAGAIN && errno != EWOULDBLOCK),1,1,2
1000 == p->pongs,1,1,2
sockname.sin_family == AF_INET,2,0,2
"0 == uv_tcp_bind(&tcp, (const struct sockaddr*) &client_addr)",1,1,2
ctx->parent_handle != NULL,2,0,2
handle == (uv_handle_t*)&prepare_handle,1,1,2
handle->type == OIO_ASYNC,1,1,2
b - a >= NANOSEC / MILLISEC,1,1,2
"0 == uv_tcp_bind((uv_tcp_t*) &ctx.server_handle, listen_addr)",1,1,2
pwd.homedir == NULL,2,0,2
"memcmp(""hello\n"", buf.base, buf.len) == 0",1,1,2
"0 == uv_fs_chmod(loop, reqs + n++, ""/"", 0, fail_cb)",1,1,2
"0 == uv_tcp_connect(&connect_req, &client_handle, &addr, connect_cb)",1,1,2
"0 == uv_process_kill(&process, 15)",2,0,2
"strcmp(buf.base, PING) == 0",1,1,2
"wcscmp(expected, env) == 0",1,1,2
"0 == uv_tcp_bind(&server, (struct sockaddr*) &addr, 0)",2,0,2
"uv_inet_pton(AF_INET6, ADDR, &addr).code == UV_OK",1,1,2
0 == uv_rwlock_trywrlock(&rwlock),2,0,2
s->st_mtimespec.tv_sec == mtime,1,1,2
pipe->eof_timer == NULL,1,1,2
parent.close_cb_called == 3,1,1,2
diff < (uint64_t) 120 * NANOSEC / MILLISEC,1,1,2
ev_is_active(&handle->_.read_watcher),1,1,2
address.sin_family == AF_INET,1,1,2
"0 == uv_fs_symlink(loop, reqs + n++, ""/"", ""/"", 0, fail_cb)",1,1,2
handle->flags & OIO_HANDLE_LISTENING,1,1,2
"""ol_close_cb not called exactly once"" && close_cb_called",1,1,2
close_cb_count == 1,2,0,2
removed_handle == handle,2,0,2
uv_default_loop()->counters.eio_init == ++eio_init_prev,1,1,2
ipc_frame.header.flags <= UV_IPC_UV_STREAM | UV_IPC_RAW_DATA,1,1,2
"0 == uv_timer_start(&timer1_handle, timer1_cb, 50, 0)",1,1,2
s->st_mtime == mtime,1,1,2
rusage.ru_maxrss >= 0,1,1,2
handle == &getaddrinfo_handle,1,1,2
"errorno != EAGAIN && ""write queueing not yet supported""",1,1,2
status == 0 || status == UV_ENETUNREACH,2,0,2
"task && ""When an ares socket is closed we should have a handle for it""",1,1,2
!(areq->req.flags & OIO_REQ_PENDING),1,1,2
diff > (uint64_t) 80 * NANOSEC / MILLISEC,1,1,2
oio_last_error().code == OIO_EACCESS,1,1,2
UV_NAMED_PIPE == uv_guess_handle(pipe_fds[0]),1,1,2
"memeq(dst, ""CD"", 3)",1,1,2
"0 == uv_run(ctx->loop, UV_RUN_DEFAULT)",1,1,2
hThread == handle->readfile_thread,1,1,2
err.code != UV_OK,1,1,2
req == &req1,2,0,2
(req) == &req_,2,0,2
req->handle == (uv_stream_t*)tcp,1,1,2
ticks <= 10,1,1,2
s->st_gen == t.st_gen,2,0,2
r == UV_EFAULT,2,0,2
"0 == uv_timer_start(&timer, timer_counter_cb, 10, 0)",2,0,2
s->st_flags == t.st_flags,2,0,2
afinet_dgram >= 0,1,1,2
r == UV_ENOBUFS,2,0,2
c->main_barrier_wait_rval == 0,1,1,2
((struct stat*)req.ptr)->st_mode & S_IFDIR,1,1,2
req->errorno == UV_ECANCELED,1,1,2
err.code == UV_ESRCH,1,1,2
s->st_atim.tv_sec == atime,1,1,2
s->st_gid == t.st_gid,1,1,2
"0 == uv_fs_chown(loop, reqs + n++, ""/"", 0, 0, fail_cb)",1,1,2
pipe->flags && UV_HANDLE_CONNECTION,1,1,2
uv_timer_get_repeat(handle) == 50,1,1,2
no_epoll_wait == 0 || no_epoll_pwait == 0,2,0,2
req.host != NULL,1,1,2
"0 == uv_udp_bind(&s->udp_handle, addr, 0)",1,1,2
access_cb_count == 1,2,0,2
"wcscmp(expected, result) == 0",1,1,2
0 == uv_is_closing((uv_handle_t*) req->handle),2,0,2
req->write_buffer,1,1,2
0 == uv_timer_stop(&timer_handle),2,0,2
fs_event_cb_called == fs_event_created + fs_event_removed,2,0,2
0 < recv_cb_called && recv_cb_called <= ARRAY_SIZE(sockets),1,1,2
(uv_loop_t*)watcher->data == loop,1,1,2
r == -1 || r == 1,1,1,2
!(data->req.flags & OIO_REQ_PENDING),1,1,2
"0 == uv_udp_send(&s->send_req, &s->udp_handle, bufs, ARRAY_SIZE(bufs), (const struct sockaddr*) &s->addr, send_cb)",2,0,2
"memcmp(""hello again\n"", buf.base, nread) == 0",1,1,2
uv_last_error(req->loop).code == UV_ECANCELED,1,1,2
!!(events & UV__IO_READ) ^ !!(events & UV__IO_WRITE),1,1,2
exit_status == err,1,1,2
0 == uv_async_send(&ctx->main_async),2,0,2
"wcscmp(verbatim_output, L""cmd.exe /c c:\\path\\to\\node.exe --eval \""require('c:\\\\path\\\\to\\\\test.js')\"""") == 0",1,1,2
((volatile CFRunLoopRef) loop->cf_loop) != NULL,1,1,2
revents & UV__IO_READ,1,1,2
uv_cnt_tcp_init == tcpcnt + 1,1,1,2
!uv_is_active((uv_handle_t*) timer),1,1,2
req->write_index < req->read_bufcnt,1,1,2
timeout_req != NULL,1,1,2
uv_default_loop()->counters.tcp_init == 1,1,1,2
loop->refs == 0,1,1,2
default_loop_ptr->ev == EV_DEFAULT_UC,1,1,2
handle->write_queue_size >= req->u.io.queued_bytes,2,0,2
"0 == uv_getaddrinfo(loop, reqs + 1, fail_cb, NULL, ""fail"", NULL)",1,1,2
handle == (uv_handle_t*)&timer_handle,1,1,2
data[i] == MARKER,2,0,2
uv_last_error(uv_default_loop()).code == UV_EACCESS,1,1,2
uv_last_error(loop).code == UV_ENOTCONN,1,1,2
"0 && ""should never get here""",2,0,2
700 <= uv_now(uv_default_loop()) - start_time,1,1,2
"filename == NULL || strcmp(filename, ""file1"") == 0 || strstr(filename, ""watch_dir"") != NULL",1,1,2
open_req2.result != -1,1,1,2
handle->read_buffer.base != NULL,1,1,2
uv_default_loop()->counters.check_init == ++check_init_prev,1,1,2
"0 == uv_timer_start(&handle_a, order_cb_a, 0, 0)",2,0,2
"0 == uv_thread_create(&pthread, producer, NULL)",1,1,2
num_recv_handles == 1,1,1,2
"0 == uv_fs_fsync(loop, reqs + n++, 0, fail_cb)",1,1,2
!(handle->flags & UV_HANDLE_CONNECTION),1,1,2
chown_cb_count == 1,2,0,2
sizeof(oio_buf) == sizeof(struct iovec),1,1,2
req->statbuf.st_atim.tv_nsec == 0,1,1,2
external != NULL,1,1,2
uv_default_loop()->counters.handle_init == 1,1,1,2
uv_default_loop()->counters.process_init == ++process_init_prev,1,1,2
uv_default_loop()->counters.idle_init == ++idle_init_prev,1,1,2
"memeq(dst, ""ABCD"", 5)",1,1,2
"0 == uv_ip4_addr(""239.255.0.1"", TEST_PORT, &addr)",2,0,2
handle == (uv_handle_t*) &repeat_2,1,1,2
!(handle->flags & OIO_HANDLE_CLOSING),1,1,2
ev_events & (EV_READ | EV_WRITE),1,1,2
1 == uv_is_active((uv_handle_t*) &process),1,1,2
UV_EBUSY == uv_rwlock_tryrdlock(&rwlock),2,0,2
revents & EV_WRITE,1,1,2
write_cb_called == WRITES,2,0,2
bytes >= 0,1,1,2
!(handle->flags & UV_HANDLE_TTY_READABLE) || handle->tty.rd.read_line_handle == NULL,1,1,2
uv_is_readable((uv_stream_t*)&ctx.channel),1,1,2
handle->remaining_ipc_rawdata_bytes >= bytes,1,1,2
req->type == UV_WORK,1,1,2
"0 == uv_fs_futime(loop, reqs + n++, 0, 0, 0, fail_cb)",1,1,2
"""ol_close_cb not called from a fresh stack"" && nested == 0",1,1,2
state == STATE_MAIN_CLOSE,1,1,2
output_used == 1,2,0,2
uv_last_error(loop).code == UV_ENOTDIR,1,1,2
"memcmp(buf, test_buf, sizeof(test_buf)) == 0",1,1,2
handle->send_queue_size >= req->queued_bytes,1,1,2
uv_timer_get_repeat(handle) == 100,1,1,2
"0 && ""connection_cb should not be called.""",2,0,2
"0 == uv_async_init(ctx->loop, &ctx->worker_async, worker_async_cb)",1,1,2
order_cb_called++ == *(int*)handle->data,2,0,2
"0 == uv_queue_work(loop, reqs + i, fail_cb, NULL)",1,1,2
req->after_work_cb,1,1,2
s->st_blocks == t.st_blocks,1,1,2
r != ERROR_SUCCESS,2,0,2
"0 == uv_ip4_addr(""0.0.0.0"", port, &addr)",2,0,2
UV_NAMED_PIPE == uv_guess_handle(pipe_fds[1]),1,1,2
stream->accepted_fd == -1,2,0,2
err.code == UV_EPIPE,1,1,2
"0 && ""unexpected address family""",2,0,2
oio_refs_ == 0,1,1,2
"0 == uv_timer_start(&timer, fs_event_unlink_files_in_subdir, 1, 0)",2,0,2
"!oio_flag_is_set(handle, OIO_CLOSED)",1,1,2
t == &tcp,1,1,2
once != NULL,1,1,2
0 != uv_is_closing((uv_handle_t*) &process),1,1,2
cl_recv_cb_called == 2,1,1,2
timer_cb_called > 0,1,1,2
"0 == uv_read_start((uv_stream_t *) &pipe_handle, alloc_cb, read_cb)",2,0,2
status == 0 || (status == -1 && err == UV_ECANCELED),1,1,2
avail - sizeof(ipc_frame.header) >= sizeof(ipc_frame.socket_info),1,1,2
0 == uv_thread_join(&tid),1,1,2
"0 == uv_pipe_init(loop, &ctx.ipc_pipe, 1)",2,0,2
(req->result == -1 && req->ptr == NULL) || (req->result >= 0 && req->ptr != NULL),1,1,2
"0 == uv_fs_utime(loop, reqs + n++, ""/"", 0, 0, fail_cb)",1,1,2
"uv_inet_pton(AF_INET6, ADDR ""%en1:1.2.3.4"", &addr).code == UV_OK",1,1,2
arg == (void *) 42,2,0,2
uv_counters()->tcp_init == tcpcnt,1,1,2
0 == setuid(pw->pw_uid),2,0,2
0 == uv_thread_join(threads + 0),2,0,2
&tcp == (uv_tcp_t*) req->handle,1,1,2
handle->read_raw_wait == NULL,1,1,2
req->errorno == 0,1,1,2
"0 == uv_tcp_connect(&ctx->connect_req, (uv_tcp_t*) &ctx->client_handle, listen_addr, cl_connect_cb)",1,1,2
!(data->req.flags & OL_REQ_PENDING),1,1,2
"0 == uv_tcp_bind((uv_tcp_t*) &ctx.server_handle, (const struct sockaddr*) &listen_addr)",1,1,2
afinet6_dgram >= 0,1,1,2
timeout_cb_called > 0,1,1,2
"0 == uv_ip4_addr(""127.0.0.1"", server_port, &server_addr)",2,0,2
utime_req.result == 0,1,1,2
uv_default_loop()->counters.async_init == ++async_init_prev,1,1,2
!ngx_queue_empty(&handle->read_reqs) || (nread < 0 && errorno == EAGAIN),1,1,2
events == (events & (UV__POLLIN | UV__POLLOUT)),1,1,2
"memcmp(req->ptr, ""file1\0file2\0"", 12) == 0 || memcmp(req->ptr, ""file2\0file1\0"", 12) == 0",1,1,2
"0 == uv_fs_readdir(loop, reqs + n++, ""/"", 0, fail_cb)",1,1,2
uv_counters()->handle_init == 1,1,1,2
"0 == uv_fs_fdatasync(loop, reqs + n++, 0, fail_cb)",1,1,2
timer_counter == 1,2,0,2
"0 == uv_ip4_addr(""0.0.0.0"", 0, &addr)",2,0,2
uv_last_error(uv_default_loop()).code == UV_ENOTSOCK,1,1,2
chmod_cb_count == 1,2,0,2
thread2_id != 0,1,1,2
c->rdstate == c_busy,2,0,2
(uv_loop_t*)loop->timer.data == loop,1,1,2
"0 && ""Unreachable""",1,1,2
write_cb_error_called == 1,1,1,2
"memcmp(buf, ""test-buffer\n\0test-buffer\n\0"", sizeof(buf)) == 0",1,1,2
events == UV_CHANGE,2,0,2
!req->ptr,2,0,2
uv_last_error(uv_default_loop()).code == UV_EMSGSIZE,1,1,2
1 == uv_is_readable((uv_stream_t*)&ctx.channel),1,1,2
"0 == uv_fs_readdir(loop, reqs + n++, ""/"", 0, fs_cb)",1,1,2
status == UV_EPIPE,1,1,2
"0 == uv_timer_init(uv_default_loop(), &huge_timer1)",2,0,2
"timeout_cb_called == 1 && ""timeout_cb must be called exactly once""",1,1,2
(uintptr_t) &((uv_buf_t*) 0)->base == (uintptr_t) &((struct iovec*) 0)->iov_base,1,1,2
"(bytes <= 0) && ""uv__ahafs_event - Error reading monitor file""",1,1,2
s->st_mtim.tv_sec == mtime,1,1,2
stream->read_cb == NULL,1,1,2
"0 == uv_fs_unlink(loop, reqs + n++, ""/"", fail_cb)",1,1,2
handle->handle && handle->handle != INVALID_HANDLE_VALUE,2,0,2
pGetQueuedCompletionStatusEx,1,1,2
UV_TCP == uv_guess_handle(afinet_stream),1,1,2
"0 == uv_timer_start(&timer_handle, timer_cb, 10, 0)",2,0,2
"0 == uv_timer_start(&timer, fs_event_unlink_files, 1, 0)",2,0,2
"0 == uv_fs_ftruncate(loop, reqs + n++, 0, 0, fail_cb)",1,1,2
"0 == uv_udp_bind(&s->udp_handle, &addr, 0)",1,1,2
"0 == uv_write(&write_req, (uv_stream_t*) &in, &buf, 1, write_cb)",2,0,2
uv_last_error(loop).code == UV_ECANCELED,1,1,2
LOOP->refs == 0,1,1,2
w->events == UV__POLLIN,1,1,2
uv_last_error(loop).code == UV_ENAMETOOLONG,1,1,2
knp->data_type == KSTAT_DATA_INT32,1,1,2
"0 == uv_fs_event_init(loop, watchers + 1, path, fail_cb, 0)",1,1,2
fs_event_removed < fs_event_file_count,2,0,2
uv_counters()->tcp_init == 1,1,1,2
s->st_uid == t.st_uid,1,1,2
!uv_is_active((uv_handle_t*)&handle),1,1,2
handle == (uv_handle_t*)&server || handle == (uv_handle_t*)&server6,1,1,2
async1_cb_called = 20,1,1,2
uv_default_loop()->counters.fs_event_init == ++fs_event_init_prev,1,1,2
"0 == uv_getaddrinfo(loop, reqs + 0, fail_cb, ""fail"", NULL, NULL)",1,1,2
"0 == uv_poll_start(&poll_handle, UV_READABLE, (uv_poll_cb) abort)",2,0,2
"0 > uv_getaddrinfo(uv_default_loop(), &req, NULL, ""xyzzy.xyzzy.xyzzy"", NULL, NULL)",1,1,2
idle_2_cb_called == idle_2_cb_started,1,1,2
"0 == uv_pipe_init(loop, (uv_pipe_t*) &ctx.server_handle, 0)",1,1,2
called_tcp_close_cb == 0,2,0,2
1 == connect_cb_called,2,0,2
req->statbuf.st_mtim.tv_sec == checkme->mtime,1,1,2
tv.tv_sec == timebase.tv_sec || (tv.tv_sec == timebase.tv_sec && tv.tv_usec >= timebase.tv_usec),1,1,2
0 == uv_thread_join(&cthreads[i]),1,1,2
seen_timer_handle == 0,2,0,2
iovs != NULL,2,0,2
rename_req.result == 0,2,0,2
"0 == memcmp(curr, &zero_statbuf, sizeof(zero_statbuf))",2,0,2
shutdown_req != NULL,1,1,2
UV_NAMED_PIPE == uv_guess_handle(afunix_stream),1,1,2
pipe_client_connect_cb_called == 1,2,0,2
&server == s,1,1,2
uv_last_error(handle->loop).code == UV_EOF,1,1,2
avg != NULL,1,1,2
req->handle == (uv_stream_t*) &client_handle,2,0,2
"0 == uv_fs_lstat(loop, reqs + n++, ""/"", fail_cb)",1,1,2
opened - closed < max_delta,1,1,2
child_fd >= 0,1,1,2
((struct stat*)req.ptr)->st_size == strlen(test_dir + 4),1,1,2
exit_status == -1,1,1,2
"strcmp(""testval"", output) == 0",2,0,2
req == handle->fs_req,1,1,2
idle_cb_called == 0,2,0,2
uv_default_loop()->counters.handle_init == ++handle_init_prev,1,1,2
"UV_ENOENT == uv_fs_readlink(loop, &req, ""no_such_file"", NULL)",1,1,2
revents == EV_LIBUV_KQUEUE_HACK,1,1,2
s->st_ino == t.st_ino,1,1,2
idle_2_cb_started >= ITERATIONS,1,1,2
diff < (uint64_t) 60 * NANOSEC / MILLISEC,1,1,2
"0 == uv_fs_readlink(loop, reqs + n++, ""/"", fail_cb)",1,1,2
uv_default_loop()->counters.prepare_init == ++prepare_init_prev,1,1,2
((struct stat*)req.ptr)->st_size == 22,1,1,2
0 == uv_cond_init(&full),1,1,2
revents & UV__POLLIN,1,1,2
status == 0 || (status == -1 && uv_last_error(uv_default_loop()).code == UV_EINTR),1,1,2
options->file != NULL,2,0,2
"0 == uv_timer_init(loop, &timer)",2,0,2
"0 && ""poll_fail_cb should never be called""",1,1,2
r == 27,2,0,2
diff >= NANOSEC / MICROSEC,1,1,2
"0 == uv_fs_poll_init(loop, &poll_handle)",2,0,2
err == 0 || err == EINVAL || err == ESRCH,1,1,2
child.connection_accepted == 1,1,1,2
!QUEUE_EMPTY(&handle->write_queue) || !QUEUE_EMPTY(&handle->write_completed_queue),1,1,2
pipe_close_cb_called == 1,2,0,2
events != 0,2,0,2
uv_default_loop()->counters.req_init == ++req_init_prev,1,1,2
"!uv__io_active(&stream->io_watcher, UV__POLLIN)",1,1,2
"0 == uv_timer_start(&timer_handle, timer_cb, 1, 0)",2,0,2
0 == (events & UV__POLLERR),1,1,2
"0 == uv_listen((uv_stream_t*) &server_handle, 8, connection_cb)",2,0,2
errno == EMFILE,2,0,2
uv__is_active(handle),1,1,2
"!uv__io_active(&stream->io_watcher, UV__IO_READ | UV__IO_WRITE)",1,1,2
"0 == uv_udp_init(loop, &s->udp_handle)",2,0,2
"uv_inet_pton(AF_INET6, ADDR ""%en1:1.2.3.4"", &addr).code != UV_OK",1,1,2
"(pfd.revents & (POLLIN|POLLHUP)) && ""unexpected poll() revents""",1,1,2
!uv_write_queue_head(handle),1,1,2
req->ptr == NULL,2,0,2
"memeq(dst, ""A"", 1)",1,1,2
"0 == uv_fs_close(loop, reqs + n++, 0, fail_cb)",1,1,2
!uv_is_closing((uv_handle_t*)&ctx.channel),1,1,2
uv_last_error(loop).code == UV_ELOOP,1,1,2
"match && !strcmp(match, executable_path)",1,1,2
handle->type == OIO_TCP,1,1,2
"0 == uv_inet_ntop(AF_INET6, &address->sin6_addr, string_address, INET6_ADDRSTRLEN)",1,1,2
"0 == uv_pipe_bind((uv_pipe_t*) &ctx.server_handle, IPC_PIPE_NAME)",1,1,2
!handle->pending_socket_info,1,1,2
prefix_len + vt100_len < sizeof handle->last_key,1,1,2
"!uv__io_active(&handle->io_watcher, POLLIN | POLLOUT)",2,0,2
(uv_pipe_t*)stream == &b,1,1,2
"0 == uv_getaddrinfo(uv_default_loop(), &req, getaddrinfo_fail_cb, ""xyzzy.xyzzy.xyzzy"", NULL, NULL)",1,1,2
"0 == uv_getaddrinfo(loop, reqs + 3, fail_cb, ""fail"", NULL, &hints)",1,1,2
"strcmp(buf, ""test-bu"") == 0",2,0,2
pid > 0,1,1,2
"0 == memcmp(prev, &zero_statbuf, sizeof(zero_statbuf))",2,0,2
uv_last_error(loop).code == UV_EINTR,1,1,2
address.sin6_family == AF_INET6,1,1,2
r == UV_EPERM,2,0,2
"strcmp(""hello world\nhello errworld\n"", output) == 0",2,0,2
req->type == OIO_WAKEUP,1,1,2
500 <= uv_now() - start_time,1,1,2
incoming->wrstate == c_done,2,0,2
((struct stat*)req.ptr)->st_mode & S_IFLNK,1,1,2
"0 == uv_tcp_connect(&connect_req, &client, (struct sockaddr*) &addr, connect_cb)",2,0,2
signal1_cb_counter == 4 * NUM_SIGNAL_HANDLING_THREADS,1,1,2
idle_cb_called <= 1,1,1,2
"UV_ENOENT == uv_spawn(uv_default_loop(), &process, &options)",1,1,2
channel.ipc,1,1,2
"memcmp(""hello\n"", buf->base, nread) == 0",2,0,2
prepare_cb_called == 4,1,1,2
(size_t)write_req.result == sizeof(test_buf) * iovcount,2,0,2
afinet6_stream >= 0,1,1,2
"0 == uv_listen((uv_stream_t*) &server_handle, 1, connection_cb)",2,0,2
"0 == uv_ip4_addr(""0.0.0.0"", 0, &client_addr)",2,0,2
(uintptr_t) &((uv_buf_t*) 0)->len == (uintptr_t) &((struct iovec*) 0)->iov_len,1,1,2
"0 == uv_fs_stat(loop, reqs + n++, ""/"", fail_cb)",1,1,2
req->work_cb,1,1,2
"uv_inet_pton(AF_INET6, ADDR ""%en1"", &addr).code == UV_OK",1,1,2
"0 == uv_fs_read(loop, reqs + n++, 0, NULL, 0, 0, fail_cb)",1,1,2
events == UV_CHANGE || UV_RENAME,2,0,2
"0 == uv_ip6_addr(""::"", TEST_PORT, &addr)",2,0,2
req->type == OIO_UNKNOWN_REQ,1,1,2
!UV_LOOP_ALIVE((loop)),1,1,2
oio_last_error().code == OIO_EAGAIN,1,1,2
recv_cb_called == 2,2,0,2
handle->tty.rd.read_line_buffer.base != NULL,2,0,2
"0 == uv_fs_close(uv_default_loop(), &fs_req, fd, NULL)",1,1,2
"0 == uv_fs_rename(loop, reqs + n++, ""/"", ""/"", fail_cb)",1,1,2
"0 == uv_read_start((uv_stream_t*) &pipe_handle, on_alloc, on_read_once)",2,0,2
req->errorno == UV_ENOENT,1,1,2
"QUEUE_EMPTY(&loop->wq) && ""thread pool work queue not empty!""",2,0,2
"0 == uv_tcp_init(loop, &peer_handle)",2,0,2
spurious_writable_wakeups == 0 || (valid_writable_wakeups + spurious_writable_wakeups) / spurious_writable_wakeups > 100,1,1,2
uv_is_closing((uv_handle_t*) &timer),1,1,2
async2_cb_called = 16,1,1,2
req == &open_req1,2,0,2
receive_buffer != NULL,1,1,2
uv_loop_alive(uv_default_loop()),2,0,2
uv_is_writable(req->handle),1,1,2
"strcmp(buf + sizeof(test_buf), test_buf2) == 0",1,1,2
"(stream->type == UV_TCP || stream->type == UV_NAMED_PIPE) && ""uv_write (unix) does not yet support other types of streams""",1,1,2
handle->_.fd < 0,1,1,2
"!""no""",1,1,2
server->acceptConnection,1,1,2
1 == read_cb_called,2,0,2
req == &work_req,2,0,2
parent.connection_accepted == 1,1,1,2
"0 == uv_thread_create(&tid, pummel, &handle)",1,1,2
uv_cnt_tcp_init == tcpcnt,1,1,2
read_cb_count == 1,1,1,2
0 == uv_run(ctx->loop),1,1,2
handle->recv_buffer.len > 0,1,1,2
pwd.username == NULL,2,0,2
res == NULL,2,0,2
s->st_mtimespec.tv_nsec == 0,1,1,2
timer_handle != NULL,2,0,2
r == 65543,1,1,2
nqueues > 0,1,1,2
"strcmp(output, ""TEST"") == 0",2,0,2
dup_stream.type == UV_TCP,1,1,2
handle->accept_reqs,1,1,2
diff > MICROSEC,1,1,2
write_req != NULL,1,1,2
uv_last_error(req->loop).code == UV_ENOTDIR,1,1,2
uv_last_error().code == UV_EMSGSIZE,1,1,2
ctx != NULL,2,0,2
UV_ECANCELED == status,1,1,2
pipe_close_cb_called == 2,2,0,2
!got_eof,2,0,2
uv_timer_get_repeat(&repeat_2) == 100,2,0,2
test != NULL,2,0,2
r == UV_EADDRNOTAVAIL,2,0,2
r == 0 || uv_last_error(loop).code == UV_ENOENT,1,1,2
uv__has_active_handles(h->loop),1,1,2
"0 == uv_timer_init(uv_default_loop(), &handle)",2,0,2
"0 == uv_tcp_bind((uv_tcp_t*) &ctx.server_handle, &listen_addr)",1,1,2
s->st_mode == t.st_mode,1,1,2
handle->io_watcher.fd >= 0,1,1,2
value < MAX_LOOPS * MAX_CONSUMERS,1,1,2
s->st_rdev == t.st_rdev,1,1,2
prepare_2_cb_called == floor(ITERATIONS / 2),1,1,2
0 == prepare_cb_called,2,0,2
"strstr(uv_strerror(e), ""Success"") == NULL",1,1,2
revents & UV__POLLOUT,1,1,2
start_time < now,1,1,2
"!memcmp(""PING"", buf->base, nread)",2,0,2
"memcmp(""world\n"", buf.base, nread) == 0",1,1,2
0 == uv_sem_trywait(&sem),2,0,2
msg && 0,1,1,2
connect_cb_calls == 1,2,0,2
ev_is_pending(&handle->write_watcher),1,1,2
!oio_write_queue_head(handle),1,1,2
UV_UNKNOWN_HANDLE == uv_guess_handle(devnull_fd),1,1,2
"(handle->type == UV_TCP || handle->type == UV_NAMED_PIPE) && ""uv_shutdown (unix) only supports uv_tcp_t right now""",1,1,2
unlink_req.result != -1,1,1,2
0 == uv_cond_init(&empty),1,1,2
unlink_cb_count == 1,2,0,2
prepare_called == 3,1,1,2
n_senders <= MAX_SENDERS,1,1,2
called_timer_cb == 1,2,0,2
req->data == &data,2,0,2
s->st_atime == atime,1,1,2
"0 == uv_getaddrinfo(loop, reqs + 2, fail_cb, ""fail"", ""fail"", NULL)",1,1,2
"0 == uv_fs_write(loop, reqs + n++, 0, NULL, 0, 0, fs_cb)",1,1,2
"0 == uv_tcp_init(uv_default_loop(), &peer_handle)",1,1,2
"0 == uv_timer_start(&handle_b, order_cb_b, 0, 0)",2,0,2
order_cb_called == 2,2,0,2
uv_last_error(stream->loop).code == UV_ECONNRESET || uv_last_error(stream->loop).code == UV_EOF,1,1,2
!(handle->flags & UV_HANDLE_TTY_READABLE) || handle->read_raw_wait == NULL,1,1,2
"UV_EOF == uv_fs_readdir_next(&req, &dent)",1,1,2
revents & UV__IO_WRITE,1,1,2
"0 == uv_tcp_bind(&server_handle, &addr)",1,1,2
UV_ECANCELED == uv_last_error(req->loop).code,1,1,2
ol_refs_ == 0,1,1,2
UV_EAGAIN == uv_sem_trywait(&sem),2,0,2
1 == uv_is_writable((uv_stream_t*)&ctx.channel),1,1,2
0 != uv_is_active((uv_handle_t*)&process),1,1,2
"0 == uv_sem_init(&wc.sem, 0)",2,0,2
first_fd > 0,2,0,2
"memcmp(""hello world\n"", output, 12) == 0",2,0,2
timeouts == expected,1,1,2
p->buf.base[i] == PING[p->state],1,1,2
"handle->type == UV_TCP && ""uv_write (unix) does not yet support other types of streams""",1,1,2
r == UV_ETIMEDOUT,1,1,2
uv_last_error().code == UV_EACCESS,1,1,2
"0 == uv_fs_event_init(loop, watchers + 0, path, fail_cb, 0)",1,1,2
uv_is_active(handle),1,1,2
"ngx_queue_empty(&loop->wq) && ""thread pool work queue not empty!""",1,1,2
child.loop,1,1,2
"0 == uv_poll_init(uv_default_loop(), &poll_handle, fd)",2,0,2
s->st_size == t.st_size,1,1,2
send_cb_called == 0,2,0,2
n == 500,1,1,2
"0 == uv_tcp_connect(&ctx->connect_req, (uv_tcp_t*) &ctx->client_handle, &listen_addr, cl_connect_cb)",1,1,2
uv_cnt_handle_init == 1,1,1,2
uv_timer_get_repeat(handle) == 0,1,1,2
req == &open_req,1,1,2
handle == &async2_handle,1,1,2
done_cb_called == num_threads,1,1,2
"0 == uv_listen((uv_stream_t*) &server, 128, connection_cb)",2,0,2
conn != NULL,2,0,2
"handle->loop == uv_default_loop() && ""uv_signal_t is currently only supported by the default loop""",1,1,2
async1_cb_called > 2,1,1,2
"0 == uv_timer_start(&timer, fs_event_create_files_in_subdir, 50, 0)",1,1,2
"memcmp(&addr.sin_addr, &sockname.sin_addr, sizeof(addr.sin_addr)) == 0",2,0,2
loop->active_reqs > 0,1,1,2
"strstr(msg, dlerror_no_error) == NULL",2,0,2
"0 == uv_timer_start(&timer, fs_event_unlink_files, 50, 0)",1,1,2
req->data,1,1,2
"0 && ""pipe_server_connection_cb should never be called""",1,1,2
connect_cb_called == 0,2,0,2
write_cb_error_called >= 1,1,1,2
!ngx_queue_empty(&handle->read_reqs),1,1,2
thread3_id != 0,1,1,2
"""oio_close_cb not called from a fresh stack"" && nested == 0",1,1,2
"0 == uv_timer_start(&timer, fs_event_unlink_files_in_subdir, 50, 0)",1,1,2
req->errorno == UV_ELOOP,1,1,2
"strcmp((const char*)req->ptr, ""file1"") == 0",1,1,2
uv_is_writable((uv_stream_t*)&ctx.channel),1,1,2
dir_fd >= 0,1,1,2
got_q,2,0,2
s->st_nlink == t.st_nlink,1,1,2
"0 == uv_fs_fchown(loop, reqs + n++, 0, 0, 0, fail_cb)",1,1,2
timeout >= 0,1,1,2
req->fs_type == UV_FS_STAT,1,1,2
"""Yes, it always fails"" && 0",1,1,2
"0 == uv_ip4_addr(""0.0.0.0"", server_port, &addr)",2,0,2
ev_is_active(&(handle->read_watcher)),1,1,2
abspath_size > 0,2,0,2
"""oio_close error"" && e == 0",1,1,2
"0 == openpty(&master_fd, &slave_fd, NULL, NULL, &w)",1,1,2
uv_default_loop()->counters.pipe_init == ++pipe_init_prev,1,1,2
ftruncate_cb_count == 1,2,0,2
"0 == uv_fs_sendfile(loop, reqs + n++, 0, 0, 0, 0, fail_cb)",1,1,2
stream->type == UV_TCP,1,1,2
sockname.sin6_family == AF_INET6,2,0,2
"nested == 0 && ""timeout_cb must be called from a fresh stack""",1,1,2
!ngx_queue_empty(&queue),1,1,2
read_bytes == 4,1,1,2
req == &timeout_req,1,1,2
ipc_header_req != NULL,1,1,2
&server == (uv_tcp_t*)s,1,1,2
state == STATE_MAIN_START,1,1,2
events == UV_RENAME || events == UV_CHANGE,1,1,2
pipefds[1] >= 0,1,1,2
s->st_dev == t.st_dev,1,1,2
"0 == uv_tcp_init(uv_default_loop(), &server)",2,0,2
!(handle->flags & UV_HANDLE_TTY_READABLE) || handle->read_line_handle == NULL,1,1,2
oio_last_error().code == OIO_ECONNREFUSED,1,1,2
"0 == uv_thread_create(&cthreads[i], consumer, NULL)",1,1,2
"0 == uv_accept(tcp, (uv_stream_t*) &incoming)",2,0,2
!(options->flags & ~(UV_PROCESS_DETACHED | UV_PROCESS_SETGID | UV_PROCESS_SETUID | UV_PROCESS_WINDOWS_HIDE | UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS)),2,0,2
(ev_events & ~(EV_READ | EV_WRITE)) == 0,1,1,2
(pevents & ~(UV_READABLE | UV_WRITABLE)) == 0,1,1,2
"0 == uv_accept((uv_stream_t*) &ctx->ipc_pipe, ctx->server_handle)",1,1,2
uv_is_readable(req->handle),1,1,2
rusage.ru_majflt >= 0,1,1,2
regfile_fd >= 0,1,1,2
req->handle->write_queue_size > 0,1,1,2
0 == uv_pipe_pending_count(pipe),2,0,2
"!uv__io_active(&stream->io_watcher, UV__POLLIN) && ""stream->read_cb(status=-1) did not call uv_close()""",1,1,2
"0 == uv_fs_fchmod(loop, reqs + n++, 0, 0, fail_cb)",1,1,2
s->st_atimespec.tv_sec == atime,1,1,2
NUM_PINGS == p->pongs,1,1,2
r == UV_ENOTCONN,2,0,2
req->result == 65548,1,1,2
oio_last_error().code == OIO_EADDRINUSE,1,1,2
err == pid,2,0,2
"0 == uv_fs_read(loop, reqs + n++, 0, NULL, 0, 0, fs_cb)",1,1,2
uv_default_loop()->counters.tcp_init == ++tcp_init_prev,1,1,2
req->handle == (uv_stream_t*)&tcp_client,2,0,2
uv_default_loop()->counters.udp_init == ++udp_init_prev,1,1,2
req_,1,1,2
!handle->pending_ipc_info.socket_info,1,1,2
handle == &tiny_timer,2,0,2
events == UV__IO_READ,1,1,2
worker,1,1,2
uv__stream_fd(handle) >= 0,1,1,2
local_conn_accepted == 1,2,0,2
h == &handle,2,0,2
"!uv__io_active(&stream->io_watcher, UV__POLLIN | UV__POLLOUT)",1,1,2
handle->pending_signum = 0,1,1,2
req->statbuf.st_atim.tv_sec == checkme->atime,1,1,2
"uv_inet_pton(AF_INET6, ADDR ""%%%%"", &addr).code != UV_OK",1,1,2
"UV_EOF == uv_fs_readdir_next(req, &dent)",1,1,2
revents & EV_READ,1,1,2
1 == exit_cb_called,1,1,2
got_eof,2,0,2
(uv_pipe_t*)stream == &a,1,1,2
"0 && ""Failed to add file descriptor (pc.fd) to pollset""",2,0,2
handle == (uv_handle_t*)&async1_handle,1,1,2
handle == (uv_handle_t*) &pipe_client || handle == (uv_handle_t*) &pipe_server,2,0,2
s->st_ctim.tv_sec == t.st_ctime,2,0,2
"0 == uv_read2_start((uv_stream_t*) &ctx->ipc_pipe, ipc_alloc_cb, ipc_read2_cb)",1,1,2
"""oio_close_cb not called exactly once"" && close_cb_called",1,1,2
stream->loop == uv_default_loop(),1,1,2
((h)->flags & UV__HANDLE_CLOSING) == 0,2,0,2
read_req != NULL,1,1,2
nread == -1 && uv_last_error().code == UV_EOF,1,1,2
status != 0,2,0,2
"0 == uv_tcp_bind(&pinger->tcp, (const struct sockaddr*) &client_addr)",1,1,2
err == 0 || err == ESRCH,1,1,2
h->loop->active_handles > 0,1,1,2
req->result > 0 ? (req->ptr != NULL) : (req->ptr == NULL),1,1,2
"wcscmp(non_verbatim_output, L""cmd.exe /c \""c:\\path\\to\\node.exe --eval \\\""require('c:\\\\path\\\\to\\\\test.js')\\\""\"""") == 0",1,1,2
65548 == s2.st_size && s1.st_size == s2.st_size,1,1,2
"strncmp(buffer + index * sizeof(test_buf), test_buf, sizeof(test_buf)) == 0",2,0,2
UV_UNKNOWN_HANDLE == uv_guess_handle(dir_fd),1,1,2
0 == uv_is_closing((uv_handle_t*)&ctx.channel),1,1,2
pipe_open == 1,2,0,2
context != NULL,2,0,2
state == STATE_THREAD_START,1,1,2
handle->flags & OIO_HANDLE_READING,1,1,2
"0 == uv_thread_create(&thread, thread_main, &ctx)",2,0,2
req.service != NULL,1,1,2
stat_cb_count == 2,1,1,2
0 == setgid(pw->pw_gid),2,0,2
child.close_cb_called == 3,1,1,2
idle_1_cb_called >= ITERATIONS * IDLE_COUNT * 2,1,1,2
ctx->loop != NULL,1,1,2
handle->signum = 0,1,1,2
"(r == 1) && ""poll()_on read end of pipe failed""",1,1,2
n <= MAX_WRITE_HANDLES,2,0,2
"events != 0 || FD_ISSET(s->int_fd, s->sread)",2,0,2
1 == prepare_cb_called,2,0,2
!uv__has_active_reqs(loop),2,0,2
afinet_stream >= 0,1,1,2
(req->stat.st_mode & _S_IFMT) == _S_IFDIR,1,1,2
!ngx_queue_empty(&handle->read_reqs) || (nread < 0 && errno == EAGAIN),1,1,2
timer_cb_called == 2,2,0,2
"0 == uv_timer_start(&timer, fs_event_create_files, 50, 0)",1,1,2
"uv_inet_pton(AF_INET6, ADDR, &addr).code != UV_OK",1,1,2
incoming->rdstate == c_done,2,0,2
"0 == uv_fs_fstat(loop, reqs + n++, 0, fail_cb)",1,1,2
w->events == UV__IO_READ,1,1,2
status == UV_EAI_CANCELED,2,0,2
afunix_stream >= 0,1,1,2
uv_default_loop()->counters.tty_init == ++tty_init_prev,1,1,2
r == 0 && len == 0,2,0,2
uv_is_closing((uv_handle_t*) req->handle),1,1,2
s->st_size == sizeof(test_buf),2,0,2
"0 == uv_fs_link(loop, reqs + n++, ""/"", ""/"", fail_cb)",1,1,2
thread1_id != 0,1,1,2
oio_last_error().code == OIO_EINVAL,1,1,2
handle->read_line_handle == NULL,1,1,2
1 == uv_is_active((uv_handle_t*) &timer),2,0,2
!uv__io_active(&stream->read_watcher),1,1,2
"memeq(dst, """", 1)",1,1,2
!(handle->flags & UV_HANDLE_IPV6),2,0,2
buf->base[i] == PING[pinger->state],2,0,2
uv_last_error().code == UV_ENOTCONN,1,1,2
open_req.result == 0,1,1,2
"0 == uv_tcp_bind(&server, (struct sockaddr*) &addr)",1,1,2
len + 1 == bufsize,1,1,2
handle->read_buffer.len > 0,1,1,2
!process_title,1,1,2
r == pathw_len,1,1,2
"close_cb_called == 1 && ""close_cb must be called exactly once""",1,1,2
ipc_frame.header.flags <= (UV_IPC_UV_STREAM | UV_IPC_RAW_DATA),1,1,2
ngx_queue_empty(&req->read_reqs),1,1,2
req->errorno == UV_ENAMETOOLONG,1,1,2
req->handle->write_queue_size <= size,1,1,2
UV_FILE == uv_guess_handle(regfile_fd),1,1,2
"0 == uv_fs_mkdir(loop, reqs + n++, ""/"", 0, fs_cb)",2,0,2
r == new_pathw_len,1,1,2
len > SMALLPATH,2,0,2
events == UV__POLLIN,1,1,2
remote_conn_accepted == 1,2,0,2
"0 == uv_read_start((uv_stream_t*) &peer_handle, alloc_cb, read_cb)",2,0,2
handle->write_reqs_pending > 0,1,1,2
!(stream->flags & UV_STREAM_BLOCKING),2,0,2
handle->signum == 0,2,0,2
handle == &idle_handle,2,0,2
handle == (uv_handle_t*)&repeat_1,1,1,2
"memeq(dst, ""AB"", 3)",1,1,2
UV_UDP == uv_guess_handle(afinet6_dgram),1,1,2
handle->read_watcher.fd == handle->fd,1,1,2
uv_default_loop()->counters.tcp_init == tcpcnt,1,1,2
n_receivers <= MAX_RECEIVERS,1,1,2
"0 == uv_accept(handle, (uv_stream_t*) &peer_handle)",2,0,2
nread > 0 || err.code == UV_EOF,1,1,2
uv_is_tty(0) == 1,1,1,2
err,1,1,2
"0 != uv_run(uv_default_loop(), UV_RUN_NOWAIT)",2,0,2
watcher == &loop->uv_eio_poller,1,1,2
"uv_inet_pton(AF_INET6, ADDR ""%%%%"", &addr).code == UV_OK",1,1,2
sizeof(uv_buf) == sizeof(struct iovec),1,1,2
req->statbuf.st_mtim.tv_nsec == 0,1,1,2
s->st_mtim.tv_sec == t.st_mtime,2,0,2
UV_TCP == uv_guess_handle(afinet6_stream),1,1,2
uv_cnt_tcp_init == 1,1,1,2
&tcp == req->handle,1,1,2
uv_last_error(uv_default_loop()).code == UV_EACCES,1,1,2
req->type == OL_CONNECT,1,1,2
UV_UDP == uv_guess_handle(afinet_dgram),1,1,2
recv_cb_called == 0,2,0,2
data,2,0,2
signal2_cb_counter == 2 * NUM_SIGNAL_HANDLING_THREADS,1,1,2
s->st_atimespec.tv_nsec == 0,1,1,2
nread > 0 || uv_last_error(uv_default_loop()).code == UV_EOF,1,1,2
"(""libev: ev_io_start called with illegal event mask"", !(w->events & ~(EV__IOFDSET | EV_READ | EV_WRITE | EV_LIBUV_KQUEUE_HACK)))",1,1,2
prepare_cb_called == 2,1,1,2
(unsigned)(zone_index - ip) < address_part_size,1,1,2
uv_backend_timeout(loop) == 0,2,0,2
fs_event_created < fs_event_file_count,2,0,2
uv_default_loop()->counters.stream_init == ++stream_init_prev,1,1,2
"(pfd.revents & POLLIN) == 0 && ""unexpected POLLIN on pipe read end""",1,1,2
"UV_ENOENT == uv_fs_readlink(NULL, &req, ""no_such_file"", NULL)",1,0,1
req.data != NULL,1,0,1
"uv_pipe_open(&pipe_stdout_parent, fds_stdout[0]) == 0",1,0,1
"strcmp(buffer_orig, buffer_new) == 0",1,0,1
"0 == uv_tcp_bind((uv_tcp_t*) &ctx.server_handle, (const struct sockaddr*) &listen_addr, 0)",1,0,1
0 == close(master_fd),1,0,1
ARRAY_SIZE(sockets) == close_cb_called,1,0,1
n == sizeof(data),1,0,1
"0 == uv_async_init(&loop, &ctx->async_handle, sv_async_cb)",1,0,1
0 == uv_is_active((uv_handle_t*) timer),1,0,1
handle == (uv_handle_t*)&conn || handle == (uv_handle_t*)&timer,1,0,1
1 == uv_is_closing((uv_handle_t*) &timer),1,0,1
req.result == UV_ELOOP,1,0,1
s->st_birthtim.tv_nsec == t.st_birthtim.tv_nsec,1,0,1
"0 != uv_poll_init(uv_default_loop(), &poll_handle, fd)",1,0,1
no_term_signal || term_signal == 15,1,0,1
"0 == uv_tcp_init(loop, (uv_tcp_t*) ctx->server_handle)",1,0,1
n == fs_cb_called,1,0,1
"strcmp(buf2, test_buf2) == 0",1,0,1
timer_cb_exact_called == 2,1,0,1
handle->send_queue_count >= 1,1,0,1
"0 == uv_tcp_init(loop, &tcp_check)",1,0,1
service != NULL,1,0,1
"0 && ""Blackhole server dropped out of event loop.""",1,0,1
"strcmp(req.ptr, ""test_file_symlink"") == 0",1,0,1
connect_cb_called == 2,1,0,1
s->st_atim.tv_sec + (s->st_atim.tv_nsec / 1000000000.0) == atime,1,0,1
handle == &(name)[1],1,0,1
b_eq,1,0,1
"0 == uv_tcp_connect(&tcp_check_req, &tcp_check, addr, connect_cb)",1,0,1
avg[2] >= 0,1,0,1
"0 == uv_read_start((uv_stream_t*) &ctx->ipc_pipe, ipc_alloc_cb, ipc_read_cb)",1,0,1
"0 == uv_read_start((uv_stream_t*) &tcp_handle, (uv_alloc_cb) fail_cb, (uv_read_cb) fail_cb)",1,0,1
r,1,0,1
h_stdin != INVALID_HANDLE_VALUE,1,0,1
unlink_req.result == 0,1,0,1
rsplen + wr->buf.len < WRITE_BUF_LEN,1,0,1
"0 == uv_timer_start(&timer, fs_event_create_files, 1, 0)",1,0,1
"0 == strcmp(buf, test_buf)",1,0,1
"0 == uv_udp_send(req, handle, &sndbuf, 1, addr, on_send)",1,0,1
c->wrstate != c_dead,1,0,1
0 == close(slave_fd),1,0,1
req->result == UV_ELOOP,1,0,1
file != -1,1,0,1
size == 1,1,0,1
do_accept_called == 2,1,0,1
"stricmp(req.ptr, test_file_abs_buf) == 0",1,0,1
"UV_EOF == uv_fs_scandir_next(req, &dent)",1,0,1
"0 == uv_timer_start(&timer, timer_cb_watch_twice, 10, 0)",1,0,1
master_tty.flags & 0x80,1,0,1
"nested == 0 && ""read_cb must be called from a fresh stack""",1,0,1
released,1,0,1
((uv_stat_t*)req.ptr)->st_size == strlen(test_dir + 4),1,0,1
pinger_shutdown_cb_called == 1,1,0,1
"!uv__io_active(&stream->io_watcher, POLLIN | POLLOUT)",1,0,1
fs_req.result == 0,1,0,1
clients != NULL,1,0,1
tmpdir[len] == '\0',1,0,1
"0 == uv_timer_start(&ctx->handle, timer_cb, 5, 5)",1,0,1
"0 == uv_fs_poll_start(&poll_handle, poll_cb, FIXTURE, 100)",1,0,1
n == ARRAY_SIZE(reqs),1,0,1
pipe_open == 0,1,0,1
1 == uv_is_closing((uv_handle_t*) &process),1,0,1
"0 == uv_thread_create(threads + 0, check_thread, subthreads + 0)",1,0,1
servers != NULL,1,0,1
"0 == uv_timer_start(&timer2_handle, timer2_cb, 86400 * 1000, 0)",1,0,1
req.result < 0,1,0,1
"0 == uv_timer_start(&timer1_handle, timer1_cb, 1, 0)",1,0,1
work_cb_called == num_threads,1,0,1
idle,1,0,1
realpath_cb_count == 1,1,0,1
s->st_mtim.tv_sec == t.st_mtim.tv_sec,1,0,1
embed_timer_called == 1,1,0,1
0 == pipe(pipe_fds),1,0,1
s->st_ctim.tv_sec == t.st_ctim.tv_sec,1,0,1
req == &unlink_req,1,0,1
cb != NULL,1,0,1
handle->tty.rd.read_line_buffer.len > 0,1,0,1
"0 == uv_thread_create(threads + 1, check_thread, subthreads + 1)",1,0,1
step == current + 1,1,0,1
"0 == uv_ip4_addr(""4.4.4.4"", TEST_PORT, &addr)",1,0,1
pwd.uid == -1,1,0,1
value == 10000 || value == 20000,1,0,1
"0 == uv_timer_start(&tiny_timer, tiny_timer_cb, 1, 0)",1,0,1
"0 == uv_tcp_bind(&tcp_server, addr)",1,0,1
handle->send_queue_size >= req->u.io.queued_bytes,1,0,1
s->st_atim.tv_nsec == t.st_atim.tv_nsec,1,0,1
"strcmp(req->ptr, ""test_file_symlink2"") == 0",1,0,1
"0 == uv_fs_close(loop, reqs + n++, 0, fs_cb)",1,0,1
req->fs_type == UV_FS_FCHMOD,1,0,1
events == (events & (POLLIN | POLLOUT)),1,0,1
fd >= -1,1,0,1
events != NULL || err != 0,1,0,1
unlink_cb_count == 2,1,0,1
"0 == uv_prepare_init(uv_default_loop(), &prepare_handle)",1,0,1
n_senders <= ARRAY_SIZE(senders),1,0,1
threads[i].thread_called,1,0,1
0 == uv_is_closing((uv_handle_t*) &process),1,0,1
(uv_udp_t*)(handle) == &handle_,1,0,1
"0 == uv_timer_start(&timer_handle, timer_run_once_timer_cb, 0, 0)",1,0,1
(size_t) ((struct stat*)req.ptr)->st_size == strlen(test_dir),1,0,1
handle->pending_signum == 0,1,0,1
"0 == uv_ip6_addr(""::0"", TEST_PORT, &addr6)",1,0,1
UV_EBUSY == uv_loop_close(&loop),1,0,1
env_len == (ptr - dst),1,0,1
r == (DWORD) new_pathw_len,1,0,1
c->t.addr.sa_family == AF_INET || c->t.addr.sa_family == AF_INET6,1,0,1
"(bytes >= 0) && ""uv__ahafs_event - Error reading monitor file""",1,0,1
pipe == &ctx2.channel,1,0,1
rusage.ru_utime.tv_usec >= 0,1,0,1
pending_incoming < got_connections,1,0,1
"!memcmp(buf->base, EXPECTED, nread)",1,0,1
"UV_EBADF == uv_udp_set_multicast_ttl(&h, 32)",1,0,1
called_shutdown_cb == 0,1,0,1
"memcmp(buf, abstract_pipe, sizeof abstract_pipe) == 0",1,0,1
"0 == uv_tty_init(&loop, &slave_tty, slave_fd, 0)",1,0,1
0 == uv_mutex_init(&signal_mutex),1,0,1
req->fs_type == UV_FS_FUTIME,1,0,1
req.data == NULL,1,0,1
bytes == sizeof(ipc_frame.header),1,0,1
start + CMSG_LEN(count * sizeof(*pi)) == end,1,0,1
"filename == NULL || strcmp(filename, ""file2"") == 0",1,0,1
buffer_len > 0,1,0,1
rusage.ru_utime.tv_sec >= 0,1,0,1
"0 == uv_getnameinfo(uv_default_loop(), &req, NULL, (const struct sockaddr*)&addr4, 0)",1,0,1
r==nb,1,0,1
"nested == 0 && ""connect_cb must be called from a fresh stack""",1,0,1
(uv_udp_t*)(handle) == &server || (uv_udp_t*)(handle) == &client || (uv_timer_t*)(handle) == &timeout,1,0,1
timer_called == 0,1,0,1
s->st_birthtim.tv_sec == t.st_birthtimespec.tv_sec,1,0,1
"0 == uv_getaddrinfo(uv_default_loop(), &req, getaddrinfo_fail_cb, ""xyzzy.xyzzy.xyzzy."", NULL, NULL)",1,0,1
"0 == uv_accept(handle, (uv_stream_t*) inc)",1,0,1
req->fs_type == UV_FS_CLOSE,1,0,1
tcp == (uv_stream_t*)&tcp_connection,1,0,1
"strstr(uv_strerror(UV_EINVAL), ""Success"") == NULL",1,0,1
"0 == uv_ip6_addr(""::1"", port, &addr6)",1,0,1
"0 == uv_write(&write_req, (uv_stream_t*) &tcp_handle, &buf, 1, write_cb)",1,0,1
buffer[1] == '\0',1,0,1
timer != NULL,1,0,1
value > 0,1,0,1
"0 == uv_async_init(&ctx->loop, &ctx->worker_async, worker_async_cb)",1,0,1
"0 == uv_inet_pton(AF_INET6, ADDR ""%en1"", &addr)",1,0,1
pwd.uid >= 0,1,0,1
write_callbacks > 0,1,0,1
"UV_ENOSYS == uv_loop_configure(loop, UV_LOOP_BLOCK_SIGNAL, 0)",1,0,1
check_close_cb_called == 1,1,0,1
uv_backend_timeout(loop) <= 1000,1,0,1
"wcscmp(verbatim_output, L""cmd.exe /c c:\\path\\to\\node.exe --eval "" L""\""require('c:\\\\path\\\\to\\\\test.js')\"""") == 0",1,0,1
parser->cmd == s5_cmd_tcp_connect,1,0,1
called_timer_cb == 0,1,0,1
"uv_thread_equal(&main_thread_id, &self_id) == 0",1,0,1
timer_cb_calls == 0,1,0,1
"0 == uv_loop_configure(loop, UV_LOOP_BLOCK_SIGNAL, SIGPROF)",1,0,1
cl_send_cb_called == 2,1,0,1
close_cb_calls == 1,1,0,1
req == &stat_req,1,0,1
signal1_cb_counter == 8 * (NUM_SIGNAL_HANDLING_THREADS / 3),1,0,1
"memcmp(req->path, ""test_dir_"", 9) == 0",1,0,1
handle == (uv_handle_t*)&tcp_client,1,0,1
"0 == uv_tty_init(&loop, &tty, fd, 1)",1,0,1
sock != -1,1,0,1
homedir[2] == '\\',1,0,1
timer_close_cb_called == 1,1,0,1
"close_cb_called == 2 && ""close_cb must be called exactly twice""",1,0,1
size == 0,1,0,1
!uv_loop_alive(loop),1,0,1
QUEUE_EMPTY(&pending),1,0,1
"UV_EAFNOSUPPORT == uv_inet_pton(42, ""127.0.0.1"", &addr.sin_addr.s_addr)",1,0,1
"0 == uv_fs_readlink(loop, &req, ""no_such_file"", dummy_cb)",1,0,1
num == numcpus,1,0,1
close_cb_count == 2,1,0,1
"0 == uv_ip6_addr(""::"", TEST_PORT, &addr1)",1,0,1
QUEUE_EMPTY(&loop->pending_queue),1,0,1
hrtime >= timer_early_check_expected_time,1,0,1
socket != 0 && socket != INVALID_SOCKET,1,0,1
rusage.ru_stime.tv_sec >= 0,1,0,1
0 == uv_fs_event_stop(event),1,0,1
pc.fd >= 0,1,0,1
called_timer_close_cb == 1,1,0,1
uv_has_ref((uv_handle_t*)&h) == 0,1,0,1
req.result == UV_ENAMETOOLONG,1,0,1
!filenamew,1,0,1
"0 == uv_tcp_connect(&connection_request, &tcp_client, (const struct sockaddr *) &sa, connect_cb)",1,0,1
req == &sendfile_req,1,0,1
"0 == uv_timer_start(&timer_handle, timer_cb, 20, 0)",1,0,1
pending == UV_NAMED_PIPE,1,0,1
write_cancelled_callbacks > 0,1,0,1
"0 == uv_ip4_addr(""127.0.0.1"", TEST_PORT, &sa)",1,0,1
0 == uv_loop_init(&external),1,0,1
s->st_atim.tv_sec == t.st_atimespec.tv_sec,1,0,1
w->events == POLLIN,1,0,1
"UV_EINVAL == uv_ip4_addr(""255"", TEST_PORT, &addr)",1,0,1
connection_cb_called == NUM_CLIENTS,1,0,1
getsocknamecount == 3,1,0,1
events & context->events,1,0,1
r == 0 || r == UV_EADDRNOTAVAIL,1,0,1
"UV_EBADF == uv_udp_set_multicast_interface(&h, ""0.0.0.0"")",1,0,1
s->st_mtim.tv_sec + (s->st_mtim.tv_nsec / 1000000000.0) == mtime,1,0,1
bytes_sent_done == TOTAL_BYTES,1,0,1
req->handle->write_queue_size >= size,1,0,1
"0 == uv_timer_start(&huge_timer1, tiny_timer_cb, 0xffffffffffffLL, 0)",1,0,1
"0 == uv_udp_init(loop, &h)",1,0,1
signum == SIGUSR1,1,0,1
pwd.homedir[0] == '/',1,0,1
"0 == uv_fs_event_init(loop, watchers + 1)",1,0,1
handle->u.fd == -1 || handle->u.fd > 2,1,0,1
(size_t)read_req.result == sizeof(test_buf) * iovcount,1,0,1
pipe->pipe.conn.eof_timer == NULL,1,0,1
work_cb_count == 1,1,0,1
"0 == uv_listen((uv_stream_t*) &ctx.ipc_pipe, 128, ipc_connection_cb)",1,0,1
timer_called == 1,1,0,1
"0 == uv_fs_poll_start(&poll_handle, poll_cb_fail, FIXTURE, 100)",1,0,1
base_socket != 0 && base_socket != INVALID_SOCKET,1,0,1
c->rdstate == c_stop,1,0,1
n_receivers <= ARRAY_SIZE(receivers),1,0,1
c->wrstate == c_busy,1,0,1
compare_addr.sin_family == AF_INET,1,0,1
h == &timer,1,0,1
work_cb_count == 0,1,0,1
bytes_read == bytes_written,1,0,1
"0 == uv_udp_init(loop, &sockets[i])",1,0,1
"0 == uv_fs_close(NULL, &fs_req, fd, NULL)",1,0,1
"0 == uv_fs_ftruncate(loop, reqs + n++, 0, 0, fs_cb)",1,0,1
handle == &poll_handle,1,0,1
"0 == uv_sem_init(&sem, 3)",1,0,1
cx->state >= s_almost_dead_0,1,0,1
"0 == uv_pipe_init(loop, (uv_pipe_t*) ctx->server_handle, 0)",1,0,1
"0 == uv_read_start((uv_stream_t*) &p, alloc_cb, read_cb)",1,0,1
req->fs_type == UV_FS_LINK,1,0,1
"0 == uv_fs_event_start(watchers + 1, fail_cb, path, 0)",1,0,1
timer_close_cb_calls == 1,1,0,1
!loop->wq_async.async_sent,1,0,1
"memcmp(buf, ""watch_dir"", len) == 0",1,0,1
mpipe(fds_stdin) != -1,1,0,1
repeat_2_cb_allowed,1,0,1
buf1[len1 - 1] != 0,1,0,1
!didTimeout,1,0,1
repeat_close_cb_called == 1,1,0,1
req == &ftruncate_req,1,0,1
req == &fsync_req,1,0,1
process_open == 0,1,0,1
diff > (uint64_t) 25 * NANOSEC / MILLISEC,1,0,1
sendfile_cb_count == 1,1,0,1
exp,1,0,1
req == &utime_req,1,0,1
req->fs_type == UV_FS_SYMLINK,1,0,1
"0 == uv_inet_ntop(AF_INET6, &address->address.address6.sin6_addr, string_address, sizeof(string_address))",1,0,1
"strcmp(req.ptr, test_dir_abs_buf) == 0",1,0,1
"0 == uv_ip4_addr(""0.0.0.0"", TEST_PORT, &listen_addr)",1,0,1
req_cb_called == 1,1,0,1
"strncmp(""hello world\n"", output, 12) == 0",1,0,1
read_req.result == sizeof(test_buf) * iovcount,1,0,1
accepted_handle != NULL,1,0,1
nwritten == sizeof(test_buf),1,0,1
req->type == UV_WRITE,1,0,1
(s->st_mode & 0777) == mode,1,0,1
"wcscmp(test_str[i], cracked[i]) == 0",1,0,1
diff < (uint64_t) 80 * NANOSEC / MILLISEC,1,0,1
"0 == uv_fs_read(loop, reqs + n++, 0, &iov, 1, 0, fs_cb)",1,0,1
65546 == s2.st_size && s1.st_size == s2.st_size,1,0,1
num_threads == NUM_THREADS,1,0,1
sys_drive != NULL,1,0,1
req.host[0] != '\0',1,0,1
s->st_atim.tv_sec == t.st_atim.tv_sec,1,0,1
0 == close(pipe_fds[0]),1,0,1
(uv_udp_t*)(handle) == &client,1,0,1
prepare_called == 10,1,0,1
"(r == 0) && ""unexpected port_get() error""",1,0,1
"0 == uv_tcp_init(server->loop, incoming)",1,0,1
"0 == uv_fs_lstat(loop, reqs + n++, ""/"", fs_cb)",1,0,1
"0 == uv_ip4_addr(""0.0.0.0"", TEST_PORT_2, &addr2)",1,0,1
queued_fds->offset > 0,1,0,1
futime_cb_count == 1,1,0,1
sc[i].ncalls == NSIGNALS,1,0,1
0 == uv_read_stop(stream),1,0,1
nread == UV_ECANCELED,1,0,1
"0 == uv_getaddrinfo(uv_default_loop(), &req, NULL, name, NULL, NULL)",1,0,1
0 != uv_is_closing((const uv_handle_t *) &pipe_handle),1,0,1
1 == uv_is_closing((uv_handle_t*) req->handle),1,0,1
arg == uv_key_get(&tls_key),1,0,1
req->fs_type == UV_FS_MKDIR,1,0,1
r == filler_len,1,0,1
"strcmp(mkdtemp_req1.path, mkdtemp_req2.path) != 0",1,0,1
WIFEXITED(status) && WEXITSTATUS(status) == 0,1,0,1
close_cb_called == NUM_SOCKETS,1,0,1
avg[0] >= 0,1,0,1
homedir[len - 1] != '/',1,0,1
wr != NULL,1,0,1
"0 == uv_thread_create(&ctx->thread, worker, ctx)",1,0,1
env_len == ptr - dst_copy,1,0,1
pthread_cond_signal(&b->cond) == 0,1,0,1
req->fs_type == UV_FS_FSTAT,1,0,1
sizeof(&((uv_buf_t*) 0)->len) == sizeof(((struct iovec*) 0)->iov_len),1,0,1
req->fs_type == UV_FS_ACCESS,1,0,1
"sizeof(fd) == read(0, &fd, sizeof(fd))",1,0,1
!(handle->flags & UV_UDP_PROCESSING),1,0,1
"0 == uv_idle_start(&idle, idle_cb)",1,0,1
write_req.result == 0,1,0,1
size == strlen(buffer),1,0,1
read_cb_count == 3,1,0,1
ARRAY_SIZE(incoming) == incoming_count,1,0,1
width > 10,1,0,1
buf2[len2 - 1] != 0,1,0,1
s->st_mode == (uint64_t) t.st_mode,1,0,1
handle->req_pending,1,0,1
w >= 0,1,0,1
once_cb_called == 1,1,0,1
fail_cb_called == 0,1,0,1
ctx->worker_seen == NUM_PINGS,1,0,1
0 == uv_is_active((uv_handle_t*) &handle),1,0,1
0 == uv_cond_init(&condvar),1,0,1
"UV_EINVAL == uv_ip4_addr(""255.255.255*000"", TEST_PORT, &addr)",1,0,1
0 == uv_thread_join(&thread_id),1,0,1
"0 == uv_thread_create(threads + 1, tls_thread, threads + 1)",1,0,1
efds.fd_count == 1,1,0,1
"0 == uv_fs_event_init(loop, event)",1,0,1
"CompareStringOrdinal(prev, -1, str, -1, TRUE) == 1",1,0,1
"offsetof(uv_buf_t, len) == offsetof(struct iovec, iov_len)",1,0,1
r == 0 || got_eagain(),1,0,1
start_time == 0,1,0,1
ticks <= 20,1,0,1
req->fs_type == UV_FS_UNLINK,1,0,1
handle->dir_handle != INVALID_HANDLE_VALUE,1,0,1
"0 == uv_timer_start(&huge_timer1, huge_repeat_cb, 1, (uint64_t) -1)",1,0,1
handle->submitted_events_2 == 0,1,0,1
req.service[0] != '\0',1,0,1
prepare_1_close_cb_called == 1,1,0,1
dispatched_signum != 0,1,0,1
"0 == uv_ip4_addr(""127.0.0.1"", BASE_PORT + (i % n_receivers), &s->addr)",1,0,1
tcp_read_cb_called == 1,1,0,1
"0 == uv_fs_poll_getpath(&poll_handle, buf, &len)",1,0,1
2 == timer_cb_called,1,0,1
"0 == uv_timer_start(&timer_handle, timeout_cb, timeout, 0)",1,0,1
homedir[len] == '\0',1,0,1
"0 == uv_tcp_bind(&tcp, (struct sockaddr*) &addr, 0)",1,0,1
stdout_file != -1,1,0,1
h_stdout != INVALID_HANDLE_VALUE,1,0,1
"strcmp(req->ptr, test_file_abs_buf) == 0",1,0,1
spurious_writable_wakeups == 0 || (valid_writable_wakeups + spurious_writable_wakeups) / spurious_writable_wakeups > 20,1,0,1
"0 == memcmp(buf, FIXTURE, len)",1,0,1
tids != NULL,1,0,1
s->st_mtim.tv_nsec == t.st_mtimespec.tv_nsec,1,0,1
0 == uv_timer_stop(&handle_b),1,0,1
0 == close(pipe_fds[1]),1,0,1
req->fs_type == UV_FS_WRITE,1,0,1
"0 == uv_tcp_connect(&ctx->connect_req, (uv_tcp_t*) &ctx->client_handle, (const struct sockaddr*) &listen_addr, cl_connect_cb)",1,0,1
"0 > uv_getaddrinfo(uv_default_loop(), &req, NULL, ""xyzzy.xyzzy.xyzzy."", NULL, NULL)",1,0,1
0 == uv_thread_join(&ctx->thread_id),1,0,1
"0 == uv_accept(ipc_pipe, (uv_stream_t*) &pc->peer_handle)",1,0,1
events == POLLIN,1,0,1
"uv_pipe_open(&pipe_stdin_parent, fds_stdin[1]) == 0",1,0,1
idles_1_active > 0,1,0,1
QUEUE_EMPTY(&stream->write_completed_queue),1,0,1
handle == &async,1,0,1
"0 == socketpair(AF_UNIX, SOCK_STREAM, 0, fd)",1,0,1
"0 == uv_timer_start(&timer_handle, timer_early_check_cb, timeout_ms, 0)",1,0,1
"0 == uv_fs_utime(loop, reqs + n++, ""/"", 0, 0, fs_cb)",1,0,1
r == UV_EACCES,1,0,1
"strcmp(""fourth stdio!\n"", output) == 0",1,0,1
handle->stream.conn.write_reqs_pending > 0,1,0,1
"0 == uv_thread_create(&thread, thread_check_stack, NULL)",1,0,1
recv_cb_called == 1,1,0,1
"0 == uv_tcp_init(server_handle->loop, (uv_tcp_t*) storage)",1,0,1
strlen(homedir) == len,1,0,1
"0 == uv_fs_sendfile(loop, reqs + n++, 0, 0, 0, 0, fs_cb)",1,0,1
!handle->exit_cb_pending,1,0,1
pwd.homedir[2] == '\\',1,0,1
cl_send_cb_called == 0,1,0,1
on_read_cb_called > 1,1,0,1
addrlen <= sizeof(req->addr),1,0,1
"memcmp(""hello again\n"", buf->base, nread) == 0",1,0,1
1 == uv_is_writable(req->handle),1,0,1
"0 == uv_ip6_addr(""4:4:4:4:4:4:4:4"", TEST_PORT, &addr)",1,0,1
r == ws_len,1,0,1
helper_timer_cb_calls == 1,1,0,1
!((handle)->flags & UV__HANDLE_CLOSING),1,0,1
handle->io_watcher.fd == -1,1,0,1
r == (DWORD) pathw_len,1,0,1
uptime > 0,1,0,1
"uv_pipe_init(loop, &pipe_stdout_parent, 0) == 0",1,0,1
uv_timer_get_repeat(&repeat_1) == 0,1,0,1
"0 == uv_tcp_connect(&ctx->connect_req, handle, (const struct sockaddr*) &listen_addr, cl_connect_cb)",1,0,1
"0 == uv_run(uv_default_loop(), UV_RUN_NOWAIT)",1,0,1
"strnicmp(req.ptr, test_dir + 4, test_dir_abs_size - 5) == 0",1,0,1
handle == &prepare,1,0,1
"0 == uv_fs_futime(loop, reqs + n++, 0, 0, 0, fs_cb)",1,0,1
"0 == uv_ip4_addr(""255.255.255.255"", TEST_PORT, &addr)",1,0,1
1 == timer_run_once_timer_cb_called,1,0,1
"memcmp(&check_addr.sin_addr, &compare_addr.sin_addr, sizeof compare_addr.sin_addr) == 0",1,0,1
"0 == uv_read_start((uv_stream_t*) &incoming, alloc_cb, read_cb)",1,0,1
r == 12,1,0,1
"0 == uv_ip4_addr(""127.0.0.1"", TEST_PORT, &listen_addr)",1,0,1
knp->data_type == KSTAT_DATA_STRING,1,0,1
"0 == uv_fs_scandir(loop, reqs + n++, ""/"", 0, fs_cb)",1,0,1
req->event_handle,1,0,1
ticks == NUM_TICKS,1,0,1
"0 == uv_tcp_bind(&tcp_server, (const struct sockaddr*) &addr, 0)",1,0,1
"timer_cb_called == 1 && ""timer_cb must be called exactly once""",1,0,1
!(handle->flags & UV_HANDLE_PIPESERVER),1,0,1
fs_event_error_reported == UV_EMFILE,1,0,1
"0 == uv_tcp_init(uv_default_loop(), &tcp_handle)",1,0,1
req->type == UV_POLL_REQ,1,0,1
"strcmp(fs_req.path, watched_dir) == 0",1,0,1
"strcmp(buffer, output) == 0",1,0,1
tcp_conn_read_cb_called == 1,1,0,1
"0 == uv_tty_init(&loop, &master_tty, master_fd, 0)",1,0,1
"0 == uv_tcp_init(loop, (uv_tcp_t*) &ctx.server_handle)",1,0,1
0 == uv_key_create(&tls_key),1,0,1
"0 == uv_signal_start(&ctx->handle, signal_cb, signum)",1,0,1
"0 != uv_inet_pton(AF_INET6, ADDR ""%en1:1.2.3.4"", &addr)",1,0,1
s->st_dev == (uint64_t) t.st_dev,1,0,1
req == &futime_req,1,0,1
req->result == UV_EPERM,1,0,1
"strcmp(uv_strerror(1337), ""Unknown error"") == 0",1,0,1
"0 == uv_fs_event_start(watchers + 0, fail_cb, path, 0)",1,0,1
req->fs_type == UV_FS_CHMOD,1,0,1
"0 == uv_fs_chmod(loop, reqs + n++, ""/"", 0, fs_cb)",1,0,1
send_cb_called == 2,1,0,1
"nested == 0 && ""shutdown_cb must be called from a fresh stack""",1,0,1
"0 == uv_fs_fstat(loop, reqs + n++, 0, fs_cb)",1,0,1
hostname != NULL,1,0,1
r >= 12,1,0,1
prefix_len + vt100_len < sizeof handle->tty.rd.last_key,1,0,1
pwd.gid >= 0,1,0,1
timer_cb_called == NUM_TIMERS,1,0,1
"0 == uv_thread_create(tids + i, pummel, &handle)",1,0,1
address->sa_family == family,1,0,1
"UV_EBADF == uv_udp_set_broadcast(&h, 1)",1,0,1
"0 && ""alloc_cb should not have been called""",1,0,1
free_mem > 0,1,0,1
"0 == uv_fs_fchmod(loop, reqs + n++, 0, 0, fs_cb)",1,0,1
"0 == uv_timer_start(&timer_handle, timer_cb, 200, 0)",1,0,1
rfds.fd_count == 1,1,0,1
req->result == UV_ENOTDIR,1,0,1
0 == check_cb_called,1,0,1
"0 == uv_read_start((uv_stream_t*) incoming, alloc_cb, read_cb)",1,0,1
!(events & ~context->events),1,0,1
loop_iteration % 2 != 0,1,0,1
"0 == uv_accept(server_handle, (uv_stream_t*) storage)",1,0,1
cl_send_cb_called == 1,1,0,1
"UV_ENOENT == uv_fs_realpath(NULL, &req, ""no_such_file"", NULL)",1,0,1
"0 == uv_fs_open(loop, reqs + n++, ""/"", 0, 0, fs_cb)",1,0,1
"0 == uv_stream_set_blocking((uv_stream_t*) &pipe_handle, 1)",1,0,1
1 == uv_is_readable(req->handle),1,0,1
"0 && ""Pollset does not contain file descriptor""",1,0,1
"0 == uv_tcp_init(loop, handle)",1,0,1
"0 == uv_timer_init(uv_default_loop(), &handle_b)",1,0,1
0 == uv_mutex_init(&wait_mutex),1,0,1
rusage.ru_stime.tv_usec >= 0,1,0,1
send_buffer != NULL,1,0,1
incoming_count < ARRAY_SIZE(incoming),1,0,1
fchown_cb_count == 1,1,0,1
"0 == uv_fs_rename(loop, reqs + n++, ""/"", ""/"", fs_cb)",1,0,1
handle == &(name)[2],1,0,1
a_eq,1,0,1
service == NULL,1,0,1
avail >= sizeof(ipc_frame.header),1,0,1
!long_filenamew,1,0,1
link_cb_count == 1,1,0,1
found,1,0,1
"0 == uv_inet_pton(AF_INET6, ADDR ""%en1:1.2.3.4"", &addr)",1,0,1
req == &fdatasync_req,1,0,1
"!""read_cb_called > 2""",1,0,1
"0 == uv_idle_init(loop, &ctx->idle_handle)",1,0,1
seen_timer_handle == 1,1,0,1
strlen(req.ptr) == test_dir_abs_size - 5,1,0,1
ARRAY_SIZE(tcp_outgoing) == write_cb_called,1,0,1
calls_initiated == TOTAL_CALLS,1,0,1
"0 == uv_listen((uv_stream_t*) &ctx->server_handle, 128, sv_connection_cb)",1,0,1
"UV_EINVAL == uv_timer_start(&handle, NULL, 100, 100)",1,0,1
cx->state != s_dead,1,0,1
0 == uv_cancel((uv_req_t*) req),1,0,1
process_title.len + 1 == size,1,0,1
repeat_2_cb_called == 2,1,0,1
"0 == uv_timer_init(&loop, &timer_handle)",1,0,1
handle->send_queue_count == 0,1,0,1
!found_in_loc_env[i],1,0,1
context->delayed_events != 0,1,0,1
req->type == UV_FS_EVENT_REQ,1,0,1
"0 == uv_tcp_init(&loop, &tcp_client)",1,0,1
path_len == buf_sz - (pos - buf),1,0,1
"0 == uv_tcp_init(uv_default_loop(), &tcp)",1,0,1
stat_cb_count == 4,1,0,1
"0 == uv_pipe_open(&p, fds[1])",1,0,1
"memcmp(""PING"", rcvbuf->base, nread) == 0 || memcmp(""PANG"", rcvbuf->base, nread) == 0",1,0,1
sockname.sa_family == AF_INET,1,0,1
"0 == uv_ip4_addr(address_ip4, port, &addr4)",1,0,1
context->read == 0,1,0,1
ticks == kMaxTicks,1,0,1
!(handle->flags & UV_CLOSING),1,0,1
"0 != uv_inet_pton(AF_INET6, ADDR, &addr)",1,0,1
buf->base[0] == ' ',1,0,1
"0 == uv_fs_fdatasync(loop, reqs + n++, 0, fs_cb)",1,0,1
fchmod_cb_count == 1,1,0,1
loop_iteration == ITERATIONS,1,0,1
"0 == uv_write(&write_reqs[i], outgoing, &buf, 1, write_cb)",1,0,1
"UV_EINVAL == uv_ip4_addr(""2555.0.0.0"", TEST_PORT, &addr)",1,0,1
"UV_EBADF == uv_udp_set_ttl(&h, 1)",1,0,1
(events & ~(UV_READABLE | UV_WRITABLE | UV_DISCONNECT)) == 0,1,0,1
calls_completed == TOTAL_CALLS,1,0,1
"0 == uv_udp_bind(&sockets[i], (const struct sockaddr*) &addr, UV_UDP_REUSEADDR)",1,0,1
"0 == uv_udp_recv_start(&sockets[i], alloc_cb, recv_cb)",1,0,1
*flag == 1,1,0,1
arg == (void*)magic_cookie,1,0,1
"memcmp(req->path, ""test_file2\0"", 11) == 0",1,0,1
f != -1,1,0,1
name == uv_key_get(&tls_key),1,0,1
req == &close_req,1,0,1
completed_pingers == 0,1,0,1
err == UV_ESRCH,1,0,1
once_close_cb_called == 10,1,0,1
server.reqs_pending == 1,1,0,1
"0 && ""fail_cb2 should not have been called""",1,0,1
loop->nfds == 0,1,0,1
500 <= uv_now(uv_default_loop()) - start_time,1,0,1
"0 == uv_udp_bind(&udp, (struct sockaddr*) &addr, 0)",1,0,1
avg[1] >= 0,1,0,1
process_open == 1,1,0,1
(uv_handle_t*)&conn.conn == (uv_handle_t*)req->handle,1,0,1
total_mem > 0,1,0,1
"0 == uv_udp_bind(&s->udp_handle, (const struct sockaddr*) &addr, 0)",1,0,1
"0 == uv_pipe_init(p->loop, inc, 0)",1,0,1
status == UV_EMSGSIZE,1,0,1
uv_backend_timeout(loop) > 100,1,0,1
getaddrinfo_cbs == 1,1,0,1
called_tcp_close_cb == 1,1,0,1
handle->pipe.serv.accept_reqs[0].pipeHandle != INVALID_HANDLE_VALUE,1,0,1
sizeof(&((uv_buf_t*) 0)->base) == sizeof(((struct iovec*) 0)->iov_base),1,0,1
"WriteFile(h_stdout, pbuf, to_write, &n_written, NULL)",1,0,1
"buffer == fgets(buffer, sizeof(buffer) - 1, stdin)",1,0,1
"memcmp(""EXIT"", rcvbuf->base, nread) == 0",1,0,1
0 == uv_loop_init(&ctx->loop),1,0,1
handle == &huge_timer1,1,0,1
"nested == 0 && ""write_cb must be called from a fresh stack""",1,0,1
"strcmp(req.ptr, test_file_abs_buf) == 0",1,0,1
c->wrstate == c_stop || c->wrstate == c_done,1,0,1
buffer[0] == '\0',1,0,1
fd > 2,1,0,1
req->fs_type == UV_FS_FSYNC,1,0,1
"0 == uv_thread_create(&thread, thread_cb, NULL)",1,0,1
poll_cb_called == 5,1,0,1
check_cb_called == 1,1,0,1
avail - sizeof(ipc_frame.header) >= sizeof(ipc_frame.socket_info_ex),1,0,1
"0 && ""Buffer wrap detected, Some event occurrences lost!""",1,0,1
1 == uv_pipe_pending_count(ipc_pipe),1,0,1
req->fs_type == UV_FS_UTIME,1,0,1
req == &mkdir_req,1,0,1
"0 == uv_inet_pton(AF_INET6, ADDR ""%%%%"", &addr)",1,0,1
0 == uv_thread_join(&threads[i].thread),1,0,1
bytes_sent == TOTAL_BYTES,1,0,1
req->fs_type == UV_FS_STAT || req->fs_type == UV_FS_LSTAT,1,0,1
"write_cb_called == 1 && ""write_cb must be called exactly once""",1,0,1
s->st_blksize == (uint64_t) t.st_blksize,1,0,1
"strstr(msg, dlerror_no_error) != NULL",1,0,1
signum == SIGUSR2,1,0,1
"0 == uv_tcp_bind(&tcp, (const struct sockaddr*) &client_addr, 0)",1,0,1
req->fs_type == UV_FS_FCHOWN,1,0,1
"0 == uv_ip4_addr(""0.0.0.0"", BASE_PORT + i, &addr)",1,0,1
req->type == UV_SIGNAL_REQ,1,0,1
!(pipe->flags & UV_HANDLE_NON_OVERLAPPED_PIPE),1,0,1
bytes_received_done == TOTAL_BYTES,1,0,1
"0 != uv_inet_pton(AF_INET6, ADDR ""%%%%"", &addr)",1,0,1
pthread_get_stacksize_np(pthread_self()) > 512*1024,1,0,1
check_cb_called == ITERATIONS,1,0,1
req->fs_type == UV_FS_RENAME,1,0,1
s->st_birthtim.tv_sec == t.st_birthtim.tv_sec,1,0,1
req != current,1,0,1
"uv_pipe_init(loop, &pipe_stdin_child, 0) == 0",1,0,1
ARRAY_SIZE(incoming) + 1 == close_called,1,0,1
"uv_pipe_init(loop, &pipe_stdout_child, 0) == 0",1,0,1
"strcmp(uv_strerror(-1337), ""Unknown error"") == 0",1,0,1
channel->ipc,1,0,1
fstat_cb_count == 1,1,0,1
handle->type == UV_SIGNAL,1,0,1
"memcmp(buf, ""test-buffer\n\0test-buffer\n\0"", sizeof(""test-buffer\n\0test-buffer\n\0"") - 1) == 0",1,0,1
"0 == uv_barrier_init(&ctx.barrier, 2)",1,0,1
c->rdstate != c_dead,1,0,1
fail_cb_called == 1,1,0,1
i == *data,1,0,1
ipc_frame.header.flags <= (UV_IPC_TCP_SERVER | UV_IPC_RAW_DATA | UV_IPC_TCP_CONNECTION),1,0,1
strlen(req->path) == 15,1,0,1
sv_recv_cb_called == 2,1,0,1
req->bufs != NULL,1,0,1
handle->pipe.conn.remaining_ipc_rawdata_bytes >= bytes,1,0,1
len > 0 && len < ARRAY_SIZE(key_name),1,0,1
buffer[0] != '\0',1,0,1
tcp_conn_write_cb_called == 1,1,0,1
"0 == uv_thread_create(&thread_id, thread_cb, NULL)",1,0,1
(s->events == 0) || (stream->flags & UV_CLOSING),1,0,1
1 == nread,1,0,1
req->handle == (uv_stream_t*) &peer_handle,1,0,1
!filename,1,0,1
height > 10,1,0,1
"!memcmp(""PING"", rcvbuf->base, nread)",1,0,1
"0 != uv_thread_equal(&main_thread_id, &main_thread_id)",1,0,1
s->st_size == (uint64_t) t.st_size,1,0,1
0 == uv_check_stop(&check_handle),1,0,1
prepare_2_cb_called == floor(ITERATIONS / 2.0),1,0,1
loop_creation_counter >= NUM_LOOP_CREATING_THREADS,1,0,1
prepare,1,0,1
"0 == uv_read_start((uv_stream_t*) storage, sv_alloc_cb, sv_read_cb)",1,0,1
"UV_EOF == uv_fs_scandir_next(&req, &dent)",1,0,1
r > 0 || r == UV_EAGAIN,1,0,1
!found_in_usr_env[i],1,0,1
0 == uv_cancel(req),1,0,1
errno == EPERM,1,0,1
s->st_ino == (uint64_t) t.st_ino,1,0,1
threads != NULL,1,0,1
"0 == uv_tcp_init(loop, (uv_tcp_t*) &pc->peer_handle)",1,0,1
"0 && ""Failed to query pollset for file descriptor""",1,0,1
(uv_tcp_t*)t == &tcp,1,0,1
connection_cb_called == 2,1,0,1
"match && !strcmp(match, path)",1,0,1
"0 == uv_prepare_start(&prepare_handle, prepare_cb)",1,0,1
"0 == uv_fs_realpath(loop, &req, ""no_such_file"", dummy_cb)",1,0,1
req->result == UV_ENAMETOOLONG,1,0,1
"!""bad uv_fs_type""",1,0,1
nread == UV_ECONNRESET || nread == UV_EOF,1,0,1
mpipe(fds_stdout) != -1,1,0,1
idle_cb_called > 0,1,0,1
fd > -1,1,0,1
once_cb_called == 10,1,0,1
"0 == uv_run(&ctx->loop, UV_RUN_DEFAULT)",1,0,1
s->st_ctim.tv_nsec == t.st_ctimespec.tv_nsec,1,0,1
close_cb_count == 3,1,0,1
(ARRAY_SIZE(tcp_outgoing) + 2) == close_cb_called,1,0,1
recv_cb_called > 0,1,0,1
((uv_stat_t*)req.ptr)->st_mode & S_IFDIR,1,0,1
uv__signal_control_handler_refs == 1,1,0,1
req->fs_type == UV_FS_SENDFILE,1,0,1
handle->type == UV_TCP || handle->type == UV_TTY || handle->type == UV_NAMED_PIPE,1,0,1
efds.fd_array[0] == handle->socket,1,0,1
"0 && ""this function should not have been called""",1,0,1
"0 == uv_ip4_addr(""127.0.0.1"", TEST_PORT, &connect_addr)",1,0,1
pipe->pipe.conn.ipc_pid != -1,1,0,1
"0 && ""unreachable code""",1,0,1
"0 == uv_send_buffer_size((uv_handle_t*) &client, &buffer_size)",1,0,1
"0 == uv_tcp_init(loop, client)",1,0,1
"0 == uv_timer_start(&timer_handle, timer_cb, 1000, 0)",1,0,1
"0 == socketpair(AF_UNIX, SOCK_STREAM, 0, fds)",1,0,1
"0 == uv_fs_event_start(event, fs_event_error_report_cb, ""watch_dir"", 0)",1,0,1
write_req.result == filler_len,1,0,1
tv.tv_sec > timebase.tv_sec || (tv.tv_sec == timebase.tv_sec && tv.tv_usec >= timebase.tv_usec),1,0,1
uv_timer_get_repeat((uv_timer_t*)handle) == 50,1,0,1
"0 == uv_listen((uv_stream_t*) &tcp_server, ARRAY_SIZE(tcp_outgoing), connection_cb)",1,0,1
test_output != NULL,1,0,1
ctx->main_seen == (unsigned int) NUM_PINGS,1,0,1
signum == ctx->signum,1,0,1
r == UV_ELOOP,1,0,1
"nested == 0 && ""timer_cb must be called from a fresh stack""",1,0,1
"uv_spawn(loop, &child_req, &options) == 0",1,0,1
0 == uv_cond_init(&signal_cond),1,0,1
s->st_ctim.tv_sec == t.st_ctimespec.tv_sec,1,0,1
!process->exit_cb_pending,1,0,1
bytes_written > 0,1,0,1
ctx->parent_handle->poll_ctx == ctx,1,0,1
command_line != NULL,1,0,1
exit_status == 42,1,0,1
((uv_stat_t*)req.ptr)->st_mode & S_IFLNK,1,0,1
handle == getaddrinfo_handle,1,0,1
"0 == uv_fs_write(loop, reqs + n++, 0, &iov, 1, 0, fs_cb)",1,0,1
readlink_cb_count == 1,1,0,1
connect_port > 0,1,0,1
req == &rmdir_req,1,0,1
"0 == uv_fs_link(loop, reqs + n++, ""/"", ""/"", fs_cb)",1,0,1
called_shutdown_cb == 1,1,0,1
idle_2_close_cb_called == idle_2_cb_started,1,0,1
"0 == uv_queue_work(loop, &req, nop_work_cb, nop_done_cb)",1,0,1
"0 == uv_timer_init(loop, &timer2_handle)",1,0,1
"0 == uv_timer_start(&timer_handle, timer_run_once_timer_cb, 1, 0)",1,0,1
!handle->req_pending,1,0,1
s->st_nlink == (uint64_t) t.st_nlink,1,0,1
timers != NULL,1,0,1
stream == (uv_stream_t*)&tcp_server,1,0,1
r == 26,1,0,1
after_work_cb_count == 0,1,0,1
!(handle->flags & UV_HANDLE_TTY_READABLE) || handle->tty.rd.read_raw_wait == NULL,1,0,1
"0 == uv_fs_realpath(loop, reqs + n++, ""/"", fs_cb)",1,0,1
1 == uv_is_writable((uv_stream_t*)&ctx2.channel),1,0,1
"0 ==uv_ip6_addr(""::1"", TEST_PORT, &server_addr)",1,0,1
recv_cb_called == alloc_cb_called,1,0,1
compare_port == 0 || check_addr.sin_port == compare_addr.sin_port,1,0,1
"0 && ""signal_unexpected_cb should never be called""",1,0,1
"memcmp(req->path + 9, ""XXXXXX"", 6) != 0",1,0,1
new_path == NULL || path != NULL,1,0,1
pc != NULL,1,0,1
"0 == uv_shutdown(sreq, handle, after_shutdown)",1,0,1
1 == close_cb_called,1,0,1
0 == uv_is_active(handle),1,0,1
sv_recv_cb_called == 0,1,0,1
req->fs_type == UV_FS_MKDTEMP,1,0,1
"0 == uv_async_init(uv_default_loop(), &handle, async_cb)",1,0,1
"UV_EINVAL == uv_fs_poll_getpath(&poll_handle, buf, &len)",1,0,1
"0 == uv_ip4_addr(""127.0.0.1"", TEST_PORT_2, &addr2)",1,0,1
signal2_cb_counter == 4 * (NUM_SIGNAL_HANDLING_THREADS / 3),1,0,1
"0 == uv_udp_bind(&sockets[i], (const struct sockaddr*) &addr, 0)",0,1,1
req->type == UV_READ,1,0,1
s->st_atim.tv_nsec == t.st_atimespec.tv_nsec,1,0,1
stream->flags & UV_CLOSED,1,0,1
s->st_uid == (uint64_t) t.st_uid,1,0,1
pipe_handle != INVALID_HANDLE_VALUE,1,0,1
"0 == uv_timer_start(&timer_handle, timer_cb, timeout, 0)",1,0,1
"0 == uv_queue_work(uv_default_loop(), req, work_cb, done_cb)",1,0,1
stderr_file != -1,1,0,1
"0 && ""Invalid signum""",1,0,1
"0 == uv_tcp_bind(&pinger->tcp, (const struct sockaddr*) &client_addr, 0)",1,0,1
"0 == uv_signal_init(loop, &ctx->handle)",1,0,1
"0 && ""Failed to delete file descriptor (pc.fd) from pollset""",1,0,1
"0 == uv_loop_configure(&loop, UV_LOOP_BLOCK_SIGNAL, SIGPROF)",1,0,1
req == &ctx.connect_req,1,0,1
0 == remove(fs_event_get_filename_in_subdir(fs_event_removed)),1,0,1
"0 == uv_udp_send(&reqs[i], &sockets[i], &buf, 1, addr, send_cb)",1,0,1
"0 && ""work2_cb called""",1,0,1
prepare_cb_called > 0,1,0,1
connect_cb_called == NUM_CLIENTS,1,0,1
conn_close_cb_called == 1,1,0,1
"0 && ""this will never be called""",1,0,1
udp.send_queue_size == 0,1,0,1
timer_cb_touch_called == 1,1,0,1
req->result == 65546,1,0,1
closed_connections == NUM_CLIENTS * 2,1,0,1
"0 == uv_timer_start(&timer, timer_cb_nop, 2, 0)",1,0,1
hostname == NULL,1,0,1
prepare_2_close_cb_called == 1,1,0,1
"!memcmp(""PONG"", buf->base, nread)",1,0,1
check,1,0,1
timer_cb_calls == 1,1,0,1
check_addr.sin_family == AF_INET,1,0,1
"0 == uv_tcp_nodelay(&client_handle, 1)",1,0,1
"uv_run(uv_default_loop(), UV_RUN_NOWAIT) == 0",1,0,1
"0 == uv_write(&write_request, (uv_stream_t *)&tcp_client, &buf, 1, write_cb)",1,0,1
0 == uv_read_stop((uv_stream_t*) p),1,0,1
write_callbacks + write_error_callbacks + write_cancelled_callbacks == REQ_COUNT,1,0,1
uv_pipe_pending_count(pipe) > 0,1,0,1
buf->base != NULL,1,0,1
"0 == uv_pipe_init(loop, (uv_pipe_t*) &pc->peer_handle, 1)",1,0,1
server.reqs_pending == 32,1,0,1
strlen(tmpdir) == len,1,0,1
"0 == uv_udp_init(uv_default_loop(), &udp)",1,0,1
"0 == uv_signal_start(&signal, sig_func, SIGUSR1)",1,0,1
((uv_stat_t*)req.ptr)->st_size == strlen(test_dir),1,0,1
"0 == uv_async_init(uv_default_loop(), &async_handle, NULL)",1,0,1
"0 == uv_inet_pton(AF_INET6, ADDR, &addr)",1,0,1
0 == uv_prepare_stop(&prepare_handle),1,0,1
err == -1,1,0,1
req->fs_type == UV_FS_READLINK,1,0,1
2 == read_cb_called,1,0,1
sizeof(scratch) >= msg.msg_controllen,1,0,1
handle->pipe.serv.accept_reqs,1,0,1
fs_req.fs_type == UV_FS_UTIME,1,0,1
req->result == 2,1,0,1
tc[i].ncalls == NSIGNALS,1,0,1
sizeof(uv_thread_t) <= sizeof(void*),1,0,1
"0 == uv_udp_recv_start(&s->udp_handle, alloc_cb, recv_cb)",1,0,1
r == UV_ENOTDIR,1,0,1
"0 == uv_accept(server, (uv_stream_t*) incoming)",1,0,1
"0 == uv_timer_start(&timer, fs_event_create_files_in_subdir, 1, 0)",1,0,1
c->t.buf == buf->base,1,0,1
r == sizeof msg || (r == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)),1,0,1
"0 == uv_timer_init(uv_default_loop(), &handle_a)",1,0,1
mkdir_cb_count == 1,1,0,1
timer_close_cb_calls == 0,1,0,1
"memcmp(buf1, buf2, len1) == 0",1,0,1
0 == uv_rwlock_init(&rwlock),1,0,1
"uv_pipe_open(&pipe_stdout_child, fds_stdout[1]) == 0",1,0,1
handle->recv_buffer.base != NULL,1,0,1
pipe->u.fd == -1 || pipe->u.fd > 2,1,0,1
"0 && ""timer_cb should not have been called""",1,0,1
"0 == uv_thread_create(threads + 0, tls_thread, threads + 0)",1,0,1
"0 && ""Shouldn't be called"" && (&name[0])",1,0,1
"0 == kill(getpid(), SIGUSR1)",1,0,1
"UV_EBADF == uv_udp_set_multicast_loop(&h, 1)",1,0,1
"0 == uv_tcp_init(handle->loop, (uv_tcp_t*) &ctx->client_handle)",1,0,1
r == 65542,1,0,1
size1 == size2,1,0,1
1 == uv_is_readable((uv_stream_t*)&ctx2.channel),1,0,1
strlen(tmpdir) == 0,1,0,1
"offsetof(uv_buf_t, base) == offsetof(struct iovec, iov_base)",1,0,1
read_cb_called == 2,1,0,1
"0 == uv_interface_addresses(&addresses, &count)",1,0,1
"0 == uv_pipe_init(server_handle->loop, (uv_pipe_t*) storage, 0)",1,0,1
loop->watchers[w->fd] == w,1,0,1
timer1_cb_called == 1,1,0,1
h != NULL,1,0,1
callback_counts[i] == 1,1,0,1
"0 == uv_fs_fchown(loop, reqs + n++, 0, 0, 0, fs_cb)",1,0,1
close_cb_called == 4,1,0,1
"0 == uv_timer_init(loop, timers + i)",1,0,1
"stricmp(req->ptr, test_file_abs_buf) == 0",1,0,1
(pevents & ~(UV_READABLE | UV_WRITABLE | UV_DISCONNECT)) == 0,1,0,1
"0 == uv_thread_create(&ctx->thread_id, server_cb, ctx)",1,0,1
req->write_buffer.base,1,0,1
err == KERN_SUCCESS,1,0,1
"0 == uv_idle_init(loop, &idle)",1,0,1
"0 == uv_ip4_addr(""1.2.3.4"", TEST_PORT, &addr)",1,0,1
"0 == uv_fs_unlink(loop, reqs + n++, ""/"", fs_cb)",1,0,1
prefix_address->sa_family == family,1,0,1
ARRAY_SIZE(tcp_outgoing) == got_connections,1,0,1
errno == EBADF,1,0,1
strlen(homedir) == 0,1,0,1
i == ARRAY_SIZE(send_fds),1,0,1
r == 0 || r == UV_EEXIST,1,0,1
"UV_EINVAL == uv_ip4_addr(""255.255.255.256"", TEST_PORT, &addr)",1,0,1
"0 == uv_timer_init(uv_default_loop(), &huge_timer2)",1,0,1
status == 0 || status == UV_ECANCELED,1,0,1
s->st_blocks == (uint64_t) t.st_blocks,1,0,1
"0 == uv_pipe_bind(&ctx.ipc_pipe, IPC_PIPE_NAME)",1,0,1
fsync_cb_count == 1,1,0,1
ctx->worker_sent == NUM_PINGS,1,0,1
fs_event_cb_called < 3,1,0,1
"0 == uv_ip4_addr(compare_ip, compare_port, &compare_addr)",1,0,1
req == &rename_req,1,0,1
"0 == uv_check_init(loop, &check_handle)",1,0,1
pwd.gid == -1,1,0,1
uv_timer_get_repeat(&repeat_1) == 50,1,0,1
"0 == uv_accept(handle, ctx->server_handle)",1,0,1
QUEUE_EMPTY(&stream->write_queue),1,0,1
signum == SIGCHLD,1,0,1
req->handle == &s->udp_handle,1,0,1
"0 == uv_fs_event_init(loop, watchers + 0)",1,0,1
connect_reqs <= req,1,0,1
result_size == sppi_size,1,0,1
req->write_index < req->nbufs,1,0,1
container != NULL,1,0,1
errno == ECHILD,1,0,1
0 == uv_timer_get_repeat(&handle),1,0,1
"0 == uv_fs_stat(loop, reqs + n++, ""/"", fs_cb)",1,0,1
"0 == uv_pipe_init(uv_default_loop(), &p, 1)",1,0,1
buf->base[0] == 'Q',1,0,1
req->fs_type == UV_FS_RMDIR,1,0,1
"0 && ""read_cb should not have been called""",1,0,1
"0 == uv_tcp_connect(&connect_reqs[i], client, addr, connect_cb)",1,0,1
ctx->main_sent == (unsigned int) NUM_PINGS,1,0,1
r < 0,1,0,1
0 == uv_async_send(&ctx->worker_async),1,0,1
req->handle == (uv_stream_t*)&tcp_connection,1,0,1
0 == errno,1,0,1
w->fd < INT_MAX,1,0,1
bytes_received == sizeof MESSAGE,1,0,1
tcp_write_cb_called == 1,1,0,1
context->sent == 0,1,0,1
prepare_1_cb_called == ITERATIONS,1,0,1
repeat_cb_called == 5,1,0,1
req->result == UV_ENOENT,1,0,1
handle->submitted_events_1 == 0,1,0,1
ftruncate_req.result == 0,1,0,1
rfds.fd_array[0] == handle->socket,1,0,1
"0 == uv_fileno((uv_handle_t*) &client_handle, &fd)",1,0,1
"0 == uv_read_start((uv_stream_t*) &tcp_check, alloc_cb, read_cb)",1,0,1
0 == uv_loop_close(uv_default_loop()),1,0,1
req->type == UV_FS,1,0,1
thread_called == 1,1,0,1
req->fs_type == UV_FS_FDATASYNC,1,0,1
s->st_ctim.tv_nsec == t.st_ctim.tv_nsec,1,0,1
(unsigned) pc.fd < loop->nwatchers,1,0,1
timer_cb_touch_called == 0,1,0,1
"0 == uv_timer_start(&tiny_timer, huge_repeat_cb, 2, 2)",1,0,1
req->fs_type == UV_FS_FTRUNCATE,1,0,1
"memcmp(""hello world\n"", buf->base, nread) == 0",1,0,1
ARRAY_SIZE(reqs) == done2_cb_called,1,0,1
rmdir_cb_count == 1,1,0,1
"uv_pipe_open(&pipe_stdin_child, fds_stdin[0]) == 0",1,0,1
r==na,1,0,1
hThread == handle->pipe.conn.readfile_thread,1,0,1
!(handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE),1,0,1
storage != NULL,1,0,1
"0 == uv_timer_start(&huge_timer2, tiny_timer_cb, (uint64_t) -1, 0)",1,0,1
(uv_stream_t*) &tcp == req->handle,1,0,1
0 == remove(fs_event_get_filename(fs_event_removed)),1,0,1
mkdtemp_cb_count == 1,1,0,1
"0 == uv_write2(&pc->write_req, (uv_stream_t*) &pc->peer_handle, &buf, 1, (uv_stream_t*) &sc->server_handle, ipc_write_cb)",1,0,1
found_in_loc_env[i],1,0,1
"0 == uv_udp_bind(&sockets[i], addr, 0)",1,0,1
"0 == uv_async_init(loop, handle, async_cb)",1,0,1
"0 == uv_ip4_addr(""0.0.0.0"", TEST_PORT, &addr1)",1,0,1
handle->exit_cb_pending,1,0,1
process_title,1,0,1
disconnects == NUM_CLIENTS * 2,1,0,1
"0 && ""unexpected handle""",1,0,1
0 == uv_thread_join(tids + i),1,0,1
repeat_1_cb_called == 10,1,0,1
symlink_cb_count == 1,1,0,1
req->fs_type == UV_FS_REALPATH,1,0,1
"strncmp(filename, file_prefix_in_subdir, sizeof(file_prefix_in_subdir) - 1) == 0",1,0,1
handle->tcp.conn.read_buffer.base != NULL,1,0,1
req <= connect_reqs + ARRAY_SIZE(connect_reqs),1,0,1
old == NULL,1,0,1
"0 == uv_ip6_addr(""::"", 0, &baddr)",1,0,1
s->st_birthtim.tv_nsec == t.st_birthtimespec.tv_nsec,1,0,1
async_cb_called == 3,1,0,1
0 == uv_timer_stop(&handle_a),1,0,1
!(handle->flags & UV_HANDLE_CANCELLATION_PENDING),1,0,1
s->st_rdev == (uint64_t) t.st_rdev,1,0,1
0 == uv_is_closing((uv_handle_t*)&ctx2.channel),1,0,1
"0 == uv_fs_readlink(loop, reqs + n++, ""/"", fs_cb)",1,0,1
read_cb_called > 0,1,0,1
"shutdown_cb_called == 1 && ""shutdown_cb must be called exactly once""",1,0,1
"0 == uv_timer_start(timers + i, timer_cb, timeout, 0)",1,0,1
context->read == TRANSFER_BYTES,1,0,1
homedir[len - 1] != '\\',1,0,1
(s->st_mode & 0777) & mode,1,0,1
"0 == uv_tcp_init(loop, &tcp_handle)",1,0,1
0 == uv_is_active((const uv_handle_t *) &pipe_handle),1,0,1
s->st_gid == (uint64_t) t.st_gid,1,0,1
"0 != uv_inet_pton(AF_INET6, ADDR ""%en1"", &addr)",1,0,1
s->st_mtim.tv_sec == t.st_mtimespec.tv_sec,1,0,1
"memcmp(""world\n"", buf->base, nread) == 0",1,0,1
wfds.fd_array[0] == handle->socket,1,0,1
"(fp = fopen(FIXTURE, ""w+""))",1,0,1
"0 == uv_fs_chown(loop, reqs + n++, ""/"", 0, 0, fs_cb)",1,0,1
"0 == uv_ip4_addr(""127.255.255.255"", TEST_PORT, &addr)",1,0,1
"strncmp(filename, file_prefix, sizeof(file_prefix) - 1) == 0",1,0,1
handle->send_queue_size == 0,1,0,1
nread > 0 || nread == UV_EOF,1,0,1
*flag == 0,1,0,1
"0 == uv_write(&write_req, (uv_stream_t*) &peer_handle, &buf, 1, write_cb)",1,0,1
server->flags & UV_HANDLE_TCP_SINGLE_ACCEPT,1,0,1
knp->data_type == KSTAT_DATA_INT32 || knp->data_type == KSTAT_DATA_INT64,1,0,1
w->pevents == POLLIN,1,0,1
"0 == uv_tcp_bind(&tcp_server, (const struct sockaddr*) &addr)",0,1,1
"!uv__io_active(&stream->io_watcher, UV__POLLOUT) || !QUEUE_EMPTY(&stream->write_completed_queue) || !QUEUE_EMPTY(&stream->write_queue) || stream->shutdown_req != NULL || stream->connect_req != NULL",0,1,1
"0 == uv_ip6_addr(""::"", TEST_PORT_2, &addr2)",1,0,1
write_reqs != NULL,1,0,1
"filename == NULL || strncmp(filename, file_prefix, sizeof(file_prefix) - 1) == 0",1,0,1
open_req2.result >= 0,1,0,1
handle == (uv_handle_t*) &tcp,1,0,1
utime_cb_count == 1,1,0,1
"strcmp(req.ptr, test_dir + 4) == 0",1,0,1
fd_to_send >= 0,1,0,1
after_work_cb_count == 1,1,0,1
r >= 15,1,0,1
"UV_ENOSYS == uv_loop_configure(&loop, UV_LOOP_BLOCK_SIGNAL, 0)",1,0,1
0 == (slave_tty.flags & 0x80),1,0,1
homedir[0] == '/',1,0,1
req->result == UV_ECANCELED,1,0,1
"connect_cb_called == 1 && ""connect_cb must be called exactly once""",1,0,1
"nested == 0 && ""close_cb must be called from a fresh stack""",1,0,1
idle_1_close_cb_called == IDLE_COUNT,1,0,1
getpeernamecount == 3,1,0,1
((uv_stat_t*)stat_req.ptr)->st_mode & S_IFDIR,1,0,1
req == &mkdtemp_req1,1,0,1
found_in_usr_env[i],1,0,1
close_cb_called == NUM_TIMERS,1,0,1
"0 == uv_stream_set_blocking((uv_stream_t*) &client_handle, 1)",1,0,1
stream->alloc_cb != NULL,1,0,1
handle == &(name)[0],1,0,1
bytes == sizeof(ipc_frame) - sizeof(ipc_frame.header),1,0,1
loop->nfds > 0,1,0,1
fdatasync_cb_count == 1,1,0,1
"0 == uv_fs_fsync(loop, reqs + n++, 0, fs_cb)",1,0,1
wfds.fd_count == 1,1,0,1
"0 == uv_timer_start(&timer, timer_cb, 100, 0)",1,0,1
len1 == len2,1,0,1
done_cb_called == num_threads + 1,1,0,1
udpServer.send_queue_size == 0,1,0,1
"0 == uv_ip4_addr(""0.0.0.0"", 0, &baddr)",1,0,1
pending == UV_UNKNOWN_HANDLE,1,0,1
read_req.result == 26,1,0,1
handle == (uv_stream_t*)&ctx2.listen,1,0,1
called_timer_close_cb == 0,1,0,1
"0 == uv_signal_init(loop, &signal)",1,0,1
nread == sizeof(test_buf),1,0,1
"0 == uv_timer_init(loop, &timer1_handle)",1,0,1
"0 == uv_stream_set_blocking((uv_stream_t*) &client_handle, 0)",1,0,1
"strcmp(req.ptr, test_dir) == 0",1,0,1
timer_called == 10,1,0,1
after_write_cb_called == 1,1,0,1
"-1 == write(fd, ""x"", 1)",1,0,1
(int64_t)((uv_stat_t*)stat_req.ptr)->st_size == offset + (int64_t)(iovcount * sizeof(test_buf)),1,0,1
"0 == uv_ip4_addr(""8.8.8.8"", 9999, &addr)",1,0,1
"0 == uv_thread_create(&thread, thread_rwlock_trylock_peer, NULL)",1,0,1
req->fs_type == UV_FS_READ,1,0,1
r == 6,1,0,1
"0 == uv_queue_work(loop, reqs + i, work2_cb, done2_cb)",1,0,1
"uv_pipe_init(loop, &pipe_stdin_parent, 0) == 0",1,0,1
"0 && ""Bad serverType""",1,0,1
"0 == socketpair(AF_UNIX, SOCK_STREAM, 0, send_fds + i)",1,0,1
2 == timer_run_once_timer_cb_called,1,0,1
idle_counter == NUM_TICKS,1,0,1
uv_has_ref((uv_handle_t*)&h) == 1,1,0,1
s->st_mtim.tv_nsec == t.st_mtim.tv_nsec,1,0,1
server == s,1,0,1
open_cb_count == 2,1,0,1
GetLastError() == ERROR_BROKEN_PIPE,1,0,1
"0 && ""should not be called""",1,0,1
fs_event_cb_called == 3,1,0,1
"strncmp(""hello errworld\n"", output, 15) == 0",1,0,1
status == UV_ENOTSOCK || status == UV_ECONNREFUSED,1,0,1
r > 0 || got_eagain(),1,0,1
"0 == uv_thread_equal(subthreads + 0, subthreads + 1)",1,0,1
"0 == uv_ip6_addr(scoped_addr, TEST_PORT, &addr)",1,0,1
"0 == uv_pipe_init(uv_default_loop(), &in, 0)",1,0,1
new_time >= loop->time,1,0,1
"0 == uv_sem_init(&ctx->semaphore, 0)",1,0,1
"0 && ""bad handle in close_cb""",1,0,1
close_cb_called == 7,1,0,1
0 == uv_read_stop((uv_stream_t*) &tcp_handle),1,0,1
"filename == NULL || strcmp(filename, ""watch_file"") == 0",1,0,1
r == UV_EMSGSIZE,1,0,1
r == UV_ENAMETOOLONG,1,0,1
"0 == uv_fs_symlink(loop, reqs + n++, ""/"", ""/"", 0, fs_cb)",1,0,1
req->accept_socket == INVALID_SOCKET,1,0,1
req == &read_req,1,0,1
prepare_called > 1,1,0,1
"0 == uv_tcp_init(loop, &tcp_server)",1,0,1
output_used == 12,1,0,1
"0 == uv_timer_init(loop, &ctx->handle)",1,0,1
context->sent == TRANSFER_BYTES,1,0,1
tio != NULL,1,0,1
