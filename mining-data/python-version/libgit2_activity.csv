x_val,y_added,y_removed,y_combined
git_buf_oom(&buf) == 0,87,58,145
ignored,67,65,132
!ignored,60,59,119
"0, exp.file_status[GIT_DELTA_ADDED]",68,33,101
"1, exp.file_status[GIT_DELTA_DELETED]",60,30,90
"test_file_contents(GIT_MERGE_MODE_FILE, """")",44,44,88
"1, exp.file_status[GIT_DELTA_MODIFIED]",56,28,84
"git_oid_cmp(&id1, &id2) == 0",46,34,80
"test_file_contents(GIT_ORIG_HEAD_FILE, ORIG_HEAD ""\n"")",48,25,73
repo,41,27,68
"GIT_ITEROVER, error",40,24,64
"1, expected.files",31,26,57
"1, exp.files",36,20,56
0,35,21,56
git_index_reuc_entrycount(repo_index) == 0,32,22,54
"0, exp.file_adds",27,27,54
p != NULL,33,20,53
"4, exp.files",37,15,52
"0, expected.files_binary",29,23,52
"0, counts.wrong_sorted_path",37,14,51
"GITERR_INVALID, err->klass",32,19,51
"0, counts.wrong_status_flags_count",37,14,51
"counts.expected_entry_count, counts.entry_count",36,14,50
&expected,33,17,50
git_index_reuc_entrycount(result) == 0,30,20,50
GIT_SUBMODULE_STATUS_IS_UNMODIFIED(status),31,16,47
delta != NULL,27,17,44
sm,24,20,44
patch,28,16,44
"1, expected.hunks",23,20,43
"0, exp.file_status[GIT_DELTA_DELETED]",27,15,42
"1, exp.file_status[GIT_DELTA_RENAMED]",28,13,41
"expected_count, count",24,17,41
ref,27,14,41
"0, exp.file_status[GIT_DELTA_IGNORED]",27,13,40
_backend,21,19,40
"0, exp.files",26,14,40
index,30,9,39
"1, (int)git_diff_num_deltas(diff)",26,13,39
entry,25,13,38
"2, exp.file_status[GIT_DELTA_MODIFIED]",27,11,38
remote,27,11,38
i == 1,22,15,37
"0, error",21,16,37
!git_merge_result_is_fastforward(result),18,18,36
"1, exp.file_mods",18,18,36
git_index_entrycount(index) == 0,23,12,35
"1, expected.file_status[GIT_DELTA_MODIFIED]",18,17,35
assign,21,14,35
"0, exp.file_dels",17,17,34
"GIT_ENOTFOUND, error",20,14,34
"2, exp.files",22,12,34
"0, exp.hunks",21,13,34
"1, exp.file_status[GIT_DELTA_IGNORED]",24,10,34
"3, exp.files",22,11,33
"2, result.count",20,12,32
"entrycount - 1, git_reflog_entrycount(g_reflog)",19,13,32
giterr_last() != NULL,21,10,31
rule->assigns.length == 1,18,12,30
!error || error == GIT_ITEROVER,18,12,30
"1, exp.hunks",18,12,30
"1, exp.file_status[GIT_DELTA_ADDED]",20,9,29
"0, exp.line_dels",17,12,29
"""12341234123412341234"", git_buf_cstr(&buf)",16,12,28
"git_oid_cmp(&reuc->oid[2], &oid) == 0",14,14,28
false,17,11,28
"1, git_diff_num_deltas(diff)",19,9,28
"1, exp.file_status[GIT_DELTA_UNMODIFIED]",21,7,28
exp.files == 1,14,14,28
"git_oid_cmp(&reuc->oid[0], &oid) == 0",14,14,28
"0, exp.file_status[GIT_DELTA_MODIFIED]",18,10,28
status_flags == GIT_STATUS_WT_NEW,17,11,28
"git_oid_cmp(&reuc->oid[1], &oid) == 0",14,14,28
"expected, git_buf_cstr(&buf)",18,10,28
"1, exp.line_adds",16,11,27
merge_trivial_conflict_entrycount() == 0,18,9,27
"""Hello world!"", git_buf_cstr(&_buf)",18,9,27
merge_trivial_conflict_entrycount(result) == 0,18,9,27
"1, exp.file_status[GIT_DELTA_UNTRACKED]",19,8,27
S_ISREG(st.st_mode),22,5,27
fd >= 0,15,12,27
submodule,19,8,27
"test_file_contents(GIT_MERGE_MODE_FILE, ""no-ff"")",25,2,27
file.buffer == NULL,16,10,26
"git_oid_equal(&a, &b)",13,13,26
"strcmp(git_buf_cstr(&buf), stat) == 0",14,12,26
"1, (int)git_patch_num_hunks(p)",16,10,26
git_reference_type(ref) & GIT_REF_OID,17,9,26
"6, exp.files",17,9,26
merge_trivial_conflict_entrycount(result) == 2,14,11,25
n == 2,15,10,25
"GIT_REF_SYMBOLIC, git_reference_type(head)",15,10,25
buf.size == 0,15,10,25
merge_trivial_conflict_entrycount() == 2,14,11,25
result.status == GIT_STATUS_WT_NEW,15,10,25
git_buf_oom(&a) == 0,15,10,25
"2, exp.file_status[GIT_DELTA_DELETED]",17,8,25
ENOTDIR,16,9,25
table != NULL,12,12,24
"(b = resolve_commit_oid_to_tree(g_repo, b_commit)) != NULL",16,8,24
"strcmp(git_buf_cstr(&buf), email) == 0",12,12,24
written == 0,16,8,24
values[0] == GIT_ATTR_TRUE,12,12,24
reuc->mode[1] == 0100644,16,8,24
"0, expected.line_dels",12,12,24
"(a = resolve_commit_oid_to_tree(g_repo, a_commit)) != NULL",16,8,24
reuc->mode[2] == 0100644,16,8,24
""""", git_buf_cstr(&buf)",15,9,24
ENOENT,16,8,24
"4, exp.file_status[GIT_DELTA_MODIFIED]",17,7,24
st.status == GIT_STATUS_IGNORED,16,8,24
"10, item->value",16,8,24
tree,15,8,23
out,17,6,23
"3, exp.file_status[GIT_DELTA_UNTRACKED]",15,8,23
"""refs/heads/master"", git_reference_symbolic_target(head)",14,9,23
"remote, NULL",13,10,23
out && repo,19,4,23
"repo, ""when"", GIT_STATUS_WT_NEW",19,3,22
git_index_entrycount(repo_index) == 8,15,7,22
"!git_path_exists(""./foo"")",12,10,22
git_index_entrycount(index) == 1,14,8,22
"3, exp.file_status[GIT_DELTA_MODIFIED]",15,7,22
object,11,11,22
commit,15,7,22
"4, exp.file_status[GIT_DELTA_DELETED]",16,6,22
S_ISDIR(st.st_mode),17,5,22
"1, exp.file_ignored",11,11,22
"0, git_pathspec_match_list_entrycount(m)",14,7,21
"repo, ""how"", GIT_STATUS_CURRENT",19,2,21
obj,12,9,21
"test_string, git_buf_cstr(&buf)",12,9,21
file.buffer != NULL,13,8,21
"""foo"", git_buf_cstr(&a)",12,9,21
reuc->mode[0] == 0100644,14,7,21
"1, result.count",13,8,21
"pass, NULL",13,8,21
error == GIT_ENOTFOUND,13,8,21
"1, exp.line_ctxt",12,9,21
"0, git_pathspec_match_list_failed_entrycount(m)",14,7,21
"false, git_path_isfile(""./testrepo/README"")",13,8,21
values[1] == GIT_ATTR_TRUE,10,10,20
!entry,12,8,20
"2, exp.file_status[GIT_DELTA_ADDED]",13,7,20
GIT_ATTR_TRUE(values[0]),14,6,20
GIT_ATTR_TRUE(value),13,7,20
assign->value == GIT_ATTR_TRUE,10,10,20
"0, expected.line_ctxt",10,10,20
"2, exp.file_status[GIT_DELTA_RENAMED]",13,7,20
"GIT_ENOTFOUND, git_submodule_lookup(&sm, g_repo, ""just_a_dir"")",10,10,20
" GIT_ENOTFOUND, git_futils_find_global_file(&found, testfile)",10,10,20
i == 123,12,8,20
"str, ""huzzah""",10,10,20
entry->mode != GIT_FILEMODE_TREE,12,8,20
"GIT_EEXISTS, git_submodule_lookup(&sm, g_repo, ""not-submodule"")",10,10,20
asize < path.asize,12,8,20
expected.files == 1,10,10,20
"git_oid_cmp(&result, &expected) == 0",10,10,20
repo != NULL,11,8,19
"false, git_repository_head_detached(repo)",13,6,19
"5, exp.files",13,6,19
path,12,7,19
"merge_test_index(repo_index, merge_index_entries, 8)",13,6,19
"git_refspec_src(_refspec), ""refs/heads/*""",10,9,19
"git_oid_cmp(&id_commit, git_commit_id(commit)) == 0",11,8,19
"test_file_contents(GIT_MERGE_HEAD_FILE, OCTO1_OID ""\n"")",12,7,19
"13, exp.files",13,6,19
"3, exp.line_ctxt",12,7,19
(delta = git_patch_get_delta(patch)) != NULL,13,6,19
"host, ""example.com""",13,6,19
commit != NULL,11,8,19
str_in_error != NULL,12,6,18
"1, (int)git_diff_patch_num_hunks(p)",9,9,18
st.status == GIT_STATUS_WT_NEW,12,6,18
git_path_exists(temp_path.ptr),12,6,18
"error, GIT_ITEROVER",14,4,18
"committer, entry->committer",10,8,18
(status & GIT_SUBMODULE_STATUS_WD_MODIFIED) != 0,12,6,18
"GIT_REPOSITORY_STATE_REBASE_MERGE, git_repository_state(repo)",18,0,18
"4, exp.file_mods",9,9,18
"2, exp.file_status[GIT_DELTA_UNTRACKED]",12,6,18
"current_master_tip, oid_str",9,9,18
GIT_ATTR_TRUE(assign->value),12,6,18
"merge_test_index(repo_index, merge_index_entries, 6)",12,6,18
"test_file_contents(GIT_MERGE_HEAD_FILE, OCTO1_OID ""\n"" OCTO2_OID ""\n"")",12,6,18
i == 0,11,7,18
"path, ""/resource""",12,6,18
"0, exp.lines",11,7,18
"entry = git_index_get_byindex(repo_index, i)",12,6,18
fd != 0,9,9,18
"0, exp.file_status[GIT_DELTA_UNTRACKED]",12,6,18
"4, exp.file_dels",9,9,18
"0, (int)git_patch_num_hunks(p)",12,6,18
git_index_entry_stage(entry) == 0,10,7,17
status_flags == GIT_STATUS_INDEX_NEW,10,7,17
"GIT_REPOSITORY_STATE_NONE, git_repository_state(repo)",17,0,17
"GIT_DELTA_MODIFIED, delta->status",9,8,17
"g_repo, ""master""",14,3,17
git_remote_pushurl(_remote) == NULL,9,8,17
giterr_last() == NULL,13,4,17
map != NULL,11,6,17
GIT_REPOSITORY_STATE_NONE,15,2,17
"1, exp.file_status[GIT_DELTA_COPIED]",13,4,17
"git_oid_cmp(&id1, &entry->oid) == 0",8,8,16
expected.at_least_one_of_them_is_binary == false,8,8,16
"1, v",8,8,16
exp.hunks == 1,8,8,16
git_reference_type(ref) == GIT_REF_OID,10,6,16
"false, git_path_isfile(""./testrepo/new.txt"")",10,6,16
len > 0,8,8,16
"git_oid_cmp(&conflict_entry[1]->oid, &oid) == 0",8,8,16
"merge_test_index(index, merge_index_entries, 6)",14,2,16
"8, exp.hunks",10,6,16
"git_oid_cmp(&entry->oid, &expected_oid) == 0",8,8,16
index->entries.sorted,8,8,16
"0, exp.line_ctxt",9,7,16
(st.st_mode & 0777) == 0777,8,8,16
n == 1,8,8,16
"git_oid_cmp(&conflict_entry[0]->oid, &oid) == 0",8,8,16
ctx,12,4,16
"false, git_path_isfile(""./testrepo/branch_file.txt"")",10,6,16
exp.at_least_one_of_them_is_binary == false,8,8,16
"0, exp.file_mods",8,8,16
"60, (int)p.items",8,8,16
"git_oid_cmp(&conflict_entry[2]->oid, &oid) == 0",8,8,16
rule->match.flags == 0,8,8,16
"2, expect.file_status[GIT_DELTA_MODIFIED]",10,5,15
"reference->name, loose_tag_ref_name",9,6,15
INVALID_HANDLE_VALUE != find_handle,9,6,15
GIT_ATTR_TRUE(values[1]),10,5,15
"(item = git_sortedcache_entry(sc, 0)) != NULL",10,5,15
x.length == 10,9,6,15
"1, git_pathspec_match_list_failed_entrycount(m)",10,5,15
"repo, ""just.ignore"", GIT_STATUS_IGNORED",10,5,15
"30, item->value",10,5,15
result.status == GIT_STATUS_INDEX_NEW,9,6,15
git_trace_level() == GIT_TRACE_INFO,9,6,15
"""foo@example.com"", git_reflog_entry_committer(entry)->email",10,5,15
x.length == 4,10,5,15
(error == 0 && entry != NULL) || (error == GIT_ITEROVER && entry == NULL),9,6,15
_refspec != NULL,8,7,15
i == 5,9,6,15
"exp, out",9,6,15
"(entry = git_index_get_byindex(repo_index, entry_idx)) != NULL",10,5,15
git_repository_is_bare(g_repo),9,6,15
"user, ""user""",10,5,15
"test_file_contents(GIT_MERGE_HEAD_FILE, OCTO1_OID ""\n"" OCTO2_OID ""\n"" OCTO3_OID ""\n"")",10,5,15
"GIT_STATUS_WT_MODIFIED, status",9,6,15
"10, git_pathspec_match_list_entrycount(m)",10,5,15
"3, exp.lines",9,6,15
file->rules.length == 3,9,6,15
"""two.txt"", reuc->path",10,5,15
"2, expect.files",10,5,15
"1, expected.files_binary",10,5,15
"repo, ""who"", GIT_STATUS_CURRENT",12,3,15
g_data[i].type == git_object_type(obj),10,5,15
"merge_test_reuc(repo_index, merge_reuc_entries, 3)",11,4,15
"repo, ""testrepo"", GIT_STATUS_WT_MODIFIED",10,5,15
"2, git_index_reuc_entrycount(repo_index)",10,5,15
"GIT_DELTA_MODIFIED, (int)delta->status",10,5,15
reference_is_packed(reference) == 0,10,5,15
"3, exp.file_untracked",7,7,14
"behind, 2",8,6,14
expected,7,7,14
x.length == 2,9,5,14
"5, exp.line_dels",9,5,14
"result = merge_simple_branch(0, 0)",7,7,14
"13 + 3, g_diff_perf.stat_calls",7,7,14
""""", a.ptr",8,6,14
"1, g_diff_perf.submodule_lookups",7,7,14
exp,7,7,14
"expected_path, joined_path.ptr",8,6,14
"fun, a.ptr",8,6,14
(st.st_mode & 0777) == 0755,7,7,14
"git_refspec_dst(_refspec), ""refs/*""",8,6,14
"REP4(""0123456789""), data",8,6,14
"test_4096, git_buf_cstr(&buf)",8,6,14
"ahead, 2",8,6,14
"0, exp.file_ignored",7,7,14
hunk,9,5,14
"merge_test_index(index, merge_index_entries, 8)",13,1,14
walk,10,4,14
"test_string_x2, git_buf_cstr(&buf)",8,6,14
"behind, 1",8,6,14
"""myAttr"", assign->name",8,6,14
"git_refspec_src(_refspec), ""refs/*""",8,6,14
str && *str == '\0' && str != out,8,6,14
"expected_result, git_buf_cstr(&buf)",8,6,14
"false, ""File.txt""",9,5,14
a,9,5,14
""""", data",8,6,14
"1, count",9,5,14
git_index_name_entrycount(repo_index) == 0,8,5,13
b,8,5,13
"git_path_isfile(""testrepo/a/b.txt"")",9,4,13
"0, expected.lines",8,5,13
"git_remote_url(_remote), ""git://github.com/libgit2/libgit2""",7,6,13
"6, counts.entry_count",10,3,13
"git_odb_exists(_odb, &id) == 1",8,5,13
os != NULL,8,5,13
"0, expected.hunks",8,5,13
"14, exp.lines",8,5,13
" GIT_FILEMODE_BLOB, git_tree_entry_filemode(entry)",8,5,13
delta,7,6,13
git_repository_path(repo) != NULL,8,5,13
"stat, git_buf_cstr(&buf)",12,0,12
git_repository_head_detached(repo) == 0,6,6,12
"git_oid_cmp(&oid, &entry->id) == 0",6,6,12
expected.hunks == 1,6,6,12
"GIT_DIFF_LINE_ADDITION, (int)line->origin",8,4,12
"false, git_branch_is_head(branch)",8,4,12
error != GIT_ENOTFOUND,7,5,12
"(item = git_sortedcache_entry(sc, 2)) != NULL",8,4,12
git_repository_is_bare(barerepo),8,4,12
"git_oid_cmp(&expected, &entry->oid) == 0",6,6,12
"cl_fixture(""attr/attr1""), file->path",6,6,12
"GIT_EEXISTS, git_submodule_lookup(&sm, g_repo, ""not"")",6,6,12
"cl_toggle_filemode(""issue_592/a.txt"")",8,4,12
error != 0,8,4,12
"conndata.pass, NULL",8,4,12
" GIT_ENOTFOUND, git_object_lookup(&object, g_repo, &oid, GIT_OBJ_TAG)",7,5,12
"git_oid_cmp(&expected, oid) == 0",6,6,12
"GIT_DIFF_LINE_DELETION, (int)line->origin",8,4,12
"cl_fixture(""attr/attr0""), file->path",6,6,12
error == -1,8,4,12
"git__suffixcmp(git_repository_workdir(repo2), repo_wd) == 0",8,4,12
S_ISLNK(st.st_mode),10,2,12
"buffer, """"",6,6,12
git_repository_head_orphan(repo) == 0,6,6,12
"git_oid_cmp(&id, git_reference_target(resolved_ref)) == 0",6,6,12
"1, expected->files",8,4,12
"merge_test_index(repo_index, merge_index_entries, 4)",10,2,12
"4, exp.file_status[GIT_DELTA_UNTRACKED]",9,3,12
"0, git_oid_cmp(git_object_id(g_expectedobject), git_object_id(g_actualobject))",6,6,12
"3, expected.lines",6,6,12
"170, (int)p.items",6,6,12
"0, expect.file_status[GIT_DELTA_ADDED]",8,4,12
reference_is_packed(another_looked_up_ref) == 0,8,4,12
"""final"", item->path",8,4,12
values[2] == NULL,6,6,12
"buffer, ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""12345678\n""",6,6,12
"2, git_pathspec_match_list_failed_entrycount(m)",8,4,12
object != NULL,8,4,12
"expected1, text",6,6,12
"0, (int)git_diff_patch_num_hunks(p)",6,6,12
"test_file_contents(GIT_MERGE_HEAD_FILE, OCTO1_OID ""\n"" OCTO2_OID ""\n"" OCTO3_OID ""\n"" OCTO4_OID ""\n"")",8,4,12
"""modified_file"", git_pathspec_match_list_entry(m, 1)",8,4,12
filter,8,4,12
cb_data.i == cb_data.len,8,4,12
cred,7,5,12
"2, exp.line_dels",8,4,12
"merge_test_index(repo_index, merge_index_entries, 3)",10,2,12
"20, item->value",8,4,12
repo && name,10,2,12
"reuc = git_index_reuc_get_byindex(repo_index, 0)",8,4,12
ptrs[i] != NULL,6,6,12
cfg->files.length,6,6,12
"str, """"",6,6,12
"git_sortedcache_entry(sc, 0) == NULL",8,4,12
values[2] == GIT_ATTR_FALSE,6,6,12
reference_is_packed(looked_up_ref) == 0,8,4,12
"git_oid_streq(git_submodule_index_id(sm), oid) == 0",8,4,12
g_data[i].type == git_odb_object_type(odb_obj),8,4,12
"0, pos",8,4,12
"strcmp(exp, out) == 0",6,6,12
"a.ptr, """"",8,4,12
" GIT_ENOTFOUND, git_futils_find_global_file(&path, ""nonexistentfile"")",6,6,12
"12, exp.files",7,5,12
"0, expect.file_status[GIT_DELTA_DELETED]",8,4,12
"""Short\n"", buffer",6,6,12
reuc_entry_exists() == false,8,4,12
"-1, line->old_lineno",8,4,12
!git_path_exists(temp_path.ptr),8,4,12
"expected, text",6,6,12
"git_path_exists(""stash/zero.txt"")",8,4,12
git_reference_is_packed(looked_up_ref) == 0,6,6,12
table,6,6,12
(rule->match.flags & GIT_ATTR_FNMATCH_HASWILD) != 0,8,4,12
" (int)GIT_SUBMODULE_UPDATE_REBASE, (int)git_submodule_update(sm1)",6,6,12
"git_remote_supported_url(""git://github.com/libgit2/libgit2"")",6,6,12
"git__suffixcmp(git_repository_path(repo2), repo_path) == 0",8,4,12
"1, git_submodule_fetch_recurse_submodules(sm1)",6,6,12
"(item = git_sortedcache_entry(sc, 1)) != NULL",8,4,12
index->on_disk,8,4,12
" (int)GIT_SUBMODULE_IGNORE_UNTRACKED, (int)git_submodule_ignore(sm1)",6,6,12
"conndata.user, NULL",8,4,12
exp.file_mods == 1,6,6,12
"GIT_DIFF_LINE_CONTEXT, (int)line->origin",8,4,12
"0, count",8,4,12
"ahead, 1",7,5,12
"""current_file"", git_pathspec_match_list_entry(m, 0)",8,4,12
"3, expected.line_adds",6,6,12
"git_oid_equal(git_blob_id(d), &delta->new_file.oid)",6,6,12
values[3] == NULL,6,6,12
crlf != NULL,10,2,12
"1, ignored",10,1,11
"GIT_DELTA_DELETED, delta->status",8,3,11
"git_path_isfile(""testrepo/branch_file.txt"")",8,3,11
"12, exp.hunks",7,4,11
"false, git_path_isdir(""./testrepo/ab/"")",8,3,11
"true, ""NewFolder/NewFolder/File.txt""",7,4,11
found,6,5,11
GIT_ATTR_FALSE(value),7,4,11
"true, ""NewFolder""",7,4,11
"expected, buf.ptr",8,3,11
"expected.ptr, actual.ptr",7,4,11
"repo, ""what"", GIT_STATUS_CURRENT",9,2,11
GIT_ATTR_FALSE(values[2]),8,3,11
ptr != NULL,6,5,11
"8, exp.files",8,3,11
GIT_ATTR_UNSPECIFIED(values[3]),8,3,11
git_repository_workdir(repo) != NULL,7,4,11
i == 7,6,5,11
"2, count",8,3,11
callcount > 0,8,3,11
"git_oid_streq(&entry->oid_old, GIT_OID_HEX_ZERO) == 0",7,4,11
v,9,2,11
"16, exp.files",7,4,11
!git_repository_is_bare(_repo),8,3,11
"user, NULL",7,4,11
"true, ""NewFolder/NewFolder""",7,4,11
entry != NULL,8,3,11
"exp, big",7,4,11
"git_index_has_conflicts(repo_index), 0",11,0,11
l == expected,7,4,11
GIT_ATTR_UNSPECIFIED(value),7,4,11
out && db && id,6,5,11
"0, (int)git_index_entrycount(index)",7,4,11
entrycount > 2,7,4,11
"6, (int)git_treebuilder_entrycount(builder)",7,3,10
counts.entry_count == counts.expected_entry_count,5,5,10
_struct_count == 10,6,4,10
"link_size, strlen(""new.txt"")",6,4,10
"expected_new, exp.file_status[GIT_DELTA_ADDED]",6,4,10
"""just.ignore"", GIT_STATUS_IGNORED",5,5,10
repo && diff,5,5,10
"5, g_diff_perf.oid_calcs",5,5,10
"0, problems.count",10,0,10
result.status == GIT_STATUS_IGNORED,6,4,10
" 0, git__strncmp(""hero"", git_filter_source_path(source), 4)",6,4,10
"&head_id, git_commit_id(head_commit)",10,0,10
obj->raw.type == type,5,5,10
exp.line_ctxt == 3,5,5,10
ref_in,5,5,10
git_buf_oom(&tgt) == 0,6,4,10
"GIT_DELTA_MODIFIED, git_diff_patch_delta(p)->status",5,5,10
p,7,3,10
out && loc,6,4,10
obj->raw.len == len,5,5,10
"false, invoked",6,4,10
"3, exp.file_mods",5,5,10
"MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, _source, -1, wsource, MAX_PATH)",6,4,10
"2, exp.line_ctxt",7,3,10
"git_oid_cmp(&expected_id, &actual_id) == 0",5,5,10
"port, ""8080""",7,3,10
delta == NULL,5,5,10
counts.wrong_sorted_path == 0,5,5,10
"(entry = git_index_get_bypath(index, ""automergeable.txt"", 0)) != NULL",7,3,10
"!git_path_isdir(""testrepo/a"")",7,3,10
"!strcmp(git_refspec_src(_refspec), ""refs/heads/*"")",5,5,10
"2, exp.file_adds",5,5,10
"expected_new + 2, exp.files",6,4,10
!rule->match.directory,5,5,10
git_object_owner((const git_object *)tree) == repo,5,5,10
"strcmp(reuc->path, ""two.txt"") == 0",5,5,10
i == 1 * 1024,6,4,10
ERROR_NO_MORE_FILES == GetLastError(),6,4,10
"GIT_FILEMODE_TREE, entry->mode",6,4,10
"true, fetch_progress_cb_was_called",6,4,10
expected.file_mods == 1,5,5,10
"14, expected.lines",6,4,10
exp.line_ctxt == 1,5,5,10
counts.wrong_status_flags_count == 0,5,5,10
"0, git_push_unpack_ok(push)",5,5,10
p->index_map.data,6,4,10
"link_data, ""new.txt""",6,4,10
"expected_new + 1, exp.files",6,4,10
"GIT_STATUS_CURRENT, status",6,4,10
i == 1 * 1024 * 1024 * 1024,6,4,10
i == -2147483648LL,6,4,10
diff,7,3,10
git_reference_is_packed(reference) == 0,5,5,10
"!git_oid_cmp(git_note_oid(_note), &note_oid)",5,5,10
"expect_path, entry->path",6,4,10
"1, expected.file_status[GIT_DELTA_ADDED]",6,4,10
file->rules.length == 10,6,4,10
"4, exp.line_adds",6,4,10
i == 1 * 1024 * 1024,6,4,10
GIT_ATTR_UNSPECIFIED(values[2]),7,3,10
i == 2147483647,6,4,10
diff && repo,5,5,10
status_flags == GIT_STATUS_IGNORED,6,4,10
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge branch '"" OCTO1_BRANCH ""'\n"")",6,4,10
git_repository_is_empty(_repo),7,3,10
"0, git_diff_num_deltas(diff)",9,1,10
"_repo, ""remote.test.fetch"", false",6,4,10
git_buf_oom(&buf2) == 0,6,4,10
"1, exp.line_dels",6,4,10
"&_pathspecs, false, NULL",7,3,10
"1, expected.file_mods",5,5,10
"GIT_EEXISTS, git_branch_move(&new_ref, original_ref, ""master"", 0)",6,4,10
"2, expected.hunks",6,4,10
out && db,6,4,10
git_object_type(obj) == GIT_OBJ_COMMIT,5,5,10
!rule->match.fullpath,5,5,10
"_repo, ""remote.just/renamed.fetch"", false",6,4,10
"7, counts.entry_count",8,2,10
"expected_new + 1, exp.file_status[GIT_DELTA_ADDED]",6,4,10
assign->name_hash == git_attr_file__name_hash(assign->name),6,4,10
"1, git_reflog_entrycount(log)",8,2,10
"2, exp.lines",6,4,10
file->rules.length == 11,6,4,10
file->rules.length == 1,6,4,10
buf.asize == 0,6,4,10
"2, git_blame_get_hunk_count(g_blame)",7,3,10
"looked_up_ref->name, packed_test_head_name",6,4,10
"""efad0b11c47cb2f0220cbd6f5b0f93bb99064b00\n"", 41, ""rebase/.git/rebase-merge/onto""",10,0,10
"expected_path, entry->path",6,4,10
list.count == 4,5,5,10
"git_path_isfile(""testrepo/README"")",8,2,10
"(item = git_sortedcache_entry(sc, 3)) != NULL",6,3,9
!git_path_exists(git_buf_cstr(&file)),6,3,9
!git_repository_is_bare(g_repo),5,4,9
"repo, ""when"", GIT_ENOTFOUND",7,2,9
"git_oid_streq(git_submodule_head_id(sm), oid) == 0",6,3,9
"git__strcmp(conflict_entry[0]->path, ""conflicts-one.txt"") == 0",6,3,9
"1, st.count",6,3,9
"0, expect.file_status[GIT_DELTA_TYPECHANGE]",6,3,9
"""aaa"", item->path",6,3,9
"conndata.path, ""/foo/""",6,3,9
"git_oid_streq(git_submodule_wd_id(sm), ""be3563ae3f795b2b4353bcce3a527ad0a4f7f644"") == 0",9,0,9
"28, i",6,3,9
"conndata.port, ""443""",6,3,9
"13, file_count",6,3,9
"n, 1",6,3,9
"conndata.use_ssl, true",6,3,9
(status & GIT_SUBMODULE_STATUS_INDEX_ADDED) != 0,6,3,9
"1, expect.line_ctxt",6,3,9
"git__suffixcmp(str, ""/submod2_target"") == 0",6,3,9
"""staged_changes_modified_file"", git_pathspec_match_list_entry(m, 2)",6,3,9
"1, expect.file_status[GIT_DELTA_MODIFIED]",6,3,9
(status & GIT_SUBMODULE_STATUS_WD_DELETED) != 0,6,3,9
"repo, ""why"", GIT_STATUS_INDEX_NEW",9,0,9
obj->cached.size == len,6,3,9
"NULL, git_pathspec_match_list_failed_entry(m, 2)",6,3,9
"true, git_path_isfile(git_buf_cstr(&path))",5,4,9
(status & GIT_SUBMODULE_STATUS_INDEX_MODIFIED) != 0,6,3,9
git_reference_type(ref) & GIT_REF_SYMBOLIC,6,3,9
"git_index_get_bypath(index, ""b.txt"", 0) != NULL",6,3,9
"8, stream->received_bytes",6,3,9
index && path,8,1,9
"&expected_id, &commit_id",9,0,9
"repo, ""how"", GIT_STATUS_INDEX_MODIFIED",6,3,9
index->tree,9,0,9
"0, (entry->flags_extended & GIT_IDXENTRY_UPTODATE)",9,0,9
"0, cts.n_untracked",6,3,9
"0, exp.line_adds",5,4,9
"refs_len, 28",6,3,9
list.count == 5,5,4,9
"0, git_sortedcache_entrycount(sc)",6,3,9
!git_buf_text_contains_nul(&b),6,3,9
path.ptr,6,3,9
"1, expect.file_status[GIT_DELTA_DELETED]",6,3,9
"git_pathspec_match_list_entry(matches, 0) == NULL",6,3,9
git_reference_type(reference) & GIT_REF_OID,6,3,9
parser->flags & F_CHUNKED,8,1,9
written == 1,6,3,9
"40, val",6,3,9
"git_pathspec_match_list_diff_entry(matches, 0) != NULL",6,3,9
obj->cached.type == type,6,3,9
"5, git_pathspec_match_list_entrycount(m)",6,3,9
"7, git_pathspec_match_list_entrycount(m)",6,3,9
"port, ""9191""",6,3,9
"""test/master"",name",5,4,9
" GIT_EAMBIGUOUS, git_odb_read_prefix(&obj, _odb, &oid, strlen(hex))",6,3,9
strlen(content) == (size_t)st.st_size,6,3,9
"""one.txt"", reuc->path",6,3,9
"true, checkout_progress_cb_was_called",5,4,9
git_object_type(object) == GIT_OBJ_COMMIT,6,3,9
git_reference_type(resolved_ref) == GIT_REF_OID,6,3,9
"!git_path_isdir(""alternative"")",6,3,9
"9, git_pathspec_match_list_entrycount(m)",6,3,9
"conndata.host, ""example.com""",6,3,9
"GIT_EEXISTS, error",6,3,9
"-1, line->new_lineno",6,3,9
git_index_reuc_entrycount(result) == 1,6,3,9
git_index_reuc_entrycount(repo_index) == 1,6,3,9
" GIT_EINVALIDSPEC, git_remote_create(&remote, _repo, """", ""git://github.com/libgit2/libgit2"")",5,4,9
"""zzz"", item->path",6,3,9
"""new_file"", git_pathspec_match_list_failed_entry(m, 0)",6,3,9
"5, (int)git_treebuilder_entrycount(builder)",6,3,9
"(c = resolve_commit_oid_to_tree(g_repo, c_commit)) != NULL",6,3,9
"GIT_SUBMODULE_RECURSE_YES, git_submodule_fetch_recurse_submodules(sm1)",4,5,9
git_reference_type(head) == GIT_REF_SYMBOLIC,6,3,9
"git__strcmp(conflict_entry[0]->path, ""conflicts-two.txt"") == 0",6,3,9
"git__suffixcmp(git_repository_path(repo), ""/"") == 0",6,3,9
"""garbage"", git_pathspec_match_list_failed_entry(m, 1)",6,3,9
"git_blob_rawsize(a), delta->old_file.size",5,4,9
"true, git_repository_head_detached(repo)",6,3,9
"15, expect.line_dels",6,3,9
"""abc"", item->path",6,3,9
"0, cts.n_ignored",6,3,9
"GIT_ENOTFOUND, git_branch_upstream(&upstream, branch)",6,3,9
(status & GIT_SUBMODULE_STATUS_WD_UNINITIALIZED) != 0,6,3,9
error == 0 || error == GIT_ITEROVER,5,4,9
"1, _fake->read_calls",6,3,9
conflict_entry[2] == NULL,6,3,9
"2, expect.file_status[GIT_DELTA_ADDED]",6,3,9
"git_sortedcache_lookup(sc, ""aaa"") == NULL",6,3,9
"expected_data, git_buf_cstr(&tgt)",5,4,9
"7, expect.line_adds",6,3,9
min_len >= 0,5,4,9
"&oid, &entry->id",8,1,9
"&expected, 4",6,3,9
"1, git_patch_num_lines_in_hunk(p, 0)",6,3,9
"git_path_isfile(""testrepo/ab/4.txt"")",7,2,9
"!git_path_isfile(""empty_standard_repo/.git/config"")",6,3,9
" GIT_EINVALIDSPEC, git_remote_create(&remote, _repo, ""Inv@{id"", ""git://github.com/libgit2/libgit2"")",5,4,9
"!git_path_exists(""testrepo/branch_file.txt"")",6,3,9
"repo, ""who"", GIT_STATUS_WT_MODIFIED",7,2,9
compare != (void *)0x001,6,3,9
"SM_LIBGIT2_URL, git_submodule_url(sm1)",4,4,8
" GIT_ENOTFOUND, git_futils_find_system_file(&path, ""nonexistentfile"")",4,4,8
!rule->match.negative,4,4,8
"git_oid_cmp(&conflict_entry[2]->id, &oid) == 0",4,4,8
"""5\n"", 2, ""rebase/.git/rebase-merge/end""",8,0,8
"git_blob_rawsize(c), delta->new_file.size",4,4,8
"ids, lengths",4,4,8
" GIT_EMERGECONFLICT, git_checkout_tree(g_repo, g_object, &g_opts)",4,4,8
"git_oid_equal(git_blob_id(a), &delta->old_file.oid)",4,4,8
value == GIT_ATTR_TRUE,4,4,8
exp.at_least_one_of_them_is_binary == true,4,4,8
expected.at_least_one_of_them_is_binary == true,4,4,8
"SetEnvironmentVariableW(name_utf16, value_utf16)",4,4,8
"git_strmap_exists(table, ""ggggggggg"")",4,4,8
"GIT_DIFF_LINE_DELETION, (int)origin",4,4,8
git_diff_stats_files_changed(stats) == 2,4,4,8
"ref, ""refs/remotes/test/master""",4,4,8
(delta->flags & GIT_DIFF_FLAG_BINARY) != 0,5,3,8
"git_oid_cmp(&id, git_reference_target(looked_up_ref)) == 0",4,4,8
"1, expected.file_status[GIT_DELTA_DELETED]",5,3,8
"g_repo, ""sm_gitmodules_only""",5,3,8
expected.lines == 0,4,4,8
"1, expected.line_ctxt",4,4,8
"git_path_isfile(""testrepo/new.txt"")",6,2,8
"4, exp.file_untracked",4,4,8
"NULL, 3, ""a65fed"", ""e90810"", ""41bc8c""",5,3,8
" REGULAR_FILE, git_tree_entry_attributes(entry)",4,4,8
"strlen(expected), buf.size",5,3,8
exp.lines == 0,4,4,8
"!git_path_exists(""./foo.git"")",4,4,8
" cl_fixture(""template""), git_repository_path(_repo), ""hooks/update.sample"", filemode",4,4,8
"0, file, line, err, buf, should_abort",4,4,8
"true, git_path_isfile(""./testrepo/ab/de/2.txt"")",6,2,8
"git_path_exists(""git-test-config"")",5,3,8
"GIT_EUSER, git_tree_walk( tree, GIT_TREEWALK_PRE, treewalk_skip_de_cb, &data)",4,4,8
a.asize == (ssize_t)strlen(fun) + 1,4,4,8
"git_oid_equal(git_blob_id(d), &delta->old_file.oid)",4,4,8
"expected_remote_name_length, git_branch_remote_name(NULL, 0, g_repo, remote_tracking_branch_name)",4,4,8
"""I'm a global config value!"", s",4,4,8
"cl_fixture(""attr/attr1""), file->key + 2",4,4,8
"value_utf16 = git__calloc(alloc_len, sizeof(wchar_t))",4,4,8
git_error_last() != NULL,4,4,8
"git_oid_cmp(git_reference_oid(ref_tag), &tag_id) == 0",4,4,8
"4, ca.count",5,3,8
"how_many_refs, 26",4,4,8
"GIT_NOTFOUND, error",4,4,8
"git_oid_cmp(&conflict_entry[0]->id, &oid) == 0",4,4,8
"2, exp.file_dels",4,4,8
"info->expect[info->expect_idx], path->ptr",4,4,8
"5, expected.line_adds",4,4,8
equals,5,3,8
!assign->is_allocated,4,4,8
git_push_unpack_ok(push),4,4,8
ret != 0,6,2,8
repository_folder && object,4,4,8
exp.hunks == 0,4,4,8
"""refs/heads/master"", git_reference_target(head)",4,4,8
"0, git_oid_cmp(&expected_oid, git_object_id(peeled))",4,4,8
git_oid_iszero(&delta->new_file.oid),4,4,8
"!git_strmap_exists(table, ""abcdefghi"")",4,4,8
"2, (int)array.count",4,4,8
exp.file_mods == 3,4,4,8
"GIT_ITEROVER, git_iterator_advance(&e, i)",5,3,8
" GIT_SUBMODULE_RECURSE_ONDEMAND, git_submodule_fetch_recurse_submodules(sm1)",4,4,8
"10, v",4,4,8
"!git_remote_supported_url(""git@github.com:libgit2/libgit2.git"")",4,4,8
exp.file_dels == 1,4,4,8
a.size == (ssize_t)strlen(fun),4,4,8
"git_oid_cmp(&reuc->oid[2], &their_oid) == 0",4,4,8
"GIT_ENOTFOUND, git_submodule_lookup(&sm, g_repo, ""just_a_file"")",4,4,8
"(entry = git_index_get_bypath(index, ""test.txt"", 0)) != NULL",5,3,8
"repo, ""who"", GIT_STATUS_INDEX_MODIFIED",7,1,8
"1, exp.file_dels",4,4,8
"expected0, text",4,4,8
str && *str == '\0' && str == out,5,3,8
"GIT_DELTA_ADDED, git_diff_patch_delta(p)->status",4,4,8
"git_oid_cmp(&id, git_object_id(object)) == 0",4,4,8
git_oid_iszero(&delta->old_file.oid),4,4,8
"(entry = git_index_get_bypath(g_idx, ""README.txt"", 0)) != NULL",8,0,8
"!git_strmap_exists(table, ""aaaaaaaab"")",4,4,8
"git_strmap_exists(table, ""aaaaaaaaa"")",4,4,8
"s, SM_LIBGIT2_URL",4,4,8
"git_buf_cstr(&buf), ""refs/remotes/test/master""",4,4,8
"git_oid_cmp(&reuc->oid[1], &our_oid) == 0",4,4,8
value == NULL,4,4,8
values[1] == GIT_ATTR_FALSE,4,4,8
"GIT_STATUS_INDEX_DELETED|GIT_STATUS_WT_NEW, status",4,4,8
"git__suffixcmp(git_repository_workdir(repo), ""/"") == 0",5,3,8
"git_oid_equal(git_blob_id(c), &delta->new_file.oid)",4,4,8
"GIT_ENOTFOUND, git_repository_message(NULL, 0, _repo)",4,4,8
"git_reference_cmp(a, b) == 0",6,2,8
"GIT_DELTA_UNMODIFIED, git_diff_patch_delta(p)->status",4,4,8
"value, ""refs/heads/master""",4,4,8
"git_oid_streq(git_submodule_index_oid(sm), oid) == 0",4,4,8
"GIT_DIFF_LINE_CONTEXT, (int)origin",4,4,8
" GIT_FILEMODE_BLOB, git_tree_entry_attributes(entry)",4,4,8
"str, ""this \""has\"" quotes and \t""",4,4,8
"stats.total_objects, 3",5,3,8
te,5,3,8
"!git_path_exists(TEST_REPO_PATH ""/.git/MERGE_MSG"")",6,2,8
"GIT_ENOTFOUND, git_remote_load(&_remote, _repo, ""just-left-few-minutes-ago"")",4,4,8
"nfc, data",6,2,8
expected.hunks == 0,4,4,8
obj && backend && oid,4,4,8
t->cred,5,3,8
" 0, git_oid_cmp(git_reference_target(ref1), git_reference_target(ref2))",4,4,8
"str, ""this also \""has\"" quotes""",4,4,8
"(int)ref_list.count, 14",4,4,8
"i, 4",7,1,8
"git_oid_cmp(&a, &b)",5,3,8
"merge_test_reuc(repo_index, merge_reuc_entries, 4)",6,2,8
"0, exp.file_untracked",4,4,8
name_utf16,4,4,8
!error || error == GIT_ENOTFOUND,5,3,8
how_many_refs == 12,4,4,8
((size_t)len) < n,4,4,8
"git_oid_equal(&oid, &check)",4,4,8
git_reference_is_packed(another_looked_up_ref) == 0,4,4,8
"git_oid_cmp(&conflict_entry[1]->id, &oid) == 0",4,4,8
"git_reference_target(ref), ref_master_name",4,4,8
git_repository_workdir(repo) == NULL,5,3,8
source->open && source->write_ptr,4,4,8
" cl_fixture(""template""), git_repository_path(_repo), ""hooks/link.sample"", filemode",4,4,8
"6, expected.lines",4,4,8
"actuallen, expectedlen",4,4,8
values[3] == GIT_ATTR_FALSE,4,4,8
"GIT_DIFF_LINE_ADDITION, (int)origin",4,4,8
git_pool__open_pages(&p) == 1,4,4,8
"""don't find me!"", s",4,4,8
"g_repo, ""sm_unchanged""",5,3,8
"""""",5,3,8
"GIT_EUNMERGED, git_reset(repo, target, GIT_RESET_SOFT, NULL, NULL)",4,4,8
"100, sim",5,3,8
(out != NULL) && (len > 0),4,4,8
"19, exp.lines",5,3,8
git_merge_result_is_uptodate(result),4,4,8
"GIT_EUNMERGED, git_reset(repo, target, GIT_RESET_SOFT)",4,4,8
"!git_oid_cmp(&oid, git_reference_target(looked_up_ref))",4,4,8
"GIT_ENOTFOUND, git_submodule_lookup(&sm, g_repo, ""no_such_file"")",4,4,8
"cl_fixture(""attr/attr0""), file->key + 2",4,4,8
"str, ""this \""has\"" quotes""",4,4,8
"expected2, text",4,4,8
"""master\n"", 7, ""rebase/.git/rebase-merge/onto_name""",8,0,8
exp.file_adds == 2,4,4,8
"git_oid_cmp(&reuc->oid[0], &ancestor_oid) == 0",4,4,8
"-1, oldno",4,4,8
"""pat8 with spaces"", rule->match.pattern",4,3,7
"ahead, 0",4,3,7
backend,7,0,7
"""yes"", values[3]",4,3,7
"entry = git_index_get_bypath(result, ""removed-in-9-branch.txt"", 1)",4,3,7
"expected, buf",4,3,7
"GIT_STATUS_INDEX_NEW, status",5,2,7
"!git_oid_cmp(&id, git_reference_target(ref))",5,2,7
"B, base.ptr",4,3,7
"expected_ab, git_buf_cstr(&buf)",4,3,7
"(entry = git_index_get_bypath(result, ""removed-in-8.txt"", 0)) == NULL",4,3,7
" ALL_LF_TEXT_AS_CRLF ""\r\n$Id: fcf6d4d9c212dc66563b1171b1cd99953c756467 $\r\n"", 0, ""crlf/lf.ident""",4,3,7
"0, delta->old_file.size",5,2,7
"""0123456789"", data",4,3,7
"""yes!"", assign->value",4,3,7
"""shoop da 23 woop 42"", git_buf_cstr(&buf)",4,3,7
"p.ptr, expect[i]",4,3,7
"""README"", rule->match.pattern",4,3,7
"""another"", assign->name",4,3,7
"""unspecified"", assign->value",4,3,7
"""+"", git_buf_cstr(&buf)",4,3,7
"5, tmp",5,2,7
giterr_last()->klass == GITERR_NOMEMORY,5,2,7
giterr_last()->klass == GITERR_INVALID,4,3,7
"""pat1"", rule->match.pattern",4,3,7
"""pat3dir/pat3file"", rule->match.pattern",4,3,7
"objstr, expected_oid",4,3,7
"expected_names[count], entry->path",4,3,7
"expected_abcab, git_buf_cstr(&buf)",4,3,7
bad_tag != NULL,4,3,7
"name, assign->name",4,3,7
" GIT_ENOTFOUND, git_object_lookup(&object, g_repo, &oid, GIT_OBJ_ANY)",4,3,7
"committer, &oid",4,3,7
"""filfre"", value",4,3,7
db && id,4,3,7
"""test"", path.basename",4,3,7
"""hahaha"", values[4]",4,3,7
"output.length, ARRAY_SIZE(refnames)",4,3,7
"""values"", assign->name",4,3,7
"""also"", assign->name",4,3,7
"(entry = git_index_get_bypath(result, ""removed-in-both.txt"", 0)) == NULL",4,3,7
"commit_msg, entry->msg",4,3,7
"1, result.automergeable",7,0,7
"(entry = git_index_get_bypath(result, ""removed-in-10-branch.txt"", 0)) == NULL",4,3,7
"behind, 3",4,3,7
"B, dir2",4,3,7
"entry = git_index_get_bypath(repo_index, ""removed-in-9-branch.txt"", 1)",4,3,7
"(entry = git_index_get_bypath(repo_index, ""removed-in-both.txt"", 0)) == NULL",4,3,7
"git_refspec_dst(_refspec), ""refs/remotes/test/*""",4,3,7
"""pat7"", rule->match.pattern",4,3,7
"entry = git_index_get_bypath(result, ""removed-in-7.txt"", 3)",4,3,7
"false, git_path_isfile(git_buf_cstr(&path))",4,3,7
"""answer"", values[2]",4,3,7
ignored == (entry_statuses0[i] == GIT_STATUS_IGNORED),4,3,7
"(entry = git_index_get_bypath(repo_index, ""removed-in-10-branch.txt"", 0)) == NULL",4,3,7
"behind, 8",4,3,7
"17, i",4,3,7
" ALL_CRLF_TEXT_RAW ""\r\n$Id: f2c66ad9b2b5a734d9bf00d5000cc10a62b8a857 $\r\n\r\n"", 0, ""crlf/crlf.ident""",4,3,7
"""happy"", assign->name",4,3,7
"(entry = git_index_get_bypath(repo_index, ""removed-in-8.txt"", 0)) == NULL",4,3,7
"""*.pat5"", rule->match.pattern",4,3,7
url,4,3,7
"ahead, 4",4,3,7
"entry = git_index_get_bypath(repo_index, ""removed-in-7.txt"", 1)",4,3,7
oids != NULL,5,2,7
"3, exp.file_status[GIT_DELTA_DELETED]",5,2,7
"B, dir.ptr",4,3,7
"""refs/remotes/test/master"", false",5,2,7
"entry = git_index_get_bypath(result, ""removed-in-7.txt"", 1)",4,3,7
"expected, tgt.ptr",4,3,7
"g_repo, ""sm_added_and_uncommited""",4,3,7
"""01"", data",4,3,7
status == expected,4,3,7
"0, git_repository_is_shallow(g_repo)",5,2,7
"""shoop da 23 "", git_buf_cstr(&buf)",4,3,7
"entry = git_index_get_bypath(repo_index, ""removed-in-9-branch.txt"", 2)",4,3,7
"""again"", assign->name",4,3,7
tree != NULL,4,3,7
giterr_last()->message != NULL,5,2,7
"19, (int)refnames.count",5,2,7
"git_oid_cmp(&expected_tree_oid, &tree_oid) == 0",4,3,7
(base2 = git_path_basename(A)) != NULL,4,3,7
"expected_values[count], entry->path",4,3,7
"""attr7"", assign->name",4,3,7
"6, git_patch_num_lines_in_hunk(p, 0)",4,3,7
"""++++++++++++++++++"", git_buf_cstr(&buf)",4,3,7
bad_tag->tagger == NULL,4,3,7
"""java"", assign->value",4,3,7
"&reuc->oid[2], &oid",7,0,7
"""*.java"", rule->match.pattern",4,3,7
"""attr0"", assign->name",4,3,7
"1, (int)tc",4,3,7
"test_8192, git_buf_cstr(&buf)",4,3,7
"git_remote_name(_remote), ""test""",4,3,7
"path.ptr, ""/foo/this is a new string/grow the buffer, grow the buffer, grow the buffer""",4,3,7
"true, git_repository_is_empty(g_repo)",4,3,7
ref_out && repo && name,4,3,7
"0, delta->new_file.size",5,2,7
"""bar"", git_buf_cstr(&b)",4,3,7
"expected->email, actual->email",4,3,7
"""xo"", git_buf_cstr(&buf)",4,3,7
"expected_abcabc, git_buf_cstr(&buf)",4,3,7
"""pat7[a-e]??[xyz]"", rule->match.pattern",4,3,7
"expected_count + expected_ignores, count_all",4,3,7
"expected_names[count_all], entry->path",4,3,7
"""foo"", b",4,3,7
"""a-really-long-value/*"", assign->value",4,3,7
"5, (int)ta",4,3,7
"""diff"", assign->name",4,3,7
"REP4(REP16(""x"")) REP16(""x"") REP16(""x"") REP16(""x"") ""xxxxxxxxxxxxxxx"", data",4,3,7
"""xoxo"", git_buf_cstr(&buf)",4,3,7
"&reuc->oid[0], &oid",7,0,7
"git_oid_streq(git_submodule_head_id(sm), ""a65fedf39aefe402d3bb6e24df4d4f5fe4547750"") == 0",7,0,7
"git_remote_url(_remote), url",4,3,7
"""caveat"", assign->name",4,3,7
git_buf_text_is_binary(&b),4,3,7
"(entry = git_index_get_bypath(repo_index, ""removed-in-9-branch.txt"", 0)) == NULL",4,3,7
"""bar"", git_buf_cstr(&a)",4,3,7
"e->path, test_entries[i].path",4,3,7
"git_oid_streq(git_submodule_index_id(sm), ""a65fedf39aefe402d3bb6e24df4d4f5fe4547750"") == 0",7,0,7
"pattern, rule->match.pattern",4,3,7
"git_blob_rawsize(d), delta->new_file.size",4,3,7
"""pat8"", rule->match.pattern",4,3,7
"entry = git_index_get_bypath(result, ""removed-in-9-branch.txt"", 2)",4,3,7
"path.ptr, ""/foo/this is a new string""",4,3,7
"git_tag_name(bad_tag), ""e90810b""",4,3,7
"g_repo, ""dir""",5,2,7
" GIT_EINVALIDSPEC, git_remote_create(&remote, _repo, NULL, ""git://github.com/libgit2/libgit2"")",4,3,7
"""foo"", git_buf_cstr(&b)",4,3,7
git_index_entrycount(repo_index) == 11,5,2,7
!git_buf_text_is_binary(&b),5,2,7
"exp, ""nulltoken/HEAD""",4,3,7
out && repo && input_array,5,2,7
"13 + 3, perf.stat_calls",7,0,7
"path.ptr, ""/bar/baz""",4,3,7
"""*"", rule->match.pattern",4,3,7
"""single"", assign->name",4,3,7
"(entry = git_index_get_bypath(repo_index, ""removed-in-7.txt"", 0)) == NULL",4,3,7
"""pat0"", path.basename",4,3,7
"""xoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxoxo"", git_buf_cstr(&buf)",4,3,7
"path.ptr, ""/foo""",4,3,7
"""foo/bar"", git_buf_cstr(&a)",4,3,7
"ahead, 8",4,3,7
"""pat9"", rule->match.pattern",4,3,7
"""test"", path.path",4,3,7
"B, dir",4,3,7
"""12321"", assign->value",4,3,7
"&reuc->oid[1], &oid",7,0,7
"git_remote_name(_remote), ""origin""",4,3,7
"""NoMyAttr.java"", rule->match.pattern",4,3,7
"git_oid_cmp(&id, git_tag_id(bad_tag)) == 0",4,3,7
tag2 != NULL,4,3,7
"0, (int)td",4,3,7
"path.ptr, ""/baz/somethinglongenoughtorealloc""",4,3,7
rebase,6,1,7
"""77"", values[4]",4,3,7
idx == test_entries[i].index,4,3,7
"""foo/bar/baz"", git_buf_cstr(&a)",4,3,7
(dir2 = git_path_dirname(A)) != NULL,4,3,7
"""multiple"", assign->name",4,3,7
"git_oid_cmp(&id, &id_zero) == 0",4,3,7
"""crlf"", assign->name",4,3,7
"*expect, buf.ptr",4,3,7
"(unsigned int)status_flags, status",4,3,7
"""2341234123412341234"", git_buf_cstr(&buf)",4,3,7
"""binary"", assign->name",4,3,7
"expected->name, actual->name",4,3,7
"looked_up_ref->name, ref_two_name",4,3,7
"""pat0"", rule->match.pattern",4,3,7
"repo, ""why"", GIT_ENOTFOUND",7,0,7
"GIT_BRANCH_REMOTE, 2",4,3,7
"""pat4.*"", rule->match.pattern",4,3,7
"""pat2"", rule->match.pattern",4,3,7
"(entry = git_index_get_bypath(result, ""removed-in-7.txt"", 0)) == NULL",4,3,7
"git_oid_cmp(&id2, git_tag_id(tag2)) == 0",4,3,7
"git_odb_exists(odb, &id)",4,3,7
"buf_a, git_buf_cstr(&buf)",4,3,7
"""++"", git_buf_cstr(&buf)",4,3,7
"entry = git_index_get_bypath(repo_index, ""removed-in-7.txt"", 3)",4,3,7
"(entry = git_index_get_bypath(result, ""removed-in-9-branch.txt"", 0)) == NULL",4,3,7
entry->file_size == strlen(AUTOMERGEABLE_MERGED_FILE),5,2,7
"git_tag_name(tag1), ""test""",4,3,7
"5, exp.line_ctxt",4,3,7
"repo, ""what"", GIT_STATUS_WT_MODIFIED",7,0,7
"expected_abc, git_buf_cstr(&buf)",4,3,7
"NULL, b",4,3,7
"""Some text\nRight here\n"", out.ptr",4,3,7
"3, exp.file_status[GIT_DELTA_RENAMED]",4,3,7
"B, base2",4,3,7
"expected_abca, git_buf_cstr(&buf)",4,3,7
"""1"", assign->value",4,3,7
"test_file_contents(GIT_MERGE_HEAD_FILE, OCTO1_OID ""\n"" OCTO1_OID ""\n"" OCTO1_OID ""\n"")",4,2,6
e->file_size == test_entries[i].file_size,3,3,6
"strcmp(reuc->path, ""one.txt"") == 0",3,3,6
"GIT_ENOTFOUND, git_repository_discover(found_path, sizeof(found_path), SUB_REPOSITORY_FOLDER_SUB_SUB, 0, ceiling_dirs)",3,3,6
reuc_entry_exists() == true,4,2,6
" (int)GIT_SUBMODULE_UPDATE_REBASE, (int)git_submodule_update_strategy(sm1)",2,4,6
((git_refcount *)new_index)->refcount.val == 1,4,2,6
exp.file_ignored == 1,3,3,6
"false, git_path_isfile(git_buf_cstr(&master_log_path))",4,2,6
"0, __FILE__, __LINE__, ""Test failed."", desc, 1",3,3,6
refs,3,3,6
" ""Some text\n$Id$\nGoes there\n"", git_blob_rawcontent(blob)",4,2,6
"7, git_message_prettify(buffer, sizeof(buffer), ""Short"", 0)",3,3,6
" ALL_CRLF_TEXT_AS_LF ""\n$Id: f2c66ad9b2b5a734d9bf00d5000cc10a62b8a857 $\n\n"", 0, ""crlf/crlf.ident""",3,3,6
"GIT_DELTA_ADDED, git_patch_get_delta(p)->status",4,2,6
"14, git_patch_num_lines_in_hunk(p, 0)",4,2,6
tag_list.count == 3,3,3,6
reference_is_packed(looked_up_ref) != 0,4,2,6
"git_oid_cmp(oid, &entry->oid_cur) == 0",4,2,6
"git_oid_streq(git_tree_id(tree), ""az"")",4,2,6
"repo, ""branch.track-local.merge"", false",4,2,6
"str, ""http://example.com/git/abba""",3,3,6
"(idx = git_index_get_bypath(repo_index, ""automergeable.txt"", 0))",5,1,6
t->new_oid = git__malloc(sizeof(*t->new_oid)),3,3,6
"3, git_blame_get_hunk_count(g_blame)",4,2,6
"stats.received_objects, 3",4,2,6
"buffer, expectedcontents",3,3,6
ref_list.count > 0,4,2,6
"8, count",4,2,6
"repo, ""modified"", GIT_STATUS_CURRENT",4,2,6
"git_note_message(note), note_message[i]",4,2,6
git_reference_type(reference) & GIT_REF_SYMBOLIC,4,2,6
"expected, _actual",3,3,6
st.count == 1,4,2,6
"a.ptr, ""happ""",4,2,6
"git_refspec_dst(_refspec), ""refs/remotes/upstream/*""",3,3,6
"""string/join"", a.ptr",6,0,6
git_index_entry_stage(entry) == 1,4,2,6
"1, pos",4,2,6
"2, exp.file_status[GIT_DELTA_UNMODIFIED]",4,2,6
idx2head->strcomp == wd2idx->strcomp,3,3,6
"git_oid_cmp(&expected, &tree_oid) == 0",3,3,6
error == GIT_EEXISTS,4,2,6
"""mmm"", item->path",4,2,6
cfg_file->reader.read_ptr,3,3,6
"diff, NULL",4,2,6
"git_reference_symbolic_target(ref), ref_master_name",4,2,6
expect.idx == expect.len,4,2,6
"100, git_hashsig_compare(a, b)",4,2,6
"submodule_status, GIT_SUBMODULE_STATUS_IN_HEAD | GIT_SUBMODULE_STATUS_IN_INDEX | GIT_SUBMODULE_STATUS_IN_CONFIG | GIT_SUBMODULE_STATUS_WD_UNINITIALIZED",6,0,6
"""submodules/libgit2"", git_submodule_name(sm)",4,2,6
(status & GIT_SUBMODULE_STATUS_WD_WD_MODIFIED) != 0,4,2,6
obj != NULL,4,2,6
"1, git_diff_patch_num_lines_in_hunk(p, 0)",3,3,6
"git_config_delete(cfg, ""core.imaginary"") == GIT_ENOTFOUND",3,3,6
exp.hunks == 2,3,3,6
"ignored == one_test->expected, one_test->path",3,3,6
expected.lines == 14,3,3,6
t,6,0,6
"&expected, GIT_DELTA_ADDED",4,2,6
"n, 3",4,2,6
git_index_name_entrycount(repo_index) == 3,4,2,6
"git_path_isdir(""submodules/testrepo/.git"")",4,2,6
"1, git_index_reuc_entrycount(repo_index)",4,2,6
"""refs/stash^3:who"", NULL",4,2,6
reflog,4,2,6
"""aaa"", item",4,2,6
"conndata.path, ""/zap/baz/biff?bam""",4,2,6
"n, 2",4,2,6
"git_message_prettify(buffer, sizeof(buffer), ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""12345678"", 0) > 0",3,3,6
" GIT_EAMBIGUOUS, git_revparse_single(&g_obj, g_repo, ""wrapped_tag^{blob}"")",3,3,6
"&oid, &conflict_entry[0]->id",6,0,6
"""test"", remotename",3,3,6
"GIT_EAMBIGUOUS, ""53fc32d17276939fc79ed05badaef2db09990016"", GIT_OBJ_BLOB",3,3,6
"git_oid_cmp(&expected_blob_oid, &entry->oid) == 0",3,3,6
"!git_path_exists(""testrepo/new.txt"")",5,1,6
"7, i",4,2,6
"7, count",4,2,6
"""refs/stash^3:how"", NULL",4,2,6
x.length == 0,4,2,6
"reflog_entry = git_reflog_entry_byindex(reflog, 0)",6,0,6
"6, expect.hunks",4,2,6
"!git_odb_exists(odb, &id2)",3,3,6
git_reference_type(test_ref) == GIT_REF_OID,4,2,6
"4, data.dirs",4,2,6
reference_is_packed(reference),4,2,6
"git_path_is_empty_dir(""testrepo/a"")",4,2,6
"&oid, &conflict_entry[2]->id",6,0,6
remote->url == NULL,4,2,6
"cl_fixture(""attr/attr2""), file->path",3,3,6
" strlen(expected), git_patch_size(patch, 1, 1, 1)",4,2,6
"GIT_EEXISTS, git_remote_rename(_remote, ""test"", dont_call_me_cb, NULL)",3,3,6
"strcmp(conflict_name->ancestor, ""ancestor2"") == 0",4,2,6
"GIT_ITEROVER, err",4,2,6
"git_sortedcache_entry(sc, 5) == NULL",4,2,6
"18, (int)hunklen",4,2,6
"testname, testfile",4,2,6
((git_refcount *)new_odb)->refcount.val == 1,4,2,6
"GIT_ENOTFOUND, git_stash_drop(repo, 0)",3,3,6
(status & GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED) != 0,4,2,6
oid_str = git_oid_allocfmt(expected_refs[i].oid),3,3,6
s = git__malloc(sizeof(*s)),3,3,6
"GIT_REMOTE_DOWNLOAD_TAGS_AUTO, git_remote_autotag(_remote)",4,2,6
"git_path_isfile(""submodules/.gitmodules"")",4,2,6
"false, read_index->on_disk",4,2,6
"git__strcmp(entry->path, ""test.txt"") == 0",4,2,6
"1, _fake->read_prefix_calls",4,2,6
"merge_test_workdir(repo, merge_index_entries, 24)",4,2,6
"(item = git_sortedcache_lookup(sc, ""mmm"")) != NULL",4,2,6
"2, i",4,2,6
e->mtime.seconds == test_entries[i].mtime,3,3,6
"2, (int)num_d",4,2,6
"original_remote, ce->value",3,3,6
"GIT_DIRECTION_PUSH, "":"", true",4,2,6
"conndata.port, ""80""",4,2,6
"git_path_isdir(""submod2/.git/modules"")",4,2,6
"(item = git_sortedcache_lookup(sc, ""abc"")) != NULL",4,2,6
"5, git_sortedcache_entrycount(sc)",4,2,6
"out, ""ed""",3,3,6
"-1, newno",3,3,6
list.count == 3,3,3,6
"git_path_isdir(""submodules/.git"")",4,2,6
"true, git_repository_head_orphan(g_repo)",3,3,6
"(item = git_sortedcache_lookup(sc, ""zzz"")) != NULL",4,2,6
"git_config_get_string(&opt, cfg, ""remote.test.tagopt"") == GIT_ENOTFOUND",3,3,6
"GIT_BRANCH_LOCAL | GIT_BRANCH_REMOTE, 14",3,3,6
repo && commit,4,2,6
st.count == 2,4,2,6
"!git_path_isfile(""alternate/3/.gitconfig"")",4,2,6
"0, expected->lines",4,2,6
git_repository_is_bare(bare) == true,4,2,6
"git_path_exists(""testrepo/README"")",4,2,6
out && out_len && diriter,5,1,6
"!git_oid_cmp(git_note_oid(note), &note_oid)",3,3,6
"8, (int)num_d",4,2,6
"2, pos",4,2,6
"""mmm"", item",4,2,6
"status_flags, error",3,3,6
object_out && repo,3,3,6
"conndata.use_ssl, false",4,2,6
"new_ref->name, new_name",4,2,6
"REFNAME, git_reference_name(ref2)",4,2,6
"&oid, &conflict_entry[1]->id",6,0,6
"GIT_DELTA_DELETED, git_diff_patch_delta(p)->status",3,3,6
"GIT_DELTA_UNMODIFIED, delta->status",4,2,6
"""zzz"", item",4,2,6
"repo, ""what"", GIT_STATUS_WT_MODIFIED | GIT_STATUS_INDEX_MODIFIED",4,2,6
remote->pushurl == NULL,4,2,6
"git_message_prettify(buffer, sizeof(buffer), ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""12345678\n"", 0) > 0",3,3,6
git_index_entrycount(repo_index) == 2,4,2,6
git_index_entrycount(repo_index) == 5,4,2,6
"conndata.host, ""foo.com""",4,2,6
exp.line_dels == 4,3,3,6
"1, _fake->exists_calls",4,2,6
entry && entry->owner,3,3,6
"""refs/stash^3:what"", NULL",4,2,6
"buffer, ""This is longer\nAnd multiline\n# with some comments still in\n""",3,3,6
"""testing"", item->path",4,2,6
"0, ignored",6,0,6
"4, behind",3,3,6
"2, ct",4,2,6
line,4,2,6
"size, _remote->refspec_strings.length",3,3,6
"expected_ret, ret",3,3,6
"GIT_EUNBORNBRANCH, git_repository_head(&head, repo)",4,2,6
"GIT_STATUS_WT_NEW, status",5,1,6
"""0000000000000000000000000000000000000000"", oid_str",3,3,6
"49, line->new_lineno",4,2,6
"tree, ""nope/de/fgh/1.txt"", GIT_ENOTFOUND, NULL",3,3,6
"!git_path_exists(""issue_592/c/a.txt"")",4,2,6
"4, exp.file_status[GIT_DELTA_UNMODIFIED]",4,2,6
exp.line_adds == 12,3,3,6
"strcmp(conflict_name->ancestor, ""ancestor3"") == 0",4,2,6
git_repository_head_detached(repo) == 1,3,3,6
"how_many_refs, 28",3,3,6
"GIT_DELTA_ADDED, delta->status",4,2,6
"0, git_tree_walk( tree, GIT_TREEWALK_PRE, treewalk_skip_de_cb, &data)",4,2,6
"!git_path_exists(TEST_REPO_PATH ""/.git/REVERT_HEAD"")",4,2,6
"g_repo, git_object_id(obj), NULL, true",4,2,6
"1, expected.line_dels",3,3,6
"3, (int)git_diff_num_deltas(diff)",4,2,6
exp.line_ctxt == 0,3,3,6
repo && old_tree && diff,4,2,6
"(int)strlen(expected_tracked_branch_name) + 1, git_branch_upstream_name(buffer, 1024, g_repo_cloned, local_name)",3,3,6
git_diff_stats_files_changed(stats) == 1,3,3,6
"value, ""one""",4,2,6
"git_pool_malloc(&p, i) != NULL",4,2,6
"strcmp(reference->name, loose_tag_ref_name) == 0",3,3,6
"false, ""dir1/dir2/dir3/dir1""",3,3,6
"""staged_changes"", git_pathspec_match_list_entry(m, 0)",4,2,6
repo && old && diff,2,4,6
"2, ahead",3,3,6
"GIT_ENOTFOUND, git_repository_discover(found_path, sizeof(found_path), SUB_REPOSITORY_FOLDER_SUB_SUB_SUB, 0, ceiling_dirs)",3,3,6
exp.line_dels == 1,3,3,6
"1, expected->file_status[GIT_DELTA_MODIFIED]",4,2,6
"GIT_EINVALIDSPEC, git_remote_load(&_remote, _repo, ""Inv@{id"")",3,3,6
"git_oid_equal(git_blob_id(a), &delta->old_file.id)",3,3,6
transport && transport->connected,3,3,6
"""subdir/current_file"", git_pathspec_match_list_entry(m, 6)",4,2,6
"""again"", item->path",4,2,6
"0, __FILE__, __LINE__, ""Warning during test execution:"", desc, 0",3,3,6
"GIT_ENOTFOUND, git_branch_tracking(&tracking, branch)",3,3,6
"git_remote_pushurl(_remote), ""git://github.com/libgit2/notlibgit2""",3,3,6
GIT_ATTR_FALSE(values[3]),4,2,6
"git_message_prettify(NULL, 0, """", 0) == 1",3,3,6
"3, ct",4,2,6
"NULL, git_remote_name(remote)",3,3,6
a.size == strlen(fun),4,2,6
"7, (int)git_pathspec_match_list_entrycount(matches)",4,2,6
"strcmp(conflict_name->theirs, ""theirs3"") == 0",4,2,6
"git_path_isfile(""testrepo/ab/c/3.txt"")",4,2,6
"true, git_repository_head_unborn(repo)",4,2,6
"strcmp(entry->path, ""conflicts-one.txt"") != 0",4,2,6
"git_oid_streq(git_submodule_head_oid(sm), oid) == 0",3,3,6
""""", ""# comment \n"", 1",4,2,6
"h, NULL",4,2,6
a.asize == strlen(fun) + 1,4,2,6
"""newfile.txt"", reuc->path",4,2,6
pos != kh_end(map),4,2,6
"2, exp.line_adds",4,2,6
exp.lines == 14,3,3,6
"git_path_is_empty_dir(""./foo"")",4,2,6
"str, ""true""",3,3,6
"5, exp.file_status[GIT_DELTA_DELETED]",4,2,6
"git_oid_equal(&found, git_odb_object_id(obj))",3,3,6
"out, ""auto""",3,3,6
"&automergeable_id, &idx->id",5,1,6
"git_path_isfile(""./testrepo/path1"")",4,2,6
"GIT_DELTA_UNMODIFIED, git_patch_get_delta(p)->status",4,2,6
expected->newname == NULL,3,3,6
"&a, &b",6,0,6
"4, exp.line_ctxt",4,2,6
"g_repo, ""subtrees""",5,1,6
"git_oid_cmp(&id, git_reference_oid(resolved_ref)) == 0",3,3,6
conflict_name->ours == NULL,4,2,6
"git__suffixcmp(git_repository_workdir(repo2), ""alternate/"") == 0, git_repository_workdir(repo2)",4,2,6
"expected_result, git_reference_has_log(ref)",3,3,6
"ttt ""\n"", ttt, 0",4,2,6
GIT_ATTR_FALSE(values[1]),4,2,6
"git_index_get_bypath(index, ""a/1.txt"", 0) == NULL",4,2,6
self && dest && source,3,3,6
"statbuf.st_mode & os_mask, (expected & ~mask) & os_mask",4,2,6
"size, _remote->refspecs.length",3,3,6
"9, (int)hunk->new_lines",4,2,6
"3, git_sortedcache_entrycount(sc)",4,2,6
"git_refspec_dst(_refspec), ""refs/heads/*""",3,3,6
"7, expect.hunks",4,2,6
!git_path_isdir(path.ptr),6,0,6
"GIT_ENOTFOUND, result",4,2,6
"!git_path_is_empty_dir(""empty_dir"")",4,2,6
"0, git_index_name_entrycount(repo_index)",4,2,6
"git_path_isfile(""./testrepo/path0/file0"")",4,2,6
"true, git_path_isfile(git_buf_cstr(&master_log_path))",4,2,6
"git__strcmp(newname, expected->newname) == 0",3,3,6
"strcmp(conflict_name->theirs, ""theirs"") == 0",4,2,6
" !git_remote_valid_url(""/home/git/repos/libgit2.git"") ",3,3,6
"1, git_push_unpack_ok(push)",3,3,6
"EAFNOSUPPORT, errno",4,2,6
"GIT_STATUS_WT_NEW, (int)status",4,2,6
name == NULL,4,2,6
"git_repository_message(_actual, len, _repo) > 0",3,3,6
"5, git_blame_get_hunk_count(g_bufferblame)",4,2,6
"diff->submodule_lookups, 1",3,3,6
"count + 1, (int)git_cache_size(&g_repo->objects)",4,2,6
"EXP,0,PATH",4,2,6
git_ref_type(ref) == GIT_REF_OID,3,3,6
!git_repository_is_bare(repo),4,2,6
"""when"", GIT_STATUS_WT_NEW",3,3,6
"7, git_message_prettify(buffer, sizeof(buffer), ""Short"", 1)",3,3,6
db && db->backend,5,1,6
"repo, ""branch.track-local.merge"", true",4,2,6
"ELSEWHERE ""/test.txt"", git_buf_cstr(&full_path), &git_blob_create_fromdisk",4,2,6
git_object_type(target) == GIT_OBJ_COMMIT,4,2,6
"GIT_EEXISTS, git_remote_rename(_remote, ""test_with_pushurl"", dont_call_me_cb, NULL)",3,3,6
"stats.indexed_objects, 3",4,2,6
git_repository_head_detached(repo) == should_be_detached,4,2,6
"GIT_STATUS_IGNORED, (int)status",4,2,6
"3, cts.n_updates",4,2,6
url == NULL,4,2,6
"7, data.files",4,2,6
"0, git_index_entrycount(read_index)",4,2,6
" git_remote_valid_url(""git@github.com:libgit2/libgit2.git"") ",3,3,6
" GIT_EINVALIDSPEC, git_remote_rename(_remote, ""new@{name"", dont_call_me_cb, NULL)",3,3,6
"reuc = git_index_reuc_get_byindex(repo_index, 1)",4,2,6
"str, ""hello""",3,3,6
"pass, ""pass""",4,2,6
git_path_isfile(git_buf_cstr(&path)),4,2,6
"git_remote_pushurl(_remote), ""git://github.com/libgit2/libgit2_push""",3,3,6
"merge_test_reuc(index, merge_reuc_entries, 4)",4,2,6
"git_oid_cmp(git_reference_target(ref_tag), &tag_id) == 0",4,2,6
"git_refspec_string(_refspec), ""refs/*:refs/*""",4,2,6
"(int)strlen(expected_remote_name) + 1, git_branch_remote_name(buffer, 1024, g_repo_cloned, expected_tracked_branch_name)",3,3,6
"0, free_count",4,2,6
"git_message_prettify(buffer, sizeof(buffer), ""This is longer\nAnd multiline\n# with some comments still in\n"", 1) > 0",3,3,6
"cl_fixture(""attr/attr3""), file->path",3,3,6
reference_is_packed(new_ref) == 0,4,2,6
"(item = git_sortedcache_lookup(sc, ""aaa"")) != NULL",4,2,6
exp.line_adds == 6,3,3,6
"expected, n",4,2,6
"""--no-tags"", opt",3,3,6
"""test123test\n"", git_note_message(_note)",4,2,6
"err->klass, GITERR_INVALID",4,2,6
!git_path_exists(path.ptr),5,1,6
t = git__malloc(sizeof(*t)),3,3,6
"true, git_oid_cmp(out, git_object_id(top_stash)) == 0",3,3,6
"""how"", GIT_STATUS_INDEX_MODIFIED",3,3,6
pos == kh_end(map),4,2,6
"0, expected->hunks",4,2,6
"GIT_EAMBIGUOUS, error",3,3,6
"GIT_ENOTFOUND, git_repository_discover(found_path, sizeof(found_path), ALTERNATE_NOT_FOUND_FOLDER, 0, ceiling_dirs)",3,3,6
"(item = git_sortedcache_lookup(sc, ""final"")) != NULL",4,2,6
git_repository_path(repo2) != NULL,4,2,6
"git_path_isdir(""typechanges"")",4,2,6
"str, ""one one one two two three three""",3,3,6
"!git_path_isfile(""testrepo/branch_file.txt"")",4,2,6
"git_message_prettify(NULL, 0, ""Short test"", 0) == 12",3,3,6
" ALL_LF_TEXT_RAW ""\n$Id: fcf6d4d9c212dc66563b1171b1cd99953c756467 $\n"", 0, ""crlf/lf.ident""",3,3,6
"""staged_delete_modified_file"", git_pathspec_match_list_entry(m, 3)",4,2,6
"message, git_commit_message(commit)",4,2,6
"ids, lengths, types",3,3,6
wi->entry.path[len - 1] == '/',3,3,6
"(item = git_sortedcache_entry(sc, 4)) != NULL",4,2,6
"strcmp(conflict_name->ours, ""ours"") == 0",4,2,6
"st.st_mode & 0777, 0755",3,3,6
"""remote_url"", remote_url",4,2,6
"GIT_MERGE_ANALYSIS_NORMAL, (analysis & GIT_MERGE_ANALYSIS_NORMAL)",3,3,6
"1, _fake->read_header_calls",4,2,6
"git_message_prettify(buffer, sizeof(buffer), ""This is longer\nAnd multiline\n# with some comments still in\n"", 0) > 0",3,3,6
"str, ""http://example.com/git/ab""",3,3,6
"path.ptr, check",3,3,6
"kh_val(map, pos), &items[i]",4,2,6
"""# comment\n"", ""# comment \n"", 0",4,2,6
"strcmp(current_master_tip, oid_str) == 0",3,3,6
t->old_oid = git__malloc(sizeof(*t->old_oid)),3,3,6
"GIT_ENOTFOUND, git_repository_discover(repository_path, sizeof(repository_path), DISCOVER_FOLDER, 0, ceiling_dirs)",3,3,6
is_merge == 0,4,2,6
GIT_ATTR_FALSE(assign->value),4,2,6
git_repository_workdir(repo2) != NULL,4,2,6
"expected_type, git_object_type(peeled)",4,2,6
"git_message_prettify(buffer, sizeof(buffer), """", 0) == 1",3,3,6
"0, expect.file_status[GIT_DELTA_MODIFIED]",4,2,6
"str, ""yes""",3,3,6
"git_oid_cmp(&expected, &oid) == 0",3,3,6
"""refs/stash^3"", ""untracked files on master: """,4,2,6
"40, item->value",4,2,6
"git_index_get_bypath(index, ""a/2.txt"", 0) != NULL",4,2,6
oid_str = git_oid_allocfmt(&actual->oid),3,3,6
"""refs/stash^3:when"", ""b6ed15e81e2593d7bb6265eb4a991d29dc3e628b""",4,2,6
"diff->stat_calls, 13 + 3",3,3,6
"git_message_prettify(buffer, sizeof(buffer), """", 1) == 1",3,3,6
"strcmp(conflict_name->ours, ""ours2"") == 0",4,2,6
"8, hunk_count",4,2,6
git_trace_level() == GIT_TRACE_INFO_AND_BELOW,3,3,6
conflict_name->theirs == NULL,4,2,6
"raw_message, git_commit_message_raw(commit)",4,2,6
"&_pathspecs, true, &after",4,2,6
(delta->flags & (GIT_DIFF_FLAG_BINARY|GIT_DIFF_FLAG_NOT_BINARY)) != 0,4,2,6
"i, v",4,2,6
"1, expected.lines",3,3,6
"1, (int)git_index_entrycount(index)",4,2,6
"message, entry->msg",4,2,6
"git_oid_equal(git_blob_id(d), &delta->new_file.id)",3,3,6
ident != NULL,4,2,6
"count, (int)git_cache_size(&g_repo->objects)",4,2,6
walk && commit,3,3,6
"repo, ""branch.track-local.remote"", false",4,2,6
"repo, ""branch.track-local.remote"", true",4,2,6
git_repository_head_orphan(repo) == 1,3,3,6
"3, expect.files",4,2,6
"(entry = git_index_get_bypath(index, ""all-lf"", 0)) != NULL",4,2,6
"""staged_delete_modified_file"", git_pathspec_match_list_entry(m, 4)",4,2,6
"""c47800c7266a2be04c571c04d5a6614691ea99bd"", 3, ""a65fed"", ""763d71"", ""849607""",4,2,6
"git_message_prettify(buffer, sizeof(buffer), ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890\n"" ""# 1234567890"" ""1234567890"" ""1234567890"" ""1234567890"" ""1234567890\n"" ""1234567890"", 1) > 0",3,3,6
"15, (int)hunk->old_lines",4,2,6
"tree, ""ab/me-neither/fgh/2.txt"", GIT_ENOTFOUND, NULL",3,3,6
"(int)size, (int)git_remote_refspec_count(_remote)",4,2,6
"(entry = git_index_get_bypath(index, ""crlf_file.txt"", 0)) != NULL",4,2,6
"st.st_mode & 0777, 0701",3,3,6
"3, free_count",4,2,6
"git_oid_cmp(&expected_oid, oid) == 0",4,2,6
"3, git_pathspec_match_list_failed_entrycount(m)",4,2,6
"st.st_mode & 0777, 0700",3,3,6
"true, i",4,2,6
entrycount > 4,4,2,6
"""just.renamed"", git_remote_name(_remote)",3,3,6
"found_path, expected_path",3,3,6
"git_message_prettify(NULL, 0, ""Test\n# with\nComments"", 1) == 15",3,3,6
self && self->nodes,3,3,6
"original_merge, ce->value",3,3,6
"git_sortedcache_entry(sc, 3) == NULL",4,2,6
"git_oid_streq(git_submodule_wd_id(sm), oid) == 0",4,2,6
buf,4,2,6
_actual != NULL,3,3,6
S_ISDIR(e->mode),4,2,6
"true, git_path_isfile(""./testrepo/ab/de/fgh/1.txt"")",4,2,6
"buffer, ""This is longer\nAnd multiline\n""",3,3,6
h,4,2,6
"0100755, result.mode",6,0,6
"(entry = git_index_get_bypath(index, ""all-crlf"", 0)) != NULL",4,2,6
"""--tags"", opt",3,3,6
values[0] == NULL,3,3,6
"0, expect.line_ctxt",4,2,6
"reuc = git_index_reuc_get_bypath(repo_index, ""newfile.txt"")",4,2,6
expected.hunks == 2,3,3,6
resolved && diff_list && conflict,5,1,6
"plain->username, ""alice""",4,2,6
"GIT_MERGE_ANALYSIS_FASTFORWARD, (analysis & GIT_MERGE_ANALYSIS_FASTFORWARD)",3,3,6
"""who"", GIT_STATUS_CURRENT",3,3,6
"ref, ""refs/heads/master""",3,3,6
"strcmp(conflict_name->ancestor, ""ancestor"") == 0",4,2,6
"NULL, git_pathspec_match_list_entry(m, 7)",4,2,6
"1, expect.files",4,2,6
"GIT_ENOTFOUND, git_repository_discover(found_path, sizeof(found_path), SUB_REPOSITORY_FOLDER_SUB, 0, ceiling_dirs)",3,3,6
"exp, ""origin/HEAD""",3,2,5
"git_object_string2type(""REF_DELTA"") == GIT_OBJ_REF_DELTA",3,2,5
"GIT_ENOTFOUND, git_reference_lookup(&reference, g_repo, ""refs/test/master"")",3,2,5
"git_remote__urlfordirection(_remote, GIT_DIRECTION_PUSH), ""git://github.com/libgit2/libgit2""",3,2,5
"git_oid_streq(git_submodule_index_id(sm), ""be3563ae3f795b2b4353bcce3a527ad0a4f7f644"") == 0",5,0,5
tagger1->when.offset == 60,3,2,5
"""this doesn't make sense~2""",3,2,5
!path.is_dir,3,2,5
git_object_typeisloose(GIT_OBJ_OFS_DELTA) == 0,3,2,5
"true, ""refs/heads/master""",3,2,5
"""be3563a^-1""",3,2,5
"git_oid_cmp(&object_id, &existing_object_id) == 0",3,2,5
"""refs/tags/e90810b@{u}""",3,2,5
git_object_typeisloose(8) == 0,3,2,5
git__fromhex('C') == 0xc,3,2,5
"""point_to_blob:readme.txt""",3,2,5
"git_path_topdir(""/usr/.git"") == NULL",3,2,5
" ""$Id: f7830382dac1f1583422be5530fdfbd26289431b$\n"" MORE_LF_TEXT_AS_LF, 0, ""crlf/more1.identlf""",3,2,5
"5, exp.lines",3,2,5
"""@{-1b}""",3,2,5
str && str == big && *(str+GIT_OID_HEXSZ+3) == 'Z',3,2,5
entry->msg == NULL,3,2,5
"""master@{0}@{0}""",3,2,5
"""e90810b@{u}""",3,2,5
"actual.line_dels, expected->line_dels",3,2,5
"4, exp.line_dels",3,2,5
"""8d1f13f93c4995760ac07d129246ac1ff64c0be9\n"", 41, ""rebase/.git/rebase-merge/cmt.2""",5,0,5
"GIT_ENOTFOUND, git_reference_lookup(&underlying, _repo, ""refs/remotes/just/renamed"")",3,2,5
git_object_typeisloose(GIT_OBJ_COMMIT) == 1,3,2,5
"reference->name, GIT_HEAD_FILE",3,2,5
"_repo, ""remote.just/renamed.fetch"", ""+refs/*:refs/*""",3,2,5
((my_struct *)old)->content == ((my_struct *)new)->content,3,2,5
"git_oid_cmp(&expected_commit_oid, &commit_oid) == 0",3,2,5
"GIT_ENOTFOUND, git_path_prettify(&p, NON_EXISTING_FILEPATH ""/so-do-i"", NULL)",3,2,5
"reference->name, head_tracker_sym_ref_name",3,2,5
"p_inet_pton(AF_INET6, in6_addr_data[i].p, &addr6) == 1",3,2,5
"2, st.count",3,2,5
"!git_index_find(&idx, index, test_entries[i].path)",3,2,5
object_out,3,2,5
"expected1, buf.ptr",3,2,5
"dels, actual_dels",3,2,5
"expected, actual.ptr",5,0,5
"a.ptr, ""test/string/join""",3,2,5
*(str+(i+1)) == 'Z',3,2,5
"git__suffixcmp(""a"", ""b"") < 0",3,2,5
"GIT_BRANCH_LOCAL, 12",3,2,5
"git__prefixcmp(""a"", ""b"") < 0",3,2,5
"looked_up_ref->name, ref_two_name_new",3,2,5
"""321cbdf08803c744082332332838df6bd160f8f9"", ""dummy.data""",3,2,5
" ""Another test\n$59001fe193103b1016b27027c0c827d036fd0ac8 :dI$\nCrazy!\n"", buf.ptr",3,2,5
"git_object_type2string(GIT_OBJ__EXT1), """"",3,2,5
"_repo, ""remote.just/renamed.fetch"", true",3,2,5
"expected_path, p",3,2,5
expected_st.st_size == st.st_size,3,2,5
expected->when.offset == actual->when.offset,3,2,5
" GIT_EINVALIDSPEC, git_revparse_single(&g_obj, g_repo, invalid_spec)",3,2,5
"git_object_type2string(GIT_OBJ_COMMIT), ""commit""",3,2,5
x.length == 5,3,2,5
tgt.size == expected_size,3,2,5
"count_all, count_all_post_reset",3,2,5
actual,3,2,5
"""@{-0}""",3,2,5
"rule->match.length == strlen(""pat1"")",3,2,5
"git_path_topdir("""") == NULL",3,2,5
"true, ""HEAD""",3,2,5
"looked_up_ref->name, new_head",3,2,5
"entrycount, git_reflog_entrycount(g_reflog)",3,2,5
"GIT_OBJ_COMMIT, git_object_type((git_object*)target)",3,2,5
"1, (int)array.count",3,2,5
git_object_typeisloose(GIT_OBJ_BAD) == 0,3,2,5
"expected, result.ptr, result.len",5,0,5
"-1, index->tree->entry_count",5,0,5
"git_object_type2string(1234), """"",3,2,5
"ref->name, refnames[i]",3,2,5
"bname.ptr, git_reference_symbolic_target(head)",3,2,5
" git__suffixcmp(workdir, expected_working_directory) == 0 ",3,2,5
"GIT_EBAREREPO, git_status_file(&status, repo, ""dummy"")",3,2,5
expected->when.time == actual->when.time,3,2,5
"false, ""refs/heads/subtrees""",3,2,5
"git_submodule_lookup(NULL, g_repo, ""nonexistent"") == GIT_ENOTFOUND",3,2,5
"strlen(ALL_LF_TEXT_AS_CRLF), entry->file_size",3,2,5
"behind, 0",3,2,5
" expected_names[count_all_post_reset], entry->path",3,2,5
"GIT_STATUS_WT_DELETED, status",3,2,5
"exp2, out",3,2,5
"20, (int)refnames.count",4,1,5
"CreateDirectoryW(_wdest, NULL)",3,2,5
"GIT_ENOTFOUND, git_path_prettify(&p, NON_EXISTING_FILEPATH, NULL)",3,2,5
"memcmp(out.id, exp, sizeof(out.id)) == 0",3,2,5
"""master@{-2}""",3,2,5
"git__prefixcmp(""b"", ""a"") > 0",3,2,5
"4, cases",3,2,5
"expected_status, status",3,2,5
"tagger1->name, tagger_name",3,2,5
"5, perf.oid_calculations",5,0,5
out[GIT_OID_HEXSZ] == 'Z',3,2,5
short_tag->message == NULL,3,2,5
git__fromhex('1') == 0x1,3,2,5
"git_object_type2string(GIT_OBJ_REF_DELTA), ""REF_DELTA""",3,2,5
operation,3,2,5
"git__suffixcmp(""zaz"", ""ac"") > 0",3,2,5
"git_oid_cmp(&entry->id, &expected_oid) == 0",4,1,5
"GIT_ENOTFOUND, git_repository_head(&head, repo)",3,2,5
"LIBGIT2_VER_MINOR, minor",3,2,5
"actual.hunks, expected->hunks",3,2,5
""""", "" """,4,1,5
"""@{-3}@{0}""",3,2,5
"git_tag_message(tag), tagger_message",3,2,5
count == 2,3,2,5
"git_config_get_int32(&i, cfg, ""core.dummy"") == GIT_ENOTFOUND",3,2,5
"&buf, ""/a/b/c"", ""//a/b/c""",3,2,5
git_index_entrycount(index) == index_entry_count,3,2,5
"git_object_type2string(-2), """"",3,2,5
"12, exp.line_adds",3,2,5
"git_path_topdir(""."") == NULL",3,2,5
"""da9c51a23d02d931a486f45ad18cda05cf5d2b94\n"", 41, ""rebase/.git/rebase-merge/cmt.1""",5,0,5
db,4,1,5
x.length == 20,3,2,5
"""@{u}@{-1}""",3,2,5
"git_path_topdir(""a"") == NULL",3,2,5
"strcmp(message, ""Hello world!"") == 0",3,2,5
should_fail || expected_result,3,2,5
"behind, 4",3,2,5
DeleteFileW(wsource),3,2,5
"""refs/heads/*"", git_refspec_src(_refspec)",3,2,5
count == 6,3,2,5
git_iterator_ignore_case(i) == ignore_case,3,2,5
"expected[idx].path, entry->path",3,2,5
git_index_entrycount(index) == index_entry_count_2,3,2,5
"expected_str, value",3,2,5
rule != NULL,3,2,5
root,3,2,5
"git__suffixcmp(""a"", """") == 0",3,2,5
assign != NULL,3,2,5
*(str+i) == '\0',3,2,5
"MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, _dest, -1, wdest, MAX_PATH)",3,2,5
"""Inv@{id""",3,2,5
"git_object_string2type(""tree"") == GIT_OBJ_TREE",3,2,5
i == 2147483657LL,3,2,5
"memcmp(&addr6, in6_addr_data[i].n, sizeof(struct in6_addr)) == 0",3,2,5
"rule->match.length == strlen(""pat2"")",3,2,5
i == -2147483657LL,3,2,5
"looked_up_ref->name, packed_head_name",3,2,5
"""e9671e138a780833cb689753570fd10a55be84fb"", ""dummy.txt""",3,2,5
min_len < 0,3,2,5
"reference->name, packed_test_head_name",3,2,5
"false, git_path_isfile(""testrepo/readme.txt"")",3,2,5
git_remote_connected(remote),3,2,5
"git_oid_cmp(&a, &b) > 0",3,2,5
entry->file_size == st.st_size,3,2,5
"repo, ""what"", GIT_STATUS_INDEX_MODIFIED",4,1,5
"git_object_type2string(GIT_OBJ_BAD), """"",3,2,5
"""point_to_blob^{blob}~""",3,2,5
"""master~bar""",3,2,5
"passcase->email, person.email",3,2,5
git__fromhex('F') == 0xf,3,2,5
git_object_typeisloose(GIT_OBJ_TAG) == 1,3,2,5
"git_object_type2string(GIT_OBJ_TREE), ""tree""",3,2,5
"""test/string/join"", a.ptr",5,0,5
"""master^{/((}""",3,2,5
git_object_typeisloose(1234) == 0,3,2,5
"git_buf_cstr(&buf2), ""shoop da 23 woop 42""",3,2,5
"ref_name_from_tag_name.ptr, loose_tag_ref_name",3,2,5
tagger1->when.time == 123456789,3,2,5
buffer_out && size > 0,3,2,5
"a.ptr, ""test/string""",3,2,5
"""/"", p.ptr",3,2,5
"1, findings[pos].encounters",3,2,5
"actual.lines, expected->lines",3,2,5
"_repo, ""branch.master.remote"", ""test""",3,2,5
"GIT_STATUS_INDEX_DELETED, status",3,2,5
20 == GIT_OID_RAWSZ,3,2,5
repo && old_tree && new_tree && diff,3,2,5
rule,3,2,5
"git_buf_cstr(&buf2), ""shoop da 23 """,3,2,5
rule->assigns.length == 2,3,2,5
"git__suffixcmp(""b"", ""a"") > 0",3,2,5
"git_oid_streq(git_tree_id(tree), oid_p) == 0",3,2,5
"(int)tag_list.count, 6",3,2,5
"""be3563a^{tree}~""",3,2,5
"git__suffixcmp(""zaa"", ""ac"") < 0",3,2,5
"expected_values[count_post_reset], entry->path",3,2,5
"GIT_ENOTFOUND, git_revparse_single(&target, repo, ""refs/remotes/origin/bim_with_3d@11296"")",3,2,5
"exp, ""master""",3,2,5
"exp, ""origin/packed""",3,2,5
"8, data.count",4,1,5
git_object_typeisloose(-2) == 0,3,2,5
"GIT_ENOTFOUND, git_reference_lookup(&reference, g_repo, ""refs/tags/test/farther/master"")",3,2,5
"""master~0bar""",3,2,5
git_object_typeisloose(GIT_OBJ_REF_DELTA) == 0,3,2,5
tgt && src,3,2,5
!assign,3,2,5
"git_oid_streq(git_submodule_head_id(sm), ""be3563ae3f795b2b4353bcce3a527ad0a4f7f644"") == 0",5,0,5
"git__suffixcmp("""", ""a"") < 0",3,2,5
"git_refspec_src_matches(_refspec, ""refs/heads/multi/level/branch"")",3,2,5
"git__suffixcmp("""", """") == 0",3,2,5
patch && print_cb,3,2,5
entry->uid == st.st_uid,3,2,5
"git_remote_pushurl(_remote2), ""git://github.com/libgit2/pushlibgit2""",3,2,5
expected.files_binary > 0,3,2,5
str && str == big && *(str+GIT_OID_HEXSZ) == '\0',3,2,5
git_path_exists(path),3,2,5
"git__suffixcmp(""ba"", ""a"") == 0",3,2,5
git__fromhex('f') == 0xf,3,2,5
sizeof(out.id) == GIT_OID_RAWSZ,3,2,5
"git_oid_cmp(oid, &entry->oid_old) == 0",3,2,5
INVALID_FILE_ATTRIBUTES == GetFileAttributesW(wdest),3,2,5
0 == fs_rmdir_rmdir(_wsource),3,2,5
"git__prefixcmp(""ab"", ""aa"") > 0",3,2,5
"actual.line_adds, expected->line_adds",3,2,5
expected[idx].path == NULL,3,2,5
git__fromhex('0') == 0x0,3,2,5
"git_object_type2string(GIT_OBJ_BLOB), ""blob""",3,2,5
"git_path_basename_r(&base, A) >= 0",3,2,5
"false, git_path_isfile(git_buf_cstr(&moved_log_path))",3,2,5
"git__prefixcmp(""ab"", ""ac"") < 0",3,2,5
"((my_struct *)git_vector_get(&x, i))->content == i",3,2,5
git__fromhex('a') == 0xa,3,2,5
"CopyFileW(buf_source, buf_dest, TRUE)",3,2,5
strlen(git_buf_cstr(&buf1)) == strlen(test_string) * 2,3,2,5
"11, exp.hunks",3,2,5
"""b146bd7608eac53d9bf9e1a6963543588b555c64\n"", 41, ""rebase/.git/ORIG_HEAD""",5,0,5
"_refspec->push, false",3,2,5
count == 4,3,2,5
"git_vector_get(&x, i) == (void*)(i / 2 + 1)",3,2,5
"git_object_type2string(GIT_OBJ_TAG), ""tag""",3,2,5
"LIBGIT2_VER_MAJOR, major",3,2,5
info->expect[info->expect_idx] != NULL,3,2,5
n->count == 1,3,2,5
"SetFileAttributesW(wsource, attrs & ~FILE_ATTRIBUTE_READONLY)",3,2,5
"git_buf_cstr(&buf1), test_string",3,2,5
"git_object_string2type(""OFS_DELTA"") == GIT_OBJ_OFS_DELTA",3,2,5
"git__prefixcmp(""ab"", ""a"") == 0",3,2,5
"looked_up_ref->name, ""refs/heads/test""",3,2,5
strlen(git_buf_cstr(&buf)) == (size_t)((i + 1) * 2),3,2,5
"expected_flat, count",3,2,5
"_repo, ""remote.test.fetch"", true",3,2,5
"git_blob_rawsize(b), delta->new_file.size",3,2,5
"tagger1->email, tagger_email",3,2,5
" git__suffixcmp(git_repository_path(_repo), expected_path_repository) == 0 ",3,2,5
40 == GIT_OID_HEXSZ,3,2,5
str && str == big && *(str+GIT_OID_HEXSZ+2) == 'Y',3,2,5
"repository, target, ""mergeless""",3,2,5
"GIT_EEXISTS, git_branch_create(&branch, repo, ""br2"", target, 0)",3,2,5
""":/""",3,2,5
tagger1 != NULL,3,2,5
"a.ptr, ""test""",3,2,5
str && str == big && *(str+GIT_OID_HEXSZ+1) == 'X',3,2,5
"""b146bd7608eac53d9bf9e1a6963543588b555c64\n"", 41, ""rebase/.git/rebase-merge/cmt.5""",5,0,5
"true, git_path_isfile(git_buf_cstr(&moved_log_path))",3,2,5
"&tree_index_id, &tree_updater_id",5,0,5
rule->assigns.length == 5,3,2,5
git__fromhex('X') == -1,3,2,5
"0, git_status_list_entrycount(status)",4,1,5
"memcmp(o->data, d->data, o->len) == 0",3,2,5
"git_path_dirname_r(&dir, A) >= 0",3,2,5
"GIT_ENOTFOUND, git_repository_set_head(repo, ""refs/tags/doesnt/exist/yet"")",3,2,5
sizeof(out) == GIT_OID_RAWSZ,3,2,5
"exp, ""origin/master""",3,2,5
"(int)passcase->time, (int)person.when.time",3,2,5
"rule->match.length == strlen(""pat0"")",3,2,5
"5, counts.entry_count",5,0,5
"GIT_EINVALIDSPEC, git_branch_create(&branch, repo, ""inv@{id"", target, 0)",3,2,5
"git_oid_streq(git_tree_id(tree), oid_ppp) == 0",3,2,5
tree && filename,3,2,5
INVALID_FILE_ATTRIBUTES != source_attrs,3,2,5
"14, exp.files",3,2,5
"""refs/remotes/addtest/*"", git_refspec_dst(_refspec)",3,2,5
t->name = git__strdup(refname),3,2,5
"_repo, ""remote.just/renamed.fetch"", ""+refs/heads/*:refs/remotes/just/renamed/*""",3,2,5
git_tag_target_type(tag1) == GIT_OBJ_TAG,3,2,5
"""@{-1}@{-1}""",3,2,5
"git__prefixcmp("""", ""a"") < 0",3,2,5
t != NULL,3,2,5
out[GIT_OID_HEXSZ + 1] == 'Z',3,2,5
"git_object_type2string(8), """"",3,2,5
"GIT_ENOTFOUND, git_revparse_single(&target, repo, ""origin/bim_with_3d@11296"")",3,2,5
"true, git_path_isfile(git_buf_cstr(&log_path))",4,1,5
git_buf_oom(&b) == 0,3,2,5
"(entry = git_index_get_bypath(index, ""TEST.txt"", 0)) != NULL",3,2,5
"passcase->offset, person.when.offset",3,2,5
short_tag != NULL,3,2,5
"&expected, &result",5,0,5
"8, exp.line_adds",3,2,5
"git_oid_cmp(&id, git_tag_id(short_tag)) == 0",3,2,5
"1, ca.count",3,2,5
"17, exp.lines",3,2,5
"_repo, ""branch.master.remote"", ""just/renamed""",3,2,5
git_object_typeisloose(GIT_OBJ__EXT2) == 0,3,2,5
"actual.files, expected->files",3,2,5
"git_remote_name(_remote2), ""test_with_pushurl""",3,2,5
"""e9671e138a780833cb689753570fd10a55be84fb"", ""dummy.dunno""",3,2,5
" ""Some text\n$Id: 3164f585d548ac68027d22b104f2d8100b2b6845$\nGoes there\n"", buf.ptr",3,2,5
DeleteFileW(buffer),3,2,5
"GIT_ENOTFOUND, git_repository_open(&repo, ""i-do-not/exist"")",3,2,5
"git_remote__urlfordirection(_remote2, GIT_DIRECTION_FETCH), ""git://github.com/libgit2/fetchlibgit2""",3,2,5
"""3069cc907e6294623e5917ef6de663928c1febfb\n"", 41, ""rebase/.git/rebase-merge/cmt.3""",5,0,5
"git_oid_cmp(&a, &b) < 0",3,2,5
o->len == d->dlen,3,2,5
"git_oid_cmp(&object_id, &target_id) == 0",3,2,5
rule->assigns.length == 3,3,2,5
"reference->name, packed_head_name",3,2,5
"""this doesn't make sense^1""",3,2,5
(dir = git_path_topdir(A)) != NULL,3,2,5
range,3,2,5
"git_refspec_src_matches(_refspec, ""refs/heads/master"")",3,2,5
entry_statuses0[i] == status_flags,3,2,5
"git_object_type2string(GIT_OBJ__EXT2), """"",3,2,5
"count - 1, git_reflog_entrycount(reflog)",3,2,5
"git_oid_streq(git_tree_id(tree), oid_pp) == 0",3,2,5
"expected->status, actual->status, ""%04x""",3,2,5
git_object_typeisloose(GIT_OBJ_TREE) == 1,3,2,5
"_refspec->push, true",3,2,5
git__fromhex('g') == -1,3,2,5
"passcase->name, person.name",3,2,5
"strlen(expected), result.len",5,0,5
"looked_up_ref->name, new_head_tracker",3,2,5
"p_lstat(""this_file_does_not_exist"", &st) < 0",3,2,5
"git_object_string2type(""tag"") == GIT_OBJ_TAG",3,2,5
index->tree == NULL,5,0,5
"(int)sucessfully_found, (int)data->expected_matches",3,2,5
"15, exp.files",3,2,5
bytes_received > 0,3,2,5
"CopyFileW(wsource, wdest, TRUE)",3,2,5
"repository, target, ""remoteless""",3,2,5
git__fromhex('c') == 0xc,3,2,5
repo && remote,4,1,5
"actual.line_ctxt, expected->line_ctxt",3,2,5
"ignored == expected[idx].ignored, expected[idx].path",3,2,5
"&commit_id, git_reflog_entry_id_new(reflog_entry)",5,0,5
git__fromhex('9') == 0x9,3,2,5
backend && oid,4,1,5
" ""Some text\r\n$Id: 3164f585d548ac68027d22b104f2d8100b2b6845$\r\nGoes there\r\n"", buf.ptr",3,2,5
tgt.asize == expected_asize,3,2,5
min_len == GIT_OID_HEXSZ + 1,3,2,5
"git__prefixcmp("""", """") == 0",3,2,5
"git_object_string2type("""") == GIT_OBJ_BAD",3,2,5
"!git__suffixcmp(git_repository_path(_repo), ""/templated.git/"")",3,2,5
"git_submodule_lookup(NULL, g_repo, ""modified"") == GIT_ENOTFOUND",3,2,5
git_repository_is_bare(_repo),3,2,5
"counter, n",3,2,5
"""@{-xyz}""",3,2,5
entry->file_size == strlen(ALL_CRLF_TEXT_RAW),3,2,5
(S_ISGID & st.st_mode) == S_ISGID,3,2,5
source,3,2,5
"GIT_ENOTFOUND, git_reference_lookup(&underlying, _repo, ""refs/remotes/test/master"")",3,2,5
git_object_typeisloose(GIT_OBJ__EXT1) == 0,3,2,5
"GIT_ENOTFOUND == git_index_find(NULL, index, test_entries[i].path)",3,2,5
"3, exp.file_status[GIT_DELTA_ADDED]",4,1,5
"GIT_EINVALIDSPEC, git_branch_move(&new_ref, original_ref, ""Inv@{id"", 0)",3,2,5
"expected, current_value",3,2,5
side == conflict->ours || side == conflict->theirs,3,2,5
" GIT_ENOTFOUND, git_object_lookup_prefix(&object, g_repo, &oid, strlen(commit), GIT_OBJ_TAG)",3,2,5
data->expected_matches <= MAX_USED_TAGS,3,2,5
line == line_end,3,2,5
"GIT_EUNBORNBRANCH, git_repository_detach_head(repo)",3,2,5
"""^""",3,2,5
"""b146bd7608eac53d9bf9e1a6963543588b555c64\n"", 41, ""rebase/.git/rebase-merge/orig-head""",5,0,5
git__fromhex('z') == -1,3,2,5
rule->match.length == 1,3,2,5
"git__prefixcmp(""a"", """") == 0",3,2,5
str && str == out && *(str+GIT_OID_HEXSZ) == '\0',3,2,5
git_refspec_force(_refspec) == 1,3,2,5
git__fromhex('3') == 0x3,3,2,5
"a.ptr, ""test/string/join/test/string/join/more""",3,2,5
1 == 1,3,2,5
"expected_total, count",3,2,5
" GIT_EAMBIGUOUS, git_revparse_single(&g_obj, g_repo, ""e90"")",3,2,5
!value,3,2,5
" ""\r\n$Id: 74677a68413012ce8d7e7cfc3f12603df3a3eac4$\r\n"" MORE_CRLF_TEXT_AS_CRLF, 0, ""crlf/more2.identcrlf""",3,2,5
git_buf_oom(&buf1) == 0,3,2,5
"git_vector_get(&x, i) == (void*)(i + 1)",3,2,5
str && str == out,3,2,5
"git_tag_name(short_tag), ""no_description""",3,2,5
"git_object_type2string(GIT_OBJ_OFS_DELTA), ""OFS_DELTA""",3,2,5
"git_tree_entry_name(entry), ""README""",3,2,5
"SetFileAttributesW(buffer, find_data.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY)",3,2,5
"ahead, 3",3,2,5
" GIT_PERMS_IS_EXEC(st.st_mode), GIT_PERMS_IS_EXEC(entry->mode)",3,2,5
"git_reference_type(head) == GIT_REF_SYMBOLIC, branch",3,2,5
"""588e5d2f04d49707fe4aab865e1deacaf7ef6787\n"", 41, ""rebase/.git/rebase-merge/cmt.4""",5,0,5
"git_object_string2type(""CoMmIt"") == GIT_OBJ_BAD",3,2,5
entry->gid == st.st_gid,3,2,5
id && obj,3,2,5
"""point_to_blob^{blob}^""",3,2,5
"""e90810b8df3e80c413d903f631643c716887138d"", GIT_OBJ_TREE, ""53fc32d17276939fc79ed05badaef2db09990016"", GIT_OBJ_TREE",3,2,5
"""master"",name",3,2,5
"GIT_ENOTFOUND, git_reference_lookup(&reference, g_repo, ""TEST_MASTER"")",3,2,5
git_repository_is_bare(_repo) == is_bare,3,2,5
"""~""",3,2,5
"git_object_string2type(""commit"") == GIT_OBJ_COMMIT",3,2,5
"another_looked_up_ref->name, brand_new_name",3,2,5
"""wrapped_tag^{trip}""",3,2,5
"git_object_string2type(""hohoho"") == GIT_OBJ_BAD",3,2,5
treediff_conflict_data_len == merge_diff_list->conflicts.length,3,2,5
assign == NULL,3,2,5
"git_remote__urlfordirection(_remote, GIT_DIRECTION_FETCH), ""git://github.com/libgit2/libgit2""",3,2,5
0 == fs_rm_wait(wsource),3,2,5
"""this doesn't make sense""",3,2,5
"git_remote__urlfordirection(_remote2, GIT_DIRECTION_PUSH), ""git://github.com/libgit2/pushlibgit2""",3,2,5
type == 't' || type == 'T' || type == 'b' || type == 'B',3,2,5
"LIBGIT2_VER_REVISION, rev",3,2,5
"""refs/heads/master""",4,1,5
"git_remote_url(_remote), ""http://github.com/libgit2/libgit2""",3,2,5
"value, check",3,2,5
"git_object_string2type(""blob"") == GIT_OBJ_BLOB",3,2,5
git_object_string2type(NULL) == GIT_OBJ_BAD,3,2,5
"GIT_BRANCH_REMOTE, 3",3,2,5
"g_repo, ""sm_just_added_head""",5,0,5
"""master~-1""",3,2,5
"was_called, true",3,2,5
"git_remote_url(_remote2), ""git://github.com/libgit2/fetchlibgit2""",3,2,5
"GIT_ENOTFOUND, git_repository_set_head_detached(repo, &oid)",3,2,5
"exp, ""nulltoken/master""",3,2,5
"(fd = p_creat(d->file, S_IREAD | S_IWRITE)) >= 0",3,2,5
o->type == git_object_string2type(d->type),3,2,5
"adds, actual_adds",3,2,5
git__fromhex('A') == 0xa,3,2,5
!git_remote_connected(remote),3,2,5
git_object_typeisloose(GIT_OBJ_BLOB) == 1,3,2,5
expected[idx] == NULL,3,2,5
"count, count_post_reset",3,2,5
"git_oid_cmp(&a, &b) == 0",3,2,5
"repository, target, ""mergeandremoteless""",3,2,5
"e->matched_pathspec, matched_pathspec",3,2,5
internal != NULL,3,2,5
"expected[idx], entry->path",3,2,5
"""be3563a^{tree}^""",3,2,5
errno == EEXIST,3,2,5
"GIT_ENOTFOUND, git_reference_lookup(&reference, g_repo, ""refs/tags/test/master"")",3,2,5
"rule->match.length == strlen(""pat8 with spaces"")",3,2,5
"!strcmp(git_object_type2string(GIT_OBJ_BAD), """")",2,2,4
"data, REP4(""0123456789"")",2,2,4
signature && log_message,2,2,4
"""hi, this is a ; multiline comment # with ;\n special chars and other stuff !@#"", str",2,2,4
"""B"", ""HEAD^^2^"", repo, &opts, &fmt_opts, false",2,2,4
"another_looked_up_ref->name, new_name",2,2,4
(GetFileAttributes(git_repository_path(_repo)) & FILE_ATTRIBUTE_HIDDEN) != 0,2,2,4
"strcmp(git_buf_cstr(&buf2), ""shoop da 23 woop 42"") == 0",2,2,4
GIT_REPOSITORY_STATE_CHERRY_PICK,2,2,4
"""Normal\nCRLF\nline-endings.\n"", out.ptr",4,0,4
"false, git_oid_cmp(&oid, git_object_id(next_top_stash)) == 0",2,2,4
"!strcmp(git_remote_name(_remote), ""test"")",2,2,4
"(int)strlen(""refs/heads/master"") + 1, git_branch_upstream_name(NULL, 0, repo, ""refs/heads/track-local"")",2,2,4
"git_config_get_int32(cfg, ""core.dummy"", &i) == GIT_ENOTFOUND",2,2,4
exp.files == 14,2,2,4
"expected, strlen(expected), TEST_REPO_PATH ""/applied.txt""",4,0,4
"""refs/heads/master"", git_refspec_src(actual_fs)",2,2,4
exp.line_dels == 3,2,2,4
"3, (int)td",2,2,4
object && !object->in_memory,2,2,4
"memcmp(git_blob_rawcontent(blob), AUTOMERGEABLE_MERGED_FILE, (size_t)entry->file_size) == 0",3,1,4
found_collision == 1,2,2,4
"!git_path_isdir(""testrepo/ab"")",3,1,4
"GIT_EINVALIDSPEC, git_reference_create( &new_reference, g_repo, name, &id, 0)",2,2,4
"0, git_index_entrycount(index)",2,2,4
" GIT_EUSER, git_tree_walk(tree, GIT_TREEWALK_POST, treewalk_stop_cb, &ct)",2,2,4
" 1, git_submodule_set_fetch_recurse_submodules(sm1, old_fetchrecurse)",2,2,4
"2, num_files",2,2,4
"0, p_mkdir(""xdg"", 0777)",2,2,4
((git_refcount *)new_index)->refcount == 1,2,2,4
"0, git__prefixcmp(git_buf_cstr(&label), expected_output)",2,2,4
"out, path",2,2,4
"repo, ""why"", GIT_STATUS_WT_NEW",2,2,4
"!strcmp(git_object_type2string(GIT_OBJ_TAG), ""tag"")",2,2,4
"!git_oid_cmp(&id, &should_id)",2,2,4
"!git_path_exists(""merge-resolve/"" GIT_MERGE_MSG_FILE)",2,2,4
"fetch_refspec1, array.strings[0]",2,2,4
"!strcmp(git_refspec_dst(_refspec), ""refs/remotes/test/*"")",2,2,4
git_object_owner((const git_object *)parents[i]) == repo,2,2,4
"value, ""test""",2,2,4
"2, exp.file_status[GIT_DELTA_IGNORED]",2,2,4
"GIT_ENOTFOUND, git_repository_message(&_actual, _repo)",2,2,4
containing_tree != NULL && expected_result == GIT_SUCCESS,2,2,4
"git_oid_cmp(&ff_oid, &expected) == 0",2,2,4
exp.lines == 15,2,2,4
a->old_attr - b->old_attr == 0,2,2,4
0 != (idx2head->opts.flags & GIT_DIFF_DELTAS_ARE_ICASE) && 0 != (wd2idx->opts.flags & GIT_DIFF_DELTAS_ARE_ICASE),2,2,4
"expected, is_ignored",2,2,4
path_len > prefix_len,2,2,4
"51, exp.file_status[GIT_DELTA_ADDED]",2,2,4
"tree, ""ab/de"", GIT_SUCCESS, ""f1425cef211cc08caa31e7b545ffb232acb098c3""",2,2,4
"git_blob_rawsize(c), delta->old_file.size",2,2,4
"git_submodule_lookup(&sm, g_repo, ""no_such_file"") == GIT_ENOTFOUND",2,2,4
"git_oid_cmp(&id, &entry->oid_cur) == 0",2,2,4
" GIT_ENOTFOUND, git_sysdir_find_global_file(&found, testfile)",4,0,4
type == GIT_OBJ_BLOB,2,2,4
git_diff_stats_files_changed(stats) == 4,2,2,4
"expected_remote_name_length, git_branch_remote_name(remotename, expected_remote_name_length, g_repo, remote_tracking_branch_name)",2,2,4
git__is_sizet(offset),2,2,4
"strcmp(conflicting_buf.ptr, CONFLICTING_DIFF3_FILE) == 0",3,1,4
"47 + 1640, nobj",3,1,4
"""how"", GIT_STATUS_CURRENT",2,2,4
" GIT_EUSER, git_note_foreach(_repo, ""refs/notes/i-can-see-dead-notes"", note_cancel_cb, &retrieved_notes)",2,2,4
"0, git_oid_cmp(&oid, git_reflog_entry_id_old(entry))",2,2,4
"git_oid_cmp(&oid, git_object_id(next_top_stash)) != 0",2,2,4
"git_reference_target(ref), ref_branch_name",2,2,4
ERROR_PATH_NOT_FOUND,2,2,4
log_path && oid_old && oid_new && committer,2,2,4
"expected3, text",2,2,4
c->expected == value,2,2,4
GIT_ATTR_FALSE == assign->value,2,2,4
" (int)GIT_SUBMODULE_UPDATE_REBASE, (int)git_submodule_set_update(sm1, GIT_SUBMODULE_UPDATE_RESET)",2,2,4
id && _backend && data,2,2,4
exp.files == 15,2,2,4
"value, assign->value",2,2,4
"old_url, git_submodule_url(sm1)",2,2,4
"cl_fixture(""attr/attr1""), file->ce->path",2,2,4
" (int)GIT_SUBMODULE_IGNORE_UNTRACKED, (int)git_submodule_ignore(sm2)",2,2,4
"GIT_EUSER, git_odb_foreach(_odb, foreach_stop_cb, NULL)",2,2,4
"expected_remote_name, buffer",2,2,4
"100, git_buf_text_hashsig_compare(a, b, 100)",2,2,4
str == NULL,2,2,4
"NULL, 3, ""41bc8c"", ""e90810"", ""a65fed""",3,1,4
git_diff_iterator_progress(iter) == 1.0f,2,2,4
" SHFileOperation(&fops) == 0, ""Windows SHFileOperation failed"" ",2,2,4
"git_oid_equal(git_blob_id(b), &delta->old_file.oid)",2,2,4
"entry_count6, entry_paths6, entry_statuses6, GIT_STATUS_SHOW_WORKDIR_ONLY",2,2,4
"git_oid_cmp(&expected, git_reference_target(ref)) == 0",2,2,4
((git_refcount *)new_odb)->refcount == 1,2,2,4
" cl_fixture(""template""), git_repository_path(_repo), ""hooks/link.sample"", 0",2,2,4
"GIT_EEXISTS, git_branch_move(&new_ref, original_ref, ""master"", 0, NULL, NULL)",2,2,4
!ret,2,2,4
object->source.open,2,2,4
"!strcmp(git_refspec_dst(_refspec), ""refs/*"")",2,2,4
"GIT_MERGE_STATUS_UP_TO_DATE, status",2,2,4
" GIT_EUSER, git_attr_foreach( g_repo, 0, ""sub/subdir_test1"", &cancel_iteration, &count) ",2,2,4
(ctx = git_hash_new_ctx()) != NULL,2,2,4
assign->value == NULL,2,2,4
merge_trivial_conflict_entrycount() == 1,2,2,4
"expected0, buf.ptr",2,2,4
out && repo && spec,2,2,4
"GIT_ENOTFOUND, git_buf_text_crlf_to_lf(&tgt, &src)",2,2,4
"strcmp(git_tag_message(tag), tagger_message) == 0",2,2,4
commit && new_parent,2,2,4
"strcmp(tagger1->name, tagger_name) == 0",2,2,4
"git_path_isdir(""submod2/.git/modules/"" SM_LIBGIT2)",2,2,4
"2, git_diff_stats_files_changed(_stats)",4,0,4
"9, (int)ta",2,2,4
"strcmp(dir, B) == 0",2,2,4
"git_oid_cmp(&ancestor_entry.oid, &conflict_entry[0]->oid) == 0",2,2,4
buffer[-1] == '^',2,2,4
"""<Yu V. Bin Haacked>"", signature->name",2,2,4
"str, ""c""",2,2,4
tree->entries.sorted,2,2,4
"""testfile.txt"", result.path",4,0,4
a->status - b->status == 0,2,2,4
"12, expected.line_adds",2,2,4
"strlen(ALL_LF_TEXT_RAW), entry->file_size",2,2,4
exp.file_mods == 4,2,2,4
"git_oid_cmp(&a->new_oid, &b->new_oid) == 0",2,2,4
"expected_patience, as_str",2,2,4
"GIT_DIR_PUSH, "":"", true",2,2,4
"""refs/notes/mydefaultnotesref"", default_ref",2,2,4
"counts->expected_paths[idx], p",2,2,4
"git_attr_cache__is_cached(g_repo, 0, "".git/info/exclude"")",2,2,4
exp.file_dels == 4,2,2,4
count == expected_count,2,2,4
reflog->entries.length == 2,2,2,4
"&pick_id, &rebase_operation.id",2,2,4
len_p && type_p && _backend && oid,2,2,4
exp.file_dels == 2,2,2,4
"GIT_ENOTFOUND, ""0266163a49e280c4f5ed1e08facd36a2bd716bcf"", GIT_OBJ_COMMIT",2,2,4
index_out && index_path,2,2,4
"git_path_exists(""./foo"")",2,2,4
remote && spec,2,2,4
"GIT_EINVALIDSPEC, git_reference_rename(&renamed_ref, looked_up_ref, ""i-will-sudo-you"", 0)",2,2,4
"git_oid_cmp(&id, git_reference_target(test_ref)) == 0",2,2,4
git_reference_is_packed(reference),2,2,4
"value_len, alloc_len - 1",2,2,4
"git_attr_cache__is_cached(g_repo, 0, "".git/info/attributes"")",2,2,4
"repo, ""branc#""",2,2,4
"git__strcmp(oldname, expected->oldname) == 0",2,2,4
" GIT_NOTFOUND, git_object_lookup(&object, g_repo, &oid, GIT_OBJ_TAG)",2,2,4
"16, git_message_prettify(buffer, 128, ""Initial commit"", 0)",2,2,4
"15, expected.lines",2,2,4
"strcmp(exp, big) == 0",2,2,4
" strlen(expected), git_diff_patch_size(patch, 1, 1, 1)",2,2,4
"0, p_mkdir(""xdg/git"", 0777)",2,2,4
git_reference_type(ref) == GIT_REF_SYMBOLIC,3,1,4
"15, (int)range->old_lines",2,2,4
count == 0,2,2,4
"expectedRemoteNameLength, git_branch_remote_name(NULL, 0, g_repo, git_reference_name(ref))",2,2,4
exp.files == 2,2,2,4
"(out = fopen(out_f.ptr, ""w"")) != NULL",2,2,4
"!git_path_exists(""merge-resolve/"" GIT_MERGE_MODE_FILE)",2,2,4
internal->position == (int)i,2,2,4
"mode, st.st_mode",2,2,4
"0, expected.line_adds",2,2,4
"0, p_mkdir(""etc"", 0777)",2,2,4
"&id1, &entry->id",4,0,4
"expected_value, out",2,2,4
"SM_LIBGIT2_BRANCH, git_submodule_branch(sm1)",2,2,4
result = merge_fastforward_branch(GIT_MERGE_NO_FASTFORWARD),2,2,4
"GIT_EUNMERGED, git_reset(repo, target, GIT_RESET_SOFT, NULL, NULL, NULL)",2,2,4
"5, count",2,2,4
"&expected_id, &ids[i]",2,2,4
"_repo, ""remote.durable.url"", false",2,2,4
out && repo && their_heads,2,2,4
result != Z_STREAM_ERROR,2,2,4
" GIT_ENOTFOUND, git_futils_find_global_file(temp, file)",2,2,4
"git_path_isfile(""submod2/"" SM_LIBGIT2B ""/.git/HEAD"")",2,2,4
" ""template"", git_repository_path(_repo), ""hooks/update.sample"", filemode",2,2,4
object->modified,2,2,4
"entry = git_index_get_bypath(result, ""removed-in-8.txt"", 1)",2,2,4
"!strcmp(git_object_type2string(1234), """")",2,2,4
"1, expected.line_adds",2,2,4
commit && name && email,2,2,4
"0, tags.count",2,2,4
"4, (int)td",2,2,4
"3, expected.line_ctxt",2,2,4
(caps & GIT_CAP_HTTPS) != 0,2,2,4
exp.line_ctxt == 4,2,2,4
"GITERR_NOMEMORY, giterr_last()->klass",4,0,4
git_reference_is_packed(looked_up_ref) != 0,2,2,4
git_vector_is_sorted(&index->reuc),4,0,4
"12, (int)ta",2,2,4
"git_path_isdir(""d0"")",3,1,4
"git_submodule_lookup(&sm, g_repo, ""just_a_dir"") == GIT_ENOTFOUND",2,2,4
"git_oid_streq(git_object_id((const git_object *)containing_tree), expected_raw_oid) == GIT_SUCCESS",2,2,4
"50, exp.file_status[GIT_DELTA_ADDED]",2,2,4
"""testrepo/new.txt""",4,0,4
git_pool__full_pages(&p) == 90,2,2,4
out && origin_url && workdir_path,2,2,4
"tree, ""ab/de/fgh/1.txt"", GIT_SUCCESS, ""3259a6bd5b57fb9c1281bb7ed3167b50f224cb54""",2,2,4
" ""diff --git a/zzz.normal b/zzz.normal\n"" ""index 45141a7..75b0dbb 100644\n"" ""--- a/zzz.normal\n"" ""+++ b/zzz.normal\n"" ""@@ -1,0 +2,3 @@ Hello from the root\n"" ""+More lines\n"" ""+And more\n"" ""+Go here\n"", pout",2,2,4
"expected, actual",2,2,4
" GIT_EUSER, git_tree_walk( tree, GIT_TREEWALK_PRE, treewalk_stop_immediately_cb, NULL)",2,2,4
"GIT_EBAREREPO, git_reset(bare, target, GIT_RESET_HARD)",2,2,4
"1, git_submodule_fetch_recurse_submodules(sm2)",2,2,4
"entry_count0, entry_paths0, entry_statuses0, repo, GIT_STATUS_SHOW_INDEX_AND_WORKDIR, 0",2,2,4
"merge_test_index(index, merge_index_entries, 20)",3,1,4
obj && _backend && oid,2,2,4
workdir,2,2,4
"p_stat(object_path, &st) == 0",2,2,4
"git_oid_cmp(&expected, &actual) == 0",2,2,4
"str, ""hiya""",2,2,4
removal_type == GIT_DIRREMOVAL_EMPTY_HIERARCHY || removal_type == GIT_DIRREMOVAL_FILES_AND_DIRS || removal_type == GIT_DIRREMOVAL_ONLY_EMPTY_DIRS,2,2,4
a->status != GIT_DELTA_UNMODIFIED,2,2,4
(caps & GIT_CAP_THREADS) != 0,2,2,4
file_content && repo_path && ref_name,2,2,4
"expectedRemoteNameLength, git_branch_remote_name(NULL, 0, g_repo, ref)",2,2,4
"path, ""/""",3,1,4
out && db && loc,2,2,4
"!git__strcmp(""boom"", git_buf_cstr(&content))",2,2,4
"0, index->tree->entry_count",2,2,4
"strcmp(exp2, out) == 0",2,2,4
repo && treeish,2,2,4
"GIT_EORPHANEDHEAD, git_repository_head(&head, repo)",2,2,4
(caps & GIT_CAP_HTTPS) == 0,2,2,4
"git_oid_streq(git_submodule_wd_oid(sm), oid) == 0",2,2,4
"data, """"",2,2,4
"git_oid_cmp(&expected_target_oid, annotated_obj_id) == 0",2,2,4
"git_path_isfile(""submod2/.git/modules/"" SM_LIBGIT2 ""/HEAD"")",2,2,4
"git_attr_cache__is_cached(g_repo, 0, ""sub/.gitattributes"")",2,2,4
(onto->opts.flags & GIT_DIFF_DELTAS_ARE_ICASE) != 0 && (from->opts.flags & GIT_DIFF_DELTAS_ARE_ICASE) != 0,2,2,4
"expected_len, git_status_list_entrycount(status_list)",2,2,4
"expected_patch_text[d], text",2,2,4
"5, git_patch_num_lines_in_hunk(p, 0)",2,2,4
index_out && repo,2,2,4
(i == 0) || path != buffer_start,2,2,4
"git_oid_cmp(&expected, &ref->target.oid) == 0",2,2,4
target && signature && log_message,2,2,4
name,4,0,4
"""refs/heads/packed"", false",3,1,4
"entry = git_index_get_bypath(repo_index, ""removed-in-10-branch.txt"", 1)",2,2,4
"0, git_pqueue_size(&pq)",4,0,4
"GIT_DELTA_UNMODIFIED, git_patch_delta(p)->status",2,2,4
"actual_hunks, num_hunks",2,2,4
_tls_init,2,2,4
"0, (int)tc",2,2,4
"&_pathspecs, true, NULL",3,1,4
"5, exp.file_adds",2,2,4
patch && delta,2,2,4
exp.line_dels == 0,2,2,4
"""7b4384978d2493e851f9cca7858815fac9b10980"", GIT_OBJ_ANY, ""e90810b8df3e80c413d903f631643c716887138d"", GIT_OBJ_COMMIT",3,1,4
"10, (int)p.items",2,2,4
"GIT_BRANCH_LOCAL, 7",2,2,4
"!strcmp(git_object_type2string(GIT_OBJ_TREE), ""tree"")",2,2,4
fd != -1,3,1,4
" ""diff --git a/zzz.binary b/zzz.binary\n"" ""index 45141a7..75b0dbb 100644\n"" ""Binary files a/zzz.binary and b/zzz.binary differ\n"", pout",2,2,4
"repo, ""bra\nch""",2,2,4
delta_is_split(from),2,2,4
"9, git_patch_num_lines_in_hunk(p, 1)",2,2,4
"""when"", GIT_ENOTFOUND",2,2,4
"!git_oid_cmp(git_reference_target(ref), &id)",2,2,4
"!strcmp(git_reference_target(ref), ref_master_name)",2,2,4
"2, (int)git_patch_num_hunks(p)",2,2,4
"GIT_MERGE_ANALYSIS_UP_TO_DATE, analysis",2,2,4
"entry = git_index_get_bypath(repo_index, ""removed-in-both.txt"", 1)",2,2,4
"a->path, b->path",2,2,4
"""Out of memory"", giterr_last()->message",4,0,4
"how_many_refs, 20",2,2,4
""".git"", reserved[0].ptr",4,0,4
"GIT_ENOTFOUND, ""0266163a49e280c4f5ed1e08facd36a2bd716bcf"", GIT_OBJ_ANY",2,2,4
"git_oid_cmp(&expected, &entry->id) == 0",2,2,4
reply->type != REDIS_REPLY_ERROR,2,2,4
delta->status <= GIT_DELTA_TYPECHANGE,2,2,4
"git_path_isfile(""testrepo/ab/de/fgh/1.txt"")",3,1,4
"expected, is_ignored == 1",2,2,4
"0, p_mkdir(""home"", 0777)",2,2,4
"strcmp(git_buf_cstr(&buf2), ""shoop da 23 "") == 0",2,2,4
exp.file_untracked == 2,2,2,4
"strcmp(remote_url, ""remote_url"") == 0",2,2,4
git_pool__open_pages(&p) == 0,2,2,4
"5, exp.file_untracked",2,2,4
oid,2,2,4
"""8496071c1b46c854b31185ea97743be6a8774479"", 3, ""849607"", ""a65fed"", ""763d71""",3,1,4
"git_oid_cmp(&expected_note_oid, blob_id) == 0",2,2,4
" GIT_EUSER, git_status_foreach(repo, cb_status__interrupt, &count) ",2,2,4
"""../c_wd/"", worktree_path",2,2,4
idx[j] < p->obj_cnt,2,2,4
"13, exp.lines",2,2,4
git_pool__open_pages(&p) + git_pool__full_pages(&p) == 4,2,2,4
"entry = git_index_get_bypath(result, ""removed-in-8.txt"", 3)",2,2,4
" ""template"", git_repository_path(_repo), ""hooks/link.sample"", filemode",2,2,4
ids,4,0,4
git_strmap_num_entries(table) == 0,2,2,4
"6, git_diff_patch_num_lines_in_hunk(p, 0)",2,2,4
" (int)GIT_SUBMODULE_IGNORE_UNTRACKED, (int)git_submodule_set_ignore(sm1, GIT_SUBMODULE_IGNORE_RESET)",2,2,4
self,2,2,4
"!strcmp(looked_up_ref->name, packed_test_head_name)",2,2,4
" GIT_EEXISTS, git_remote_create(&remote, _repo, ""test"", ""git://github.com/libgit2/libgit2"")",2,2,4
git_diff_stats_deletions(stats) == 0,2,2,4
pos >= 0,2,2,4
"!git_oid_cmp(&oid, git_reference_target(ref))",2,2,4
"""works"", str",2,2,4
"git_strmap_exists(table, ""bbbbbbbbb"")",2,2,4
"!git_oid_cmp(git_note_oid(note), note_oid)",2,2,4
"NULL, 3, ""e90810"", ""a65fed"", ""41bc8c""",3,1,4
commit && tree,2,2,4
idx == GIT_ENOTFOUND,2,2,4
assign->value == value,2,2,4
"(int)old_update, (int)git_submodule_update(sm1)",2,2,4
"GIT_EUSER, git_reference_foreach_glob( repo, ""*"", interrupt_cb, &count) ",2,2,4
exp.lines == 6,2,2,4
"1, expected.file_dels",2,2,4
"strcmp(git_buf_cstr(&buf1), test_string) == 0",2,2,4
git_repository_is_empty(repo_normal) == 0,2,2,4
"merge_test_index(index, merge_index_entries, 11)",3,1,4
git_vector_is_sorted(&index->entries),4,0,4
"git__prefixcmp(out, path) == 0",2,2,4
_backend && oid,2,2,4
"strcmp(git_tag_name(tag1), ""test"") == 0",2,2,4
"str, val",2,2,4
index && file && file->is_locked,2,2,4
"git_oid_cmp(&oid, &entry->oid_cur) == 0",2,2,4
"s, url",2,2,4
" git_submodule_add_setup(NULL, g_repo, ""whatever"", ""sm_unchanged"", 1) == GIT_EEXISTS ",2,2,4
"git_oid_equal(git_blob_id(c), &delta->new_file.id)",2,2,4
"actual.file_mods, expected->file_mods",2,2,4
"3, git_blame_get_hunk_count(blame)",2,2,4
"8, exp.file_status[GIT_DELTA_UNTRACKED]",2,2,4
"""this is \ba phrase"", str",2,2,4
"9, (int)range->new_lines",2,2,4
"52, exp.files",2,2,4
"!git_oid_cmp(git_object_id(obj), git_reference_target(cloned_head))",2,2,4
"1, pack_progress_called",2,2,4
"git_submodule_lookup(&sm, g_repo, ""just_a_file"") == GIT_ENOTFOUND",2,2,4
"1, git_remote_prune_refs(origin)",4,0,4
assign->value == GIT_ATTR_FALSE,2,2,4
git_diff_stats_insertions(stats) == 0,2,2,4
path && contents,2,2,4
"true, git_path_isvalid(NULL, ""git~1 "", 0)",3,1,4
"0, cache->entries",2,2,4
"entry = git_index_get_bypath(repo_index, ""removed-in-8.txt"", 1)",2,2,4
git_merge_result_is_fastforward(result),2,2,4
"str, ""baz""",2,2,4
"git_oid_cmp(&expected_oid, git_object_id(blob)) == 0",2,2,4
git_vector_is_sorted(&tree->entries),2,2,4
(caps & GIT_CAP_SSH) != 0,2,2,4
"""huzzah"", git_buf_cstr(&buf)",4,0,4
bit < bv->length * 8,2,2,4
"0, git_oid_streq(&target->oid, expectations->sha)",2,2,4
diff && diff->repo,2,2,4
"strcmp(str, ""http://example.com/git/abba"") == 0",2,2,4
"c->expected, value",2,2,4
""""", buf.ptr",4,0,4
"&id1, &returned_entry->id",4,0,4
"""这"", git_pathspec_match_list_entry(m, 12)",2,2,4
"repo, """"",2,2,4
"0100644, read_filemode(""a/b.txt"")",2,2,4
cts.untracked > 0,2,2,4
"""refs/stash@{0}"", sha, GIT_OBJ_COMMIT",2,2,4
"git_submodule_url(sm2), str",2,2,4
"str, ""two""",2,2,4
num == 2,2,2,4
"git_submodule_url(sm3), str",2,2,4
"cl_fixture(""attr/attr0""), file->ce->path",2,2,4
"actual_lines, num_lines",2,2,4
"1, transfer_progress_called",2,2,4
"git_oid_streq(&te->oid, oid) == 0",2,2,4
git_path_isdir(path.ptr),4,0,4
"3, expected.line_dels",2,2,4
"6, expected.line_adds",2,2,4
"0, git_oid_streq(&baseline->oid, expectations->sha)",2,2,4
" ""diff --git a/zzz.textnumary b/zzz.textnumary\n"" ""index b435cd5..1604519 100644\n"" ""--- a/zzz.textnumary\n"" ""+++ b/zzz.textnumary\n"" ""@@ -3 +3 @@ 0123456789\n"" ""-0123456789\n"" ""+replace a line\n"", pout",2,2,4
id && _backend && obj,2,2,4
error == GIT_ENONFASTFORWARD,2,2,4
"!strcmp(str, ""one one one two two three three"")",2,2,4
"git_path_isfile(""testrepo/ab/de/2.txt"")",3,1,4
"4, git_blame_get_hunk_count(g_blame)",3,1,4
"false, ""example.global_with_tilde""",3,1,4
"49, newno",2,2,4
hunk_cb || line_cb,2,2,4
"!strcmp(ref, ""refs/remotes/test/master"")",2,2,4
"git_oid_cmp(git_reference_oid(ref_tag), &target_id) == 0",2,2,4
git_repository_is_empty(repo_empty) == 1,2,2,4
header_len + 1 < sizeof(hunk->header),2,2,4
"git_attr_cache__is_cached(g_repo, 0, "".gitignore"")",2,2,4
"git_note_message(_note), ""hello world\n""",2,2,4
normalized,2,2,4
"git_oid_equal(git_blob_id(b), &delta->new_file.oid)",2,2,4
"entry_count0, entry_paths0, entry_statuses0, GIT_STATUS_SHOW_INDEX_AND_WORKDIR",2,2,4
"git__suffixcmp(out, path) == 0",2,2,4
note,4,0,4
"git_submodule_url(sm1), str",2,2,4
"tree, ""i-do-not-exist.txt"", GIT_SUCCESS, tree_with_subtrees_oid",2,2,4
"g_repo, ""sm_just_added_idx""",4,0,4
"i, 3",2,2,4
!tree->object.in_memory,2,2,4
" ""diff --git a/zzz.alphary b/zzz.alphary\n"" ""index 45141a7..75b0dbb 100644\n"" ""--- a/zzz.alphary\n"" ""+++ b/zzz.alphary\n"" ""@@ -1,0 +2,3 @@ Hello from the root\n"" ""+More lines\n"" ""+And more\n"" ""+Go here\n"", pout",2,2,4
exp.file_adds == 0,2,2,4
list.count == 2,2,2,4
"git_attr_cache__is_cached(g_repo, 0, "".gitattributes"")",2,2,4
"51, exp.files",2,2,4
"scan->expected == value, b.ptr",2,2,4
"tree, ""ab/de/"", GIT_EINVALIDPATH, NULL",2,2,4
git_diff_stats_deletions(stats) == 1,2,2,4
"0, cache->entry_count",2,2,4
"""refs/heads/master"", git_reference_name(branch)",3,1,4
"!git_path_exists(""submod2/.git/modules/"" SM_LIBGIT2B)",2,2,4
"GIT_EINVALIDSPEC, git_reference_symbolic_create( &new_reference, g_repo, name, current_head_target, 0)",2,2,4
idx <= v->length,2,2,4
" GIT_EEXISTS, git_submodule_add_setup(NULL, g_repo, ""whatever"", ""sm_unchanged"", 1)",2,2,4
exp.lines == 13,2,2,4
blob && buffer,2,2,4
"value, "".""",2,2,4
how_many_refs == 14,2,2,4
"strcmp(reuc->path, ""newfile.txt"") == 0",2,2,4
exp.file_mods == 2,2,2,4
ERROR_FILE_NOT_FOUND,2,2,4
" ""diff --git a/zzz.textary b/zzz.textary\n"" ""index b435cd5..1604519 100644\n"" ""--- a/zzz.textary\n"" ""+++ b/zzz.textary\n"" ""@@ -3 +3 @@\n"" ""-0123456789\n"" ""+replace a line\n"", pout",2,2,4
value_utf8 = gitwin_from_utf16(value_utf16),2,2,4
n == 3,2,2,4
"git_blob_rawsize(b), delta->old_file.size",2,2,4
"2, exp.file_mods",2,2,4
"entry_count5, entry_paths5, entry_statuses5, GIT_STATUS_SHOW_INDEX_ONLY",2,2,4
value_utf8 = git__malloc(alloc_len),2,2,4
"""libgit2-again"", git_submodule_name(sm)",2,2,4
"merge_test_reuc(index, merge_reuc_entries, 3)",3,1,4
"tree, ""/ab"", GIT_EINVALIDPATH, NULL",2,2,4
rule->match.flags == GIT_ATTR_FNMATCH_NEGATIVE,2,2,4
"""what"", GIT_STATUS_WT_MODIFIED | GIT_STATUS_INDEX_MODIFIED",2,2,4
"str, ""hurrah""",2,2,4
"0100644, entry->mode",2,2,4
"how_many_refs, 25",2,2,4
reference->is_packed,2,2,4
"0, g_diff_perf.oid_calcs",2,2,4
"GIT_REBASE_OPERATION_PICK, rebase_operation.type",2,2,4
fp,2,2,4
values[5] == GIT_ATTR_TRUE,2,2,4
"git_oid_streq(&id, ""deadbeef"") == GIT_ENOTOID",2,2,4
"scan->expected, value",2,2,4
"repo, ""branc#.duh""",2,2,4
"4, (int)git_treebuilder_entrycount(builder)",3,1,4
"how_many_refs, 19",2,2,4
"git_oid_equal(git_blob_id(d), &delta->old_file.id)",2,2,4
i == 2,2,2,4
"cl_fixture(""attr/attr3""), file->key + 2",2,2,4
" GIT_EINVALIDSPEC, git_reference_rename(&renamed_ref, looked_up_ref, ""Hello! I'm a very invalid name."", 0)",2,2,4
exp.file_dels == 0,2,2,4
"1, expected.file_adds",2,2,4
"4, (int)tc",2,2,4
"result = merge_simple_branch(GIT_MERGE_AUTOMERGE_FAVOR_THEIRS, 0)",2,2,4
"t = resolve_commit_oid_to_tree(repo, treeish)",2,2,4
"entry = git_index_get_bypath(result, ""removed-in-10-branch.txt"", 2)",2,2,4
"!strcmp(str, ""hello"")",2,2,4
sm->path == sm->name,2,2,4
behind == 2,2,2,4
behind == 1,2,2,4
"!strcmp(""\r\n"", workdir_ending)",2,2,4
repo_out && path,2,2,4
"st.st_mode, GIT_FILEMODE_BLOB_EXECUTABLE, ""%07o""",2,2,4
git_index_entrycount(repo_index) == 9,3,1,4
tag,2,2,4
"SetEnvironmentVariableW(name_utf16, value ? value_utf16 : NULL) || !value",2,2,4
"!git_oid_cmp(git_indexer_hash(idx), &should_id)",2,2,4
obj->raw.type == GIT_OBJ_COMMIT,2,2,4
"tree, ""/ab/de"", GIT_EINVALIDPATH, NULL",2,2,4
"git_oid_cmp(git_tag_target_oid(tag), &target_id) == 0",2,2,4
"1, git_pool__open_pages(&p)",2,2,4
"strcmp(out, ""ed"") == 0",2,2,4
"6, (int)ta",2,2,4
"strcmp(git_tag_name(bad_tag), ""e90810b"") == 0",2,2,4
" GIT_EUSER, git_tree_walk( tree, GIT_TREEWALK_POST, treewalk_stop_immediately_cb, NULL)",2,2,4
"0, exp.file_status[GIT_DELTA_TYPECHANGE]",2,2,4
expected->oldname == NULL,2,2,4
"4, expected.line_ctxt",2,2,4
"size, git_remote_refspec_count(_remote)",2,2,4
"entry = git_index_get_bypath(result, ""removed-in-10-branch.txt"", 1)",2,2,4
data_p && len_p && type_p && _backend && oid,2,2,4
"NULL, 3, ""e90810"", ""763d71"", ""a65fed""",3,1,4
exp.lines == 16,2,2,4
git_submodule_update(sm) == GIT_SUBMODULE_UPDATE_CHECKOUT,2,2,4
"GIT_BRANCH_LOCAL | GIT_BRANCH_REMOTE, 9",2,2,4
a->new_attr - b->new_attr == 0,2,2,4
git_pool__full_pages(&p) == 505,2,2,4
level == Z_DEFAULT_COMPRESSION || (level >= 0 && level <= 9),2,2,4
"GIT_EEXISTS, git_reference_rename(&new_ref, ref, packed_test_head_name, 0)",2,2,4
values[4] == NULL,2,2,4
"git_remote_supported_url(""http://github.com/libgit2/libgit2"")",2,2,4
"!strcmp(git_object_type2string(GIT_OBJ_REF_DELTA), ""REF_DELTA"")",2,2,4
"ALL_CRLF_TEXT_AS_LF, buf.ptr",2,2,4
out && p && e && git__is_sizet(e->size),2,2,4
git_pool__full_pages(&p) == 492,2,2,4
"git_oid_equal(git_blob_id(c), &delta->old_file.oid)",2,2,4
"git_submodule_lookup(&sm, g_repo, ""not-submodule"") == GIT_EEXISTS",2,2,4
"0, git_clone__should_clone_local(buf.ptr, GIT_CLONE_NO_LOCAL)",4,0,4
"git_oid_cmp(&expected_oid, &oid) == 0",2,2,4
"!git_strmap_exists(table, ""bbbbbbbbb"")",2,2,4
"tree, ""ab/"", GIT_EINVALIDPATH, NULL",2,2,4
repo && cb,4,0,4
counts->expected_statuses[idx] == s,2,2,4
"""e90810b8df3e80c413d903f631643c716887138d"", GIT_OBJ_COMMIT, ""e90810b8df3e80c413d903f631643c716887138d"", GIT_OBJ_COMMIT",3,1,4
"st.st_mode, (GIT_FILEMODE_TREE | 0701) & ~um, ""%07o""",2,2,4
"1, array.count",2,2,4
remote && repo,2,2,4
"""\""C:/Program Files/Nonsense/bah.exe\"" \""--some option\"""", str",2,2,4
" old_fetchrecurse, git_submodule_fetch_recurse_submodules(sm1)",2,2,4
exp.line_dels == 2,2,2,4
"!strcmp(str, ""true"")",2,2,4
"git_oid_cmp(&a->old_oid, &b->old_oid) == 0",2,2,4
"!strcmp(str, ""yes"")",2,2,4
"how_many_refs, 23",2,2,4
"git_strmap_valid_index(table, pos)",2,2,4
"""what"", GIT_STATUS_CURRENT",2,2,4
buf && !buf->data && hdr && obj,2,2,4
"expected_output, label",2,2,4
"new, result.ptr",2,2,4
"1, exp.file_untracked",2,2,4
target,3,1,4
"git_oid_cmp(git_reference_oid(ref_tag), &old_tag_id) != 0",2,2,4
"how_many_refs, 21",2,2,4
"git_oid_streq(&id, ""deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"") == GIT_ERROR",2,2,4
"""./foo""",2,2,4
rule->match.flags == GIT_ATTR_FNMATCH_FULLPATH,2,2,4
repo_out,2,2,4
assign->is_allocated == is_allocated,2,2,4
"GIT_NOTES_DEFAULT_REF, default_ref",2,2,4
" ""diff --git a/zzz.numary b/zzz.numary\n"" ""index 45141a7..75b0dbb 100644\n"" ""--- a/zzz.numary\n"" ""+++ b/zzz.numary\n"" ""@@ -1,0 +2,3 @@\n"" ""+More lines\n"" ""+And more\n"" ""+Go here\n"", pout",2,2,4
"SM_LIBGIT2_URL, git_submodule_url(sm2)",2,2,4
"cl_fixture(""attr/attr2""), file->key + 2",2,2,4
branch,3,1,4
"!strcmp(git_object_type2string(8), """")",2,2,4
"namespace_note, ""hello new ref world\n"", &note_oid",3,1,4
"!strcmp(git_object_type2string(GIT_OBJ__EXT1), """")",2,2,4
"""refs/remotes/test/master"", git_reference_name(tracking)",2,2,4
"git_oid_cmp(&id1, &entry->oid) == 0, ""first oid check""",2,2,4
i == 4,2,2,4
"(in = fopen(in_f.ptr, ""r"")) != NULL",2,2,4
"1, (int)td",2,2,4
out && origin_url && dest_path,2,2,4
"GIT_EEXISTS, git_branch_move(&new_ref, original_ref, ""master"", 0, NULL)",2,2,4
"oitem && nitem && strcmp(oitem->path, nitem->path) == 0",2,2,4
"""Test\n"", _actual",2,2,4
"!strcmp(git_object_type2string(GIT_OBJ_OFS_DELTA), ""OFS_DELTA"")",2,2,4
idx[j+1] < p->obj_cnt+1,2,2,4
"15, git_patch_num_lines_in_hunk(p, 0)",2,2,4
"git_submodule_url(sm), str",2,2,4
"git_oid_cmp(&id1, &entry->id) == 0",2,2,4
"!git_path_isdir(""d0"")",3,1,4
"GIT_EAMBIGUOUS, ""53fc32d17276939fc79ed05badaef2db09990016"", GIT_OBJ_ANY",2,2,4
"!strcmp(git_object_type2string(GIT_OBJ_BLOB), ""blob"")",2,2,4
" ""diff --git a/zzz.normal b/zzz.normal\n"" ""index b435cd5..1604519 100644\n"" ""Binary files a/zzz.normal and b/zzz.normal differ\n"", pout",2,2,4
"strcmp(a->path, b->path) == 0",2,2,4
exp.line_adds == 9,2,2,4
"fetch_refspec2, array.strings[1]",2,2,4
"strcmp(tagger1->email, tagger_email) == 0",2,2,4
ob != NULL,2,2,4
git_diff_iterator_progress(iter) == 0.0f,2,2,4
transport,2,2,4
"2, git_blame_get_hunk_count(blame)",2,2,4
i == 14,2,2,4
"git_oid_cmp(&oid, &entry->oid), 0",2,2,4
"path, str",2,2,4
"!strcmp(git_remote_url(_remote), url)",2,2,4
found_collision == 0,2,2,4
(entry->flags_extended & GIT_IDXENTRY_ALLOCATED) == 0,2,2,4
"!strcmp(git_remote_name(_remote), ""origin"")",2,2,4
"0, git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL_AUTO)",4,0,4
exp.file_adds == 1,2,2,4
"strcmp(out, ""auto"") == 0",2,2,4
"git_oid_cmp(&id, &commit_ids[i]), 0",2,2,4
index && source_entry,2,2,4
git_diff_stats_deletions(stats) == 3,2,2,4
"str, ""f""",2,2,4
exp.file_untracked == 3,2,2,4
"!strcmp(git_object_type2string(GIT_OBJ_COMMIT), ""commit"")",2,2,4
"entry = git_index_get_bypath(result, ""removed-in-both.txt"", 1)",2,2,4
cfg_out && path,2,2,4
"""0266163a49e280c4f5ed1e08facd36a2bd716bcf"", GIT_OBJ_BLOB, ""0266163a49e280c4f5ed1e08facd36a2bd716bcf"", GIT_OBJ_BLOB",3,1,4
"GIT_EMERGECONFLICT, error",2,2,4
"repo, ""bra\nch.duh""",2,2,4
"git_oid_cmp(&id1, &entry->oid) == 0, ""second oid check""",2,2,4
expected.file_adds == 1,2,2,4
git_diff_stats_insertions(stats) == 5,2,2,4
result.count == 1,2,2,4
"2, (int)git_reflog_entrycount(reflog)",2,2,4
"0100755, entry->mode",2,2,4
"git_oid_equal(git_blob_id(b), &delta->new_file.id)",2,2,4
"git_buf_cstr(unslashify(&target_path)), buf",2,2,4
"tree, ""ab/de/fgh/i-do-not-exist.txt"", GIT_SUCCESS, ""3259a6bd5b57fb9c1281bb7ed3167b50f224cb54""",2,2,4
GIT_ATTR_TRUE == assign->value,2,2,4
git__n_inits.val,2,2,4
"GIT_DELTA_ADDED, git_patch_delta(p)->status",2,2,4
"git_oid_streq(&id, str_oid) == GIT_SUCCESS",2,2,4
out && repo && url,3,1,4
"result = merge_simple_branch(GIT_MERGE_AUTOMERGE_FAVOR_OURS, 0)",2,2,4
statuslist,2,2,4
" GIT_EUSER, git_tree_walk(tree, GIT_TREEWALK_PRE, treewalk_stop_cb, &ct)",2,2,4
"!strcmp(git_object_type2string(GIT_OBJ__EXT2), """")",2,2,4
"expected_files[*index], p",2,2,4
"!git_oid_cmp(git_note_id(_note), &note_oid)",2,2,4
giterr_last(),2,2,4
"&tree_id, git_commit_tree_id(commit)",4,0,4
git_tag_type(tag1) == GIT_OBJ_TAG,2,2,4
"!strcmp(git_object_type2string(-2), """")",2,2,4
"entry = git_index_get_bypath(repo_index, ""removed-in-8.txt"", 3)",2,2,4
"how_many_refs, 22",2,2,4
"git_tree_get_subtree(&containing_tree, root, path) == expected_result",2,2,4
"git_oid_cmp(&expected->oid, oid) == 0",2,2,4
cfg->reader.read_ptr,2,2,4
"!strcmp(git_refspec_src(_refspec), ""refs/*"")",2,2,4
delta->binary == 0 || delta->binary == 1,2,2,4
"3, (int)tc",2,2,4
"GIT_EBAREREPO, git_reset(bare, target, GIT_RESET_MIXED, NULL, NULL)",2,2,4
"!strcmp(git_note_message(_note), ""test123test\n"")",2,2,4
!t->current_stream,4,0,4
expected_progress == git_diff_iterator_progress(iter),2,2,4
cfg->backends.length > 0,2,2,4
"""B"", ""HEAD^^2^"", repo, &opts, false",2,2,4
"git_pool_strndup(&p, ""foo"", -1) == NULL",2,2,4
error != GIT_NOTFOUND,2,2,4
"push_refspec1, array.strings[0]",2,2,4
"""who"", GIT_STATUS_WT_MODIFIED",2,2,4
blob,4,0,4
"NULL, 3, ""a65fed"", ""41bc8c"", ""e90810""",3,1,4
"14, git_diff_patch_num_lines_in_hunk(p, 0)",2,2,4
"git_path_isfile(""submod2/"" SM_LIBGIT2 ""/.git"")",2,2,4
resolved_ref && ref,2,2,4
(git_diff_patch_delta(p)->flags & GIT_DIFF_FLAG_BINARY) != 0,2,2,4
"strcmp(joined_path, expected_path) == 0",2,2,4
error == GIT_NOTFOUND,2,2,4
" file, line, ""expected diff did not match actual diff"", 1, ""%s"", expected[d], patch_text",2,2,4
"git_oid_streq(&id, ""I'm not an oid.... :)"") == GIT_ENOTOID",2,2,4
"-1, index->tree->entries",2,2,4
"git_oid_cmp(&tag, &expected) == 0",2,2,4
"""53fc32d17276939fc79ed05badaef2db09990016"", GIT_OBJ_TREE, ""53fc32d17276939fc79ed05badaef2db09990016"", GIT_OBJ_TREE",3,1,4
"value_utf8 = git__calloc(alloc_len, 1)",2,2,4
"GIT_ENOTFOUND, ""refs/tags/point_to_blob"", GIT_OBJ_TAG",2,2,4
bit < 64,2,2,4
(caps & GIT_CAP_SSH) == 0,2,2,4
"tree, ""README"", GIT_SUCCESS, tree_with_subtrees_oid",2,2,4
"0, git_oid_streq(&entry->oid, expected_sha)",2,2,4
"9, expected.line_adds",2,2,4
"5, exp.file_dels",2,2,4
ob == &(objects[i]),2,2,4
(caps & GIT_CAP_THREADS) == 0,2,2,4
"""refs/heads/foo"", git_refspec_dst(actual_fs)",2,2,4
"strcmp(str, ""http://example.com/git/ab"") == 0",2,2,4
"0, git_refspec_force(_refspec)",2,2,4
"git_repository_message(_actual, 6, _repo) > 0",2,2,4
cts.conflicts > 0,2,2,4
"NULL, a.ptr",2,2,4
exp.hunks == 12,2,2,4
"!git_path_exists(""attr/.gitignore"")",3,1,4
"0, file, line, buf, err, 1",2,2,4
"(int)old_ignore, (int)git_submodule_ignore(sm1)",2,2,4
"looked_up_ref->name, brand_new_name",2,2,4
"(int)ref_list.count, 10",2,2,4
"GIT_EBAREREPO, git_reset(bare, target, GIT_RESET_HARD, NULL, NULL)",2,2,4
"looked_up_ref->name, new_name",2,2,4
"ALL_CRLF_TEXT_AS_CRLF, buf.ptr",3,1,4
"!strcmp(git_remote_url(_remote), ""git://github.com/libgit2/libgit2"")",2,2,4
"""test push"", git_reflog_entry_message(entry)",2,2,4
"tree, ""/"", GIT_EINVALIDPATH, NULL",2,2,4
"!git_path_exists(""merge-resolve/"" GIT_MERGE_HEAD_FILE)",2,2,4
"diff->oid_calculations, 5",2,2,4
expected.file_dels == 1,2,2,4
rule->match.flags == GIT_ATTR_FNMATCH_DIRECTORY,2,2,4
" GIT_EUSER, git_diff_foreach(diff, diff_stop_after_2_files, NULL, NULL, &exp) ",2,2,4
"4, expected.line_dels",2,2,4
"entry = git_index_get_bypath(repo_index, ""removed-in-10-branch.txt"", 2)",2,2,4
merge_trivial_conflict_entrycount(result) == 1,2,2,4
"actual.file_dels, expected->file_dels",2,2,4
sqlite3_step(backend->st_read_header) == SQLITE_DONE,2,2,4
"-1, giterr_capture(&err_state, -1)",2,2,4
"push_refspec2, array.strings[1]",2,2,4
"""e90810b8df3e80c413d903f631643c716887138d"", GIT_OBJ_ANY, ""53fc32d17276939fc79ed05badaef2db09990016"", GIT_OBJ_TREE",3,1,4
" (int)GIT_SUBMODULE_UPDATE_REBASE, (int)git_submodule_update(sm2)",2,2,4
"GIT_EBAREREPO, git_reset(bare, target, GIT_RESET_MIXED)",2,2,4
"git_path_isdir(""submod2/"" SM_LIBGIT2B ""/.git"")",2,2,4
"7, git_pathspec_match_list_entrycount(matches)",2,2,4
"18, (int)refnames.count",3,1,4
result = merge_fastforward_branch(0),2,2,4
" ""diff --git a/zzz.textalphary b/zzz.textalphary\n"" ""index b435cd5..1604519 100644\n"" ""--- a/zzz.textalphary\n"" ""+++ b/zzz.textalphary\n"" ""@@ -3 +3 @@\n"" ""-0123456789\n"" ""+replace a line\n"", pout",2,2,4
"39, st.st_size",4,0,4
version == 0,2,2,4
"buffer, ""Short\n""",2,2,4
exp.line_adds == 5,2,2,4
"git__suffixcmp(val, ""new_workdir/"") == 0",2,2,4
value == GIT_ATTR_FALSE,2,2,4
"how_many_refs, 24",2,2,4
"actual.file_adds, expected->file_adds",2,2,4
"git_oid_cmp(&id, git_reference_oid(looked_up_ref)) == 0",2,2,4
"in.ptr, in.size, out.ptr, out.size",2,2,4
"26, st.st_size",4,0,4
"NULL, 3, ""e90810"", ""41bc8c"", ""a65fed""",3,1,4
"!git_path_exists(""merge-resolve/"" GIT_ORIG_HEAD_FILE)",2,2,4
"note, ""hello new world\n"", &note_oid",3,1,4
ahead == 1,2,2,4
"git_note_message(_note), git_blob_rawcontent(_blob)",2,2,4
"expected_normal, as_str",2,2,4
"expected4, text",2,2,4
"true, git_repository_head_orphan(repo)",2,2,4
merge_result,2,2,4
"!git_oid_cmp(&oid, git_reference_oid(looked_up_ref))",2,2,4
"result = merge_simple_branch(0, GIT_CHECKOUT_SAFE | GIT_CHECKOUT_USE_OURS)",2,2,4
"!git_index_find(&pos, index, ""sm_changed_head"")",2,2,4
out && packname,2,2,4
git_diff_stats_insertions(stats) == 13,2,2,4
git_error_last() == NULL,2,2,4
commit && commit->committer,2,2,4
"13, expected.lines",2,2,4
"(int)ref_list.count, 13",2,2,4
"expected_tracked_branch_name, buffer",2,2,4
"git_strmap_value_at(table, pos), ""bbbbbbbbb""",2,2,4
"GIT_EUSER, ret",2,2,4
"tree, ""ab//de"", GIT_EINVALIDPATH, NULL",2,2,4
"""foo"", str",2,2,4
"git_futils_find_global_file(&path, ""nonexistentfile"") == GIT_ENOTFOUND",2,2,4
"GIT_EINVALIDSPEC, git_reference_symbolic_create(&head, g_repo, GIT_HEAD_FILE, ""refs/heads/inv@{id"", 1)",2,2,4
"18, (int)git_patch_num_lines_in_hunk(patch, 1)",2,1,3
st.st_nlink > 1,2,1,3
"&buf, ""/"", ""//a/b/../..""",2,1,3
"""refs/stash^2:when"", NULL",2,1,3
"h->orig_path, ""c""",2,1,3
"git__strcasesort_cmp(""fooBar"", ""foobar"") < 0",2,1,3
"1, update_payload.checkout_progress_called",3,0,3
"strlen(str_in_error) > strlen(""stat failed: "")",2,1,3
err >= 0,2,1,3
"!git_path_is_empty_dir(""empty_dir/content"")",2,1,3
"2, expect.file_status[GIT_DELTA_DELETED]",2,1,3
"false, git_reference_is_valid_name(""NO_TRAILING_UNDERSCORE_"")",2,1,3
"strcmp(automergeable_buf.ptr, AUTOMERGEABLE_MERGED_FILE) == 0",2,1,3
"objstr, expected_right",2,1,3
path_out && file_path,2,1,3
index->tree != NULL,2,1,3
author1 != NULL,2,1,3
"!git_path_exists(""testrepo/branch_file.txt.after"")",2,1,3
"(entry = git_index_get_bypath(repo_index, ""new-and-different.txt"", 0)) == NULL",2,1,3
"""refs/heads/master"", GIT_OBJ_ANY, ""a65fedf39aefe402d3bb6e24df4d4f5fe4547750"", GIT_OBJ_COMMIT",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge commit '"" OCTO1_OID ""'; commit '"" OCTO2_OID ""'; commit '"" OCTO3_OID ""'\n"")",2,1,3
"expected_filemode, git_tree_entry_filemode(entry)",2,1,3
"GIT_DIRECTION_FETCH, ""refs/heads/*:refs/remotes/frotz"", false",2,1,3
"0, hunk->new_lines",2,1,3
"47, line->new_lineno",2,1,3
"false, found_collision",2,1,3
!git_repository_is_empty(_repo),2,1,3
" file,line,""wrong index mods"", 1, ""%""PRIuZ, index_mods, vals.index_mods",2,1,3
"false, git_remote_is_valid_name(""no/trailing/slash/"")",2,1,3
"ALL_CRLF_TEXT_RAW, git_blob_rawcontent(blob)",2,1,3
"(iep = git_index_get_bypath(idx, ""file_deleted"", 0)) != NULL",2,1,3
flags == ignore_case ? GIT_STATUS_IGNORED : GIT_STATUS_WT_NEW,2,1,3
"false, git_reference_is_valid_name(""HEAD/"")",2,1,3
"false, ""NewFolder/NewFolder""",2,1,3
"""https://my.url.com/full/path/url.patch"", p.ptr",2,1,3
(int)git_strmap_num_entries(table) == count,2,1,3
"18, (int)git_patch_num_lines_in_hunk(patch, 0)",2,1,3
"memcmp(&addr, in_addr_data[i].n, sizeof(struct in_addr)) == 0",2,1,3
"false, git_reference_is_valid_name(""ONE.LEVEL"")",2,1,3
"""BAR~2"", (shortname = git_win32_path_8dot3_name("".bar""))",2,1,3
"expected->file_status[j], actual.file_status[j]",2,1,3
"0, data.invokes",2,1,3
"GIT_ENOTFOUND, git_branch_lookup(&branch, repo, ""where/are/you"", GIT_BRANCH_LOCAL)",2,1,3
"""bbb"", item",2,1,3
"GIT_EEXISTS, git_branch_move(&new_ref, original_ref, ""cannot-fetch"", 0)",2,1,3
""""", ""\n\n\n"", 0",2,1,3
" ""core.ignorecase"", found_without_match ? true : GIT_ENOTFOUND",2,1,3
"merge_test_names(index, merge_name_entries, 9)",2,1,3
"!git_path_isdir(""d3"")",2,1,3
"3, count",2,1,3
"git_note_message(note), message",2,1,3
"true, git_reference_is_valid_name(""refs/remotes/origin/bim_with_3d@11296"")",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge branch 'octo1' of http://remote.url/repo.git\n"")",2,1,3
"0, result.automergeable",3,0,3
flags == GIT_STATUS_WT_NEW,2,1,3
position_cake != -1,2,1,3
"""refs/stash^3:just.ignore"", NULL",2,1,3
"expected, buffer",2,1,3
"value, ""goop""",2,1,3
"(entry = git_index_get_bypath(index, ""B"", 0))",3,0,3
"""refs/tags/e90810b"", false",2,1,3
"3, ""5b5b025afb0b4c913b4c338a42934a3863bf3644""",2,1,3
"!mkfifo(""empty_standard_repo/fifo"", 0777)",2,1,3
"reuc = git_index_reuc_get_bypath(result, ""removed-in-8.txt"")",2,1,3
"ttt ""\n"" ttt ttt ""\n\n"" ttt ""\n"", ttt ""\n"" ttt ttt ""\n\n"" ttt ""\n"", 0",2,1,3
out && repo && id,2,1,3
"merge_test_merge_conflicts(&merge_diff_list->conflicts, treediff_conflict_data, treediff_conflict_data_len)",2,1,3
"port, ""1234""",2,1,3
"14, expected.line_dels",2,1,3
git_repository_is_bare(repo) == 0,2,1,3
"expected[d] == NULL, file, line",2,1,3
"34, expect.lines",2,1,3
(rule->match.flags & GIT_ATTR_FNMATCH_NEGATIVE) != 0,2,1,3
*cond,2,1,3
"!git_path_isdir(""d2"")",2,1,3
""""", ""\n"", 0",2,1,3
"count, git_tree_entrycount(tree)",3,0,3
"stats.received_objects, 2",2,1,3
" bytes > 0, file, line, ""error reading from file"", path, 1",2,1,3
"original_merge, str",3,0,3
"!git_index_find(&entry_idx, repo_index, ""one.txt"")",2,1,3
git_submodule_ignore(sm) == GIT_SUBMODULE_IGNORE_NONE,2,1,3
"entry = git_index_get_bypath(repo_index, ""modified-in-13.txt"", 0)",2,1,3
"strlen(ALL_CRLF_TEXT_RAW), entry->file_size",2,1,3
"14, stream->declared_size",2,1,3
"!git_index_find(&position, index, ""fancy.name.txt"")",2,1,3
w->inuse_cnt == 0,2,1,3
"6, counts",2,1,3
"git_config_get_int32(&i, cfg, ""core.dummy2"") == GIT_ENOTFOUND",2,1,3
"""subdir/modified_file"", git_pathspec_match_list_entry(m, 8)",2,1,3
"95, sim, 100",2,1,3
"git_object_lookup(&obj, g_repo, &id, GIT_OBJ_TREE) == 0",2,1,3
""""", sss sss sss sss ""\n"", 0",2,1,3
"GIT_EUNBORNBRANCH, git_stash_save(&stash_tip_oid, repo, signature, NULL, GIT_STASH_DEFAULT)",2,1,3
"4, git_sortedcache_entrycount(sc)",2,1,3
"git_path_isfile(""t1/b/f2"")",2,1,3
"""c47800c7266a2be04c571c04d5a6614691ea99bd"", 3, ""763d71"", ""e90810"", ""a65fed""",2,1,3
git_index_entry_stage(conflict_entry[0]) == 1,2,1,3
"sig->email, git_reflog_entry_committer(entry)->email",3,0,3
"false, git_reference_is_valid_name(""/stupid/name/master"")",2,1,3
"ttt ""\n"", ttt sss sss sss, 0",2,1,3
"""dif\nf.dirstat.lines""",2,1,3
"9, exp.hunks",2,1,3
"(int)hunks, (int)git_patch_num_hunks(patch)",2,1,3
"1, expect.line_dels",2,1,3
"strcmp(git_reference_symbolic_target(head), ref_master_name) == 0",2,1,3
"""stash@{0}^0:what"", ""ce013625030ba8dba906f756967f9e9ca394464a""",2,1,3
"GIT_DELTA_MODIFIED, git_patch_get_delta(p)->status",2,1,3
"&found, git_odb_object_id(obj)",3,0,3
repo && commitish,2,1,3
"GIT_DELTA_DELETED, (int)git_pathspec_match_list_diff_entry(matches,0)->status",2,1,3
"git_path_dirname_r(&absolute_url, git_repository_workdir(g_repo)) > 0",3,0,3
"true, git_reference_is_valid_name(""ONE_LEVEL"")",2,1,3
"GIT_EINVALIDSPEC, git_object_lookup_bypath(&g_actualobject, (git_object*)g_root_tree, ""subdir/subdir_test2.txt"", GIT_OBJ_TREE)",2,1,3
"!git_pathspec_matches_path(ps, 0, ""three.four"")",2,1,3
"!git_path_exists(""merge-resolve/directory_file-one~ours"")",2,1,3
"statbuf.st_mode & os_mask, (expected_file_mode & ~mask) & os_mask",2,1,3
"3, expect.line_adds",2,1,3
GIT_ATTR_UNSPECIFIED(values[4]),2,1,3
"!access(""empty_standard_repo/fifo"", F_OK)",2,1,3
"!git_path_isfile(""testrepo/newdir/newfile.txt"")",2,1,3
"""conflicts-two.txt"", conflict_entry[0]->path",2,1,3
"true, read_index->on_disk",2,1,3
"ttt ""\n"" ""# comment\n"" ttt ""\n"", ttt ""\n"" ""# comment\n"" ttt ""\n"", 0",2,1,3
"push_refspecs[i], array.strings[i]",2,1,3
"false, git_reference_is_valid_name(""_NO_LEADING_UNDERSCORE"")",2,1,3
"git_buf_rfind(&a, '/') == len - 1",2,1,3
"REFNAME, git_reference_name(ref1)",2,1,3
"""staged_new_file"", git_pathspec_match_list_entry(m, 5)",2,1,3
"""refs/heads/*:refs/heads/*"", ""refs/heads/master"", ""refs/heads/master""",2,1,3
"git_oid_streq(te->oid, oid) == 0",2,1,3
"actual, expected",2,1,3
"ad->new_file.id_abbrev, bd->new_file.id_abbrev",2,1,3
"git_path_exists(""status/conflicting_file"") == 0",2,1,3
o1->type == o2->type,2,1,3
"conndata.user, ""user/name""",2,1,3
"git__strcmp(entry->path, ""TEST.txt"") == 0",2,1,3
"GIT_MERGE_ANALYSIS_FASTFORWARD, (merge_analysis & GIT_MERGE_ANALYSIS_FASTFORWARD)",3,0,3
status == GIT_STATUS_WT_NEW,2,1,3
"false, write_index->on_disk",2,1,3
"""5b5b025afb0b4c913b4c338a42934a3863bf3644"", 5, ""5b5b02"", ""763d71"", ""a4a7dc"", ""a65fed"", ""41bc8c""",2,1,3
"(char *)buf, sizeof(buf), test",2,1,3
" ""Some text\n$Id$\nGoes there\n"", buf.ptr",2,1,3
"!git_index_find(&entry_idx, repo_index, ""new-file.txt"")",2,1,3
"0 != git_oid_cmp(&before_current_cur_oid, &after_current->oid_cur)",2,1,3
"git_path_isdir(""t2/c"")",2,1,3
hunk != NULL,2,1,3
"git_tree_entry_byname(tree, ""README"") != NULL",2,1,3
"GIT_DELTA_DELETED, git_patch_get_delta(p)->status",2,1,3
expect.idx > 0,2,1,3
"GIT_DELTA_UNMODIFIED, (int)delta->status",2,1,3
"merge_test_reuc(index, merge_reuc_entries, 10)",2,1,3
"GIT_ENOTFOUND, git_config_get_int32(&i, cfg, ""nope.neither"")",2,1,3
"0, git_oid_streq(&id, str_oid)",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge commit '"" OCTO1_OID ""'\n"")",2,1,3
"!git_path_exists(""typechanges/b"")",2,1,3
errno != ENOTEMPTY,2,1,3
"GIT_DIRECTION_FETCH, ""refs/heads/*/for-linus:refs/remotes/mine/*"", true",2,1,3
"true, git_path_isdir(""./testrepo/ab/"")",2,1,3
"""stash@{0}^2:how"", ""ac790413e2d7a26c3767e78c57bb28716686eebc""",2,1,3
"p_lstat_posixly(""root/d1/file/deeper/path"", &st) < 0",2,1,3
"""."", ce->value",3,0,3
"40, sim, 60",2,1,3
"true, git_blob_is_binary(alien)",2,1,3
"3, exp.line_adds",2,1,3
"""/this/is/a/test"", p.ptr",2,1,3
"error, git_object_peel(&peeled, obj, requested_type)",2,1,3
"""# comment\n"", ""# comment"", 0",2,1,3
" 0, memcmp(out.ptr, g_crlf_filtered[i].ptr, out.size)",2,1,3
"merge_test_workdir(repo, merge_index_entries, 4)",2,1,3
"!git_path_isdir(""t2"")",2,1,3
"0, git_filter_list_length(fl)",2,1,3
"true, git_index_has_conflicts(index)",2,1,3
"exp->statuses[exp->counter], (int)status_flags",2,1,3
"&buf, ""a/"", ""a/./""",2,1,3
"entry = git_index_get_bypath(repo_index, ""new-in-branch.txt"", 0)",2,1,3
p[path_len],2,1,3
"&buf, ""a/"", ""a/.""",2,1,3
"true, git_repository_is_empty(repo)",2,1,3
"entry = git_index_get_bypath(result, ""modified-in-both.txt"", 1)",2,1,3
"expected[i], entry->path",2,1,3
" GIT_ENOTFOUND, git_sortedcache_lookup_index(&pos, sc, ""final"")",2,1,3
"git_tree_entry_byname(tree, ""last"") != NULL",2,1,3
"""refs/stash:when"", NULL",2,1,3
"GIT_ENOTFOUND, git_tree_entry_bypath(&e, tree, ""nope/de/fgh/1.txt"")",2,1,3
"git_path_exists(""typechanges/b"")",2,1,3
"0, hunk->new_start",2,1,3
"6, exp.file_status[GIT_DELTA_UNMODIFIED]",2,1,3
"reuc = git_index_reuc_get_bypath(repo_index, ""removed-in-10-branch.txt"")",2,1,3
"GIT_EINVALIDSPEC, git_branch_lookup(&branch, repo, ""are/you/inv@{id"", GIT_BRANCH_LOCAL)",2,1,3
"merge_test_index(repo_index, merge_index_entries, 5)",2,1,3
" ""\n$Id$\n"" MORE_CRLF_TEXT_AS_LF, git_blob_rawcontent(blob)",2,1,3
"stats.local_objects, 1",2,1,3
"""c47800c7266a2be04c571c04d5a6614691ea99bd"", 3, ""763d71"", ""a65fed"", ""e90810""",2,1,3
"1, expected->lines",2,1,3
"22, expect.lines",2,1,3
"""refs/heads/master"", git_buf_cstr(&upstream_name)",2,1,3
"33, exp.lines",2,1,3
"true, has_nsecs()",3,0,3
"""Another replacement;\n"", actual.ptr",2,1,3
" 0, memcmp(&g_crlf_filtered_stats[i], &stats, sizeof(stats))",2,1,3
"""stash@{1}^0:when"", NULL",2,1,3
t->connected,3,0,3
"0, entry->mtime.nanoseconds",2,1,3
i == 10000,2,1,3
"""Escaped\\"", ""Es\\ca\\ped\\""",2,1,3
"46, (int)hunk->new_start",2,1,3
"git_path_isdir(""src/b"")",2,1,3
"st.st_mode & GIT_MODE_PERMS_MASK, 0700, ""%07o""",2,1,3
"0, entry->ctime.nanoseconds",2,1,3
"false, git_reference_is_valid_name(""TWO/LEVELS"")",2,1,3
"true, git_odb_exists(odb, &_oid)",2,1,3
"-1, git_oid_streq(&idp, ""deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"")",2,1,3
" 0, memcmp(g_crlf_raw[i], git_blob_rawcontent(blob), raw_len)",2,1,3
"-1, git_oid_streq(&id, ""deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"")",2,1,3
"ptr = strstr(one.ptr, ""Class1"")",2,1,3
"true, write_index->on_disk",2,1,3
"4, (int)git_pathspec_match_list_entrycount(matches)",2,1,3
"false, git_path_exists(test_lock)",2,1,3
"100, item->value",2,1,3
stream,3,0,3
new_val == 1234,2,1,3
"git__suffixcmp(git_repository_workdir(repo), repo_wd) == 0",2,1,3
"3, expect.hunks",2,1,3
message != NULL,2,1,3
"git_oid_cmp(git_reference_target(ref_tag), &target_id) == 0",2,1,3
"git_path_exists(TEST_REPO_PATH ""/conflicting.txt"")",2,1,3
"git_tag_name(tag), ""taggerless""",2,1,3
"""/this/is/the/end/of/the/string"", p.ptr",2,1,3
git_path_isdir(git_buf_cstr(&path)),2,1,3
"14, expected.hunk_old_lines",2,1,3
"git__prefixcmp(ref_list.strings[i], ""/"") != 0",2,1,3
"git__strcmp(expected->targets[expected->idx], delta->new_file.path) == 0",2,1,3
"""https://my.url.com/full/path/"", p.ptr",2,1,3
"""message"", git_reflog_entry_message(entry)",2,1,3
"git_oid_cmp(git_tag_target_id(tag), &target_id) == 0",2,1,3
"git__suffixcmp(git_submodule_url(sm), ""/submod2_target"") == 0",2,1,3
reflog && new_oid && committer,2,1,3
"git_path_isfile(""./testrepo/path1/file1"")",2,1,3
git_repository_head_unborn(repo) == 1,2,1,3
"1, ""9fd738e8f7967c078dceed8190330fc8648ee56a""",2,1,3
"should_exist, error != GIT_ENOTFOUND",2,1,3
"0, result",2,1,3
"0, p_lstat(""root/"", &st)",2,1,3
"true, git_path_isvalid(NULL, "".git "", 0)",3,0,3
entry->ctime.nanoseconds != 0,2,1,3
"str, expected_right",2,1,3
"6, (int)git_patch_num_lines_in_hunk(patch, 0)",2,1,3
git_path_exists(testlock),2,1,3
"p_lstat_posixly(""root/d1/missing/deeper/path"", &st) < 0",2,1,3
"GIT_DIRECTION_PUSH, ""refs/heads/*:refs/remotes/frotz"", false",2,1,3
"GIT_DIRECTION_PUSH, ""+:"", true",2,1,3
"!git_path_exists(""typechanges/d"")",2,1,3
"GIT_ITEROVER, git_iterator_current(&entry, i)",2,1,3
""" Leading Spaces"", "" Leading\n Spaces\n\nare preserved""",2,1,3
"7, free_count",2,1,3
"1, 3, 0, 3, 0, &expected",3,0,3
"""schacon@gmail.com"", author->email",2,1,3
"p_lstat_posixly(""root/file/invalid/deeper_path"", &st) < 0",2,1,3
"""refs/heads/*:refs/remotes/origin/*"", ""refs/heads/master"", ""refs/remotes/origin/master""",2,1,3
"git_path_exists(""typechanges/c"")",2,1,3
"t = resolve_commit_oid_to_tree(g_repo, treeish)",2,1,3
"git__strcasesort_cmp(""bar"", ""foo"") < 0",2,1,3
"""refs/stash^2"", ""index on master: """,2,1,3
"1, expect.file_status[GIT_DELTA_ADDED]",2,1,3
"6, line->old_lineno",2,1,3
"GIT_DIRECTION_PUSH, ""HEAD"", true",2,1,3
i == 19,2,1,3
"5, exp.file_status[GIT_DELTA_UNTRACKED]",2,1,3
"hunk->lines_in_hunk, len",2,1,3
id != NULL,2,1,3
"git_oid_ncmp(&id, &idp, 19)",2,1,3
path && buf && buflen,2,1,3
"""test"", GIT_EEXISTS",2,1,3
"plain->username, ""bob""",2,1,3
"31, line->old_lineno",2,1,3
"strcmp(entry->path, ""conflicts-two.txt"") != 0",2,1,3
"(entry = git_index_get_bypath(result, ""modified-in-both.txt"", 0)) == NULL",2,1,3
"expected_value, error",2,1,3
"GIT_DIRECTION_FETCH, ""refs/heads/master::refs/remotes/frotz/xyzzy"", false",2,1,3
"!git_path_exists(""testrepo/branch_file"")",2,1,3
"p_symlink(""../../b/f2"", ""src/c/d/l1"") == 0",2,1,3
"30, exp.line_adds",2,1,3
"!git_path_exists(""typechanges/untracked"")",2,1,3
"""testrepo"", git_submodule_path(sm)",2,1,3
"ttt ""\n"", ttt ""\n"" sss ""\n"" sss ""\n"" sss ""\n"", 0",2,1,3
"entry = git_index_get_bypath(index, ""A"", 0)",2,1,3
ref != NULL,2,1,3
"GIT_EINVALIDSPEC, git_reflog_rename(g_repo, ""refs/heads/master"", ""refs/heads/Inv@{id"")",2,1,3
"GIT_ENOTFOUND, git_config_get_multivar_foreach(cfg, _name, ""example"", cb, &n)",2,1,3
"tree, ""README"", ""README""",2,1,3
"""conflicting-3.txt"", git_vector_get(&paths, 2)",2,1,3
"entry = git_index_get_bypath(repo_index, ""new-and-same.txt"", 0)",2,1,3
"1, git_filter_list_length(fl)",2,1,3
"expected_tagness, git_reference_is_tag(reference)",2,1,3
"git_index_get_bypath(index, ""hello"", 0) != NULL",2,1,3
"git_tree_entry_byname(tree, """") == NULL",2,1,3
git_reference_type(looked_up_ref) & GIT_REF_OID,2,1,3
"before[i], content.ptr",2,1,3
(S_ISGID & st.st_mode) == 0,2,1,3
"git_path_isdir(""t2"")",2,1,3
"-1, git_oid_streq(&id, ""deadbeef"")",2,1,3
" ""\n!yzarC\n$Id$\ntset rehtonA"", git_blob_rawcontent(blob)",2,1,3
"""dif.dirstat.li\nes""",2,1,3
"GIT_ABBREV_DEFAULT, val",2,1,3
"git_sortedcache_lockandload(sc, &buf) > 0",2,1,3
"""schacon@gmail.com"", committer->email",2,1,3
"""\\"", ""\\""",2,1,3
"git_tree_entry_filemode(entry), GIT_FILEMODE_BLOB",2,1,3
"i % 3 == 0 || i % 7 == 0, git_bitvec_get(bv, i)",2,1,3
"git__suffixcmp(git_repository_path(repo2), ""alternate/.git/"") == 0, git_repository_path(repo2)",2,1,3
"git_index_has_conflicts(repo_index), 1",3,0,3
"git_path_exists(""typechanges/e"")",2,1,3
"commit_message, git_commit_message(commit)",2,1,3
"-1, apple_i",2,1,3
"""\n"", actual.ptr",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge branches '"" OCTO1_BRANCH ""' and '"" OCTO2_BRANCH ""'\n"")",2,1,3
!git_buf_oom(&parent),2,1,3
"4, (int)hunk->new_lines",2,1,3
"!git_path_exists(""merge-resolve/modify-delete"")",2,1,3
"&buf, ""//a/b/c"", ""//a/Q/../b/x/y/../../c""",2,1,3
"expected_output, git_buf_cstr(&prettified_message)",2,1,3
"42, NULL",2,1,3
"DATA,SIZE,1,PATH,__FILE__,(int)__LINE__",2,1,3
"GIT_ITEROVER, git_reference_next(&ref, iter)",2,1,3
"GIT_DIRECTION_PUSH, ""master"", true",2,1,3
"4, i->stat_calls",2,1,3
"expected->ref_name, name",2,1,3
"""this/file/.""",3,0,3
"(a = resolve_commit_oid_to_tree(g_repo, old_commit)) != NULL",2,1,3
"0, git_oid_streq(&idp, ""ae90f12eea699729ed"")",2,1,3
"""sm_unchanged"", git_submodule_name(sm)",2,1,3
"merge_test_index(index, merge_index_entries, 4)",3,0,3
"""name"", ref_name",2,1,3
"GIT_ENOTFOUND, git_stash_save(&stash_tip_oid, repo, signature, NULL, GIT_STASH_INCLUDE_UNTRACKED)",2,1,3
"p_lstat(""root/d1/missing/deeper/path"", &st) < 0",2,1,3
expected->files_binary > 0,2,1,3
"""PROGRA~1"", (shortname = git_win32_path_8dot3_name(""C:\\Program Files""))",2,1,3
"expect_setgid, (st.st_mode & S_ISGID) != 0",2,1,3
"*scan, git_tree_entry_name(te)",2,1,3
"EXPECTED_HEADER, line->content",2,1,3
o != NULL,2,1,3
"committer_email, author1->email",2,1,3
"reuc = git_index_reuc_get_bypath(repo_index, ""one.txt"")",2,1,3
"""dGhpcyEK"", buf.ptr",2,1,3
"!git_path_isdir(""an_dir"")",2,1,3
" expected, line->old_lineno - last_old_lineno",2,1,3
"""foo@example.com"", signature->email",2,1,3
reflog && reflog->db,2,1,3
"5, data.files",2,1,3
"""core.precomposeunicode"", GIT_ENOTFOUND",2,1,3
"value, ""1337""",2,1,3
((git_refcount *)new_index)->refcount.val == 2,2,1,3
"GIT_EEXISTS, git_tag_create_lightweight( &object_id, g_repo, ""e90810b"", target, 0)",2,1,3
"out.ptr, out.size, ""futils/test-file""",3,0,3
cfg,2,1,3
"ttt ""\n"", ttt ""\n\n"" sss sss sss ""\n\n"", 0",2,1,3
"""refs/heads/master"", GIT_OBJ_TREE, ""944c0f6e4dfa41595e6eb3ceecdb14f50fe18162"", GIT_OBJ_TREE",2,1,3
"sizes[0], git_patch_size(patch, 0, 0, 0)",2,1,3
"GIT_ENOTFOUND, git_merge_base_many(&oid, _repo, count, oids)",2,1,3
"true, git_reference_is_valid_name(""refs/master{yesterday"")",2,1,3
reuc->mode[0] == 0,2,1,3
'\0' != *scan++,2,1,3
GIT_ATTR_UNSPECIFIED(vals[2]),2,1,3
"3, st.count",2,1,3
" GIT_SUBMODULE_RECURSE_NO, git_submodule_fetch_recurse_submodules(sm2)",1,2,3
"!git_pathspec_matches_path(ps, 0, ""ONE"")",2,1,3
"merge_test_workdir(repo, merge_filesystem_entries, 4)",2,1,3
"expected_email, sign->email",2,1,3
"&buf, ""../.."", ""../..""",2,1,3
"git_path_isdir(BASEDIR ""/b/b1/b2"")",2,1,3
"(item = git_sortedcache_lookup(sc, ""again"")) != NULL",2,1,3
"EXPECTED_HUNK, line->content",2,1,3
" GIT_MODE_TYPE(expect_mode), GIT_MODE_TYPE(st.st_mode), ""%07o""",2,1,3
"""refs/tags/point_to_blob"", GIT_OBJ_BLOB, ""1385f264afb75a56a5bec74243be9b367ba4ca08"", GIT_OBJ_BLOB",2,1,3
"&_pathspecs, true, &before",2,1,3
"p_lstat(""root/file/invalid/deeper_path"", &st) < 0",2,1,3
"git_path_exists(""typechanges/untracked"")",2,1,3
"GIT_ELOCKED, error",2,1,3
d2038 < d2039,2,1,3
"(val), err",2,1,3
"GIT_DELTA_UNTRACKED, delta->status",2,1,3
"GIT_ENOTFOUND, git_config_open_level(&local_cfg, cfg, GIT_CONFIG_LEVEL_LOCAL)",2,1,3
"2, git_index_entrycount(write_index)",2,1,3
"GIT_DIRECTION_PUSH, ""refs/heads/*/*/for-linus:refs/remotes/mine/*"", false",2,1,3
err != SSL_ERROR_WANT_WRITE,2,1,3
buf->size == 0 && buf->asize == 0,2,1,3
"stats.total_objects, 2",2,1,3
"th, *((int *)rval)",2,1,3
"committer_name, committer1->name",2,1,3
"&buf, ""a/b"", ""a//b""",2,1,3
"""Ivory their outposts were--the guardrooms of them gilded,\n"", actual.ptr",2,1,3
"4, expect.lines",2,1,3
"""refs/stash^2"", ""index on (no branch): """,2,1,3
"ttt ""\n"", ttt sss sss ""\n"", 0",2,1,3
"true, git_path_isvalid(NULL, ""foo /bar"", 0)",3,0,3
patches[p] != NULL,2,1,3
"GIT_REBASE_OPERATION_PICK, rebase_operation->type",3,0,3
committer1 != NULL,2,1,3
"!git__suffixcmp(git_repository_path(_repo), ""/init_shared_from_tpl/.git/"")",2,1,3
"BITFLIPPED_AND_REVERSED_DATA_LEN, out.size",2,1,3
"""../../there"", p.ptr",2,1,3
entry->level == GIT_CONFIG_LEVEL_SYSTEM,2,1,3
"(d = resolve_commit_oid_to_tree(g_repo, d_commit)) != NULL",2,1,3
"GIT_DIRECTION_PUSH, ""refs/heads/*/for-linus:refs/remotes/mine/*-blah"", false",2,1,3
"git_path_isfile(path), path",2,1,3
""""", ""# comment"", 1",2,1,3
"&ad->new_file.id, &bd->new_file.id",2,1,3
git_repository_head_unborn(repo) == 0,2,1,3
"git_path_isdir(""t1/b"")",2,1,3
"false, git_blob_is_binary(d)",2,1,3
"str, expected_left",2,1,3
"""x"", ""foo@bar.baz"", ""x"", ""foo@bar.baz""",2,1,3
"""nulltoken"", ""emeric.fermas@gmail.com"", "" nulltoken "", "" emeric.fermas@gmail.com """,2,1,3
signaled,2,1,3
"""refs/heads/development"", git_reference_symbolic_target(ref)",2,1,3
data == original,2,1,3
"repo, ""where"", GIT_STATUS_INDEX_NEW",3,0,3
"-100, ret",2,1,3
"""7b4384978d2493e851f9cca7858815fac9b10980"", GIT_OBJ_COMMIT, ""e90810b8df3e80c413d903f631643c716887138d"", GIT_OBJ_COMMIT",2,1,3
"""diff.dirstat.lines#""",2,1,3
"""refs/stash:just.ignore"", NULL",2,1,3
"ctxt, actual_ctxt",2,1,3
"GIT_DIRECTION_PUSH, "":refs/remotes/frotz/delete me"", false",2,1,3
"ttt ""\n"" ttt ttt ""\n"" ttt ""\n"", ttt ""\n"" ttt ttt ""\n"" ttt ""\n"", 0",2,1,3
"g_expected, count",2,1,3
"0, ""be3563ae3f795b2b4353bcce3a527ad0a4f7f644""",2,1,3
"&buf, ""/"", ""/a/../.""",2,1,3
"5, free_count",2,1,3
"GIT_DIRECTION_FETCH, """", true",2,1,3
"GIT_DIRECTION_PUSH, ""refs/heads/ nitfol"", false",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge branch '"" OCTO1_BRANCH ""', remote-tracking branch 'refs/remotes/origin/"" OCTO2_BRANCH ""'\n"")",2,1,3
"!bytes, file, line, ""error reading from file"", path, 1",2,1,3
" ""\n!nuf evaH\n$dI$\ntset a si sihT"", git_blob_rawcontent(blob)",2,1,3
"strcmp(git_submodule_url(sm2), str) != 0",2,1,3
" GIT_EBAREREPO, git_diff_tree_to_workdir(&diff, g_repo, tree, &opts)",2,1,3
"GIT_DIRECTION_PUSH, ""refs/heads/*:refs/remotes/frotz/*"", true",2,1,3
"false, git_remote_is_valid_name(""/"")",2,1,3
"10, val",2,1,3
"&buf, """", "".""",2,1,3
"GIT_ENOTFOUND, git_reference_lookup(&ref, g_repo_cloned, local_name)",2,1,3
"48, line->new_lineno",2,1,3
"""staged_new_file_modified_file"", git_pathspec_match_list_entry(m, 6)",2,1,3
"true, git_path_isfile(""./testrepo/de/fgh/1.txt"")",2,1,3
"3, git_filter_list_length(fl)",2,1,3
th != NULL,2,1,3
"11, exp.lines",2,1,3
"0, git_oid_strcmp(&idp, ""ae90f12eea699729ed"")",2,1,3
"type, git_object_type(obj)",2,1,3
"59, expect.lines",2,1,3
"!git_path_exists(""merge-resolve/directory_file-one/file"")",2,1,3
"g_peel_repo, ""refs/foo/tag-outside-tags"", GIT_OBJ_ANY, ""0df1a5865c8abfc09f1f2182e6a31be550e99f07"", GIT_OBJ_COMMIT",2,1,3
"31 + 16, git_patch_size(patch, 1, 1, 0)",2,1,3
"2, data.invokes",2,1,3
"git_path_isdir(""d3/d3.1/d3.2"")",2,1,3
"entry = git_index_get_bypath(repo_index, ""modified-in-14-branch.txt"", 0)",2,1,3
"""current_file"", git_pathspec_match_list_entry(matches,0)",2,1,3
"GIT_EINVALIDSPEC, git_tag_create(&tag_id, g_repo, ""Inv@{id"", target, tagger, tagger_message, 0) ",2,1,3
"memcmp(o1->data, o2->data, o1->len) == 0",2,1,3
"8 + 6, stream->received_bytes",2,1,3
"repo_path, ""info"", GIT_FILEMODE_TREE | GIT_REPOSITORY_INIT_SHARED_GROUP, true, filemode",2,1,3
"""Scott Chacon"", committer->name",2,1,3
"value, ""1234""",2,1,3
"tree, ""ab/de/"", ""de""",2,1,3
"0, git_oid_streq(git_reference_target(head), KNOWN_COMMIT_IN_BARE_REPO)",2,1,3
"""stash@{1}^3"", NULL, GIT_OBJ_COMMIT",2,1,3
"GIT_ENOTFOUND, git_tree_entry_bypath(&e, tree, ""ab/de/fgh/i-do-not-exist.txt"")",2,1,3
git_repository_head_detached(cloned),2,1,3
git_repository_is_bare(repo) == 1,2,1,3
" GIT_STATUS_WT_DELETED, git_status_byindex(status, 0)->status",2,1,3
"git__suffixcmp(git_repository_workdir(repo), ""attr/"") == 0",2,1,3
"GIT_OBJ_TAG, git_object_type(tag)",2,1,3
"false, git_index_has_conflicts(repo_index)",2,1,3
GIT_REPOSITORY_STATE_REBASE_INTERACTIVE,2,1,3
"!git_path_exists(""testrepo/README.after"")",2,1,3
"""a.lock"", GIT_EINVALIDSPEC",2,1,3
flags == GIT_STATUS_IGNORED,2,1,3
"!git_oid_ncmp(&id, &idp, 2)",2,1,3
"!git_path_exists(""stash/three.txt"")",2,1,3
"GIT_ENOTFOUND, git_object_lookup_bypath(&g_actualobject, (git_object*)g_root_tree, ""file/doesnt/exist"", GIT_OBJ_ANY)",2,1,3
"GIT_ENOTFOUND, git_stash_save(&stash_tip_oid, repo, signature, NULL, GIT_STASH_DEFAULT)",2,1,3
"&buf, """", ""a/../.""",2,1,3
""""", sss ""\n"" sss ""\n"" sss ""\n"", 0",2,1,3
"0, git_oid_strcmp(&id, str_oid)",2,1,3
"GIT_ENOTFOUND, git_tree_entry_bypath(&e, tree, ""README/"")",2,1,3
"tree, ""ab/de"", ""de""",2,1,3
"GIT_ATTR_TRUE(value), name",2,1,3
db && short_id,2,1,3
"host, ""hostname.com""",2,1,3
"true, ""example.global_with_tilde""",2,1,3
new_val == old_val,2,1,3
"delta->status, expected->status[expected->idx]",2,1,3
"git_pathspec_matches_path(ps, GIT_PATHSPEC_NO_GLOB, ""two*"")",2,1,3
"""branch_file.txt"", ""hello\n"", ""5b5b025"", ""c47800c""",2,1,3
"31, (int)hunk->old_start",2,1,3
"0, git_oid_cmp(&before_current_old_oid, &after_current->oid_old)",2,1,3
"""refs/tags/test"", GIT_OBJ_ANY, ""e90810b8df3e80c413d903f631643c716887138d"", GIT_OBJ_COMMIT",2,1,3
"i, (int)git_cache_size(&g_repo->objects) - start",2,1,3
"git__strcasesort_cmp(""foo"", ""foo"") == 0",2,1,3
"ttt ""\n"", ttt ""\n\n\n\n"", 0",2,1,3
"GIT_MERGE_ANALYSIS_NORMAL, (merge_analysis & GIT_MERGE_ANALYSIS_NORMAL)",3,0,3
GIT_REPOSITORY_STATE_REBASE,2,1,3
"""refs/stash^2:just.ignore"", NULL",2,1,3
"expected_branchness, git_reference_is_branch(reference)",2,1,3
"""xx"", ""foo@bar.baz"", ""xx"", ""foo@bar.baz""",2,1,3
"ptr = strstr(two.ptr, ""Class2"")",2,1,3
"conndata.pass, ""pass@word%zyx%v""",2,1,3
"GIT_REMOTE_DOWNLOAD_TAGS_AUTO, origin->download_tags",2,1,3
"GIT_DELTA_COPIED, (int)delta->status",2,1,3
"git_pathspec_matches_path(ps, 0, ""one"")",2,1,3
"0, git_status_list_entrycount(statuslist)",3,0,3
git_path_exists(empty_tmp_dir) == false,2,1,3
"0, result.size",2,1,3
" GIT_ENOTFOUND, git_sortedcache_lookup_index(&pos, sc, ""again"")",2,1,3
"&buf, ""../"", "".././""",2,1,3
"0, cts.conflicts",2,1,3
conflict_entry[0] == NULL,2,1,3
"!git_index_find(&position, index, ""lame.name.txt"")",2,1,3
st.st_gid == entry->gid,2,1,3
"!git_path_isfile(""testrepo/untracked_file"")",2,1,3
(status & GIT_SUBMODULE_STATUS_WD_UNTRACKED) != 0,2,1,3
"&pick_id, &rebase_operation->id",3,0,3
"DATA_LEN, out.size",3,0,3
closed,2,1,3
"absolute_url.ptr, config_url",3,0,3
walk && oid,3,0,3
git_path_exists(git_buf_cstr(&file)),2,1,3
"ttt ""\n"", ttt ""\n"" sss sss ""\n"" sss ""\n\n"", 0",2,1,3
"ttt ""\n"", ttt ""\n"" sss sss sss ""\n\n\n"", 0",2,1,3
"""conflicting-1.txt"", git_vector_get(&paths, 0)",2,1,3
WAIT_OBJECT_0 == wait_result,2,1,3
"42, current_value",2,1,3
"""refs/heads/packed"", true",2,1,3
"&buf, """", """"",2,1,3
"""testrepo"", git_submodule_name(sm)",2,1,3
"34, line->old_lineno",2,1,3
"delta->new_file.size, git_blob_rawsize(d)",2,1,3
"50, item->value",2,1,3
repo && callback,2,1,3
"merge_test_names(repo_index, merge_name_entries, 1)",2,1,3
" file,line,""wrong workdir dels"", 1, ""%""PRIuZ, wt_dels, vals.wt_dels",2,1,3
"!git_index_find(&entry_idx, repo_index, ""two.txt"")",2,1,3
"8 + 4, stream->received_bytes",2,1,3
"!git_path_exists(""testrepo/link_to_new.txt"")",2,1,3
"p_lstat_posixly(""root/d1/file/extra"", &st) < 0",2,1,3
"6, exp.line_adds",2,1,3
committer1->when.time == 123456789,2,1,3
"""../../that"", p.ptr",2,1,3
"ttt ""\n"", ""# comment\n"" ttt ""\n"", 1",2,1,3
"(b = resolve_commit_oid_to_tree(g_repo, new_commit)) != NULL",2,1,3
sm != NULL,2,1,3
"""subdir/modified_file"", git_pathspec_match_list_entry(m, 6)",2,1,3
"expected_value, current_value",2,1,3
"p_inet_pton(AF_INET, in_addr_data[i].p, &addr) == 1",2,1,3
"false, git_remote_is_valid_name(""//"")",2,1,3
"4, (int)hunk->old_lines",2,1,3
"GIT_DIRECTION_PUSH, ""refs/heads/*/for-linus:refs/remotes/mine/*"", true",2,1,3
"ttt ""\n"", sss sss ""\n"" sss ""\n\n"" ttt ""\n"", 0",2,1,3
"GIT_ENOTFOUND, git_tree_entry_bypath(&e, tree, ""ab/me-neither/fgh/2.txt/"")",2,1,3
aardvark_i < apple_after_i,2,1,3
"""stash@{1}^2:what"", ""dd7e1c6f0fefe118f0b63d9f10908c460aa317a6""",2,1,3
"7 + 24 + 1 + 6 + 6, expect.lines",2,1,3
x.length == 1,2,1,3
obj == NULL,2,1,3
"GIT_DIRECTION_FETCH, ""refs/heads/master:refs/remotes/frotz/xyzzy"", true",2,1,3
"!git_path_isdir(""t1/c/e"")",2,1,3
"false, git_repository_head_unborn(repo)",2,1,3
"reuc = git_index_reuc_get_bypath(result, ""removed-in-both.txt"")",2,1,3
" file, line, ""expected_mode != actual_mode"", 1, ""%07o"", (int)expected, (int)(actual & 0777)",2,1,3
"1, expected->line_adds",2,1,3
"""*"", 22",2,1,3
g_repo,2,1,3
"25, (int)hunk->new_start",2,1,3
"0, git_oid_strcmp( git_blob_id(blob), ""8ca0df630d728c0c72072b6101b301391ef10095"")",2,1,3
"th, ((int *)data)[0]",2,1,3
"""Scott Chacon"", author->name",2,1,3
diff != NULL,2,1,3
"7 + 1, expect.line_dels",2,1,3
"git_path_exists(""testrepo/link_to_new.txt"")",2,1,3
"4, cts.n_updates",2,1,3
"""new_file"", git_pathspec_match_list_entry(m, 2)",2,1,3
"git_tree_entry_name(entry), expected_entry_name",2,1,3
"-1, git_oid_streq(&idp, ""I'm not an oid.... :)"")",2,1,3
"&buf, ""/"", ""/a/../""",2,1,3
"entry = git_index_get_bypath(result, ""new-and-different.txt"", 3)",2,1,3
"1, filter_for(""foo.lf"", ""crlf"")",3,0,3
"1, ct.n_conflicts",2,1,3
"entry = git_index_get_bypath(result, ""modified-in-both.txt"", 3)",2,1,3
"11, count",2,1,3
specs.strings,2,1,3
"""sm_changed_head"", git_submodule_name(sm)",2,1,3
"value, ""5""",2,1,3
"!git_path_exists(""typechanges/c"")",2,1,3
"""\n\\ No newline at end of file\n"", actual.ptr",2,1,3
"g_repo, ""sm_just_added_2""",3,0,3
"&expected, oid",3,0,3
"GIT_ITEROVER, ret",2,1,3
"4, (int)git_diff_num_deltas(diff)",2,1,3
(git_index_caps(index) & GIT_INDEXCAP_NO_FILEMODE) == 0,2,1,3
"git_path_isdir(""d4/d4.1"")",2,1,3
"NULL, git_pathspec_match_list_entry(m, 4)",2,1,3
"GIT_DIRECTION_FETCH, ""HEAD"", true",2,1,3
"revspec.flags, expected_revparseflags",2,1,3
caps == git_index_caps(index),2,1,3
"&buf, ""../"", ""../""",2,1,3
o1->len == o2->len,2,1,3
"""new_tag"", git_tag_name(tag)",2,1,3
"false, git_reference_is_valid_name(""refs/tags/0.17.0^{}"")",2,1,3
"expected, count",2,1,3
"GIT_DIRECTION_PUSH, ""HEAD:"", false",2,1,3
"git__suffixcmp(git_repository_path(repo), repo_path) == 0",2,1,3
hunk == NULL,2,1,3
"git_path_isdir(""t1/c"")",2,1,3
"""\\^match\\\\s\\*\\[A-Z\\]\\+\\.\\*"", a.ptr",2,1,3
"""sm_added_and_uncommited"", git_submodule_name(sm)",2,1,3
""".git""",3,0,3
is_merge == 1,2,1,3
"true, git_reference_is_valid_name(""refs/LEVELS"")",2,1,3
"GIT_EBAREREPO, git_stash_save(&stash_tip_oid, local, signature, NULL, GIT_STASH_DEFAULT)",2,1,3
apple_after_i < apple_extra_i,2,1,3
"0, (int)git_reflog_entrycount(g_reflog)",2,1,3
"g_crlf_filtered[i].size, out.size",2,1,3
"&buf, ""../"", ""../.""",2,1,3
"git_path_isdir(""t1"")",2,1,3
"ALL_CRLF_TEXT_RAW, buf.ptr",2,1,3
"git__strcmp(expected->sources[expected->idx], delta->old_file.path) == 0",2,1,3
(rule->match.flags & GIT_ATTR_FNMATCH_FULLPATH) != 0,2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge branches '"" OCTO1_BRANCH ""' and '"" OCTO3_BRANCH ""'; commit '"" OCTO2_OID ""'; commit '"" OCTO4_OID ""'\n"")",2,1,3
"git_path_is_empty_dir(""empty_dir/content"")",2,1,3
ancestor_out && our_out && their_out && index && path,2,1,3
"true, GIT_STATUS_CURRENT, GIT_STATUS_CURRENT",2,1,3
"10, exp.file_status[GIT_DELTA_UNTRACKED]",2,1,3
"GIT_DIRECTION_FETCH, "":refs/remotes/frotz/HEAD to me"", false",2,1,3
"""Es\\caped\\"", ""Es\\\\ca\\ped\\\\""",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge branch '"" OCTO1_BRANCH ""'; commit '"" OCTO2_OID ""'\n"")",2,1,3
"""origin"", git_remote_name(remote)",2,1,3
"(fd = p_open(path, flags, mode)) >= 0",2,1,3
patch != NULL,2,1,3
"3, pos",2,1,3
"1, hunk->old_start",2,1,3
"git_path_exists(path.ptr), path.ptr",2,1,3
committer1->when.offset == 60,2,1,3
"0, file, line, fncall, msg, 1",2,1,3
"git_blob_rawsize(d), delta->old_file.size",2,1,3
"p_inet_pton(AF_INET, ""10.foo.bar.1"", &addr) == 0",2,1,3
"22, expect.line_dels",2,1,3
"0, git_oid_streq(&idp, ""ae90f12eea699729ed0000000000000000000000"")",2,1,3
git_buf_oom(ceiling_dirs) == 0,2,1,3
"true, git_reference_is_valid_name(""HEAD"")",2,1,3
"entry = git_index_get_bypath(result, ""new-and-same.txt"", 0)",2,1,3
"""7b4384978d2493e851f9cca7858815fac9b10980"", GIT_OBJ_TAG, ""7b4384978d2493e851f9cca7858815fac9b10980"", GIT_OBJ_TAG",2,1,3
delta->status == GIT_DELTA_UNMODIFIED || (delta->flags & GIT_DIFF_FLAG_BINARY) != 0,2,1,3
"""stash@{0}^2:when"", NULL",2,1,3
" GIT_ENOTFOUND, git_sortedcache_lookup_index(&pos, sc, ""testing"")",2,1,3
"err->klass, GITERR_INDEX",2,1,3
"test_file_contents(GIT_MERGE_HEAD_FILE, OCTO1_OID ""\n"" OCTO2_OID ""\n"" OCTO3_OID ""\n"" OCTO4_OID ""\n"" OCTO5_OID ""\n"")",2,1,3
"!git_path_exists(""stash/one.txt"")",2,1,3
"!git_path_exists(""issue_592/l.txt"")",2,1,3
"strcmp(automergeable_buf.ptr, AUTOMERGEABLE_MERGED_FILE_CRLF) == 0",2,1,3
"git_pool__ptr_in_pool(&p, ptr)",2,1,3
"GIT_DIRECTION_FETCH, ""refs/heads/*/*/for-linus:refs/remotes/mine/*"", false",2,1,3
"git_path_isdir(""base/dir/here/d"")",2,1,3
out && repo && ref,2,1,3
"expected, buf->ptr",2,1,3
"""stash@{1}^2:when"", NULL",2,1,3
"46, (int)hunk->old_start",2,1,3
"!git__suffixcmp(git_repository_workdir(_repo), ""/c_wd/"")",2,1,3
""""", sss sss ""\n"", 0",2,1,3
"6, expect.files",2,1,3
"expected_camel_cased_file_status, status",2,1,3
"16, exp.lines",2,1,3
"GIT_DIRECTION_PUSH, "":refs/remotes/frotz/deleteme"", true",2,1,3
"git__prefixcmp(str_in_error, ""stat failed: "") == 0",2,1,3
"""c47800c7266a2be04c571c04d5a6614691ea99bd"", 3, ""a65fed"", ""849607"", ""763d71""",2,1,3
" GIT_ENOTFOUND, git_sortedcache_lookup_index(&pos, sc, ""abc"")",2,1,3
"""some;thing"", str4",2,1,3
"false, git_remote_is_valid_name(""/no/leading/slash"")",2,1,3
"git_submodule_name(sm), name",2,1,3
"2, (int)git_patch_num_hunks(patch)",2,1,3
"reuc = git_index_reuc_get_bypath(repo_index, ""TWO.txt"")",2,1,3
g_data[4].type == git_object_type(obj),2,1,3
"git__strcasesort_cmp(""foo"", ""bar"") > 0",2,1,3
"0, p_lstat(""root/d1/file"", &st)",2,1,3
repo && refdb,2,1,3
e->refcount.val == 0,2,1,3
"""refs/remotes/test/master"", git_reference_name(upstream)",2,1,3
"GIT_ENOTFOUND, git_filter_unregister(""not-a-filter"")",2,1,3
"""/"", GIT_EINVALIDSPEC",2,1,3
"ttt ""\n"", ttt ""\n"" ""# comment\n"", 1",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge commit '"" OCTO1_OID ""'; commit '"" OCTO1_OID ""'; commit '"" OCTO1_OID ""'\n"")",2,1,3
ctx && ctx->type,3,0,3
"&buf, ""a"", ""a""",2,1,3
repo && object_out && id,2,1,3
"""refs/heads/master2"", git_reference_name(branch)",2,1,3
merge_trivial_conflict_entrycount() == 3,2,1,3
out && commit,2,1,3
"git_path_exists(TEST_REPO_PATH ""/.git/MERGE_MSG"")",3,0,3
"git_path_isdir(BASEDIR ""/a"")",2,1,3
"git_oid_strcmp(&id, ""deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"") < 0",2,1,3
scan > content.ptr,2,1,3
"1, git_diff_stats_files_changed(_stats)",3,0,3
"error, GIT_ENOTFOUND",2,1,3
"false, git_reference_is_valid_name(""//"")",2,1,3
(rule->match.flags & GIT_ATTR_FNMATCH_DIRECTORY) != 0,2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge branches '"" OCTO1_BRANCH ""', '"" OCTO1_BRANCH ""' and '"" OCTO1_BRANCH ""'\n"")",2,1,3
""" -- Rudyard Kipling"", actual.ptr",2,1,3
fn(data) == data,2,1,3
"1, git_reflog_entrycount(reflog)",2,1,3
""" Something"", str1",2,1,3
"GIT_EINVALIDSPEC, error",2,1,3
"git_oid_ncmp(&id, &idp, 41)",2,1,3
"expected_patterned, n",2,1,3
"git_path_isfile(""testrepo/newdir/newfile.txt"")",2,1,3
""""", sss sss sss ""\n"", 0",2,1,3
"git_reference_shorthand(ref), shorthand",2,1,3
"&buf, ""/"", ""////""",2,1,3
""""", """", 0",2,1,3
"!git_path_exists(""attr_index/README.txt"")",2,1,3
"7, (int)git_treebuilder_entrycount(builder)",2,1,3
"2, git_filter_list_length(fl)",2,1,3
"2, hunk->old_lines",2,1,3
"""refs/remotes/*"", 2",2,1,3
"refs_len_before, refs_len_after",2,1,3
"merge_test_index(index, merge_index_entries, 41)",2,1,3
"(item = git_sortedcache_lookup(sc, ""testing"")) != NULL",2,1,3
"repo, 0, ""a65fedf39aefe402d3bb6e24df4d4f5fe4547750"", ""e90810b8df3e80c413d903f631643c716887138d"", msg",3,0,3
"!git_oid_ncmp(&id, &idp, 1)",2,1,3
"&buf, """", ""./""",2,1,3
"repo, ""refs/tags/test"", ""test""",2,1,3
"""dGhpcw=="", buf.ptr",2,1,3
"-1, git_oid_streq(&idp, ""ae90f12eea699729ec"")",2,1,3
"false, git_branch_is_head(super)",2,1,3
type == GIT_OBJ_REF_DELTA || type == GIT_OBJ_OFS_DELTA,2,1,3
"""staged_new_file_modified_file"", git_pathspec_match_list_entry(m, 5)",2,1,3
"47, line->old_lineno",2,1,3
"""//"", GIT_EINVALIDSPEC",2,1,3
"&buf, ""/"", ""///a/..""",2,1,3
"ttt ""\n"", ttt sss sss, 0",2,1,3
git_path_exists(d->file),2,1,3
"true, git_remote_is_valid_name(""yishaigalatzer/rules"")",2,1,3
git_object_type(target) == GIT_OBJ_BLOB,2,1,3
array->strings!=NULL,2,1,3
git_object_type(object) == GIT_OBJ_TAG,2,1,3
"30, val",2,1,3
"git_path_isdir(""d1/d1.1"")",2,1,3
"original_remote, str",3,0,3
merge_trivial_conflict_entrycount(result) == 3,2,1,3
"0, git_oid_strcmp(&idp, ""ae90f12eea699729ed0000000000000000000000"")",2,1,3
"""garbage"", git_pathspec_match_list_failed_entry(m, 0)",2,1,3
"config_key, expected_value, true",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge branch '"" OCTO2_BRANCH ""', remote-tracking branch 'refs/remotes/origin/"" OCTO1_BRANCH ""'\n"")",2,1,3
"-1, git_oid_streq(&idp, ""ae90f12eea699729ed1"")",2,1,3
"stats.indexed_objects, 2",2,1,3
"!git_oid_ncmp(&id, &id, 1)",2,1,3
func(&id[t]) == &id[t],2,1,3
"committer_email, committer1->email",2,1,3
"1, 6, 1, 5, 0, &expected",3,0,3
"0, (int)git_diff_num_deltas(diff)",2,1,3
"git__prefixcmp( git_commit_message(commit), ""a simple commit which works"") == 0",2,1,3
"(link_fd = git_futils_creat_withpath(link.ptr, 0777, 0666)) >= 0",2,1,3
"""refs/heads/master"", GIT_OBJ_COMMIT, ""a65fedf39aefe402d3bb6e24df4d4f5fe4547750"", GIT_OBJ_COMMIT",2,1,3
"""This is some new text;\n"", actual.ptr",2,1,3
"(entry = git_index_get_bypath(repo_index, ""modified-in-both.txt"", 0)) == NULL",2,1,3
"true, git_path_isdir(""./testrepo/dir/subdir/subsubdir"")",2,1,3
"git_buf_rfind(&a, 'q') == -1",2,1,3
"git_buf_len(&target_path), st.st_size",3,0,3
git_path_is_empty_dir(empty.path.ptr),2,1,3
"git_path_isdir(""t2/c/e"")",2,1,3
"&buf, ""../"", ""./../""",2,1,3
head_old != NULL,2,1,3
"p_inet_pton(AF_INET, ""foo"", &addr) == 0",2,1,3
_backend && reflog,2,1,3
"git_path_isfile(""t1/f1"")",2,1,3
"entry = git_index_get_bypath(result, ""modified-in-13.txt"", 0)",2,1,3
"entry = git_index_get_byindex(index, i)",2,1,3
"""core.logallrefupdates"", GIT_ENOTFOUND, true",2,1,3
"48, line->old_lineno",2,1,3
"git_buf_rfind(&a, 'i') == len - 3",2,1,3
"default_namespace_note, ""hello world\n"", &note_oid",2,1,3
S_ISREG(e->mode),2,1,3
"""d"", e->path",2,1,3
"ttt ""\n"" ""# comment\n"", ttt ""\n"" ""# comment\n"", 0",2,1,3
"git_path_isfile(""t2/b/f2"")",2,1,3
"1, git_oid_equal(id, &expected_id)",3,0,3
"false, ""NewFolder""",2,1,3
"ttt ""\n"", ttt sss ""\n"", 0",2,1,3
"git_oid_streq(git_submodule_wd_id(sm), ""a65fedf39aefe402d3bb6e24df4d4f5fe4547750"") == 0",3,0,3
"expectations->file, path",2,1,3
"config_key, expected_value, false",2,1,3
git_tree_entrycount(tree) == 3,2,1,3
"p_inet_pton(AF_INET, """", &addr) == 0",2,1,3
sig->name && sig->email,2,1,3
git_path_exists(git_buf_cstr(&file)) == true,2,1,3
author1->when.time == 987654321,2,1,3
"git__suffixcmp(git_submodule_path(sm), ""sm_unchanged"") == 0",2,1,3
"""yes"", vals[3]",2,1,3
"statbuf.st_mode & os_mask, (0666 & ~mask) & os_mask",2,1,3
"""refs/heads/master"", true",2,1,3
"false, git_path_isdir(""./testrepo/dir"")",2,1,3
"0, status->status",3,0,3
onto && from,2,1,3
"&expected, GIT_DELTA_DELETED",2,1,3
"git_path_isdir(""src/c/d"")",2,1,3
"git_tree_entry_byname(tree, "".first"") != NULL",2,1,3
"reuc = git_index_reuc_get_bypath(repo_index, ""removed-in-8.txt"")",2,1,3
"33, expect.line_ctxt",2,1,3
"!git_path_exists(""merge-resolve/test-one-side-two.txt"")",2,1,3
"a.ptr, ""some""",2,1,3
"&buf, ""/a"", ""///a""",2,1,3
"git_tree_entry_byindex(tree, (unsigned int)-1) == NULL",2,1,3
" GIT_SUBMODULE_UPDATE_REBASE, git_submodule_set_update(sm1, GIT_SUBMODULE_UPDATE_RESET)",1,2,3
"nlogs_after, nlogs",3,0,3
walk && glob,3,0,3
"git_sortedcache_lookup(sc, ""abc"") == NULL",2,1,3
"entry = git_index_get_bypath(result, ""modified-to-same.txt"", 0)",2,1,3
"""stash@{1}^0:what"", ""bc99dc98b3eba0e9157e94769cd4d49cb49de449""",2,1,3
git_commit_author(parent) != NULL,2,1,3
"&buf, "".."", ""..""",2,1,3
"6, tmp",2,1,3
"git_path_isfile(""root/b/c_wd/.git"")",2,1,3
"""cde"", item->path",2,1,3
"""refs/stash@{0}"", NULL, GIT_OBJ_COMMIT",2,1,3
"false, git_branch_is_head(linked)",2,1,3
"g_repo, ref_name, requested_type, expected_sha, expected_type",2,1,3
"strstr(git_commit_message(commit), fragment) != NULL",2,1,3
!status,2,1,3
"e->names[e->files], delta->old_file.path",2,1,3
"ttt ""\n"", ttt ""\n\n\n"" sss sss sss ""\n\n"", 0",2,1,3
"1, expected->file_status[GIT_DELTA_UNMODIFIED]",2,1,3
"GIT_EEXISTS, git_tag_create( &tag_id, g_repo, ""e90810b"", target, tagger, tagger_message, 0)",2,1,3
git_path_exists(empty_tmp_dir) == true,2,1,3
"fetch_refspecs[i], array.strings[i]",2,1,3
entry->level == GIT_CONFIG_LEVEL_GLOBAL,2,1,3
"25, line->new_lineno",2,1,3
"submodule_status, GIT_SUBMODULE_STATUS_IN_HEAD | GIT_SUBMODULE_STATUS_IN_INDEX | GIT_SUBMODULE_STATUS_IN_CONFIG | GIT_SUBMODULE_STATUS_IN_WD | GIT_SUBMODULE_STATUS_WD_MODIFIED",3,0,3
"""refs/stash^3:just.ignore"", ""78925fb1236b98b37a35e9723033e627f97aa88b""",2,1,3
"value, ""garble""",2,1,3
blame,3,0,3
""""", sss sss sss sss, 0",2,1,3
"repo, ""branch.moved.remote"", true",2,1,3
"""newurl"", entry->value",2,1,3
"!git_diff_get_delta(diff, num_d)",2,1,3
"GIT_DIRECTION_FETCH, ""refs/heads/*:refs/remotes/frotz/*"", true",2,1,3
oid != NULL,2,1,3
"GIT_DIRECTION_PUSH, ""::"", false",2,1,3
"git_repository_path(_repo), git_repository_path(reinit)",2,1,3
"&buf, ""/a/b/c"", ""//a/Q/../b/x/y/../../c""",2,1,3
"7, val",2,1,3
"GIT_DIFF_LINE_DEL_EOFNL, (int)line->origin",2,1,3
"!git__suffixcmp(git_repository_path(_repo), ""/c.git/"")",2,1,3
"0, (int)git_reflog_entrycount(reflog)",2,1,3
"""refs/stash"", ""On master: "" MESSAGE",2,1,3
"git_tree_entry_byindex(tree, 3) == NULL",2,1,3
"""refs/stash:who"", ""a0400d4954659306a976567af43125a0b1aa8595""",2,1,3
"""submodules/libgit2"", git_submodule_path(sm)",3,0,3
""""", sss sss, 0",2,1,3
"""dGhpcyE="", buf.ptr",2,1,3
"git_oid_ncmp(&id, &idp, 42)",2,1,3
"git_object_id(g_expectedobject), git_object_id(g_actualobject)",3,0,3
"git_path_root(""non/rooted/path"") == -1",2,1,3
"(delta = git_diff_get_delta(diff, 3)) != NULL",2,1,3
"ttt ""\n"", ""\n"" sss ""\n"" sss sss ""\n"" ttt ""\n"", 0",2,1,3
"!git_path_isdir(""d1"")",2,1,3
"""\\"", ""\\\\""",2,1,3
git_tag_target_type(tag) == GIT_OBJ_COMMIT,2,1,3
status == GIT_STATUS_CURRENT,2,1,3
author1->when.offset == 90,2,1,3
"exp->paths[exp->counter++], path",2,1,3
git_buf_text_contains_nul(&b),2,1,3
t->rpc || t->current_stream == stream,2,1,3
"1, expected->file_status[mod]",2,1,3
"""a"", ""hello\n"", ""a4a7dce"", ""cf80f8d""",2,1,3
"1, ct.n_updates",2,1,3
"ad->old_file.id_abbrev, bd->old_file.id_abbrev",2,1,3
"true, git_reference_is_valid_name(""refs/tags/0.17.0"")",2,1,3
position_cake < position_config,2,1,3
"git_path_isdir(""t1/c/d"")",2,1,3
"git_tree_entry_byname(tree, ""apple_extra"") != NULL",2,1,3
"!git_path_exists(""merge-resolve/conflicting-2.txt"")",2,1,3
"merge_test_index(repo_index, merge_index_entries, 11)",2,1,3
"committer_name, author1->name",2,1,3
" GIT_EINVALIDSPEC, git_reference_normalize_name(buffer_out, sizeof(buffer_out), input_refname, flags)",2,1,3
"git_path_isfile(""t2/c/f3"")",2,1,3
"0, (int)git_treebuilder_entrycount(builder)",2,1,3
"git_path_isfile(""src/c/d/f4"")",2,1,3
"git_note_message(note), (const char *)git_blob_rawcontent(blob)",2,1,3
conflict_entry[1] == NULL,2,1,3
"5, exp.file_status[GIT_DELTA_ADDED]",2,1,3
"hex, ""5d410bdf97cf896f9007681b92868471d636954b""",2,1,3
"14, i->stat_calls",2,1,3
"expected, out.ptr",2,1,3
"git_pathspec_matches_path(ps, GIT_PATHSPEC_IGNORE_CASE, ""ONE"")",2,1,3
"""iii"", item->path",2,1,3
(leaks == 1),3,0,3
"tree, ""ab/de/fgh/"", ""fgh""",2,1,3
NULL == ref,2,1,3
"12, expect.line_ctxt",2,1,3
"""subdir/current_file"", git_pathspec_match_list_entry(m, 4)",2,1,3
"entry = git_index_get_bypath(result, ""modified-in-14-branch.txt"", 0)",2,1,3
type >= GIT_OBJ_COMMIT && type <= GIT_OBJ_REF_DELTA,2,1,3
git_repository_head_detached(repo) == false,2,1,3
"patch_expected, patchbuf.ptr",2,1,3
commit_time > 0,2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge branches '"" OCTO1_BRANCH ""', '"" OCTO2_BRANCH ""' and '"" OCTO3_BRANCH ""' of http://remote.url/repo.git\n"")",2,1,3
"git_path_isfile(""./new_workdir/.git"")",2,1,3
"&buf, ""a/b/c"", ""a/b/c""",2,1,3
"&buf, ""a/c"", ""a/./c""",2,1,3
"42, i->stat_calls",2,1,3
"GIT_EUNBORNBRANCH, git_checkout_head(g_repo, NULL)",2,1,3
"2, expect.hunks",2,1,3
"git_oid_streq(&entry->oid_old, GIT_OID_HEX_ZERO) != 0",2,1,3
"""conflicting-2.txt"", git_vector_get(&paths, 1)",2,1,3
"git_buf_rfind_next(&a, 'h') == 2",2,1,3
"!git_oid_ncmp(&id, &idp, 17)",2,1,3
"objstr, expected_left",2,1,3
GIT_REPOSITORY_STATE_BISECT,2,1,3
"nonblobs, (int)git_cache_size(&g_repo->objects) - start",2,1,3
"git_path_root(""//computername/sharefolder"") == 14",2,1,3
"git_path_isdir(""t2/b"")",2,1,3
"true, found_collision",2,1,3
GIT_ATTR_UNSPECIFIED(assign->value),2,1,3
"expected_flags, revspec.flags",2,1,3
"9, line->new_lineno",2,1,3
flen == 2 || flen == 3,2,1,3
"NULL, giterr_last()",3,0,3
"""stash@{1}^0:who"", ""a0400d4954659306a976567af43125a0b1aa8595""",2,1,3
"git_path_isfile(""t1/c/d/f4"")",2,1,3
git_submodule_owner(sm) == g_repo,2,1,3
"5, buf1.size",3,0,3
"git_path_isdir(""d1/d1.1/d1.2"")",2,1,3
"DATA,SIZE,0,PATH,__FILE__,(int)__LINE__",2,1,3
"!git_index_find(&entry_idx, repo_index, ""conflicts-two.txt"")",2,1,3
"git_tree_entry_byname(tree, ""apple_after"") != NULL",2,1,3
string_w,2,1,3
"0, git_oid_cmp(&oid, git_tree_entry_id(entry))",2,1,3
"1, data.invokes",2,1,3
bld,3,0,3
"""this is a test"", a.ptr",2,1,3
"3, data.invokes",2,1,3
--entrycount > 0,2,1,3
proxy_stream,3,0,3
"git_buf_rfind_next(&a, 'i') == len - 3",2,1,3
pass,2,1,3
git_index_entry_stage(conflict_entry[2]) == 3,2,1,3
"""link_to_new.txt"", ""old.txt"", ""a65fedf"", ""099faba""",2,1,3
"index, ""huh.dunno"", ""22c74203bace3c2e950278c7ab08da0fca9f4e9b""",2,1,3
"""TestGitRepository"", git_repository_workdir(g_repo)",2,1,3
"6, (int)hunk->new_start",2,1,3
"""refs/tags/e90810b"", true",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge commit '"" OCTO1_OID ""'; branches '"" OCTO2_BRANCH ""' and '"" OCTO4_BRANCH ""'; commit '"" OCTO3_OID ""'\n"")",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge remote-tracking branches 'refs/remotes/origin/"" OCTO1_BRANCH ""', 'refs/remotes/origin/"" OCTO2_BRANCH ""' and 'refs/remotes/origin/"" OCTO3_BRANCH ""'\n"")",2,1,3
"GIT_ENOTFOUND, git_reflog_drop(g_reflog, entrycount, 0)",2,1,3
"git_sortedcache_lookup(sc, ""cde"") == NULL",2,1,3
git_path_exists(git_buf_cstr(&orig_head_path)),2,1,3
"GIT_ENOTFOUND, git_branch_lookup(&branch, repo, ""over/here"", GIT_BRANCH_REMOTE)",2,1,3
"4, git_pathspec_match_list_entrycount(m)",2,1,3
pathspecs != NULL && pathspecs->count > 0,2,1,3
"!git_pathspec_matches_path(ps, GIT_PATHSPEC_NO_GLOB, ""two"")",2,1,3
"""refs/heads/br2"", git_reference_name(head)",2,1,3
idx->nr_objects == (size_t)((unsigned int)idx->nr_objects),2,1,3
"GIT_ERROR, git_index_add_bypath(index, ""test.txt"")",2,1,3
"false, git_reference_is_valid_name(""HEAD/aa"")",2,1,3
"GIT_EBAREREPO, git_index_add_bypath(index, ""test.txt"")",2,1,3
"merge_test_index(index, merge_index_entries, 1)",3,0,3
"GIT_EINVALIDSPEC, git_branch_lookup(&branch, repo, ""yes/i am"", GIT_BRANCH_REMOTE)",2,1,3
"-1, git_oid_streq(&id, ""I'm not an oid.... :)"")",2,1,3
"!git_path_exists(""empty_standard_repo/.git/config"")",2,1,3
"!git_path_isdir(""d4"")",2,1,3
"entry = git_index_get_bypath(repo_index, ""new-and-different.txt"", 3)",2,1,3
"""conflicts-one.txt"", conflict_entry[0]->path",2,1,3
after > scan,2,1,3
GIT_ATTR_TRUE(vals[0]),2,1,3
"entry = git_index_get_bypath(result, ""new-and-different.txt"", 2)",2,1,3
"entry = git_index_get_bypath(repo_index, ""new-in-3alt.txt"", 0)",2,1,3
"1, git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL_NO_LINKS)",3,0,3
!git_path_exists(git_buf_cstr(&merge_msg_path)),2,1,3
GIT_ATTR_UNSPECIFIED(values[0]),2,1,3
"GIT_EINVALIDSPEC, git_reference_lookup(&reference, g_repo, ""refs/heads/Inv@{id"")",2,1,3
"!git_path_exists(""typechanges/a"")",2,1,3
"""/this/is/the/end"", p.ptr",2,1,3
list.count == 7,2,1,3
"0, (int)st.st_size",2,1,3
"2, (int)git_diff_num_deltas(diff)",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge branches '"" OCTO1_BRANCH ""' and '"" OCTO2_BRANCH ""' of http://remote.url/repo.git\n"")",2,1,3
"git__strcasesort_cmp("""", """") == 0",2,1,3
" GIT_SUBMODULE_RECURSE_YES, git_submodule_set_fetch_recurse_submodules( sm1, GIT_SUBMODULE_RECURSE_RESET)",1,2,3
"1, (int)refnames.count",2,1,3
parents <= 2,2,1,3
"4, git_vector_length(&paths)",2,1,3
toReturn,2,1,3
"git_treebuilder_get(builder, ""last"") != NULL",3,0,3
git_index_entry_stage(conflict_entry[1]) == 2,2,1,3
"git__suffixcmp(git_repository_workdir(repo), ""new_workdir/"") == 0",2,1,3
"true, git_remote_is_valid_name(""webmatrix"")",2,1,3
"reuc = git_index_reuc_get_bypath(result, ""removed-in-10-branch.txt"")",2,1,3
data.completed_steps == data.total_steps,2,1,3
"ttt ""\n"", ttt sss sss sss ""\n"", 0",2,1,3
"false, git_path_isfile(git_buf_cstr(&log_path))",2,1,3
repo && our_head && heads,2,1,3
"&buf, ""/a/"", ""/a/.""",2,1,3
"merge_test_index(repo_index, merge_index_entries, 2)",2,1,3
"4, pos",2,1,3
"""stash@{0}^0:when"", NULL",2,1,3
"""refs/stash^2:what"", ""dd7e1c6f0fefe118f0b63d9f10908c460aa317a6""",2,1,3
""".lock"", GIT_EINVALIDSPEC",2,1,3
"git_index_get_bypath(index, ""newdir/newfile.txt"", 0) == NULL",2,1,3
"!git_path_isfile(""t1/c/d/.f5"")",2,1,3
"1, git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL)",3,0,3
"""nulltoken"", ""emeric.fermas@gmail.com"", "" nulltoken "", "" emeric.fermas@gmail.com \n""",2,1,3
"""/this/"", p.ptr",2,1,3
st.st_uid == entry->uid,2,1,3
"31, git_patch_size(patch, 0, 0, 0)",2,1,3
"6, (int)hunklen",2,1,3
"1323847743, (int)signature->when.time",2,1,3
st.st_ctime == entry->ctime.seconds,2,1,3
" GIT_ENOTFOUND, git_sortedcache_lookup_index(&pos, sc, ""cde"")",2,1,3
!git_path_exists(git_buf_cstr(&merge_head_path)),2,1,3
"""subdir.txt"", delta->old_file.path",2,1,3
"git__strcasesort_cmp(""foo"", ""BAR"") > 0",2,1,3
"strcmp(git_submodule_url(sm3), str) != 0",2,1,3
"""The Daughters of the Palace whom they cherished in my Cities,\n"", actual.ptr",2,1,3
"(delta = git_diff_get_delta(diff, 1)) != NULL",2,1,3
"GIT_ENOTFOUND, git_config_get_multivar_foreach(cfg, _name, NULL, cb, &n)",2,1,3
"GIT_DIRECTION_PUSH, ""master~1:refs/remotes/frotz/backup"", true",2,1,3
"git_oid_streq(&oid, ""da5e4f20c91c81b44a7e298f3d3fb3fe2f178e32"") == 0",2,1,3
"!git_path_exists(""merge-resolve/test-one.txt~theirs"")",2,1,3
parent != NULL,2,1,3
oids[i],2,1,3
position_c != -1,2,1,3
"git_path_isdir(""d1"")",2,1,3
"""TWO.txt"", reuc->path",2,1,3
"git_path_root(""C:non/rooted/path"") == -1",2,1,3
" GIT_EAMBIGUOUS, git_odb_exists_prefix(&found, _odb, &oid, strlen(hex))",3,0,3
"&buf, ""/a/"", ""//a/b/..""",2,1,3
"0, p_lstat(""root"", &st)",2,1,3
"git_path_root(""/rooted/path"") == 0",2,1,3
"ttt ""\n"", ""\n"" sss sss sss ""\n\n"" ttt ""\n"", 0",2,1,3
"""a"", e->path",2,1,3
""""", git_commit_message(commit)",2,1,3
nobj == 1628,2,1,3
"13, git_pathspec_match_list_entrycount(m)",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge remote-tracking branches 'refs/remotes/origin/"" OCTO1_BRANCH ""' and 'refs/remotes/origin/"" OCTO2_BRANCH ""'\n"")",2,1,3
"GIT_DIRECTION_FETCH, "":refs/remotes/frotz/HEAD-to-me"", true",2,1,3
"11, i->stat_calls",2,1,3
"""stash@{0}^2:who"", ""cc628ccd10742baea8241c5924df992b5c019f71""",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge branches '"" OCTO1_BRANCH ""', '"" OCTO2_BRANCH ""' and '"" OCTO3_BRANCH ""'\n"")",2,1,3
"1, git_sortedcache_entrycount(sc)",2,1,3
"(iep = git_index_get_bypath(idx, ""modified_file"", 0)) != NULL",2,1,3
GIT_REPOSITORY_STATE_REBASE_MERGE,2,1,3
"repo_path, ""hooks"", GIT_FILEMODE_TREE | GIT_REPOSITORY_INIT_SHARED_GROUP, true, filemode",2,1,3
"git_pathspec_matches_path(ps, 0, ""two.txt"")",2,1,3
"git_index_get_bypath(index, ""newdir/newfile.txt"", 0) != NULL",2,1,3
"5, exp.file_status[GIT_DELTA_UNMODIFIED]",2,1,3
st.st_mtime == entry->mtime.seconds,2,1,3
"11, i",2,1,3
position_config != -1,2,1,3
"""staged_new_file"", git_pathspec_match_list_entry(m, 3)",2,1,3
"merge_test_index(repo_index, merge_index_entries, 1)",2,1,3
"1, expect.line_adds",2,1,3
GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE,2,1,3
"3, binary_count",2,1,3
"git_path_isdir(""t2/c/d"")",2,1,3
(ancestor && ours) || (ancestor && theirs) || (ours && theirs),2,1,3
"""refs/stash^2:how"", ""e6d64adb2c7f3eb8feb493b556cc8070dca379a3""",2,1,3
" ALL_LF_TEXT_RAW ""\n$Id$\n"", git_blob_rawcontent(blob)",2,1,3
"!git_path_exists(""merge-resolve/test-one.txt~ours"")",2,1,3
local_path_out && file_url,2,1,3
"false, git_remote_is_valid_name("".lock"")",2,1,3
"p_lstat_posixly(""root/missing/but/could/be/created"", &st) < 0",2,1,3
"""All the world went softly when it walked before my Cities--\n"", actual.ptr",2,1,3
"9, line->old_lineno",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge branches '"" OCTO1_BRANCH ""' and '"" OCTO3_BRANCH ""', remote-tracking branches 'refs/remotes/origin/"" OCTO2_BRANCH ""' and 'refs/remotes/origin/"" OCTO4_BRANCH ""'\n"")",2,1,3
"git__suffixcmp(git_buf_cstr(&content), ""testrepo.git/"") == 0",2,1,3
"git_path_exists(""typechanges/a"")",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge remote-tracking branch 'refs/remotes/origin/"" OCTO1_BRANCH ""'\n"")",2,1,3
"git__utf8_to_16_alloc(&wide_name, name) >= 0",2,1,3
"3, exp.file_status[GIT_DELTA_UNMODIFIED]",3,0,3
"git_tree_entry_byindex(tree, 0) != NULL",2,1,3
cache,3,0,3
"!git_index_find(&entry_idx, repo_index, ""conflicts-one.txt"")",2,1,3
"7, (int)git_tree_entrycount(tree)",2,1,3
"p_lstat(""root/missing/but/could/be/created"", &st) < 0",2,1,3
" GIT_PERMS_IS_EXEC(expect_mode), GIT_PERMS_IS_EXEC(st.st_mode)",2,1,3
repo && old && new && diff,1,2,3
"git_oid_streq(git_submodule_wd_id(sm), ""5e4963595a9774b90524d35a807169049de8ccad"") == 0",2,1,3
"!git_path_exists(""alternate/3/.gitconfig"")",2,1,3
"GIT_CHECKOUT_NOTIFY_CONFLICT, why",2,1,3
utf8_write_len == utf8_len,2,1,3
reference_is_packed(ref) == 0,2,1,3
"!git_index_reuc_get_bypath(repo_index, ""TWO.txt"")",2,1,3
"ttt ""\n\n"" ttt ttt ttt ""\n"", ttt ""\n\t\n \n\n \t\t\n"" ttt ttt ttt ""\n"", 0",2,1,3
"git_sortedcache_lookup(sc, ""zzz"") == NULL",2,1,3
"500, item->value",2,1,3
"""Ben Straub"", hunk->final_signature->name",2,1,3
"(item = git_sortedcache_lookup(sc, ""cde"")) != NULL",2,1,3
"true, git_branch_is_head(branch)",2,1,3
"""refs/tags/test"", GIT_OBJ_TREE, ""53fc32d17276939fc79ed05badaef2db09990016"", GIT_OBJ_TREE",2,1,3
(oitem != NULL) ^ (nitem != NULL),2,1,3
"!git__suffixcmp(git_repository_workdir(_repo), ""/extended/"")",2,1,3
sign == NULL,2,1,3
"symlink(link_tgt.ptr, link.ptr) == 0, strerror(errno)",2,1,3
min_len > 0,2,1,3
"entry = git_index_get_bypath(result, ""new-in-3alt.txt"", 0)",2,1,3
"git_pathspec_matches_path(ps, 0, ""two"")",2,1,3
" GIT_SUBMODULE_UPDATE_REBASE, git_submodule_update_strategy(sm2)",1,2,3
"1, git_repository_is_shallow(g_repo)",2,1,3
!git_path_isdir(working_directory),2,1,3
reference_is_packed(ref) == 1,2,1,3
"git_path_isfile(""t2/c/d/.f5"")",2,1,3
"git_path_isdir(""d2"")",2,1,3
" file,line,""wrong workdir mods"", 1, ""%""PRIuZ, wt_mods, vals.wt_mods",2,1,3
"-1, git_oid_streq(&idp, ""deadbeef"")",2,1,3
" GIT_ENOTFOUND, git_sysdir_find_global_file(&path, ""nonexistentfile"")",3,0,3
"&buf, ""/"", ""/.""",2,1,3
"repo, ""refs/remotes/test/master"", ""test/master""",2,1,3
"11, exp.line_adds",2,1,3
"strlen(workdir_data), out.size",2,1,3
"5, expect.hunks",2,1,3
"git_buf_rfind_next(&a, '/') == len - 4",2,1,3
"strcmp(actual, target) == 0",2,1,3
"hex, ""80e61eb315239ef3c53033e37fee43b744d57122""",2,1,3
"GIT_DIRECTION_FETCH, ""refs/heads/maste :refs/remotes/frotz/xyzzy"", false",2,1,3
" file,line,""wrong workdir adds"", 1, ""%""PRIuZ, wt_adds, vals.wt_adds",2,1,3
"!git_oid_ncmp(&id, &id, 39)",2,1,3
"git_index_get_bypath(index, ""hello"", 0) == NULL",2,1,3
b->status != GIT_DELTA_UNMODIFIED,2,1,3
st.st_size == entry->file_size,2,1,3
"git_path_isdir(""d3"")",2,1,3
"""../../this/preserves/the/prefix"", p.ptr",2,1,3
"3, data.files",2,1,3
"0, git_oid_streq(git_commit_id(parent), expected_oid)",2,1,3
"""core.""",2,1,3
"hunk->final_start_line_number, start_line",2,1,3
"git_oid_strcmp(&idp, ""ae90f12eea699729ec"") > 0",2,1,3
spec,2,1,3
tag->message == NULL,2,1,3
"git_path_isfile(""testrepo/ignored_file"")",2,1,3
"GIT_EINVALIDSPEC, git_reference_name_to_id(&id, g_repo, ""refs/heads/Inv@{id"")",2,1,3
"git_path_isdir(path), path",2,1,3
"false, git_remote_is_valid_name(""a.lock"")",2,1,3
"GIT_FILEMODE_BLOB_EXECUTABLE, entry->mode",3,0,3
"!git_oid_ncmp(&id, &id, 40)",2,1,3
"GIT_DIRECTION_FETCH, ""refs/heads*/for-linus:refs/remotes/mine/*"", false",2,1,3
"85, sim, 95",2,1,3
"!git_path_exists(""merge-resolve/directory_file-two~theirs"")",2,1,3
"p_inet_pton(AF_INET, ""bar"", &addr) == 0",2,1,3
"""My rulers and their treasure and their unborn populations,\n"", actual.ptr",2,1,3
"1, git_status_list_entrycount(status)",2,1,3
"git_path_isfile(""t1/c/f3"")",2,1,3
"opts.origin_url, git_remote_url(remote)",2,1,3
"0, index->tree->children_count",3,0,3
"""value"", entry->value",3,0,3
"git_buf_rfind(&a, 'h') == 2",2,1,3
"entry = git_index_get_bypath(result, ""modified-in-both.txt"", 2)",2,1,3
"ttt ""\n"", ttt sss, 0",2,1,3
"&buf, ""b/c"", ""./b/c""",2,1,3
"repo, ""branch.moved.merge"", true",2,1,3
"""subdir.txt"", git_pathspec_match_list_entry(m, 5)",2,1,3
"git_tree_entry_filemode_raw(entry), 0100600",2,1,3
"NULL, git_pathspec_match_list_entry(m, 9)",2,1,3
"12, exp.line_dels",2,1,3
"git_path_isfile(""t2/f1"")",2,1,3
"&buf, ""a/"", ""a/""",2,1,3
"""subdir/deleted_file"", git_pathspec_match_list_entry(m, 5)",2,1,3
"""refs/stash^2:who"", ""cc628ccd10742baea8241c5924df992b5c019f71""",2,1,3
"expected_refname, buffer_out",2,1,3
"delta->old_file.size, git_blob_rawsize(d)",2,1,3
(git_index_caps(index) & GIT_INDEXCAP_NO_FILEMODE) != 0,2,1,3
"""stash@{0}^0:how"", ""ac790413e2d7a26c3767e78c57bb28716686eebc""",2,1,3
"!git_oid_ncmp(&id, &id, 41)",2,1,3
"merge_test_index(repo_index, merge_index_entries, 20)",2,1,3
"strlen(str_in_error) > strlen(""GetProcessId failed: "")",2,1,3
((git_refcount *)new_odb)->refcount.val == 2,2,1,3
"entry = git_index_get_bypath(repo_index, ""modified-to-same.txt"", 0)",2,1,3
"1, expected->line_dels",2,1,3
*count < EXPECTATIONS_COUNT,2,1,3
"ttt ""\n\n"" ttt ttt ""\n"", ttt ""\n\t\n \n\n \t\t\n"" ttt ttt ""\n"", 0",2,1,3
x.length == 3,2,1,3
"false, git_path_isdir(""./testrepo/de/"")",2,1,3
i == 20,2,1,3
"""c/foo"", e->path",2,1,3
"GIT_IDXENTRY_UPTODATE, (entry->flags_extended & GIT_IDXENTRY_UPTODATE)",3,0,3
"p_lstat_posixly(""root/file/invalid"", &st) < 0",2,1,3
"!git_path_exists(""testrepo/READ"")",2,1,3
"""stash^3^{tree}"", EMPTY_TREE, GIT_OBJ_TREE",2,1,3
entry->file_size == strlen(AUTOMERGEABLE_MERGED_FILE_CRLF),2,1,3
"""refs/stash"", ""WIP on (no branch): """,2,1,3
"""d:/"", p.ptr",2,1,3
"""refs/tags/test"", GIT_OBJ_COMMIT, ""e90810b8df3e80c413d903f631643c716887138d"", GIT_OBJ_COMMIT",2,1,3
"GIT_DIRECTION_FETCH, ""HEAD:"", true",2,1,3
"""stash@{0}^3:when"", ""b6ed15e81e2593d7bb6265eb4a991d29dc3e628b""",2,1,3
"index, ""text.txt"", ""22c74203bace3c2e950278c7ab08da0fca9f4e9b""",2,1,3
"entry = git_index_get_bypath(index, ""a/b.txt"", 0)",3,0,3
GIT_REPOSITORY_STATE_APPLY_MAILBOX,2,1,3
nobj == 1000,2,1,3
"expected[d] && !strcmp(expected[d], ""<END>""), file, line",2,1,3
"14, expected.line_adds",2,1,3
"""Mixed\nup\nLF\nand\nCRLF\nline-endings.\n"", out.ptr",3,0,3
level == 0 || callback != NULL,2,1,3
"""refs/stash:how"", ""e6d64adb2c7f3eb8feb493b556cc8070dca379a3""",2,1,3
"""refs/tags/test"", true",2,1,3
"0, expected->files_binary",2,1,3
"""Something "", str2",2,1,3
"git_path_root(""//computername"") == -1",2,1,3
"delta->status, GIT_DELTA_RENAMED",2,1,3
"!git_pathspec_matches_path(ps, 0, ""three.txt"")",2,1,3
"31, git_patch_size(patch, 1, 0, 0)",2,1,3
"""+refs/*:refs/*"", array.strings[0]",2,1,3
"&buf, ""/a/b/c"", ""///a/b/c""",2,1,3
"""path/../funky""",3,0,3
"""FOO~1"", (shortname = git_win32_path_8dot3_name("".foo""))",2,1,3
git_index_path(index),2,1,3
"git_path_isfile(""testrepo/untracked_file"")",2,1,3
"""refs/stash^3"", NULL",2,1,3
((git_refcount *)odb)->refcount.val == 2,2,1,3
" ALL_LF_TEXT_RAW ""\n$Id: initial content$\n"", 0, ""crlf/lf.ident""",2,1,3
"p_lstat(""root/file/invalid"", &st) < 0",2,1,3
"true, git_reference_is_valid_name(""refs/stash"")",2,1,3
"git_path_exists(""testrepo/new.txt"")",2,1,3
"1, expected->hunks",2,1,3
"GIT_EINVALIDSPEC, git_tag_delete(g_repo, ""Inv@{id"")",2,1,3
"""refs/remotes/test/master"", git_buf_cstr(&upstream_name)",2,1,3
"2, (int)git_index_entrycount(index)",2,1,3
"WORKDIR ""/test.txt"", ""test.txt"", &git_blob_create_fromworkdir",2,1,3
cache_quick(&data[th]) == &data[th],2,1,3
"!git_index_find(&pos, index, filename), file, line, ""Cannot find index entry"", NULL, 1",2,1,3
LOBYTE(wsd.wVersion) == 2 && HIBYTE(wsd.wVersion) == 2,2,1,3
"""refs/tags/test"", GIT_OBJ_TAG, ""b25fa35b38051e4ae45d4222e795f9df2e43f1d1"", GIT_OBJ_TAG",2,1,3
"tree, ""ab/de/fgh/1.txt"", ""1.txt""",2,1,3
"""refs/*:refs/*"", ""refs/heads/master"", ""refs/heads/master""",2,1,3
"(entry = git_index_get_bypath(result, ""new-and-different.txt"", 0)) == NULL",2,1,3
"""sm_missing_commits"", git_submodule_name(sm)",2,1,3
"reuc = git_index_reuc_get_bypath(repo_index, ""two.txt"")",2,1,3
"GIT_ENOTFOUND, git_tree_entry_bypath(&e, tree, ""i-do-not-exist.txt"")",2,1,3
"!git__suffixcmp(git_repository_path(_repo), ""/extended/.git/"")",2,1,3
"git_index_conflict_next(&conflict_entry[0], &conflict_entry[1], &conflict_entry[2], iterator) == GIT_ITEROVER",2,1,3
wd,2,1,3
"3, (int)git_index_entrycount(index)",2,1,3
"GIT_DIRECTION_PUSH, ""refs/heads/master:refs/remotes/frotz/xyzzy"", true",2,1,3
"note, ""hello world on a custom namespace\n"", &note_oid",2,1,3
"""core.dummy2"", entry->name",2,1,3
"4, exp.file_status[GIT_DELTA_ADDED]",2,1,3
"(delta = git_diff_get_delta(diff, 0)) != NULL",2,1,3
!git_path_exists(git_buf_cstr(&merge_mode_path)),2,1,3
"""bcd"", item->path",2,1,3
"git_pathspec_match_list_diff_entry(matches,0) == NULL",2,1,3
"""GIT~1"", reserved[1].ptr",3,0,3
"git__prefixcmp(git_buf_cstr(&content), ""gitdir: "") == 0",2,1,3
"200, item->value",2,1,3
"git_sortedcache_lookup(sc, ""qqq"") == NULL",2,1,3
"""d:/from/here/and/back/"", p.ptr",2,1,3
hidden,3,0,3
"git_repository_path(repo), git_repository_path(repo2)",2,1,3
"2, git_index_entrycount(read_index)",2,1,3
"expected_mode, st.st_mode, ""%07o""",2,1,3
"36, expect.line_adds",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge branches '"" OCTO1_BRANCH ""' and '"" OCTO3_BRANCH ""' of http://remote.first/repo.git, branches '"" OCTO2_BRANCH ""' and '"" OCTO4_BRANCH ""' of http://remote.second/repo.git\n"")",2,1,3
" email, ""9264b96c6d104d0e07ae33d3007b6a48246c6f92"", &opts",3,0,3
"repo, ""modified"", GIT_STATUS_WT_MODIFIED",2,1,3
"GIT_EUNMERGED, git_index_write_tree(&tid, index)",2,1,3
"GIT_EINVALIDSPEC, git_tag_create_lightweight(&tag_id, g_repo, ""Inv@{id"", target, 0) ",2,1,3
"git_oid_cmp(git_reference_target(ref_tag), &old_tag_id) != 0",2,1,3
"git_oid_ncmp(&id, &idp, 40)",2,1,3
"insert_sequential_oids(&oids, os, MAX_OIDS, MAX_OIDS - 1) < 0",2,1,3
"giterr_last()->klass, GITERR_FILTER",2,1,3
"ttt ""\n"", sss ""\n"" sss ""\n"" sss ""\n"" ttt ""\n"", 0",2,1,3
"file, line, ""mismatched file length"", 1, ""%""PRIuZ, (size_t)expected_bytes, (size_t)total_bytes",2,1,3
"0, buf.size",3,0,3
"ttt ""\n"" ttt ""\n\n"" ttt ttt ""\n"" ttt ""\n"", ttt ""\n"" ttt ""\n\n"" ttt ttt ""\n"" ttt ""\n"", 0",2,1,3
(fattrs & FILE_ATTRIBUTE_HIDDEN) != 0,2,1,3
"""\\this is a \\tes\\t"", a.ptr",2,1,3
"ttt ""\n\n"" ttt ttt ""\n"", ttt ""\n\n\n\n\n"" ttt ttt ""\n"", 0",2,1,3
"note, ""hello world\n"", &note_oid",2,1,3
(status & GIT_SUBMODULE_STATUS_INDEX_DELETED) != 0,2,1,3
"true, git_reference_is_valid_name(""refs/master{yesterday}"")",2,1,3
" GIT_ENOTFOUND, git_sortedcache_lookup_index(&pos, sc, ""missing"")",2,1,3
" ""This is a test\n$Id$\nHave fun!\n"", buf.ptr",2,1,3
"ttt ""\n"", ""\n\n\n"" ttt ""\n"", 0",2,1,3
"7, exp.file_status[GIT_DELTA_ADDED]",2,1,3
"git_index_get_bypath(index, ""a/2.txt"", 0) == NULL",2,1,3
"-1, git_oid_strcmp(&id, ""I'm not an oid.... :)"")",2,1,3
"!git_oid_ncmp(&id, &id, 0)",2,1,3
" GIT_EBAREREPO, git_diff_index_to_workdir(&diff, g_repo, NULL, &opts)",2,1,3
"!git_path_isfile(""testrepo/ignored_file"")",2,1,3
GIT_REPOSITORY_STATE_REVERT,2,1,3
read != -1,2,1,3
"""# comment\n"" ttt ""\n"", ""# comment\n"" ttt ""\n"", 0",2,1,3
"""refs/heads/br2"", git_reference_name(branch)",2,1,3
"""And the horses and the chariots fleeing from them as of old!\n"", actual.ptr",2,1,3
"sizes[1], git_patch_size(patch, 1, 0, 0)",2,1,3
"""Some text\r\nRight here\r\n"", out.ptr",2,1,3
!git_repository_is_bare(barerepo),2,1,3
"reuc = git_index_reuc_get_bypath(repo_index, ""removed-in-both.txt"")",2,1,3
"4, retrieved_notes",2,1,3
"e->statuses[e->files], (int)delta->status",2,1,3
"ttt ""\n"", sss sss sss ""\n\n\n"" ttt ""\n"", 0",2,1,3
"20, val",2,1,3
"3, ca.count",2,1,3
"""..""",2,1,3
"""dif.dir\nstat.lines""",2,1,3
"git_config_delete_entry(cfg, ""core.imaginary"") == GIT_ENOTFOUND",2,1,3
"expected2, buf.ptr",2,1,3
out && ref && id,2,1,3
"git_pathspec_matches_path(ps, GIT_PATHSPEC_NO_GLOB, ""*four"")",2,1,3
"git_oid_strcmp(&idp, ""deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"") < 0",2,1,3
"merge_test_index(index, merge_index_entries, 32)",2,1,3
"GIT_EEXISTS, git_filter_register(""bitflip"", &fake, 0)",2,1,3
"false, git_path_isfile(git_buf_cstr(&subtrees_log_path))",2,1,3
"&buf, """", ""a/../""",2,1,3
out && ref && target,2,1,3
"strcmp(git_submodule_url(sm1), str) != 0",2,1,3
"git_path_isdir(""src"")",2,1,3
"!git_path_exists(""merge-resolve/conflicting-4.txt"")",2,1,3
"git__strcasesort_cmp(""FOO"", ""foo"") < 0",2,1,3
"GIT_DELTA_MODIFIED, (int)git_pathspec_match_list_diff_entry(matches,0)->status",2,1,3
"7 + 14, expect.line_dels",2,1,3
"state, git_repository_state(_repo)",2,1,3
"&buf, ""/"", ""/a/.././""",2,1,3
repo && refname,3,0,3
"6, (int)git_index_entrycount(index)",2,1,3
"(delta = git_diff_get_delta(diff, 2)) != NULL",2,1,3
git_submodule_head_id(sm) == NULL,2,1,3
"git__strcasesort_cmp(""BAR"", ""foo"") < 0",2,1,3
"!git_path_exists(TEST_REPO_PATH ""/conflicting.txt"")",2,1,3
"""https://"", p.ptr",2,1,3
"7, exp.hunks",3,0,3
"&buf, ""a/b/"", ""a/b/.""",2,1,3
"GIT_ENOTFOUND, git_repository_head_tree(&tree, repo)",2,1,3
calls > 0,2,1,3
"""th__is__ __is__ a__ test"", a.ptr",2,1,3
"git_tree_entry_byname(tree, ""apple"") == NULL",2,1,3
"raw_len, (size_t)git_blob_rawsize(blob)",2,1,3
"!git_path_isdir(""alternate"")",2,1,3
expected->idx < expected->len,2,1,3
"GIT_DIRECTION_FETCH, ""master"", true",2,1,3
"""bbb"", item->path",2,1,3
"""7b4384978d2493e851f9cca7858815fac9b10980"", GIT_OBJ_TREE, ""53fc32d17276939fc79ed05badaef2db09990016"", GIT_OBJ_TREE",2,1,3
"""refs/tags/point_to_blob"", GIT_OBJ_ANY, ""1385f264afb75a56a5bec74243be9b367ba4ca08"", GIT_OBJ_BLOB",2,1,3
"true, git_repository_head_unborn(g_repo)",2,1,3
"revision, expected_oid, GIT_OBJ_BLOB",2,1,3
""""", sss ""\n"", 0",2,1,3
"repo, ""branch.moved.remote"", false",2,1,3
"&buf, ""/a"", ""/a""",2,1,3
"expected_diffed_files_count, exp.files",2,1,3
" GIT_MODE_TYPE(st.st_mode), GIT_MODE_TYPE(entry->mode), ""%07o""",2,1,3
"true, git_path_isfile(""./testrepo/de/2.txt"")",2,1,3
"""refs/stash:what"", ""bc99dc98b3eba0e9157e94769cd4d49cb49de449""",2,1,3
"git__strcasesort_cmp(""foo"", ""FOO"") > 0",2,1,3
"sizes[2], git_patch_size(patch, 1, 1, 0)",2,1,3
"git__suffixcmp(git_repository_path(repo2), ""empty_standard_repo/.git/"") == 0, git_repository_path(repo2)",2,1,3
git_commit_parentcount(commit) == 0,2,1,3
"""HEAD"", GIT_OBJ_COMMIT, ""a65fedf39aefe402d3bb6e24df4d4f5fe4547750"", GIT_OBJ_COMMIT",2,1,3
"ttt ""\n"", ttt ""\n\n"", 0",2,1,3
"!git_pathspec_matches_path(ps, GIT_PATHSPEC_NO_GLOB, ""anyfour"")",2,1,3
"expected_name, sign->name",2,1,3
!git_path_exists(path),2,1,3
"GIT_ENOTFOUND, git_tree_entry_bypath(&e, tree, ""ab/me-neither/fgh/2.txt"")",2,1,3
"14, expected.hunk_new_lines",2,1,3
"""*test*"", 4",2,1,3
fl != NULL,2,1,3
git_repository_is_bare(repo),2,1,3
st.st_size != entry->file_size,2,1,3
"entry = git_index_get_bypath(result, ""new-in-branch.txt"", 0)",2,1,3
"""stash@{0}^2:what"", ""ce013625030ba8dba906f756967f9e9ca394464a""",2,1,3
"!git_path_exists(""typechanges/e"")",2,1,3
"""conflicting-4.txt"", git_vector_get(&paths, 3)",2,1,3
"&buf, ""/"", ""///.""",2,1,3
"GIT_DIRECTION_FETCH, ""refs/heads/ nitfol"", false",2,1,3
"branch_type, GIT_BRANCH_REMOTE",2,1,3
status != GIT_DELTA_MODIFIED,2,1,3
"GIT_DIRECTION_FETCH, ""::"", false",2,1,3
"GIT_ATTR_UNSPECIFIED(value), name",2,1,3
"GIT_DIRECTION_PUSH, ""refs/heads:refs/remotes/frotz/*"", false",2,1,3
git_index_name_entrycount(repo_index) > 0,2,1,3
git_index_entrycount(repo_index) == 6,2,1,3
"git_index_get_bypath(index, ""a/1.txt"", 0) != NULL",2,1,3
"git_path_root(""C:/rooted/path"") == 2",2,1,3
"tree, ""ab/de/fgh"", ""fgh""",2,1,3
"""https://my.url.com/another.git"", p.ptr",2,1,3
"!git_path_exists(""merge-resolve/test-one.txt"")",2,1,3
"5, hunk_count",2,1,3
GIT_ATTR_TRUE(values[5]),2,1,3
"""core.filemode"", cl_is_chmod_supported()",2,1,3
"0, retrieved_notes",2,1,3
"p_lstat(""root/d1/missing"", &st) < 0",2,1,3
" 0, memcmp(workdir_data, out.ptr, out.size)",2,1,3
"git__prefixcmp(giterr_last()->message, ""Invalid description"") == 0",2,1,3
"""stash@{1}^0:how"", ""e6d64adb2c7f3eb8feb493b556cc8070dca379a3""",2,1,3
"git__suffixcmp(git_repository_path(repo), ""attr/.git/"") == 0",2,1,3
"ttt ""\n"" ttt ""\n"" ttt ""\n"" ttt ttt ""\n"", ttt ""\n"" ttt ""\n"" ttt ""\n"" ttt ttt ""\n"", 0",2,1,3
"!git_oid_ncmp(&id, &idp, 0)",2,1,3
"false, git_reference_is_valid_name(""refs/heads/sub.lock/webmatrix"")",2,1,3
"repo_path, ""description"", GIT_FILEMODE_BLOB, false, filemode",2,1,3
"2, data.dirs",2,1,3
"git_buf_rfind_next(&a, 'q') == -1",2,1,3
"boundary, hunk->boundary",2,1,3
"2, exp.file_status[GIT_DELTA_COPIED]",2,1,3
"!git_path_exists(""merge-resolve/test-one-side-one.txt"")",2,1,3
"5, expect.files",2,1,3
"ad->old_file.mode, bd->old_file.mode",2,1,3
"ttt ""\n\n"" ttt ""\n"", ttt ""\n\n\n\n\n"" ttt ""\n"", 0",2,1,3
"1, expect.file_status[GIT_DELTA_TYPECHANGE]",2,1,3
"!git_path_isfile(""alternate/1/gitconfig"")",2,1,3
"GIT_DIRECTION_PUSH, ""refs/heads*/for-linus:refs/remotes/mine/*"", false",2,1,3
"expected_path.ptr, path.ptr",3,0,3
git_trace_level() == GIT_TRACE_NONE,2,1,3
"GIT_ENOTFOUND, git_index_conflict_get(&conflict_entry[0], &conflict_entry[1], &conflict_entry[2], _index, ""conflicts-one.txt"")",2,1,3
((git_refcount *)odb)->refcount.val == 1,2,1,3
"0, binary_count",2,1,3
"error, GIT_EINVALIDSPEC",2,1,3
"&buf, ""../d"", ""a/b/../../../c/../d""",2,1,3
"GIT_ENOTFOUND, git_reference_lookup(&ref, g_repo_cloned, expected_tracked_branch_name)",2,1,3
"0, sim, 30",2,1,3
spec && base && *base,2,1,3
"error, git_reference_peel(&peeled, ref, requested_type)",2,1,3
"6, (int)hunk->old_start",2,1,3
file >= 0,2,1,3
"git_path_is_empty_dir(""empty_dir"")",2,1,3
"&buf, ""../../path"", ""../../test//../././path""",2,1,3
"new_ref->name, brand_new_name",2,1,3
"git__prefixcmp(str_in_error, ""GetProcessId failed: "") == 0",2,1,3
"""libgit2 rocks\nlibgit2 rocks\n"", 0, test",2,1,3
"false, git_reference_is_valid_name("""")",2,1,3
"55, expect.lines",2,1,3
"git_pathspec_matches_path(ps, 0, ""anything.four"")",2,1,3
"false, git_odb_exists(odb, &_oid)",2,1,3
"&buf, ""//a/"", ""//a/b/..""",2,1,3
"""subdir/deleted_file"", git_pathspec_match_list_entry(m, 7)",2,1,3
"""refs/pull/*/head:refs/remotes/origin/pr/*"", ""refs/pull/23/head"", ""refs/remotes/origin/pr/23""",2,1,3
"""some#thing"", str3",2,1,3
"git_tree_entry_byname(tree, ""NOTEXISTS"") == NULL",2,1,3
"pass, ""pass/is@bad""",2,1,3
"git_path_isdir(""an_dir"")",2,1,3
"(b = resolve_commit_oid_to_tree(g_repo, ""7f483a7"")) != NULL",2,1,3
"3, (int)git_pathspec_match_list_entrycount(matches)",2,1,3
git_path_isfile(git_buf_cstr(&file)),2,1,3
"0, git_oid_streq(stash_oid, data->oids[data->invokes++])",2,1,3
"i, internal->position",2,1,3
"git_oid_strcmp(&id, ""deadbeef"") < 0",2,1,3
"!git_pathspec_matches_path(ps, 0, ""nomatch"")",2,1,3
expected->is_merge == is_merge,2,1,3
line && line->content,2,1,3
GIT_REPOSITORY_STATE_MERGE,2,1,3
"!git_index_find(&index_pos, index, filename)",2,1,3
"stats.local_objects, 0",2,1,3
"""iii"", item",2,1,3
"git_path_isfile(""t2/c/d/f4"")",2,1,3
"file, line, ""Expected mode does not match index"", 1, ""%07o"", (unsigned int)entry->mode, (unsigned int)expect_mode",2,1,3
"ttt ""\n\n"" ttt ""\n"", ttt ""\n\t\n \n\n \t\t\n"" ttt ""\n"", 0",2,1,3
"tree, ""ab/"", ""ab""",2,1,3
"&buf, """", ""a/..""",2,1,3
"(len = p_readlink(git_buf_cstr(&fullpath), actual, 1024)) > 0",2,1,3
"p_inet_pton(AF_INET, "" 127.0.0.1"", &addr) == 0",2,1,3
out && oid,2,1,3
opts.metric != NULL,2,1,3
"git_oid_cmp(&rid, &id2) == 0",2,1,3
git_path_exists(d->dir),2,1,3
""".""",2,1,3
"g_repo, ""sm_just_added""",3,0,3
"git_tree_entry_byindex(tree, 2) != NULL",2,1,3
"GIT_DIRECTION_FETCH, ""refs/heads/*/for-linus:refs/remotes/mine/*-blah"", false",2,1,3
"true, git_reference_is_valid_name(""refs/master}yesterday"")",2,1,3
"false, GIT_STATUS_WT_DELETED, GIT_STATUS_WT_NEW",2,1,3
"GIT_ATTR_FALSE(value), name",2,1,3
"""HEAD""",2,1,3
"ttt ""\n"", ""\n"" ttt ""\n"", 0",2,1,3
stats,3,0,3
"0, p_lstat(""root/file"", &st)",2,1,3
position_c < position_cake,2,1,3
"repo, ""refs/notes/fanout"", ""notes/fanout""",2,1,3
"GIT_ERROR, error",2,1,3
""" -- Rudyard Kipling\n"", actual.ptr",2,1,3
"0, p_lstat(""root/d1"", &st)",2,1,3
"strequal_ignore_eol(after[i], content.ptr)",2,1,3
in && out,2,1,3
entry->file_size == strlen(ALL_LF_TEXT_RAW),2,1,3
"false, git_reference_is_valid_name(""/"")",2,1,3
"&buf, "".."", ""./..""",2,1,3
" repo, git_tree_entry_id(te), path.ptr, true",2,1,3
GIT_ATTR_TRUE(vals[1]),2,1,3
"merge_test_workdir(repo, merge_index_entries, 20)",2,1,3
"GIT_DIRECTION_FETCH, ""refs/heads/ nitfol:"", false",2,1,3
"(a = resolve_commit_oid_to_tree(g_repo, ""8a7ef04"")) != NULL",2,1,3
(size_t)((unsigned int)cnt) == cnt,2,1,3
"false, git_reference_is_valid_name(""lower_case"")",2,1,3
"git_path_exists(""typechanges/d"")",2,1,3
"ttt ""\n"" ttt ""\n"", ttt ""\n"" ""# comment\n"" ttt ""\n"", 1",2,1,3
"""stash@{0}^0:who"", ""cc628ccd10742baea8241c5924df992b5c019f71""",2,1,3
path && content,2,1,3
"1, called",3,0,3
"git_path_root(""//computername/sharefolder/resource"") == 14",2,1,3
"""staged_new_file_deleted_file"", git_pathspec_match_list_entry(m, 4)",2,1,3
remote && refspecs,2,1,3
"6, last_i",2,1,3
"""refs/stash@{1}"", NULL, GIT_OBJ_COMMIT",2,1,3
lov < hiv,2,1,3
"6, line->new_lineno",2,1,3
branch_list.count == expected_count,1,2,3
"28, line->new_lineno",2,1,3
"!git_pool__ptr_in_pool(&p, &i)",2,1,3
"hunk->orig_path, orig_path",2,1,3
"error,expr",2,1,3
"1, (int)git_tree_entrycount(tree)",2,1,3
"""HEAD"", GIT_OBJ_TREE, ""944c0f6e4dfa41595e6eb3ceecdb14f50fe18162"", GIT_OBJ_TREE",2,1,3
"ttt ""\n\n"" ttt ttt ttt ""\n"", ttt ""\n\n\n\n\n"" ttt ttt ttt ""\n"", 0",2,1,3
"-1, git_oid_strcmp(&idp, ""I'm not an oid.... :)"")",2,1,3
writepack,3,0,3
"ttt ""\n"", ""\n\n"" sss sss sss ""\n"" ttt ""\n"", 0",2,1,3
"h->orig_path, ""b""",2,1,3
"""modified_file"", git_pathspec_match_list_diff_entry(matches,0)->new_file.path",2,1,3
out && repo && revspec,2,1,3
"GIT_EUNBORNBRANCH, git_repository_head_tree(&tree, repo)",2,1,3
ref_name == NULL,2,1,3
"""staged_changes_modified_file"", git_pathspec_match_list_entry(m, 3)",2,1,3
"lines, expected->lines",2,1,3
"3, data.dirs",2,1,3
tag->tagger == NULL,2,1,3
name && filter,2,1,3
"git_oid_strcmp(&idp, ""ae90f12eea699729ed1"") < 0",2,1,3
"git__prefixcmp(giterr_last()->message, ""Invalid for-merge"") == 0",2,1,3
out && tree,2,1,3
"""42"", entry->value",2,1,3
"!git_path_isfile(""alternate/2/config"")",2,1,3
"49, line->old_lineno",2,1,3
"merge_test_index(repo_index, merge_index_entries, 9)",2,1,3
"strcmp(git_reference_symbolic_target(head), ref_test_name) == 0",2,1,3
"entry = git_index_get_bypath(repo_index, ""new-and-different.txt"", 2)",2,1,3
"""subdir/current_file"", git_pathspec_match_list_diff_entry(matches,0)->new_file.path",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge commit '"" OCTO1_OID ""'; branches '"" OCTO2_BRANCH ""', '"" OCTO4_BRANCH ""' and '"" OCTO5_BRANCH ""'; commit '"" OCTO3_OID ""'\n"")",2,1,3
""""", sss sss sss, 0",2,1,3
" file,line,""wrong index adds"", 1, ""%""PRIuZ, index_adds, vals.index_adds",2,1,3
"p_lstat(""root/missing"", &st) < 0",2,1,3
"4, (int)git_index_entrycount(index)",2,1,3
utf8_len > 0,2,1,3
"""core.logallrefupdates"", true, false",2,1,3
"0, git_sortedcache_lockandload(sc, NULL)",2,1,3
"""be3563a^1..be3563a""",2,1,3
2 == git_tree_entrycount(tree),2,1,3
git_path_exists(TEST_CONFIG),2,1,3
"strcmp(git_buf_cstr(&data_buf), contents) == 0",2,1,3
"false, ""NewFolder/NewFolder/File.txt""",2,1,3
true,2,1,3
"statbuf.st_mode & os_mask, (expected_dir_mode & ~mask) & os_mask",2,1,3
"GIT_DIRECTION_FETCH, ""refs/heads:refs/remotes/frotz/*"", false",2,1,3
"entry = git_index_get_bypath(repo_index, ""modified-in-both.txt"", 3)",2,1,3
"p_lstat_posixly(""root/d1/file/further/invalid/items"", &st) < 0",2,1,3
"&id, git_reference_target(resolved_ref)",3,0,3
"!strcmp(expected[d], ""<END>""), file, line",2,1,3
"(entry = git_index_get_bypath(index, ""C"", 0))",3,0,3
((entry->mode & 0100) ? 1 : 0) == expected[i],2,1,3
git_reference_type(looked_up_ref) & GIT_REF_SYMBOLIC,2,1,3
"repo, ""refs/heads/master"", ""master""",2,1,3
"GIT_DIRECTION_PUSH, ""HEAD~4:refs/remotes/frotz/new"", true",2,1,3
" file,line,""wrong index dels"", 1, ""%""PRIuZ, index_dels, vals.index_dels",2,1,3
"true, git_index_has_conflicts(repo_index)",2,1,3
"(entry = git_index_get_bypath(index, ""A"", 0))",3,0,3
"git_reference_name(g_ref), ""refs/heads/test""",2,1,3
"value, ""10""",2,1,3
"expected_lower_cased_file_status, status",2,1,3
"GIT_DELTA_ADDED, (int)git_pathspec_match_list_diff_entry(matches,0)->status",2,1,3
"""subdir.txt"", delta->new_file.path",2,1,3
"ad->new_file.mode, bd->new_file.mode",2,1,3
"GIT_DIRECTION_PUSH, """", false",2,1,3
"!git_path_isdir(""t1"")",2,1,3
"2, git_sortedcache_entrycount(sc)",2,1,3
" 0, memcmp(bitflipped_and_reversed_data, out.ptr, out.size)",2,1,3
"git_oid_cmp(&id_hiearar, &id3) == 0",2,1,3
"false, git_repository_is_empty(repo)",2,1,3
"""refs/heads/*"", 12",2,1,3
"git_path_isfile(""./testrepo/path0"")",2,1,3
repo && old_iter && new_iter,2,1,3
"index, ""binary.data"", ""66eeff1fcbacf589e6d70aa70edd3fce5be2b37c""",2,1,3
"""testrepo/BRANCH_FILE.txt""",3,0,3
"24 + 1 + 5 + 5, expect.line_adds",2,1,3
"GIT_DIRECTION_FETCH, ""HEAD~4:refs/remotes/frotz/new"", false",2,1,3
"git_oid_streq(git_submodule_wd_id(sm), ""3d9386c507f6b093471a3e324085657a3c2b4247"") == 0",2,1,3
payload,2,1,3
"&buf, ""//a/b/c"", ""//a/b/c""",2,1,3
"entry = git_index_get_bypath(repo_index, ""modified-in-both.txt"", 1)",2,1,3
"""refs/heads/master"", git_reference_name(upstream)",2,1,3
"GIT_CONFIG_LEVEL_SYSTEM, entry->level",2,1,3
"repo, ""branch.moved.merge"", false",2,1,3
"git_oid_strcmp(&idp, ""deadbeef"") < 0",2,1,3
err != SSL_ERROR_WANT_READ,2,1,3
_backend && name,3,0,3
"&buf, ""../../"", ""../../""",2,1,3
"-1, giterr_state_capture(&err_state, -1)",3,0,3
"""stash@{1}^2:who"", ""cc628ccd10742baea8241c5924df992b5c019f71""",2,1,3
"&ad->old_file.id, &bd->old_file.id",2,1,3
"g_peel_repo, ""refs/tags/tag-inside-tags"", GIT_OBJ_ANY, ""0df1a5865c8abfc09f1f2182e6a31be550e99f07"", GIT_OBJ_COMMIT",2,1,3
"message, git_reflog_entry_message(entry)",3,0,3
"ttt ""\n"", ttt ""\n\n"" sss ""\n"" sss sss ""\n"", 0",2,1,3
"root_commit_message, git_commit_message(commit)",2,1,3
"!git_path_exists(""stash/two.txt"")",2,1,3
"60, signature->when.offset",2,1,3
"expected_refname, git_reference_name(ref)",2,1,3
"&buf, ""/"", ""/""",2,1,3
" GIT_SUBMODULE_UPDATE_REBASE, git_submodule_update_strategy(sm1)",1,2,3
"0, git_repository_head_unborn(g_repo)",2,1,3
" file,line,""wrong ignores"", 1, ""%""PRIuZ, ignores, vals.ignores",2,1,3
writer.complete,3,0,3
"0, p_lstat(""root/d1/"", &st)",2,1,3
"GIT_DIRECTION_PUSH, ""refs/heads/ nitfol:"", false",2,1,3
!git_buf_oom(&path),2,1,3
"1, (int)git_patch_num_hunks(patch)",2,1,3
"""stash@{1}^2:how"", ""e6d64adb2c7f3eb8feb493b556cc8070dca379a3""",2,1,3
GetProcessId(NULL) == 0,2,1,3
"""nulltoken"", ""emeric.fermas@gmail.com"", "" \t nulltoken \n"", "" \n emeric.fermas@gmail.com \n""",2,1,3
"""core.precomposeunicode"", found_with_nfd",2,1,3
"GIT_DIRECTION_FETCH, ""master~1:refs/remotes/frotz/backup"", false",2,1,3
"!git_oid_ncmp(&id, &idp, 18)",2,1,3
"4, entrycount",3,0,3
"""d#ff.dirstat.lines""",2,1,3
" expected, line->new_lineno - last_new_lineno",2,1,3
entry->mtime.nanoseconds != 0,2,1,3
""""", sss sss ""\n"" sss ""\n\n"", 0",2,1,3
"expected->remote_url, url",2,1,3
"test_file_contents(GIT_MERGE_MSG_FILE, ""Merge branch '"" OCTO1_BRANCH ""' of http://remote.first/repo.git, branch '"" OCTO2_BRANCH ""' of http://remote.second/repo.git, branch '"" OCTO3_BRANCH ""' of http://remote.third/repo.git\n"")",2,1,3
"git_reference_symbolic_target(ref), ref_branch_name",2,1,3
"GIT_ENOTFOUND, git_reference_name_to_id(&id, g_repo, ""refs/tags/test/farther/master"")",2,1,3
index->on_disk == 0,2,1,3
"8 + 15, expect.lines",2,1,3
"""current_file"", git_pathspec_match_list_diff_entry(matches,0)->new_file.path",2,1,3
"entry = git_index_get_bypath(repo_index, ""modified-in-both.txt"", 2)",2,1,3
"exp.files, exp.file_status[GIT_DELTA_UNTRACKED]",2,1,3
tree && git_tree_owner(tree) == repo,3,0,3
"17, exp.files",2,1,3
"3, expect.file_status[GIT_DELTA_MODIFIED]",2,1,3
"_refspec != git_vector_get(&_remote->refspecs, 1)",1,1,2
offset->path,1,1,2
actual->status == expected->status,1,1,2
"git_oid_streq(&idp, ""deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"") == -1",1,1,2
behind == 3,1,1,2
"0, git_diff_stats_deletions(_stats)",2,0,2
input,1,1,2
"!revparse_lookup_object(&obj, repo, git_buf_cstr(&specbuffer))",1,1,2
repo && heads,2,0,2
"!strcmp(another_looked_up_ref->name, new_name)",1,1,2
oitem && nitem && cmp == 0,1,1,2
"strlen(expected), git_buf_len(&buf)",2,0,2
""""", testfile",1,1,2
"diff, 5, true",2,0,2
"""create HEAD"", git_reflog_entry_message(entry)",1,1,2
"false, git_path_isvalid(NULL, ""git~1"", GIT_PATH_REJECT_DOS_GIT_SHORTNAME)",1,1,2
"strcmp(str, ""\""C:/Program Files/Nonsense/bah.exe\"" \""--some option\"""") == 0",1,1,2
"""d616d97082eb7bb2dc6f180a7cca940993b7a56f\n"", 41, ""rebase/.git/rebase-merge/orig-head""",2,0,2
"""gitdir: ../my_repository/"", dot_git_content.ptr",2,0,2
"""*"", GIT_REF_LISTALL, 16",1,1,2
"git_path_dirname_r(dir, sizeof(dir), A) >= 0",1,1,2
exp.line_adds == 1,1,1,2
"48, oldno",1,1,2
"strcmp(e->path, TEST_ENTRIES[i].path) == 0",1,1,2
repo && branch_name && target && oid_out,1,1,2
" GIT_SUBMODULE_UPDATE_REBASE, git_submodule_update(sm1)",1,1,2
"""*"", GIT_REF_LISTALL, 17",1,1,2
"oitem && nitem && entry_compare(oitem->path, nitem->path) == 0",1,1,2
"GIT_CERT_HOSTKEY_LIBSSH2, type",1,1,2
"true, git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL_NO_LINKS)",1,1,2
id && db && obj,1,1,2
"!git_oid_cmp(git_note_id(note), note_oid)",1,1,2
iter && towrap && comparer,1,1,2
"""e-"", ""HEAD^^"", repo, &opts, &fmt_opts, true",1,1,2
exp.file_dels == 5,1,1,2
db && pl,1,1,2
"7 + 1, exp.line_dels",1,1,2
out && remote && new_name,1,1,2
'\0' != *header++,1,1,2
"expected0, actual.ptr",2,0,2
ref->owner,1,1,2
!S_ISDIR(wd_entry->mode),1,1,2
_backend && reflog && new_oid && committer,1,1,2
ahead == 4,1,1,2
delta_is_split(to),1,1,2
"0, expected.files",1,1,2
fd,1,1,2
"git_oid_cmp(&target_id, &entry->oid_cur) == 0",1,1,2
git_index_entrycount(index) == (unsigned int)index_entry_count,1,1,2
"strcmp(sign->email, ""foo@bar.baz"") == 0",1,1,2
"GIT_ENOTFOUND, git_config_open_ondisk(&cfg, ""./no.config"")",1,1,2
" GIT_SUBMODULE_IGNORE_UNTRACKED, git_submodule_ignore(sm1)",1,1,2
" GIT_PERMS_EXECUTABLE(st.st_mode), GIT_PERMS_EXECUTABLE(entry->mode)",1,1,2
"""hello"", str",1,1,2
"GIT_DELTA_DELETED, git_pathspec_match_list_diff_entry(matches,0)->status",1,1,2
range == NULL,1,1,2
"ssh_supported, git_remote_supported_url(""git@github.com:libgit2/libgit2.git"")",1,1,2
"true, filemode",1,1,2
"GIT_ALLOC_OVERFLOW_MULTIPLY(SIZE_MAX, SIZE_MAX)",1,1,2
path != NULL && contents != NULL,1,1,2
" 96, git_atomic_get(&counts[3])",1,1,2
" cl_fixture(""template""), git_repository_path(_repo), ""hooks/update.sample"", true, 0",1,1,2
"git_index_entrycount(index), index->tree->entry_count",2,0,2
exp.files == 5,1,1,2
"GIT_DIR_PUSH, ""::"", false",1,1,2
"""more value"", entry->value",2,0,2
"st.st_mode & ~0777, entry->mode & ~0777",1,1,2
"(int)hunks, (int)git_diff_patch_num_hunks(patch)",1,1,2
"9, exp.file_untracked",1,1,2
root && treeentry_path,1,1,2
"GIT_EBAREREPO, git_diff_workdir_to_index(g_repo, &opts, &diff)",1,1,2
"(int)strlen(expected_tracked_branch_name) + 1, git_branch_tracking_name(buffer, 1024, g_repo_cloned, local_name)",1,1,2
exp.lines == 19,1,1,2
repo->is_bare == is_bare,1,1,2
expect[i + cb_count] != NULL,1,1,2
"false, git_path_isvalid(NULL, ""./foo"", GIT_PATH_REJECT_TRAVERSAL)",2,0,2
"git_config_get_int32(&i, cfg, ""core.dummy"") == GIT_NOTFOUND",1,1,2
"-1, cache->entries",1,1,2
git_path_isdir(git_buf_cstr(&subdir_path)) == true,1,1,2
"git_oid_equal(&id, &id2)",1,1,2
"!strcmp(looked_up_ref->name, new_name)",1,1,2
diff && iterator_ptr,1,1,2
"&oid, git_reference_target(ref)",2,0,2
"GIT_BRANCH_LOCAL, 6",1,1,2
" GIT_EBAREREPO, git_diff_workdir_to_index(&diff, g_repo, &opts)",1,1,2
id != NULL && th != NULL,1,1,2
"49, oldno",1,1,2
"(returned_entry = git_index_get_bypath(index, ""test.txt"", 0)) != NULL",2,0,2
"git_oid_streq(&idp, ""deadbeef"") == -1",1,1,2
buf && repo && canonical_branch_name,1,1,2
"repository, ""branch.test.remote"", false",2,0,2
" GIT_NOTFOUND, git_object_lookup(&object, g_repo, &oid, GIT_OBJ_ANY)",1,1,2
"wt_adds, vals.wt_adds",1,1,2
"GIT_ADD_SIZET_OVERFLOW(&out, SIZE_MAX, SIZE_MAX)",2,0,2
"""e90810b8df3e80c413d903f631643c716887138d"", ""7b4384978d2493e851f9cca7858815fac9b10980"", GIT_OBJ_ANY",1,1,2
"git_diff_num_deltas(a), git_diff_num_deltas(b)",1,1,2
"!strcmp(opt, ""--tags"")",1,1,2
"(val), (int)werr",1,1,2
submodule && subrepo,1,1,2
"git_oid_equal(&entry->oid, &dup1->oid)",1,1,2
"false, git_path_isvalid(NULL, ""foo/.GIT/bar"", GIT_PATH_REJECT_DOT_GIT)",1,1,2
"GIT_CERT_SSH_SHA1, key->type",1,1,2
old_entry,1,1,2
exp.lines == 11,1,1,2
"""c-"", ""HEAD^"", repo, &opts, true",1,1,2
"strcmp(sign->email, ""x@y.z"") == 0",1,1,2
"0, filter_for(""foo.bin"", ""crlf"")",2,0,2
exp.files == 13,1,1,2
"!strcmp(git_refspec_dst(_refspec), ""refs/remotes/addtest/*"")",1,1,2
"""f87d14a4a236582a0278a916340a793714256864\n"", 41, ""rebase/.git/rebase-merge/orig-head""",2,0,2
"""B-0-"", ""HEAD^^2^"", repo, &opts, true",1,1,2
repo_out && given_repo && opts,1,1,2
message,1,1,2
"false, ""dir1/dir2/dir3/file""",2,0,2
"val, git_clone__should_clone_local(path, opt)",1,1,2
num_changes < diff->deltas.length,1,1,2
"!strcmp(opt, ""--no-tags"")",1,1,2
"16, i",1,1,2
blob && filename,1,1,2
ref && new_name,1,1,2
"git_unc.ptr, git_remote_url(remote)",2,0,2
"ssh_supported, git_remote_supported_url(""ssh://git@github.com/libgit2/libgit2.git"")",1,1,2
"GIT_DIR_PUSH, ""+:"", true",1,1,2
name && buffer_out,1,1,2
"GIT_BRANCH_LOCAL | GIT_BRANCH_REMOTE, 10",1,1,2
exp.file_dels == test_expects[i].file_dels,1,1,2
"!git_buf_set(&specbuffer, spec, spec_cur - spec)",1,1,2
"(ids = git__calloc(num, sizeof(git_oid)))",1,1,2
" GIT_EINVALIDSPEC, git_remote_add(&remote, _repo, """", ""git://github.com/libgit2/libgit2"")",1,1,2
"icase, ignored",2,0,2
exp.lines == 17,1,1,2
exp.files == 3,1,1,2
"""Create 1"", git_reflog_entry_message(entry1)",1,1,2
"""c-7-"", ""HEAD"", repo, &opts, true",1,1,2
repo && repo->references.packfile,1,1,2
"!git_oid_cmp(git_object_id(commit), git_reference_target(cloned_head))",1,1,2
"git_repository_path(_repo), ""hooks"", filemode, GIT_REPOSITORY_INIT_SHARED_GROUP | S_IFDIR",1,1,2
"GIT_EINVALIDSPEC, git_remote_save(remote)",1,1,2
"(loose_object_dir_mode(TEMP_REPO_FOLDER, (git_object *)tree) & 0777) == GIT_OBJECT_DIR_MODE",1,1,2
"GIT_DIR_PUSH, ""refs/heads/*/for-linus:refs/remotes/mine/*-blah"", false",1,1,2
"expected_content, buf.ptr, file, line, msg, 1",1,1,2
"expected_nodriver, actual.ptr",1,1,2
expected.line_adds == 14,1,1,2
index == 6,1,1,2
refdb && name && oid,1,1,2
"git_oid_cmp(git_reference_target(read1), git_reference_target(write1)) == 0",1,1,2
input && repo && entry,1,1,2
"2, exp[3]",2,0,2
"""0266163a49e280c4f5ed1e08facd36a2bd716bcf"", ""0266163a49e280c4f5ed1e08facd36a2bd716bcf"", GIT_OBJ_BLOB",1,1,2
"st.st_mode & 0777, 0700, ""%07o""",1,1,2
!s->sent_request,1,1,2
pool && str && pool->item_size == sizeof(char),2,0,2
"GIT_EBAREREPO, git_reset(bare, target, GIT_RESET_MIXED, NULL, NULL, NULL)",1,1,2
"""1\n"", 2, ""rebase/.git/rebase-merge/msgnum""",2,0,2
"GIT_ENOTFOUND, git_revparse_single(&g_obj, g_repo, ""this doesn't exist"")",1,1,2
"""e"", ""HEAD^^^"", repo, &opts, &fmt_opts, false",1,1,2
"GIT_DIR_FETCH, ""refs/heads/*/for-linus:refs/remotes/mine/*-blah"", false",1,1,2
"strstr(giterr_last()->message, ""parentheses not balanced"") != NULL",1,1,2
"strcmp(expected->ref_name, name) == 0",1,1,2
git_diff_stats_deletions(stats) == 4,1,1,2
"result = merge_simple_branch(GIT_MERGE_FILE_FAVOR_THEIRS, 0)",1,1,2
"GIT_NOTFOUND, git_repository_discover(found_path, sizeof(found_path), SUB_REPOSITORY_FOLDER_SUB, 0, ceiling_dirs)",1,1,2
"cl_fixture(""attr/attr3""), file->ce->path",1,1,2
"expected_len, lengths[i]",1,1,2
git_lasterror() == NULL,1,1,2
"strcmp(sign->name, ""x"") == 0",1,1,2
index == 7,1,1,2
"git_blob_id(d), &delta->new_file.id",2,0,2
"false, git_path_isvalid(NULL, ""foo/.git"", GIT_PATH_REJECT_DOT_GIT)",1,1,2
"pass, ""my/bad:password""",1,1,2
"288, git_atomic_get(&counts[0])",1,1,2
remote && new_name,1,1,2
"GIT_DIR_FETCH, ""refs/heads/*:refs/remotes/frotz/*"", true",1,1,2
"after[i], content.ptr",1,1,2
id && repo && source_cb,1,1,2
"GetEnvironmentVariableW(wide_name, wide_value, value_len)",1,1,2
idx == GIT_NOTFOUND,1,1,2
"strcmp(REFNAME, git_reference_name(ref)) == 0",1,1,2
"i, git_cache_size(&g_repo->objects) - start",1,1,2
"492, git_pool__full_pages(&p)",1,1,2
"GIT_DIR_PUSH, ""refs/heads/*:refs/remotes/frotz"", false",1,1,2
"git_attr_cache__is_cached( g_repo, GIT_ATTR_FILE__FROM_FILE, "".git/info/attributes"")",2,0,2
repo->index && repo->index->on_disk,1,1,2
out && origin_remote && workdir_path,1,1,2
95 < sim && sim < 100,1,1,2
"GIT_DIR_FETCH, ""refs/heads:refs/remotes/frotz/*"", false",1,1,2
"DATA,SIZE,1,PATH,__FILE__,__LINE__",1,1,2
"strcmp(git_reference_name(read1), git_reference_name(write1)) == 0",1,1,2
exp.hunks == test_expects[i].hunks,1,1,2
" br2_name, git_reference_symbolic_target(reference_out)",1,1,2
"""baz"", git_buf_cstr(&buf)",2,0,2
values[1] == NULL,1,1,2
"!strcmp(git_refspec_src(refspec), ""refs/heads/*"")",1,1,2
"""test1-lightweight-"", ""HEAD"", repo, &opts, &fmt_opts, true",1,1,2
"""c-"", ""HEAD^"", repo, &opts, &fmt_opts, true",1,1,2
analysis_out && config_out && repo && their_heads,1,1,2
"GIT_OID_HEX_ZERO, oid_str",1,1,2
"index_adds, vals.index_adds",1,1,2
"8, exp[0]",2,0,2
"1, cache->entry_count",2,0,2
"""testrepo"", sm->path",1,1,2
delta->old_file.path && delta->new_file.path,1,1,2
!GIT_PERMS_IS_EXEC(entry->mode),2,0,2
"0, file, line, buf, ""Strings do not match"", 1",1,1,2
"strcmp(conflicting_buf.ptr, CONFLICTING_UNION_FILE) == 0",2,0,2
"0100644, result.mode",2,0,2
"true, git_path_exists(""linkdir/target.lock"")",2,0,2
exp.file_untracked == 4,1,1,2
git_diff_stats_deletions(stats) == 10,1,1,2
"git_path_isfile(""testrepo/ab/c/unrelated.txt"")",1,1,2
"1, filter_for(""foo.custom"", ""crlf"")",2,0,2
"GIT_DIR_PUSH, """", false",1,1,2
"sizes[2], git_diff_patch_size(patch, 1, 1, 0)",1,1,2
"&reuc->oid[1], &our_oid",2,0,2
"GIT_DIR_PUSH, ""HEAD:"", false",1,1,2
str_b < buf->ptr || str_b > buf->ptr + buf->size,1,1,2
"memcmp(git_blob_rawcontent(blob), g_raw[i], (size_t)g_len[i]) == 0",1,1,2
out && remote && ref,1,1,2
remote && refs,1,1,2
"""PROGRA~1"", shortname",1,1,2
git_index_entrycount(index) == (unsigned int)index_entry_count_2,1,1,2
buf_stream,2,0,2
"i, *(int *)p",2,0,2
"status_entry = git_status_byindex(status_list, 0)",2,0,2
" GIT_EINVALIDSPEC, git_remote_create(&remote, _repo, ""Inv@{id"", ""git://github.com/libgit2/libgit2"", NULL)",1,1,2
from && (from->flags & GIT_DIFF_FLAG__IS_RENAME_SOURCE) != 0,1,1,2
" GIT_SUBMODULE_IGNORE_UNTRACKED, git_submodule_set_ignore(sm1, GIT_SUBMODULE_IGNORE_RESET)",1,1,2
backend && backend->refcache.packfile,1,1,2
"GIT_ENOTFOUND, git_revparse_single(&g_obj, g_repo, ""test/master^1:branch_file.txt"")",1,1,2
parser->content_length != 0 && parser->content_length != ULLONG_MAX,2,0,2
"strcmp(""refs/heads/master"", git_reference_target(head)) == 0",1,1,2
"GIT_ENOTFOUND, git_reference_lookup(&stash, repo, ""refs/stash"")",1,1,2
entry && entry->path,1,1,2
"""theirs.txt"", result.path",2,0,2
" GIT_EUSER, git_diff_foreach(diff, &exp, diff_stop_after_2_files, NULL, NULL) ",1,1,2
"""e90810b8df3e80c413d903f631643c716887138d"", ""7b4384978d2493e851f9cca7858815fac9b10980"", GIT_OBJ_COMMIT",1,1,2
a && b,2,0,2
"GIT_DIR_PUSH, ""refs/heads/*/for-linus:refs/remotes/mine/*"", true",1,1,2
options->checkout_branch,1,1,2
actual = test_realpath(expected),1,1,2
"5, git_diff_patch_num_lines_in_hunk(p, 0)",1,1,2
shrink_len > 0,1,1,2
"tree, ""ab/de/fgh/1.txt"", 0, ""3259a6bd5b57fb9c1281bb7ed3167b50f224cb54""",1,1,2
"GIT_DIR_PUSH, ""refs/heads/ nitfol:"", false",1,1,2
"count, 5",1,1,2
"&expected_id, &actual_id",2,0,2
key_len == (size_t)((int)key_len),1,1,2
"0, tree_cache->entry_count",1,1,2
" GIT_ENOTFOUND, git_sysdir_find_system_file(&path, ""nonexistentfile"")",2,0,2
"5, diff->oid_calculations",1,1,2
"0, types[i]",1,1,2
"false, git_path_isvalid(NULL, ""git~1 "", GIT_PATH_REJECT_DOT_GIT_NTFS)",2,0,2
tx,2,0,2
"0, git_oid_streq(git_reference_oid(head), KNOWN_COMMIT_IN_BARE_REPO)",1,1,2
git_object_owner(target) == repository,1,1,2
"""c-"", ""HEAD"", repo, &opts, &fmt_opts, true",1,1,2
"git_oid_cmp(&oid, &entry->id), 0",1,1,2
"36, exp.line_adds",1,1,2
"cl_fixture(""attr/attr1""), file->entry->path",2,0,2
"""be3563a"", ""HEAD^"", repo, &opts, true",1,1,2
git_index_entrycount(index) == TEST_INDEX2_ENTRY_COUNT,1,1,2
buf_stream->complete == 0,2,0,2
out && diff,2,0,2
" file, line, msg, 1, ""%i"", expected_error, (int)(git_submodule_lookup(&sm, repo, name))",1,1,2
"-1, git_tree_walk( tree, GIT_TREEWALK_PRE, treewalk_skip_de_cb, &data)",2,0,2
!IS_EPSILON_NODE (type),2,0,2
dup1 = git_index_entry_dup(entry),1,1,2
"index_entry = git_index_get_bypath(index, ""README"", 0)",2,0,2
"GIT_REMOTE_DOWNLOAD_TAGS_NONE, origin->download_tags",1,1,2
"git_oid_streq(&id, str_oid) == 0",1,1,2
ref && data,1,1,2
"7, shorty.size",2,0,2
"merge_test_index(repo_index, merge_index_entries, 7)",2,0,2
"7, exp.file_adds",1,1,2
expected.hunk_new_lines == 14,1,1,2
"3, branch_list.count",1,1,2
"false, git_path_isvalid(NULL, ""foo/.git/bar"", GIT_PATH_REJECT_DOT_GIT)",1,1,2
(DWORD)len == bytes_written,2,0,2
" sm1, ""submodule.""SM1"".url"", ""branch.origin.remote""",1,1,2
"""test2-lightweight-"", ""HEAD^"", repo, &opts, true",1,1,2
"GIT_ERROR, ""53fc32d17276939fc79ed05badaef2db09990016"", GIT_OBJ_BLOB",1,1,2
"strcmp(reference->name, GIT_HEAD_FILE) == 0",1,1,2
"&ancestor_entry.id, &conflict_entry[0]->id",2,0,2
"""core.filemode"", true",1,1,2
"threedots, expected_threedots",1,1,2
"0, _remote->refspec_strings.length",1,1,2
counts == 6,1,1,2
repo->index,1,1,2
"""A-"", ""HEAD"", repo, &opts, &fmt_opts, true",1,1,2
"false, git_path_isvalid(NULL, "".git"", GIT_PATH_REJECT_DOT_GIT)",1,1,2
"tree, ""ab/"", GITERR_INVALID, NULL",1,1,2
"""*"", GIT_REF_LISTALL, 19",1,1,2
"""A-"", "".mod"", repo, &opts, &fmt_opts, true",1,1,2
exp.line_adds == 8,1,1,2
dst && src,1,1,2
"true, git_clone__should_clone_local(path, GIT_CLONE_LOCAL_NO_LINKS)",1,1,2
"""foo@example.com"", git_reflog_entry_committer(entry1)->email",1,1,2
"SetEnvironmentVariableW(name_utf16, value ? value_utf16 : NULL)",1,1,2
"18, (int)git_diff_patch_num_lines_in_hunk(patch, 0)",1,1,2
"!git_oid_cmp(git_reference_oid(ref), &id)",1,1,2
"0, git_repository_head_orphan(g_repo)",1,1,2
"strcmp(reuc->path, ""TWO.txt"") == 0",1,1,2
" GIT_EBAREREPO, git_diff_workdir_to_tree(&diff, g_repo, tree, &opts)",1,1,2
"59, exp.lines",1,1,2
" cl_fixture(""template""), git_repository_path(_repo), ""hooks/link.sample"", true",1,1,2
"strcmp(git_reference_name(read3), git_reference_name(write3)) == 0",1,1,2
"28, newno",1,1,2
patch->hunks != NULL,1,1,2
"GIT_MERGE_STATUS_NORMAL, status",1,1,2
"progress_was_called, true",1,1,2
"git_filters_load( &filters, g_repo, ""filename.txt"", GIT_FILTER_TO_ODB) > 0",1,1,2
rebase && signature,1,1,2
"NULL, git_index_get_bypath(index, ""executable.txt"", 2)",2,0,2
"0 == strcmp(expected->email, actual->email)",1,1,2
status && submodule,1,1,2
" GIT_EINVALIDSPEC, git_remote_create_inmemory(&remote, _repo, ""Inv@{id"", ""git://github.com/libgit2/libgit2"", NULL)",1,1,2
target && signature,1,1,2
repo && reference_out && name,1,1,2
diff_list && (our_tree || their_tree),1,1,2
"""refs/remotes/*"", GIT_REF_LISTALL, 2",1,1,2
odb && odb,1,1,2
"true, ""_test/a/file""",2,0,2
"git_oid_cmp(git_reference_target(read3), git_reference_target(write3)) == 0",1,1,2
"DATA,SIZE,0,PATH,__FILE__,__LINE__",1,1,2
"""heads/master"", ""HEAD"", repo, &opts, false",1,1,2
file->size == git_blob_rawsize(info->blob),1,1,2
git_submodule_head_oid(sm) == NULL,1,1,2
GIT_PERMS_IS_EXEC(entry->mode),2,0,2
"!strcmp(git_refspec_dst(refspec), ""refs/remotes/test/*"")",1,1,2
prov->type == INVALID,1,1,2
obj && path && *path,1,1,2
"&expected2, &result.ids[1]",2,0,2
" GIT_EINVALIDSPEC, git_remote_new(&remote, _repo, ""Inv@{id"", ""git://github.com/libgit2/libgit2"", NULL)",1,1,2
repo && ref_name && oid_old && oid_new && committer,1,1,2
"git_futils_find_system_file(&path, ""nonexistentfile"") == -1",1,1,2
"git_futils_readbuffer(&expected,cl_fixture(""template/description"")) == GIT_OK",1,1,2
"strcmp(base, B) == 0",1,1,2
count_all == expected_count + expected_ignores,1,1,2
"oitem && nitem && diff->entrycmp(oitem, nitem) == 0",1,1,2
"GIT_MERGE_STATUS_FASTFORWARD, status",1,1,2
"GIT_ENOTFOUND, git_repository_set_head_detached(repo, &oid, NULL)",1,1,2
status == 0,1,1,2
"GIT_NOTFOUND, git_repository_discover(repository_path, sizeof(repository_path), DISCOVER_FOLDER, 0, ceiling_dirs)",1,1,2
git_strerror(GIT_ENOTFOUND) != NULL,1,1,2
"assign->name_len == strlen(""attr0"")",1,1,2
out && id,1,1,2
i->type == GIT_ITERATOR_TYPE_TREE,2,0,2
repo && canonical_branch_name,1,1,2
expected.lines == 13,1,1,2
"""this"", buf.ptr",2,0,2
"!revparse_lookup_object(&next_obj, repo, git_buf_cstr(&specbuffer))",1,1,2
ignored == (entry_statuses0[i] == GIT_STATUS_WT_IGNORED),1,1,2
"cl_fixture(""attr/attr2""), file->ce->path",1,1,2
"""tags/e"", ""HEAD^^^"", repo, &opts, false",1,1,2
"31, git_diff_patch_size(patch, 1)",1,1,2
number > 0,1,1,2
status != GIT_STATUS_MODIFIED,1,1,2
" GIT_ECONFLICT, git_checkout_tree(g_repo, g_object, &g_opts)",2,0,2
git_buf_oom(&buf),2,0,2
"fetch_refspec, array.strings[0]",1,1,2
"gpgsig, signature.ptr",2,0,2
"&expected_id, &id",2,0,2
diff_list && (our_iter || their_iter),1,1,2
" GIT_EINVALIDSPEC, git_remote_new(&remote, _repo, """", ""git://github.com/libgit2/libgit2"", NULL)",1,1,2
"&expected_id, &ids[i].id",2,0,2
"git_oid_cmp(&expected_note_oid, &note_data->blob_oid) == 0",1,1,2
"st.st_mode & 0777, 0600",1,1,2
"GIT_EINVALIDSPEC, git_reference_symbolic_create( &new_reference, g_repo, name, current_head_target, 0, NULL, NULL)",1,1,2
"https_supported, git_remote_supported_url(""https://github.com/libgit2/libgit2.git"")",1,1,2
item_size >= 1,2,0,2
(caps & GIT_HAS_SSH) == 0,1,1,2
"strncmp(""Another replacement;\n"", text, textlen) == 0",1,1,2
"GIT_ENOTFOUND, git_revparse_single(&g_obj, g_repo, ""master@{31415}"")",1,1,2
"WORKDIR ""/test.txt"", ""test.txt"", &git_blob_create_fromfile",1,1,2
"""R-"", ""HEAD^^"", repo, &opts, true",1,1,2
"112, git_atomic_get(&counts[1])",1,1,2
"strcmp(git_reference_name(read2), git_reference_name(write2)) == 0",1,1,2
assign->name_len == strlen(name),1,1,2
"6, newno",1,1,2
grow_len > 0 && idx <= v->length,1,1,2
out && origin && local_path,1,1,2
"""this \""has\"" quotes and \t"", git_buf_cstr(&buf)",2,0,2
"revparseflags, expected_revparseflags",1,1,2
"GIT_ENOTFOUND, git_reference_lookup(&reference, g_repo, ""test/master"")",1,1,2
"name, p->first",2,0,2
passcase->offset == person.when.offset,1,1,2
"GIT_ENOTFOUND, git_repository_discover(&found_path, SUB_REPOSITORY_FOLDER_SUB_SUB, 0, ceiling_dirs)",2,0,2
backend && out && short_id,1,1,2
"expected_flags, revision.flags",1,1,2
offset < name_len,1,1,2
tag && target,1,1,2
start_path && repository_path,1,1,2
ti->head,1,1,2
"strcmp(""refs/heads/master"", git_reference_symbolic_target(head)) == 0",1,1,2
"GIT_NOTFOUND, git_repository_discover(found_path, sizeof(found_path), SUB_REPOSITORY_FOLDER_SUB_SUB, 0, ceiling_dirs)",1,1,2
ref->ref.type & GIT_REF_OID,1,1,2
"""be3563a"", ""HEAD^"", repo, &opts, &fmt_opts, true",1,1,2
"GIT_ENOTFOUND, git_config_get_multivar(cfg, _name, ""example"", cb, &n)",1,1,2
"GIT_EEXISTS, git_branch_move(ref, ""master"", 0)",1,1,2
out && diriter,2,0,2
options && options->out && options->origin_remote && options->local_path,1,1,2
range != NULL,1,1,2
oid && repo && tree && parent_count >= 0,1,1,2
"(int)ref_list.count, 15",2,0,2
"cl_fixture(""attr/attr0""), file->entry->path",2,0,2
"git_buf_cstr(&target_path), buf",2,0,2
"&commit_ids[i], &id",2,0,2
tag && tagger,1,1,2
num_rewrites < diff->deltas.length,1,1,2
"strcmp(base2, B) == 0",1,1,2
operation->index,1,1,2
"GIT_ENOTFOUND, git_revparse_single(&g_obj, g_repo, ""subtrees:ab/4.txt/nope"")",1,1,2
iter && repo,1,1,2
table->size_mask > old_size,1,1,2
"GIT_EUNMERGED, git_reset(repo, target, GIT_RESET_SOFT, NULL)",2,0,2
out && spec && name,2,0,2
"actual = realpath(expected, NULL)",1,1,2
tf,1,1,2
"""testrepo/a""",2,0,2
repository->references.packfile,1,1,2
"""*"", GIT_REF_LISTALL, 21",1,1,2
"true, git_clone__should_clone_local(path, GIT_CLONE_LOCAL_AUTO)",1,1,2
"tree, ""ab/de/"", GITERR_INVALID, NULL",1,1,2
" GIT_EINVALIDSPEC, git_remote_rename(&problems, _remote, ""new@{name"")",1,1,2
"""Normal\nLF\nonly\nline-endings.\n"", out.ptr",2,0,2
(ref->type & GIT_REF_PACKED) == 0,1,1,2
"GIT_DIR_PUSH, ""refs/heads/master:refs/remotes/frotz/xyzzy"", true",1,1,2
"GIT_NOTFOUND, git_repository_open(&repo, ""i-do-not/exist"")",1,1,2
"(int)expected->status, (int)actual->status",1,1,2
"GIT_EINVALIDSPEC, git_branch_create(&branch, repo, ""inv@{id"", target, 0, NULL)",1,1,2
"""1\n"", 2, ""rebase/.git/rebase-merge/end""",2,0,2
git_lasterror() != NULL,1,1,2
"25, st.st_size",2,0,2
expected_count == count,1,1,2
(caps & GIT_HAS_THREADS) != 0,1,1,2
git_submodule_branch(sm) == NULL,2,0,2
index->index_file_path,1,1,2
revision && repo && spec,1,1,2
"EXPECTED_HEADER, formatted_output",1,1,2
sim > 45 && sim < 55,1,1,2
path_len > 0 && path_len >= prefix_len,1,1,2
url && repo,1,1,2
pool,2,0,2
"git_path_islink(""d1"")",2,0,2
"""refs/heads/*"", GIT_REF_LISTALL, 9",1,1,2
"&reuc->oid[0], &ancestor_oid",2,0,2
"GIT_DIR_PUSH, ""HEAD"", true",1,1,2
repo && tree && diff,1,1,2
expected.lines == 6,1,1,2
out && origin_remote && dest_path,1,1,2
"""I'm a global config value!"", git_buf_cstr(&buf)",2,0,2
"""README"", index_entry->path",2,0,2
"expected[d], patch_text",1,1,2
exp.hunks == 11,1,1,2
"false, git_path_isvalid(NULL, "".git "", GIT_PATH_REJECT_DOT_GIT_NTFS)",2,0,2
read_bytes <= BUFFER_SIZE,1,1,2
reply->type == REDIS_REPLY_ERROR,1,1,2
"true, ""_test/file""",2,0,2
exp.file_adds == 5,1,1,2
"3, git_pathspec_match_list_entrycount(matches)",1,1,2
count <= MAX_SHUTDOWN_CB,1,1,2
"24 + 1 + 5 + 5, exp.line_adds",1,1,2
(st.st_mode & S_ISGID) == 0,1,1,2
ahead == 3,1,1,2
exp.files == 6,1,1,2
" GIT_EBAREREPO, git_diff_workdir_to_index(&diff, g_repo, NULL, &opts)",1,1,2
"0, perf.oid_calculations",2,0,2
"diff->oid_calculations, 0",1,1,2
"0, git_graph_descendant_of(_repo, git_commit_id(other), git_commit_id(commit))",2,0,2
e->file_size == TEST_ENTRIES[i].file_size,1,1,2
filters.length == 1,1,1,2
buffer_out && size >= GIT_PATH_MAX,1,1,2
tag && name && email,1,1,2
"strcmp(committer1->name, committer_name) == 0",1,1,2
"refname, refnames[i]",1,1,2
exp.lines == 8 + 15,1,1,2
"""test-annotated-"", ""HEAD"", repo, &opts, true",1,1,2
expected.line_adds == 6,1,1,2
message_out && buffer_size,1,1,2
"expectedRemoteNameLength, git_branch_remote_name(remotename, expectedRemoteNameLength, g_repo, git_reference_name(ref))",1,1,2
"&parent_id, git_reflog_entry_id_old(reflog_entry)",2,0,2
tracking_out && branch,1,1,2
"true, git_oid_cmp(out, &top_stash_id) == 0",1,1,2
"GIT_ECONFLICT, error",2,0,2
"GIT_DIR_PUSH, ""refs/heads/ nitfol"", false",1,1,2
"""Just_A_Dir/FILE3.txt"", entry->path",2,0,2
tx && refname && target,2,0,2
"expected, (actual & 0777), ""%07o""",1,1,2
string,2,0,2
"url, git_remote_pushurl(remote)",1,1,2
actual = p_realpath(expected),1,1,2
"""c-7-"", ""HEAD"", repo, &opts, &fmt_opts, true",1,1,2
"""what"", GIT_STATUS_INDEX_MODIFIED",1,1,2
"GIT_EINVALIDSPEC, git_branch_move(ref, ""Inv@{id"", 0)",1,1,2
"0, index->tree->entries",1,1,2
"""A-"", ""HEAD^"", repo, &opts, true",1,1,2
"!strcmp(git_note_message(_note), git_blob_rawcontent(_blob))",1,1,2
header,1,1,2
"strchr(message, '\n') != NULL",1,1,2
"1, git_commit_parentcount(commit)",2,0,2
"GIT_EEXISTS, git_reference_rename(&new_ref, ref, packed_test_head_name, 0, NULL, NULL)",1,1,2
" GIT_SUBMODULE_RECURSE_YES, git_submodule_set_fetch_recurse_submodules(sm1, old_fetchrecurse)",1,1,2
!git_index_entry_is_conflict(entry),2,0,2
blob->object.modified,1,1,2
"4, exp.lines",1,1,2
e && tree_entry,1,1,2
"nfd, data",1,1,2
"GIT_DIR_FETCH, ""::"", false",1,1,2
"entry->attr, GIT_FILEMODE_BLOB",1,1,2
"strcmp(diff_buf.ptr, ""a\n"" ""<<<<<<< HEAD\n"" ""=======\n"" ""a\n"" "">>>>>>> parent of 71eb9c2... revert me\n"" ""a\n"" ""a\n"" ""a\n"" ""a\n"" ""ab\n"") == 0",1,1,2
expected.file_unmodified == 1,1,1,2
"repository, ""branch.test.merge"", ""refs/heads/master""",2,0,2
rule->match.fullpath,1,1,2
((size_t) len) < sizeof(hdr),1,1,2
(ctx = git_hash_ctx_new()) != NULL,1,1,2
ctx->ctx.cryptoapi.valid,2,0,2
"strncmp(""This is some new text;\n"", text, textlen) == 0",1,1,2
"!strcmp(git_remote_name(remote), ""test"")",1,1,2
"&expected1, &result.ids[0]",2,0,2
remote && callbacks,1,1,2
iterator__do_autoexpand(i) ^ (prev_entry != NULL),2,0,2
"strcmp(committer1->email, committer_email) == 0",1,1,2
" GIT_FILEMODE_BLOB_GROUP_WRITABLE, git_tree_entry_attributes(entry)",1,1,2
"strcmp(author->name, ""Scott Chacon"") == 0",1,1,2
"memcmp(&g_stats[i], &stats, sizeof(stats)) == 0",1,1,2
"(entry_idx = git_index_find(repo_index, ""new-file.txt"")) >= 0",1,1,2
"true, progress_cb_was_called",1,1,2
"7 + 14, exp.line_dels",1,1,2
"NULL, git_submodule_branch(sm1)",1,1,2
"GIT_BRANCH_LOCAL | GIT_BRANCH_REMOTE, 12",1,1,2
" cl_fixture(""template""), git_repository_path(_repo), ""hooks/update.sample"", 0",1,1,2
"type, git_object_type(object)",1,1,2
reference_out && name,1,1,2
"""53fc32d17276939fc79ed05badaef2db09990016"", ""e90810b8df3e80c413d903f631643c716887138d"", GIT_OBJ_TREE",1,1,2
"!strcmp(git_refspec_dst(_refspec), ""refs/heads/*"")",1,1,2
"tree, ""ab/de"", 0, ""f1425cef211cc08caa31e7b545ffb232acb098c3""",1,1,2
expected.line_ctxt == 0,1,1,2
oid && signature,1,1,2
delta && patch,1,1,2
"diff, 9, false",2,0,2
"34, oldno",1,1,2
sqlite3_step(backend->st_read) == SQLITE_DONE,1,1,2
"2, range->old_lines",1,1,2
"git_oid_streq(&id, ""deadbeefdeadbeefdeadbeefdeadbeefdeadbeef"") == -1",1,1,2
"""e-3-"", ""HEAD"", repo, &opts, true",1,1,2
"st.st_mode, GIT_FILEMODE_TREE | 0701 & ~um, ""%07o""",1,1,2
"!git_oid_cmp(git_note_id(note), &note_oid)",1,1,2
"git_oid_streq(&entry->oid_old, master_tip) == 0",1,1,2
"GIT_EEXISTS, git_submodule_lookup(&sm, repo, ""subrepo"")",2,0,2
(st.st_mode & 0111) != 0,1,1,2
"data, signed_data.ptr",2,0,2
"GIT_DIR_FETCH, "":refs/remotes/frotz/HEAD-to-me"", true",1,1,2
"!git_path_isdir(""testrepo/new.txt"")",2,0,2
"diff, 7, true",2,0,2
"""53fc32d17276939fc79ed05badaef2db09990016"", ""7b4384978d2493e851f9cca7858815fac9b10980"", GIT_OBJ_TREE",1,1,2
"diff, 6, false",2,0,2
"file, line, ""strlen(expected_content) != strlen(actual_content)"", 1, PRIuZ, expected_len, (size_t)buf.size",1,1,2
" GIT_EAMBIGUOUS, git_revparse(&oid, NULL, NULL, g_repo, ""wrapped_tag^{blob}"")",1,1,2
"GIT_REMOTE_DOWNLOAD_TAGS_ALL, origin->download_tags",1,1,2
backend && pl,1,1,2
"!git_path_exists(""merge-resolve/.git/index.lock"")",2,0,2
exp.line_adds == 11,1,1,2
ret < peel_len + 1,1,1,2
"!git_buf_cmp(&expected,&actual)",1,1,2
"sizes[0], git_diff_patch_size(patch, 0, 0, 0)",1,1,2
"content, git_blob_rawcontent(blob)",2,0,2
!((signature == NULL) ^ (log_message == NULL)),1,1,2
"git__utf16_to_8_alloc(&utf8_value, wide_value) >= 0",1,1,2
dest && src && length,1,1,2
"false, ""dir1/dir2/file""",2,0,2
expected.line_ctxt == 3,1,1,2
"&id, git_object_id(object)",2,0,2
git_path_isdir(git_buf_cstr(&newdir_path)) == false,1,1,2
"46, (int)range->old_start",1,1,2
it,1,1,2
"""53fc32d17276939fc79ed05badaef2db09990016"", ""e90810b8df3e80c413d903f631643c716887138d"", GIT_OBJ_ANY",1,1,2
base && n > 1,1,1,2
ignores,1,1,2
expected.line_ctxt == 4,1,1,2
" GIT_EINVALIDSPEC, git_revparse(&oid, NULL, NULL, g_repo, invalid_spec)",1,1,2
"expected, oldno - lastoldno",1,1,2
"nentries + 1, nentries_after",2,0,2
id && hdr && len && obj,1,1,2
parent_count >= 0,1,1,2
refname && data,1,1,2
"GIT_DIR_PUSH, ""master~1:refs/remotes/frotz/backup"", true",1,1,2
"strncmp(""My rulers and their treasure and their unborn populations,\n"", text, textlen) == 0",1,1,2
"git_oid_cmp(&expected_target_oid, &note_data->annotated_object_oid) == 0",1,1,2
"diff, 0, false",2,0,2
"0, git__suffixcmp(git_buf_cstr(&label), expected_suffix)",1,1,2
dup2 = git_index_entry_dup(entry),1,1,2
"!shortname || !strcmp(shortname, ""PROGRA~1"")",1,1,2
"git_index_get_bypath(index, "".HEADER"", 0)",2,0,2
"false, ""dir/TeSt""",2,0,2
"git_oid_cmp(&current_id, &entry->oid_old) == 0",1,1,2
"0, git_blob_rawsize(blob)",2,0,2
diriter && path,2,0,2
" GIT_NOTFOUND, git_object_lookup_prefix(&object, g_repo, &oid, strlen(commit), GIT_OBJ_TAG)",1,1,2
"GIT_STATUS_CONFLICTED, status",2,0,2
"8 + 15, exp.lines",1,1,2
" GIT_EINVALIDSPEC, git_remote_add(&remote, _repo, NULL, ""git://github.com/libgit2/libgit2"")",1,1,2
range && header,1,1,2
"""../../../sm_libgit2/"", worktree_path",1,1,2
out && repo && oid,1,1,2
"GIT_BRANCH_LOCAL, 9",1,1,2
"(int)expected_mode, (int)st.st_mode",1,1,2
"strcmp(REFNAME, git_reference_name(ref2)) == 0",1,1,2
"before + 1, after",1,1,2
"0 == strcmp(buffer_out, expected_refname)",1,1,2
"&id, git_reference_target(ref)",2,0,2
base && *base,1,1,2
"expectedcontents, buf.ptr",1,1,2
"""refs/remotes/renamed/master"", git_reference_name(ref)",2,0,2
"strncmp(""All the world went softly when it walked before my Cities—\n"", text, textlen) == 0",1,1,2
"19, refnames.count",1,1,2
"""hi\n"", buf.ptr",1,1,2
"p_read(fd, buffer, 1024), strlen(expectedcontents)",1,1,2
" GIT_EINVALIDSPEC, git_remote_create_inmemory(&remote, _repo, """", ""git://github.com/libgit2/libgit2"", NULL)",1,1,2
"""Unknown diff line origin"" == 0",1,1,2
q,1,1,2
exp.files == 12,1,1,2
"6, count",1,1,2
"wt_dels, vals.wt_dels",1,1,2
"strcmp(passcase->name, person.name) == 0",1,1,2
exp.file_mods == test_expects[i].file_mods,1,1,2
"git_path_exists(""stash/just.ignore"")",2,0,2
rule->match.directory,1,1,2
"GIT_ENOTFOUND, git_revparse_single(&g_obj, g_repo, ""nope@{0}"")",1,1,2
"strcmp(author1->email, committer_email) == 0",1,1,2
((git_refcount *)odb)->refcount == 1,1,1,2
"git_strmap_exists(g_table, ""aaaaaaaaa"")",2,0,2
"!strcmp(""foo"", str)",1,1,2
"root, path, GIT_ERROR, expected_raw_oid",1,1,2
"user, ""arrbee""",1,1,2
reflog && reflog->db && new_oid && committer,1,1,2
"tree, ""/"", GITERR_INVALID, NULL",1,1,2
"GIT_DIFF_LINE_DEL_EOFNL, (int)origin",1,1,2
reparse_buf,2,0,2
"expectations->file, skipped_file",1,1,2
"true, ""dir/file2""",1,1,2
ahead == 2,1,1,2
found_path || error != GIT_SUCCESS,1,1,2
"GIT_EEXISTS, git_branch_create(&branch, repo, ""br2"", target, 0, NULL, NULL)",1,1,2
exp.lines == 59,1,1,2
wide_value = git__malloc(value_len * sizeof(wchar_t)),1,1,2
"git_tree_frompath(&containing_tree, root, path) == expected_result",1,1,2
exp.files == test_expects[i].files,1,1,2
" GIT_PERMS_EXECUTABLE(expect_mode), GIT_PERMS_EXECUTABLE(st.st_mode)",1,1,2
"31, git_diff_patch_size(patch, 1, 0, 0)",1,1,2
"""a/ignoreme""",2,0,2
git_diff_stats_files_changed(stats) == 3,1,1,2
git_path_isdir(git_buf_cstr(&subdir_path)) == false,1,1,2
"""just_a_dir/File1.txt"", entry->path",2,0,2
username && cred,2,0,2
reset_type == GIT_RESET_SOFT || reset_type == GIT_RESET_MIXED,1,1,2
"""testrepo"", sm->name",1,1,2
(st.st_mode & 0777) == GIT_OBJECT_FILE_MODE,1,1,2
file && path,1,1,2
"-1, line->content_offset",2,0,2
"""test1-lightweight-"", ""HEAD"", repo, &opts, true",1,1,2
tag && tagger_sig,1,1,2
"!memcmp( out.ptr, g_crlf_filtered[i].ptr, min(out.size, g_crlf_filtered[i].size))",1,1,2
" (int)GIT_SUBMODULE_UPDATE_REBASE, (int)git_submodule_set_update(sm1, GIT_SUBMODULE_UPDATE_DEFAULT)",1,1,2
"expected, filepath, __FILE__, __LINE__",2,0,2
"a,b,__FILE__,__LINE__",1,1,2
"(entry_idx = git_index_find(repo_index, ""conflicts-two.txt"")) >= 0",1,1,2
"""heads/master"", ""HEAD"", repo, &opts, &fmt_opts, false",1,1,2
((git_refcount *)new_index)->refcount == 2,1,1,2
"strcmp(author->email, ""schacon@gmail.com"") == 0",1,1,2
"""two.bar""",2,0,2
"!git_oid_cmp(git_indexer_stream_hash(idx), &should_id)",1,1,2
"conndata.pass, ""pass@word""",1,1,2
"""da9c51a23d02d931a486f45ad18cda05cf5d2b94 776e4c48922799f903f03f5f6e51da8b01e4cce0\n"", 82, ""rebase/.git/rebase-merge/rewritten""",1,1,2
"false, git_clone__should_clone_local(buf.ptr, GIT_CLONE_NO_LOCAL)",1,1,2
"GIT_ITEROVER, git_reference_next(&name, iter)",1,1,2
"git_path_exists(""stash/bundle/vendor/blah"")",2,0,2
tgt.ptr == NULL,1,1,2
"GIT_ENOTFOUND, git_revparse_single(&g_obj, g_repo, ""master@{2012-04-30 17:22:42 +0000}"")",1,1,2
expected.line_dels == 0,1,1,2
"GIT_EINVALIDSPEC, git_revparse(&l,&r,&flags, g_repo, ""^&*("")",1,1,2
S_ISDIR(ptr->old_attr) == S_ISDIR(ptr->new_attr),1,1,2
"15, git_diff_patch_num_lines_in_hunk(p, 0)",1,1,2
"expected_st.st_size, st.st_size",1,1,2
"strcmp(looked_up_ref->name, new_head) == 0",1,1,2
index_pos >= 0,1,1,2
repo && branch_name && remote_url && oid,1,1,2
"GIT_ENOTFOUND, git_repository_set_head(repo, ""refs/tags/doesnt/exist/yet"", NULL, NULL)",1,1,2
"git_oid_cmp(&oid, &entry->oid_old) == 0",1,1,2
"entry = git_index_get_bypath(index, ""COPYING"", 0)",1,1,2
new_val == (GIT_DEFAULT_CACHE_SIZE*2),1,1,2
"2, (int)git_diff_patch_num_hunks(p)",1,1,2
"9, oldno",1,1,2
"!git_path_exists(""foo/readme.txt"")",2,0,2
out && path,1,1,2
"6, (int)range->old_start",1,1,2
"diff, 3, true",2,0,2
"(entry_idx = git_index_find(repo_index, ""one.txt"")) >= 0",1,1,2
"delta->old_file.path, ""a/file.txt""",1,1,2
" GIT_EUSER, git_tree_walk(tree, treewalk_stop_cb, GIT_TREEWALK_POST, &ct)",1,1,2
"9, newno",1,1,2
"strcmp(committer->name, ""Scott Chacon"") == 0",1,1,2
"entry->path, dup2->path",1,1,2
scheme,2,0,2
"GIT_DIR_FETCH, "":refs/remotes/frotz/HEAD to me"", false",1,1,2
"""c-"", ""HEAD^^2"", repo, &opts, true",1,1,2
repo && name && target,1,1,2
"true, git_path_isvalid(NULL, ""foo "", 0)",2,0,2
" 1, git_diff_foreach(diff, diff_stop_after_2_files, NULL, NULL, &exp) ",1,1,2
"GIT_DIR_FETCH, """", true",1,1,2
"&expected, &oid",2,0,2
id,2,0,2
"22, exp.line_dels",1,1,2
nobj == 1683,1,1,2
"""Modification 1 to beef\n"", git_commit_message(commit)",2,0,2
"""Short\n"", buffer.ptr",2,0,2
"in.ptr, out.ptr",2,0,2
"git_oid_cmp(&before_next_old_oid, &after_next->oid_old) != 0",1,1,2
"st.st_mode, GIT_FILEMODE_BLOB_EXECUTABLE & ~um, ""%07o""",1,1,2
diff_list && our_tree && their_tree,1,1,2
"git_oid_cmp(&id1, &entry->id) == 0, ""first oid check""",1,1,2
"GIT_BRANCH_LOCAL, 8",1,1,2
"!git_index_find(&pos, index, filename)",1,1,2
"git_futils_readbuffer(&actual,""templated.git/description"") == GIT_OK",1,1,2
repo && glob && callback,1,1,2
"""refs/heads/*:refs/remotes/origin/*"", ""master""",2,0,2
self && key,1,1,2
"expected[d] == NULL, file, line, ""found UNMODIFIED delta where modified was expected"", NULL, 1",1,1,2
out && repo && tree,1,1,2
"true, ""dir1/dir2/dir3/dir1/file""",2,0,2
"false, filemode",1,1,2
g_len[i] == git_blob_rawsize(blob),1,1,2
exp.line_adds == 36,1,1,2
left && repo && spec,1,1,2
commit && commit->object.source.open,1,1,2
40 < sim && sim < 60,1,1,2
exp.lines == 4,1,1,2
"git_oid_equal(&expected, &actual)",1,1,2
"""be3563ae3f795b2b4353bcce3a527ad0a4f7f644"", idstr",2,0,2
"GIT_DIR_PUSH, ""refs/heads*/for-linus:refs/remotes/mine/*"", false",1,1,2
"tree, ""/ab/de"", GITERR_INVALID, NULL",1,1,2
buffer && attrs,1,1,2
repo && submodule_path && status,1,1,2
"""tags/e"", ""HEAD^^^"", repo, &opts, &fmt_opts, false",1,1,2
"git_oid_cmp(&expected_target_oid, annotated_object_oid) == 0",1,1,2
"GIT_DIR_PUSH, ""refs/heads/*:refs/remotes/frotz/*"", true",1,1,2
"507, git_pool__full_pages(&p)",1,1,2
repo && options,1,1,2
"!GIT_ALLOC_OVERFLOW_ADD(42, 69)",1,1,2
"""nonexistent/master"", name",1,1,2
nread == 1,1,1,2
"data, ""0123456789""",1,1,2
"31, (int)range->old_start",1,1,2
git_index_entrycount(index) == TEST_INDEX_ENTRY_COUNT,1,1,2
"!strcmp(looked_up_ref->name, ""refs/heads/test"")",1,1,2
"strcmp(""0000000000000000000000000000000000000000"", oid_str) == 0",1,1,2
"(int)expected_len, (int)buf.size, file, line, ""strlen(expected_content) != strlen(actual_content)"", 1",1,1,2
old_val == GIT_DEFAULT_CACHE_SIZE,1,1,2
"git_oid_streq(git_submodule_wd_oid(sm), ""3d9386c507f6b093471a3e324085657a3c2b4247"") == 0",1,1,2
"4, git_diff_stats_files_changed(_stats)",2,0,2
"git_remote_pushurl(g_remote), NULL",2,0,2
"2, diff->submodule_lookups",1,1,2
git_error_last()->klass == expected_result,1,1,2
"0, range->new_start",1,1,2
"9, diff->oid_calculations",1,1,2
tree && src,1,1,2
"strcmp(sign->email, ""emeric.fermas@gmail.com"") == 0",1,1,2
"GIT_ENOTFOUND, git_revparse(&oid, NULL, NULL, repo, ""origin/bim_with_3d@11296"")",1,1,2
path && file,1,1,2
sizeof(off_t) == 8,1,1,2
git_refspec_force(_refspec) == 0,1,1,2
buf && where <= git_buf_len(buf) && where + nb_to_remove <= git_buf_len(buf),1,1,2
"git_oid_streq(&idp, ""ae90f12eea699729ed0000000000000000000000"") == 0",1,1,2
"1, git_tree_entrycount(tree)",1,1,2
"!git_oid_cmp(&oid, git_reference_oid(ref))",1,1,2
"3, exp.hunks",1,1,2
"index_dels, vals.index_dels",1,1,2
"data, ""01""",1,1,2
expect_mode == entry->mode,1,1,2
"git_oid_equal(git_blob_id(c), &delta->old_file.id)",1,1,2
"GIT_REPOSITORY_STATE_REVERT, git_repository_state(_repo)",1,1,2
" cl_fixture(""template""), git_repository_path(_repo), ""hooks/link.sample"", filemode, 0",1,1,2
i == INT64_MAX,2,0,2
"2, (int)git_diff_patch_num_hunks(patch)",1,1,2
"git_oid_equal(&entry->oid, &dup2->oid)",1,1,2
iter->frames.size,2,0,2
"!strcmp(git_commit_message(commit), root_commit_message)",1,1,2
"exp_email, git_reflog_entry_committer(entry)->email",1,1,2
"strcmp(commit_msg, entry->msg) == 0",1,1,2
"true, git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL)",1,1,2
"&branch_list, ""remotes/nulltoken/HEAD""",1,1,2
"GIT_ENOTFOUND, git_revparse_single(&g_obj, g_repo, ""be3563a^42"")",1,1,2
70 < sim && sim < 80,1,1,2
ctx && stream,1,1,2
"strncmp(""Ivory their outposts were--the guardrooms of them gilded,\n"", text, textlen) == 0",1,1,2
"url, git_remote_pushurl(g_remote)",1,1,2
"0, git_diff_stats_insertions(_stats)",2,0,2
"3, exp.file_adds",1,1,2
"complete, git_odb_object_data(obj)",2,0,2
"GIT_EINVALIDSPEC, git_reference_symbolic_create(&head, g_repo, GIT_HEAD_FILE, ""refs/heads/inv@{id"", 1, NULL, NULL)",1,1,2
"branch_list.count, expected_count",1,1,2
"1, update_payload.update_tips_called",2,0,2
db && db->backend && ref_name,1,1,2
check_repository_dirs(repo) == GIT_SUCCESS,1,1,2
"oitem && nitem && diff->entrycomp(oitem, nitem) == 0",1,1,2
"git_path_isdir(""t3"")",2,0,2
tracking_name && canonical_branch_name,1,1,2
"!strcmp(git_refspec_dst(_refspec), ""refs/remotes/upstream/*"")",1,1,2
"!strcmp(git_buf_cstr(&buf), ""refs/remotes/test/master"")",1,1,2
"""i-do-not-locally-exist"", GIT_BRANCH_LOCAL",1,1,2
"GIT_MERGE_ANALYSIS_UNBORN, (analysis & GIT_MERGE_ANALYSIS_UNBORN)",1,1,2
"(loose_object_mode(REPOSITORY_FOLDER, (git_object *)tag) & 0777) == GIT_OBJECT_FILE_MODE",1,1,2
"3, (int)i",1,1,2
"1, filter_for(""foo.custom"", ""ident"")",2,0,2
"GIT_DELTA_ADDED, git_pathspec_match_list_diff_entry(matches,0)->status",1,1,2
"""B-0-"", ""HEAD^^2^"", repo, &opts, &fmt_opts, true",1,1,2
"""this \""has\"" quotes"", git_buf_cstr(&buf)",2,0,2
"""e-"", ""HEAD^^"", repo, &opts, true",1,1,2
"strcmp(diff_buf.ptr, ""a\n"" ""<<<<<<< HEAD\n"" ""=======\n"" ""a\n"" "">>>>>>> parent of 97e52d5... Revert me\n"" ""a\n"" ""a\n"" ""a\n"" ""a\n"" ""ab\n"") == 0",1,1,2
"GIT_ENOTFOUND, git_revparse_single(&g_obj, g_repo, ""HEAD@{10 years ago}"")",1,1,2
"99, tmp",1,1,2
(dup2->flags_extended & GIT_IDXENTRY_ALLOCATED) != 0,1,1,2
"31, git_diff_patch_size(patch, 0, 0, 0)",1,1,2
"strcmp(dir2, B) == 0",1,1,2
"GIT_EEXISTS, git_branch_move(&new_ref, original_ref, ""cannot-fetch"", 0, NULL)",1,1,2
"disable8dot3 ? "".bar"" : ""BAR~2"", (shortname = git_win32_path_8dot3_name("".bar""))",1,1,2
" GROUP_WRITABLE_FILE, git_tree_entry_attributes(entry)",1,1,2
exp.line_dels == 14,1,1,2
"(types = git__calloc(num, sizeof(git_otype)))",1,1,2
"expectations->file, file",1,1,2
"strncmp(""The Daughters of the Palace whom they cherished in my Cities,\n"", text, textlen) == 0",1,1,2
"GIT_EEXISTS, git_reference_rename(ref, packed_test_head_name, 0)",1,1,2
"_repo, ""core.worktree"", ""../c_wd/""",2,0,2
"GIT_EUSER, git_branch_foreach(repo, GIT_BRANCH_LOCAL | GIT_BRANCH_REMOTE, branch_list_interrupt_cb, &count)",1,1,2
"true, ""sub/_test/a/file""",2,0,2
"""8496071c1b46c854b31185ea97743be6a8774479"", 3, ""a65fed"", ""763d71"", ""849607""",2,0,2
"GIT_EINVALIDSPEC, git_reference_rename(&renamed_ref, looked_up_ref, ""i-will-sudo-you"", 0, NULL, NULL)",1,1,2
"git_merge_head_id(onto), git_reflog_entry_id_old(reflog_entry)",1,1,2
out && url,1,1,2
"false, ""dir/test""",2,0,2
"0, git_oid_cmp(git_object_id(obj), git_reflog_entry_id_new(entry))",1,1,2
"repo, ""untracked_repo/"", GIT_STATUS_WT_NEW",2,0,2
"git_remote_supported_url(""git@github.com:libgit2/libgit2.git"")",1,1,2
dest && src && srcLength > 0,1,1,2
(caps & GIT_HAS_THREADS) == 0,1,1,2
"1, exp.file_status[GIT_DELTA_TYPECHANGE]",1,1,2
"&parent_id, git_commit_parent_id(commit, 0)",2,0,2
"git_futils_find_global_file(&path, ""nonexistentfile"") == -1",1,1,2
builder_p,1,1,2
"git_submodule_lookup(NULL, g_repo, ""modified"") == GIT_NOTFOUND",1,1,2
error == GIT_EAMBIGUOUS,1,1,2
"(entry_idx = git_index_find(repo_index, ""conflicts-one.txt"")) >= 0",1,1,2
"""good, this is a ; multiline comment # with ;\n special chars and other stuff !@#"", str",1,1,2
show <= GIT_STATUS_SHOW_WORKDIR_ONLY,1,1,2
buf.asize > 0,1,1,2
"git_note_id(_note), &note_oid",2,0,2
"true, ""Folder/Middle/Contained""",2,0,2
"git_futils_find_system_file(&path, ""nonexistentfile"") == GIT_ENOTFOUND",1,1,2
"tree, ""README"", 0, tree_with_subtrees_oid",1,1,2
refspec != NULL,1,1,2
"strcmp(REFNAME, git_reference_name(ref1)) == 0",1,1,2
(branch_type == GIT_BRANCH_LOCAL) || (branch_type == GIT_BRANCH_REMOTE),1,1,2
head,1,1,2
"git_pool_strndup(&p, ""bar"", 0xfffffffful + 32) == NULL",1,1,2
"GIT_NOTFOUND, git_path_prettify(&p, NON_EXISTING_FILEPATH, NULL)",1,1,2
"""rebase: Modification 1 to beef"", git_reflog_entry_message(reflog_entry)",2,0,2
"git_oid_cmp(&hunk->final_commit_id, &hunk->orig_commit_id), 0",1,1,2
assign->name_len == 6,1,1,2
" cl_fixture(""template""), git_repository_path(_repo), ""hooks/update.sample"", (GIT_REPOSITORY_INIT_SHARED_GROUP | S_IFREG) & ~S_ISGID",1,1,2
level == 0 || cb != NULL,1,1,2
pool && ptrs && pool->item_size >= sizeof(void*),1,1,2
"tree, ""ab//de"", GITERR_INVALID, NULL",1,1,2
odb_dir && object,1,1,2
"repo, ""refs/remotes/origin/master""",2,0,2
"31, oldno",1,1,2
"entry_count7, entry_paths7, entry_statuses7, GIT_STATUS_SHOW_INDEX_THEN_WORKDIR",1,1,2
"0, git_commit_parentcount(new_commit)",2,0,2
"25, newno",1,1,2
b->read != NULL,1,1,2
" true, git_oid_cmp(&oid, git_object_id(next_top_stash)) == 0",1,1,2
"git_oid_cmp(&expected_note_oid, note_oid) == 0",1,1,2
delta->old_file.path,1,1,2
"0, strcmp(buffer_out, expected_refname)",1,1,2
" git_reference_target(origRefTarget), git_reference_target(refTarget) ",1,1,2
"""A-"", ""-dirty"", repo, &opts, &fmt_opts, true",1,1,2
"repo, ""where"", GIT_STATUS_INDEX_NEW | GIT_STATUS_WT_MODIFIED",2,0,2
"GIT_ENOTFOUND, git_reference_remote_tracking_from_branch(&tracking, branch)",1,1,2
name && buf,1,1,2
out && cfg && name,1,1,2
"git_oid_cmp(&oid, &entry->oid) == 0",1,1,2
"!git_strmap_exists(g_table, ""aaaaaaaab"")",2,0,2
ref->type == GIT_REF_OID || ref->type == GIT_REF_SYMBOLIC,1,1,2
" GIT_EUSER, git_path_walk_up(&p, root[j], check_one_walkup_step, &info) ",1,1,2
"GIT_SUBMODULE_UPDATE_REBASE, git_submodule_update_strategy(sm)",1,1,2
"NULL, git_index_get_bypath(index, ""executable.txt"", 1)",2,0,2
repo && remote && co_opts,1,1,2
"GIT_EINVALIDSPEC, git_reference_symbolic_set_target( head, ""refs/heads/inv@{id"")",1,1,2
"_repo, ""remote.durable.url"", ""git://github.com/libgit2/durable.git""",1,1,2
"s, SM_RELATIVE_RESOLVED_URL",1,1,2
git_diff_stats_insertions(stats) == 8,1,1,2
"true, git_path_isvalid(NULL, ""./foo"", 0)",2,0,2
"oitem && nitem && entry_compare(oitem, nitem) == 0",1,1,2
"git_path_exists(TEST_REPO_PATH ""/.git/CHERRY_PICK_HEAD"")",2,0,2
"git_oid_streq(&idp, ""I'm not an oid.... :)"") == -1",1,1,2
"0, git_oid_cmp(git_object_id(obj), git_reflog_entry_id_old(entry))",1,1,2
"module = GetModuleHandle(""kernel32"")",2,0,2
"git_oid_streq(&id, ""I'm not an oid.... :)"") == -1",1,1,2
"i, 1",1,1,2
"repo, ""untracked"", GIT_ENOTFOUND",2,0,2
git_diff_stats_deletions(stats) == 13,1,1,2
"!strcmp(looked_up_ref->name, brand_new_name)",1,1,2
i == 3,1,1,2
"GIT_NOTFOUND, git_remote_load(&_remote, _repo, ""just-left-few-minutes-ago"")",1,1,2
"git_path_islink(""d2"")",2,0,2
"""e90810b8df3e80c413d903f631643c716887138d"", ""e90810b8df3e80c413d903f631643c716887138d"", GIT_OBJ_COMMIT",1,1,2
"expectations->file, conflict_file",1,1,2
"GIT_MERGE_ANALYSIS_UNBORN, analysis",1,1,2
git_reference_is_packed(ref) == 0,1,1,2
"merge_test_workdir(repo, merge_filesystem_entries, 3)",2,0,2
expected.lines == 15,1,1,2
objects[i].visited,1,1,2
"!strcmp(default_ref, ""refs/notes/mydefaultnotesref"")",1,1,2
"entry = git_index_get_bypath(g_idx, ""just_a_dir/File1.txt"", 0)",2,0,2
exp.line_dels == 22,1,1,2
"true, git_path_exists(""linkdir/target"")",2,0,2
"5, git_diff_stats_insertions(_stats)",2,0,2
action == INDEX_ACTION_UPDATE,1,1,2
"573, git_pool__open_pages(&p)",1,1,2
"5, exp.hunks",1,1,2
e->mtime.seconds == TEST_ENTRIES[i].mtime,1,1,2
git_reference_is_packed(ref) == 1,1,1,2
"""A-"", ""HEAD"", repo, &opts, true",1,1,2
root_len >= 0,2,0,2
"1, git_diff_stats_deletions(_stats)",2,0,2
"delta->status, GIT_DELTA_CONFLICTED",2,0,2
MB_LEN_MAX >= pstr->mb_cur_max,2,0,2
shrink_len > 0 && shrink_len <= v->length,1,1,2
"GIT_ERROR, ""0266163a49e280c4f5ed1e08facd36a2bd716bcf"", GIT_OBJ_ANY",1,1,2
pool && ptr && pool->item_size >= sizeof(void*),1,1,2
"""A-"", ""HEAD^^2"", repo, &opts, &fmt_opts, true",1,1,2
exp.line_dels == 7 + 1,1,1,2
"strcmp(looked_up_ref->name, new_head_tracker) == 0",1,1,2
"old_branch, git_submodule_branch(sm1)",1,1,2
sim > 60 && sim < 70,1,1,2
"git_config_delete(cfg, ""core.imaginary"") == GIT_NOTFOUND",1,1,2
"git_remote_name(_remote), ""newname""",1,1,2
containing_tree != NULL && expected_result == 0,1,1,2
"9, shorty.size",2,0,2
ts->count < GIT_MAX_TEST_CASES,1,1,2
"10, exp.files",1,1,2
"false, git_path_isvalid(NULL, ""foo /bar"", GIT_PATH_REJECT_TRAILING_SPACE)",2,0,2
"""53fc32d17276939fc79ed05badaef2db09990016"", ""53fc32d17276939fc79ed05badaef2db09990016"", GIT_OBJ_TREE",1,1,2
"2, _remote->refspecs.length",1,1,2
"4, git_blame_get_hunk_count(blame)",1,1,2
"git_strmap_exists(g_table, ""ggggggggg"")",2,0,2
"git_oid_cmp(&binary_entry->oid, &our_file_oid) == 0",1,1,2
commit->commit_object->basic_parse,1,1,2
"tree, ""/ab"", GITERR_INVALID, NULL",1,1,2
"strcmp(git_commit_message(commit), commit_message) == 0",1,1,2
remote && bytes && stats,1,1,2
out && db && id && len > 0,1,1,2
out && p && e,1,1,2
" true, git_oid_cmp(&oid, &next_top_stash_id) == 0",1,1,2
"4, (int)range->new_lines",1,1,2
"memcmp(git_blob_rawcontent(blob), g_raw[i], g_len[i]) == 0",1,1,2
"result = merge_simple_branch(GIT_MERGE_FILE_FAVOR_OURS, 0)",1,1,2
exp.hunk_old_lines == 14,1,1,2
tag_target && tag,1,1,2
git_error_last()->klass == GITERR_NOMEMORY,1,1,2
" GIT_SUBMODULE_UPDATE_REBASE, git_submodule_update(sm2)",1,1,2
"""Branch: created"", git_reflog_entry_message(entry)",1,1,2
exp.file_adds == 7,1,1,2
"""COPYING"", dup1->path",1,1,2
"47, newno",1,1,2
"GIT_DIR_FETCH, ""HEAD"", true",1,1,2
device_out,1,1,2
"GIT_ENOTFOUND, git_revparse_single(&g_obj, g_repo, ""master@{2012-04-30 09:22:42 -0800}"")",1,1,2
" GIT_EINVALIDSPEC, git_remote_create(&remote, _repo, NULL, ""git://github.com/libgit2/libgit2"", NULL)",1,1,2
table && it,1,1,2
"GIT_DIR_FETCH, ""refs/heads/ nitfol:"", false",1,1,2
"ignores, vals.ignores",1,1,2
expected.line_ctxt == 1,1,1,2
"""test2-lightweight-"", ""HEAD^"", repo, &opts, &fmt_opts, true",1,1,2
submodule && url,1,1,2
path_len < GIT_PATH_MAX - MAX_GITDIR_TREE_STRUCTURE_PATH_LENGTH,1,1,2
"9, exp.lines",2,0,2
git_index_has_conflicts(rebase_operation->index),1,1,2
exp.line_dels == test_expects[i].line_dels,1,1,2
cred && privatekey,1,1,2
"!GIT_ALLOC_OVERFLOW_ADD(SIZE_MAX-1, 1)",1,1,2
"strcmp(reference->name, head_tracker_sym_ref_name) == 0",1,1,2
"GIT_EORPHANEDHEAD, git_checkout_head(g_repo, NULL, NULL)",1,1,2
"i, 7",2,0,2
"2, git_reflog_entrycount(log)",1,1,2
tree && id && filename,1,1,2
tgt,1,1,2
"GIT_EINVALIDSPEC, git_reference_create( &new_reference, g_repo, name, &id, 0, NULL, NULL)",1,1,2
"GIT_DELTA_MODIFIED, git_pathspec_match_list_diff_entry(matches,0)->status",1,1,2
exp.line_dels == 7 + 14,1,1,2
"expectedcontents, buffer",1,1,2
"false, git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL_AUTO)",1,1,2
"submodule_status, GIT_SUBMODULE_STATUS_IN_HEAD | GIT_SUBMODULE_STATUS_IN_INDEX | GIT_SUBMODULE_STATUS_IN_CONFIG | GIT_SUBMODULE_STATUS_IN_WD",2,0,2
"git_oid_equal(git_blob_id(b), &delta->old_file.id)",1,1,2
"!git_oid_cmp(&oid, git_reference_target(cloned_head))",1,1,2
"""binary patch did not apply cleanly"", giterr_last()->message",1,1,2
"""COPYING"", e->path",2,0,2
" size_without_context, git_diff_patch_size(patch, 0)",1,1,2
data && datasize,1,1,2
git_reflog_entrycount(log) > 0,2,0,2
"7 + 24 + 1 + 6 + 6, exp.lines",1,1,2
buf && path && *path,1,1,2
"!strcmp(looked_up_ref->name, ref_two_name)",1,1,2
"git_oid_streq(git_submodule_wd_oid(sm), ""5e4963595a9774b90524d35a807169049de8ccad"") == 0",1,1,2
(st.st_mode & 0111) == 0,1,1,2
entry->file_size == strlen(ALL_LF_TEXT_AS_CRLF),1,1,2
sim < 30,1,1,2
"""foobar"", values[1]",2,0,2
"diff, 4, true",2,0,2
"48, newno",1,1,2
"31, git_diff_patch_size(patch, 0)",1,1,2
"0, cancel_after",2,0,2
"GIT_EEXISTS, git_branch_move(&new_ref, original_ref, ""cannot-fetch"", 0, NULL, NULL)",1,1,2
out && merge_result,1,1,2
"""*test*"", GIT_REF_LISTALL, 4",1,1,2
"!strcmp(looked_up_ref->name, packed_head_name)",1,1,2
"expect[i + cb_count], iter.ptr",1,1,2
expected.line_adds == 12,1,1,2
"GIT_DIR_PUSH, ""HEAD~4:refs/remotes/frotz/new"", true",1,1,2
canonical_branch_name,1,1,2
"!git__suffixcmp(git_repository_workdir(_repo), ""root/b/c_wd/"")",2,0,2
dup != NULL,1,1,2
path_len > fi->root_len,1,1,2
"git_oid_cmp(&id, &idm) == 0",1,1,2
def->free && (def->from_odb || def->parse),1,1,2
"!strcmp(git_note_message(_note), ""hello world\n"")",1,1,2
"GIT_EINVALIDSPEC, git_reflog_rename(master, ""refs/heads/Inv@{id"")",1,1,2
"GIT_REPOSITORY_STATE_CHERRY_PICK, git_repository_state(_repo)",1,1,2
" GIT_EUSER, git_tree_walk( tree, treewalk_stop_immediately_cb, GIT_TREEWALK_PRE, NULL)",1,1,2
storage,1,1,2
"GIT_EEXISTS, git_remote_rename(&problems, _remote, ""test"")",1,1,2
"GIT_BRANCH_LOCAL | GIT_BRANCH_REMOTE, 13",1,1,2
"GIT_ENOTFOUND, git_submodule_lookup(&sm, repo, ""subdir"")",2,0,2
branch_names && repo,1,1,2
"expected[d] && !strcmp(expected[d], ""<END>""), file, line, ""found fewer deltas than expected"", expected[d], 1",1,1,2
"git_submodule_lookup(NULL, g_repo, ""nonexistent"") == GIT_NOTFOUND",1,1,2
"7, data.count",1,1,2
tag && tag->object.source.open,1,1,2
"true, git_path_isvalid(NULL, ""../foo"", 0)",2,0,2
"31 + 16, git_diff_patch_size(patch, 1, 1, 0)",1,1,2
"0, file, line, ""expected end of deltas, but found more"", patch_text, 1",1,1,2
"entry = git_index_get_bypath(g_idx, ""Just_A_Dir/file3.txt"", 0)",2,0,2
"git_path_basename_r(base, sizeof(base), A) >= 0",1,1,2
"""core.filemode"", false",1,1,2
"""\tLeading \ttabs"", ""\tLeading\n\ttabs\n\nis preserved""",1,1,2
idx == TEST_ENTRIES[i].index,1,1,2
"strcmp(author1->name, committer_name) == 0",1,1,2
start_path && repository_path && size > 0,1,1,2
grow_len > 0,1,1,2
file_path && path_out && size > 0,1,1,2
walk && refname,2,0,2
behind == 4,1,1,2
"""tags/c-"", ""HEAD^"", repo, &opts, true",1,1,2
submodule && status,1,1,2
"2, git_reflog_entrycount(reflog)",1,1,2
status == GIT_STATUS_ADDED || status == GIT_STATUS_DELETED,1,1,2
walk && commit_object,1,1,2
"expected_log_message, git_reflog_entry_message(entry)",1,1,2
"GetShortPathNameW(dest, shortPath, MAX_PATH) > 0",1,1,2
"buffer.ptr, """"",2,0,2
"false, git_clone__should_clone_local(path, GIT_CLONE_NO_LOCAL)",1,1,2
giterr_last()->klass == expected_result,1,1,2
"false, git_oid_cmp(&oid, &next_top_stash_id) == 0",1,1,2
oid && index && repo,2,0,2
"""c-"", ""HEAD^^2"", repo, &opts, &fmt_opts, true",1,1,2
"""core.filemode"", expect_filemode_support()",1,1,2
"strcmp(git_tree_entry_name(entry), ""README"") == 0",1,1,2
idx && stats,1,1,2
"!git_oid_cmp(&id, git_reference_oid(ref))",1,1,2
"git_attr_cache__is_cached(g_repo, ""sub/.gitattributes"")",1,1,2
"tree, ""ab/de/fgh/i-do-not-exist.txt"", 0, ""3259a6bd5b57fb9c1281bb7ed3167b50f224cb54""",1,1,2
tag && message,1,1,2
"strlen(""lstat_nonexistent""), st.st_size",2,0,2
"GIT_DIR_PUSH, ""refs/heads/*/*/for-linus:refs/remotes/mine/*"", false",1,1,2
"false, git_path_isvalid(NULL, "".git/foo"", GIT_PATH_REJECT_DOT_GIT)",1,1,2
n1,1,1,2
"GIT_DIR_PUSH, "":refs/remotes/frotz/delete me"", false",1,1,2
"strncmp(""Ivory their outposts were—the guardrooms of them gilded,\n"", text, textlen) == 0",1,1,2
"st.st_mode & 0111, entry->mode & 0111",1,1,2
(*repo_out)->is_bare == is_bare,1,1,2
to && (to->flags & GIT_DIFF_FLAG__IS_RENAME_TARGET) != 0,1,1,2
"git_treebuilder_get(builder, ""aardvark"") != NULL",2,0,2
"GIT_EAMBIGUOUS, ""e90810b8df3e80c413d903f631643c716887138d"", GIT_OBJ_ANY",1,1,2
"GIT_EAMBIGUOUS, result",1,1,2
"nr_before, nr_after",1,1,2
"EXPECTED_HUNK, formatted_output",1,1,2
filename && remote,1,1,2
"repository, ""branch.test.merge"", false",2,0,2
"GIT_SUBMODULE_RECURSE_YES, git_submodule_fetch_recurse_submodules(sm2)",1,1,2
"GIT_EORPHANEDHEAD, git_repository_detach_head(repo)",1,1,2
git_diff_stats_insertions(stats) == 7,1,1,2
"strcmp(expected->remote_url, url) == 0",1,1,2
"""d616d97082eb7bb2dc6f180a7cca940993b7a56f\n"", 41, ""rebase/.git/ORIG_HEAD""",2,0,2
"GIT_ENOTFOUND, git_stash_drop(repo, 42)",1,1,2
"""R-"", ""HEAD^^^"", repo, &opts, true",1,1,2
"""Yu V. Bin Haacked"", signature->email",1,1,2
"(int)strlen(""refs/heads/master"") + 1, git_branch_tracking_name(NULL, 0, repo, ""refs/heads/track-local"")",1,1,2
exp.files == 8,1,1,2
"0, git_oid_cmp(&before_previous->oid_cur, &after_next->oid_old)",1,1,2
"0100755, read_filemode(""executable.txt"")",1,1,2
"git_remote__urlfordirection(_remote2, GIT_DIR_FETCH), ""git://github.com/libgit2/fetchlibgit2""",1,1,2
git_diff_stats_insertions(stats) == 1,1,1,2
"8, buf1.asize",2,0,2
"GIT_REPOSITORY_STATE_MERGE, git_repository_state(_repo)",1,1,2
" GIT_SUBMODULE_IGNORE_UNTRACKED, git_submodule_ignore(sm2)",1,1,2
"err_state.error_msg.message != static_message, ""pointer to static buffer exposed""",1,1,2
index && entry,1,1,2
"git_repository_path(_repo), ""info"", filemode, GIT_REPOSITORY_INIT_SHARED_GROUP | S_IFDIR",1,1,2
"strcmp(sign->name, ""nulltoken"") == 0",1,1,2
"GIT_EBAREREPO, git_reset(bare, target, GIT_RESET_HARD, NULL, NULL, NULL)",1,1,2
" git_remote_url(g_remote), ""http://github.com/libgit2/libgit2""",2,0,2
"git_attr_cache__is_cached(g_repo, "".gitignore"")",1,1,2
sucessfully_found == data->expected_matches,1,1,2
"""message3"", git_reflog_entry_message(entry3)",1,1,2
git_atomic_get(&git__n_inits) > 0,2,0,2
(onto->opts.flags & GIT_DIFF_IGNORE_CASE) != 0 && (from->opts.flags & GIT_DIFF_IGNORE_CASE) != 0,1,1,2
"GIT_DIR_FETCH, ""refs/heads/*:refs/remotes/frotz"", false",1,1,2
fetchhead_ref_out && oid && ref_name && remote_url,1,1,2
"&branch_list, ""refs/remotes/nulltoken/HEAD""",1,1,2
ahead == 0,1,1,2
"true, git_clone__should_clone_local(path, GIT_CLONE_LOCAL)",1,1,2
exp.hunks == 8,1,1,2
"push_refspec, array.strings[0]",1,1,2
"GIT_BRANCH_LOCAL | GIT_BRANCH_REMOTE, 6 + 1",1,1,2
git_reference_type(branch) == GIT_REF_OID,1,1,2
"(lengths = git__calloc(num, sizeof(size_t)))",1,1,2
(expected & 0600) == (actual & 0777),1,1,2
"strcmp(ref_name_from_tag_name.ptr, loose_tag_ref_name) == 0",1,1,2
blob && as_path && out,1,1,2
"GIT_FILEMODE_BLOB, returned_entry->mode",2,0,2
" sm2, ""submodule.""SM2"".url"", ""branch.origin.remote""",1,1,2
"hunks, git_diff_patch_num_hunks(patch)",1,1,2
exp.files == 16,1,1,2
"entry = git_index_get_byindex(index, 0)",1,1,2
"GIT_DIR_FETCH, ""refs/heads/*/*/for-linus:refs/remotes/mine/*"", false",1,1,2
err < (sizeof(http_strerror_tab)/sizeof(http_strerror_tab[0])),2,0,2
"NULL, git_index_get_bypath(index, ""executable.txt"", 3)",2,0,2
"""refs/heads/*"", GIT_REF_LISTALL, 10",1,1,2
status_flags,1,1,2
dest->path,1,1,2
"strcmp(committer->email, ""schacon@gmail.com"") == 0",1,1,2
"GIT_DIR_PUSH, ""refs/heads:refs/remotes/frotz/*"", false",1,1,2
"""refs/remotes/test/master"", git_buf_cstr(&tracking_name)",1,1,2
filename = malloc(filename_len),1,1,2
"""../../../sm_gitmodules_only/"", worktree_path",1,1,2
"strcmp(conflict_entry[0]->path, ""conflicts-one.txt"") == 0",1,1,2
"index_mods, vals.index_mods",1,1,2
repo->index != NULL,1,1,2
exp.line_ctxt == test_expects[i].line_ctxt,1,1,2
"""e"", ""HEAD^^^"", repo, &opts, false",1,1,2
exp.line_ctxt == 6,1,1,2
"0, git_oid_cmp(&before_next->oid_cur, &after_next->oid_cur)",1,1,2
"memcmp(git_blob_rawcontent(blob), AUTOMERGEABLE_MERGED_FILE, entry->file_size) == 0",1,1,2
(leaks == 0),2,0,2
(ref_in_pack->flags & GIT_REF_PACKED) != 0,1,1,2
" GIT_EINVALIDSPEC, git_reference_rename(&renamed_ref, looked_up_ref, ""Hello! I'm a very invalid name."", 0, NULL, NULL)",1,1,2
count == 5,1,1,2
file && backend && ref,1,1,2
"dummy = git__calloc(1, sizeof(struct git_commit))",2,0,2
"0 == strcmp(expected->name, actual->name)",1,1,2
"""A-3-"", ""HEAD^^2"", repo, &opts, true",1,1,2
len < n,1,1,2
"(loose_object_mode(TEMP_REPO_FOLDER, (git_object *)tree) & 0777) == GIT_OBJECT_FILE_MODE",1,1,2
"""core.ignorecase"", true",1,1,2
"&branch_list, ""remotes/nulltoken/master""",1,1,2
(size_t)g_len[i] == git_blob_rawsize(blob),1,1,2
"GIT_EINVALIDSPEC, git_reference_rename(looked_up_ref, ""i-will-sudo-you"", 0)",1,1,2
"GIT_EBAREREPO, git_index_add_from_workdir(index, ""test.txt"")",1,1,2
"""this also \""has\"" quotes"", git_buf_cstr(&buf)",2,0,2
"git_blob_id(d), &delta->old_file.id",2,0,2
"GIT_EUNBORNBRANCH, git_repository_detach_head(repo, NULL)",1,1,2
counts == 7,1,1,2
transfer_progress_calls > 0,1,1,2
"git_note_message(note), git_blob_rawcontent(blob)",1,1,2
exp.file_adds == test_expects[i].file_adds,1,1,2
to->similarity == 0,1,1,2
"6, num_d",1,1,2
HTTP_PARSER_ERRNO(parser) == HPE_OK,2,0,2
"GIT_SUBMODULE_RECURSE_ONDEMAND, git_submodule_fetch_recurse_submodules(sm)",1,1,2
commit && committer_sig,1,1,2
"git_signature__equal(author, git_commit_author(commit))",2,0,2
"tree, ""nope/de/fgh/1.txt"", GIT_NOTFOUND, NULL",1,1,2
"GIT_EINVALIDSPEC, git_branch_move(&new_ref, original_ref, ""Inv@{id"", 0, NULL)",1,1,2
"9, exp.file_status[GIT_DELTA_UNTRACKED]",1,1,2
new_commit,2,0,2
"false, git_path_isvalid(NULL, ""../foo"", GIT_PATH_REJECT_TRAVERSAL)",2,0,2
"""hi\nbye!\n"", buf.ptr",1,1,2
"2, n",2,0,2
(expect_mode & 0170000) == (st.st_mode & 0170000),1,1,2
"git_submodule_lookup(&sm, g_repo, ""not_submodule"") == GIT_EEXISTS",1,1,2
direction == GIT_DIRECTION_FETCH || direction == GIT_DIRECTION_PUSH,2,0,2
"git_remote__urlfordirection(_remote2, GIT_DIR_PUSH), ""git://github.com/libgit2/pushlibgit2""",1,1,2
(GetFileAttributes(_repo->path_repository) & FILE_ATTRIBUTE_HIDDEN) != 0,1,1,2
expected.line_dels == 3,1,1,2
expected[d] == NULL,1,1,2
"""neither/remotely"", GIT_BRANCH_REMOTE",1,1,2
"strstr(git_lasterror(), ""parentheses not balanced"") != NULL",1,1,2
"(loose_object_mode(REPOSITORY_FOLDER, (git_object *)commit) & 0777) == GIT_OBJECT_FILE_MODE",1,1,2
out && committish,1,1,2
"git_merge_head_id(branch_head), git_reflog_entry_id_old(reflog_entry)",1,1,2
backend->refcache.packfile,1,1,2
"git_merge_head_id(branch), git_reference_target(branch_ref)",1,1,2
" 80, git_atomic_get(&counts[2])",1,1,2
"""A-3-"", ""HEAD^^2"", repo, &opts, &fmt_opts, true",1,1,2
expected.line_adds == 5,1,1,2
pool && pool->item_size >= sizeof(void*),1,1,2
path && path_out,2,0,2
"1, git_index_entrycount(index)",2,0,2
"expected[d], patch_text, file, line, ""expected diff did not match actual diff"", 1",1,1,2
err == REG_ESPACE,2,0,2
"""UPDAAAAAATE!!"", git_reflog_entry_message(entry)",2,0,2
"""refs/heads/development"", git_reference_target(ref)",1,1,2
(st.st_mode & S_ISGID) != 0,1,1,2
"GIT_ENOTFOUND, git_odb_exists_prefix(NULL, odb, &id2, 8)",1,1,2
_n_inits,1,1,2
(caps & GIT_HAS_HTTPS) == 0,1,1,2
"result = merge_simple_branch(0, GIT_CHECKOUT_CONFLICT_STYLE_DIFF3)",1,1,2
"0 == strcmp(found_path, expected_path)",1,1,2
"1, expected.file_unmodified",1,1,2
path_a && path_b,1,1,2
tgt != src,2,0,2
"repo, ""refs/remotes/origin/pr/42""",2,0,2
"43 + 1640, nobj",1,1,2
"strncmp(""All the world went softly when it walked before my Cities--\n"", text, textlen) == 0",1,1,2
"""message1"", git_reflog_entry_message(entry1)",1,1,2
"""f87d14a4a236582a0278a916340a793714256864\n"", 41, ""rebase/.git/ORIG_HEAD""",2,0,2
"&oid, &check",2,0,2
link && target && target_len > 0,1,1,2
""""", signature->name",1,1,2
"GIT_BRANCH_LOCAL | GIT_BRANCH_REMOTE, 11",1,1,2
"git_hashtable_lookup(table, &id) == NULL",1,1,2
ref_out && repo,1,1,2
"""../testrepo.git"", git_submodule_url(sm)",2,0,2
"590, git_pool__open_pages(&p)",1,1,2
""""", git_blob_rawcontent(blob)",2,0,2
"GIT_ENOTFOUND, git_merge_base_many(&oid, _repo, oids, count)",1,1,2
cfg && backend,1,1,2
"""message2"", git_reflog_entry_message(entry2)",1,1,2
"diff, 1, false",2,0,2
(leaks == 2),2,0,2
"false, ""test_folder/file""",2,0,2
"GIT_ERROR, git_index_add_from_workdir(index, ""test.txt"")",1,1,2
"expected[d] && !strcmp(expected[d], ""<END>"")",1,1,2
"GIT_ENOTFOUND, git_buf_text_lf_to_crlf(&tgt, &src)",1,1,2
stream && db,2,0,2
in_head && !in_index && !in_workdir && (tree_entry_type == GIT_OBJ_TREE),1,1,2
expected.hunk_old_lines == 14,1,1,2
"entry = git_index_get_bypath(g_idx, ""JUST_A_DIR/file2.txt"", 0)",2,0,2
repo && branch && (upstream || onto),1,1,2
"""TestGitRepository"", ""https://github.com/libgit2/TestGitRepository""",2,0,2
"GIT_REPOSITORY_STATE_NONE, git_repository_state(_repo)",1,1,2
reader->read_ptr,2,0,2
"entry->path, dup1->path",1,1,2
"result = merge_simple_branch(GIT_MERGE_FILE_FAVOR_UNION, 0)",1,1,2
"result = merge_simple_branch(0, GIT_CHECKOUT_CONFLICT_STYLE_MERGE)",1,1,2
"""refs/heads/*"", GIT_REF_LISTALL, 7",1,1,2
"GIT_OBJ_COMMIT, git_object_type(target)",1,1,2
"NULL , "" """,2,0,2
"GIT_SUBMODULE_IGNORE_UNTRACKED, git_submodule_ignore(sm)",1,1,2
"17, (int)refnames.count",2,0,2
" GIT_EINVALIDSPEC, git_remote_add(&remote, _repo, ""Inv@{id"", ""git://github.com/libgit2/libgit2"")",1,1,2
"""hard_tag"", ""HEAD"", repo, &opts, &fmt_opts, false",1,1,2
"false, ""dir1/file""",2,0,2
" GIT_FILEMODE_BLOB_GROUP_WRITABLE, git_tree_entry_filemode(entry)",1,1,2
"""foo@example.com"", git_reflog_entry_committer(entry2)->email",1,1,2
"1, git_graph_descendant_of(_repo, git_commit_id(commit), git_commit_id(other))",2,0,2
"GIT_DIR_FETCH, ""refs/heads/master:refs/remotes/frotz/xyzzy"", true",1,1,2
(reference->type & GIT_REF_PACKED) != 0,1,1,2
status && sm,1,1,2
oid && repo && source_cb,1,1,2
in_head && !in_index && !in_workdir,1,1,2
ref_list.count == 0,1,1,2
e && index,1,1,2
i == INT64_MIN,2,0,2
"""A-"", NULL, repo, &opts, &fmt_opts, true",1,1,2
nobj == 1681,1,1,2
s->verb == post_verb,2,0,2
"&expected_oid, git_object_id(peeled)",2,0,2
"""file.txt"", filename",1,1,2
out && host,2,0,2
info && path,1,1,2
db && ids && id_lengths,1,1,2
"git_merge_head_id(branch), git_reference_target(head_ref)",1,1,2
"GIT_EEXISTS, git_remote_rename(&problems, _remote, ""test_with_pushurl"")",1,1,2
refdb && name && ((oid && !symbolic) || (!oid && symbolic)),1,1,2
"(fd = p_open(path->ptr, O_RDWR)) >= 0",1,1,2
"strcmp(conflicting_buf.ptr, CONFLICTING_MERGE_FILE) == 0",2,0,2
"GIT_EINVALIDSPEC, ""7b4384978d2493e851f9cca7858815fac9b10980"", GIT_OBJ__EXT2",1,1,2
"0, file, line, err, buf, 1",1,1,2
"!git_path_exists(""b.txt"")",2,0,2
"47, oldno",1,1,2
"sizes[1], git_diff_patch_size(patch, 1, 0, 0)",1,1,2
"GIT_EEXISTS, git_branch_create(&branch, repo, ""br2"", target, 0, NULL)",1,1,2
"(int)old_update, (int)git_submodule_update_strategy(sm1)",1,1,2
" GIT_EUSER, git_tree_walk( tree, treewalk_stop_immediately_cb, GIT_TREEWALK_POST, NULL)",1,1,2
oid && file && file->digest,1,1,2
"entry->path, filename",1,1,2
"git_oid_cmp(git_reference_target(ref1), git_reference_target(ref2)) == 0",1,1,2
"strlen(""refs/heads/master"") + 1, git_branch_tracking_name(NULL, 0, repo, ""refs/heads/track-local"")",1,1,2
"""refs/heads/*"", GIT_REF_LISTALL, 11",1,1,2
"GIT_DIR_FETCH, ""refs/heads/*/for-linus:refs/remotes/mine/*"", true",1,1,2
"tree, ""ab/me-neither/fgh/2.txt"", GIT_NOTFOUND, NULL",1,1,2
"strcmp(msg, ""Hello world!"") == 0",1,1,2
list.count == 1,1,1,2
"GIT_EUNBORNBRANCH, git_repository_detach_head(repo, NULL, NULL)",1,1,2
"true, ""dir1/dir2/dir3/dir1/subdir/foo""",2,0,2
"revision.flags, expected_revparseflags",1,1,2
"(entry_idx = git_index_find(repo_index, ""two.txt"")) >= 0",1,1,2
"6, exp.hunks",1,1,2
"git_oid_cmp(git_reference_oid(ref), git_reference_oid(ref2)) == 0",1,1,2
"25, (int)range->new_start",1,1,2
"git_oid_cmp(&id1, &entry->id) == 0, ""second oid check""",1,1,2
"GIT_MERGE_CONFIG_NO_FASTFORWARD, (merge_config & GIT_MERGE_CONFIG_NO_FASTFORWARD)",1,1,2
"git__suffixcmp(out, path.ptr) == 0",1,1,2
"strcmp(reference->name, packed_head_name) == 0",1,1,2
"6, oldno",1,1,2
"""refs/heads/*"", GIT_REF_LISTALL, 12",1,1,2
buffer,1,1,2
"&expected_final_id, &commit_id",2,0,2
"git_note_message(note), ""hello world\n""",1,1,2
patch->hunks_size > 0,1,1,2
hash && key_eq,1,1,2
"(int)expected_st.st_mode, (int)st.st_mode",1,1,2
"252, line->content_offset",2,0,2
"!git_path_exists(""tmp"")",2,0,2
"0, _remote->refspecs.length",1,1,2
"GIT_DIR_FETCH, ""refs/heads/master::refs/remotes/frotz/xyzzy"", false",1,1,2
" ""refs/heads/master"", git_reference_symbolic_target(reference)",1,1,2
"e = git_index_get_bypath(index, ""COPYING"", 0)",2,0,2
"0, git_oid_cmp(&oid, git_reflog_entry_oidold(entry))",1,1,2
delta->status == GIT_DELTA_UNMODIFIED || delta->binary == 1,1,1,2
"strcmp(reference->name, packed_test_head_name) == 0",1,1,2
"1, filter_for(""foo.txt"", ""crlf"")",2,0,2
"11, exp.files",1,1,2
"2, _remote->refspec_strings.length",1,1,2
"GIT_ENOTFOUND, git_repository_set_head(repo, ""refs/tags/doesnt/exist/yet"", NULL)",1,1,2
"""hard_tag"", ""HEAD"", repo, &opts, false",1,1,2
"expected_st.st_mode, st.st_mode, ""%07o""",1,1,2
"""d616d97082eb7bb2dc6f180a7cca940993b7a56f\n"", 41, ""rebase/.git/rebase-merge/cmt.1""",2,0,2
str_b < buf->ptr || str_b >= buf->ptr + buf->size,2,0,2
"git_attr_cache__is_cached( g_repo, GIT_ATTR_FILE__FROM_FILE, ""sub/.gitattributes"")",2,0,2
transport == &_transport,2,0,2
pack_progress_calls > 0,1,1,2
pi->diff,1,1,2
"expected1, actual.ptr",2,0,2
"delta->new_file.path, ""b/file.txt""",1,1,2
"GIT_EBAREREPO, git_diff_workdir_to_tree(g_repo, &opts, tree, &diff)",1,1,2
"pass, ""pass%2fis%40bad""",1,1,2
" sm3, ""submodule.""SM3"".url"", ""branch.origin.remote""",1,1,2
"_repo, ""remote.volatile.url"", false",1,1,2
"6, (int)range->new_start",1,1,2
"git_oid_cmp(&blob_oid, &entry->oid) == 0",1,1,2
"diff, 8, false",2,0,2
v && key && key_lookup,2,0,2
pool && a && b && pool->item_size == sizeof(char),1,1,2
"GIT_ENOTFOUND, git_revparse_single(&g_obj, g_repo, ""subtrees:ab/42.txt"")",1,1,2
index && entry && entry->path != NULL,1,1,2
!self->is_resizing,1,1,2
oid && signature && log_message,1,1,2
reference,1,1,2
"GIT_MERGE_CONFIG_NO_FASTFORWARD, (analysis & GIT_MERGE_CONFIG_NO_FASTFORWARD)",1,1,2
"git_diff_num_deltas(diff), 1",2,0,2
repo && branch_name,1,1,2
"false, git_path_isvalid(NULL, ""foo/bar/.Git"", GIT_PATH_REJECT_DOT_GIT)",1,1,2
"!revparse_lookup_object(&cur_obj, repo, git_buf_cstr(&specbuffer))",1,1,2
ref_name,1,1,2
"3, git_diff_stats_deletions(_stats)",2,0,2
exp.hunks == 3,1,1,2
"git_tree_cache_get(index->tree, ""subdir"")",2,0,2
out && repo && (our_tree || their_tree),1,1,2
git_oid_iszero(&delta->new_file.id),2,0,2
expected.line_dels == 1,1,1,2
""".HEADER"", dup2->path",1,1,2
"0, lengths[i]",1,1,2
exp.line_adds == 3,1,1,2
behind == 0,1,1,2
"git_oid_cmp(git_reference_target(read2), git_reference_target(write2)) == 0",1,1,2
"ids, lengths, NULL",1,1,2
"git_remote_supported_url(""ssh://git@github.com/libgit2/libgit2.git"")",1,1,2
"!strcmp(another_looked_up_ref->name, brand_new_name)",1,1,2
"false, git_repository_head_orphan(repo)",1,1,2
"8, num_d",1,1,2
"0, git_oid_streq(blob_oid, expectations->sha)",1,1,2
!options || !options->pathlist,1,1,2
exp.lines == test_expects[i].lines,1,1,2
"GIT_ENOTFOUND, git_stash_drop(repo, 666)",1,1,2
"GIT_ENOTFOUND, git_revparse_single(&g_obj, g_repo, ""subtrees:nope"")",1,1,2
"ref_list.count, 10",1,1,2
"GIT_ALLOC_OVERFLOW_ADD(SIZE_MAX, SIZE_MAX)",1,1,2
"""welcome"", str",1,1,2
"disable8dot3 ? "".foo"" : ""FOO~1"", (shortname = git_win32_path_8dot3_name("".foo""))",1,1,2
"GIT_BRANCH_REMOTE, 1",1,1,2
diff && old_index && new_index,1,1,2
"!git_strmap_exists(g_table, ""abcdefghi"")",2,0,2
"git_buf_cstr(&buf), git_reflog_entry_message(entry)",2,0,2
expected.line_dels == 14,1,1,2
"GIT_BRANCH_LOCAL, 10",1,1,2
type == GIT_OBJ_OFS_DELTA,1,1,2
"git_buf_cstr(unslashify(&path2)), buf",1,1,2
"GIT_NOTFOUND, git_repository_discover(found_path, sizeof(found_path), SUB_REPOSITORY_FOLDER_SUB_SUB_SUB, 0, ceiling_dirs)",1,1,2
"nentries_master, entrycount(repo, ""refs/heads/master"")",2,0,2
"git_remote__urlfordirection(_remote, GIT_DIR_FETCH), ""git://github.com/libgit2/libgit2""",1,1,2
"git_repository_path(_repo), ""description"", filemode, (GIT_REPOSITORY_INIT_SHARED_GROUP | S_IFREG) & ~(S_ISGID | 0111)",1,1,2
"!strcmp(git_remote_url(remote), ""git://github.com/libgit2/libgit2"")",1,1,2
"""R-"", ""HEAD^^^"", repo, &opts, &fmt_opts, true",1,1,2
" cl_fixture(""template""), git_repository_path(_repo), ""hooks/update.sample"", filemode, (GIT_REPOSITORY_INIT_SHARED_GROUP | S_IFREG) & ~S_ISGID",1,1,2
exp.line_adds == test_expects[i].line_adds,1,1,2
"GIT_ENOTFOUND, git_repository_message(&actual, _repo)",2,0,2
exp.file_unmodified == 1,1,1,2
first != NULL || second != NULL || third != NULL,1,1,2
self && tgt && src,1,1,2
"GIT_DELTA_DELETED, git_patch_delta(p)->status",1,1,2
delta->new_file.path,1,1,2
!g_repo,2,0,2
"""A-"", ""HEAD^^2"", repo, &opts, true",1,1,2
"git_signature__equal(signature, git_commit_committer(commit))",2,0,2
ref_list.count == 9,1,1,2
"git_attr_cache__is_cached(g_repo, "".gitattributes"")",1,1,2
"GIT_BRANCH_LOCAL | GIT_BRANCH_REMOTE, 8",1,1,2
"GIT_ENOTFOUND, git_repository_discover(&found_path, SUB_REPOSITORY_FOLDER_SUB_SUB_SUB, 0, ceiling_dirs)",2,0,2
"1, _remote->refspecs.length",1,1,2
"entry = git_index_get_bypath(g_idx, ""Just_A_Dir/FILE3.txt"", 0)",2,0,2
"expectedRemoteNameLength, git_branch_remote_name(remotename, expectedRemoteNameLength, g_repo, ref)",1,1,2
"0, giterr_capture(&err_state, 0)",1,1,2
"index->entries._cmp(prev, curr) <= 0",1,1,2
"GIT_SUBMODULE_RECURSE_YES, git_submodule_fetch_recurse_submodules(sm)",1,1,2
"strcmp(ref_name, ""name"") == 0",1,1,2
"""core.ignorecase"", GIT_ENOTFOUND",1,1,2
te != NULL,1,1,2
input && repo && file,1,1,2
"""e-3-"", ""HEAD"", repo, &opts, &fmt_opts, true",1,1,2
"false, git_path_isvalid(NULL, ""foo "", GIT_PATH_REJECT_TRAILING_SPACE)",2,0,2
"GIT_MERGE_CONFIG_FASTFORWARD_ONLY, (merge_config & GIT_MERGE_CONFIG_FASTFORWARD_ONLY)",1,1,2
"&reuc->oid[2], &their_oid",2,0,2
(caps & GIT_HAS_SSH) != 0,1,1,2
"objstr, expected",1,1,2
"git_remote_supported_url(""https://git@github.com/libgit2/libgit2.git"")",1,1,2
" cl_fixture(""template""), git_repository_path(_repo), ""hooks/link.sample"", true, 0",1,1,2
"git_reference_target(comp_base_ref), git_reference_target(resolved_ref)",2,0,2
"2, num_d",1,1,2
"""other value"", entry->value",2,0,2
"GIT_DIR_PUSH, "":refs/remotes/frotz/deleteme"", true",1,1,2
"NULL, git_commit_message_encoding(commit)",2,0,2
spec && str,1,1,2
"host, ""github.com""",1,1,2
"9, git_diff_patch_num_lines_in_hunk(p, 1)",1,1,2
"""testfile"", testfile",1,1,2
"!strcmp(str, ""hi, this is a ; multiline comment # with ;\n special chars and other stuff !@#"")",1,1,2
ahead == 8,1,1,2
exp.line_adds == 14,1,1,2
reflog && ref,1,1,2
remote && transport,1,1,2
"""refs/heads/master"", git_buf_cstr(&tracking_name)",1,1,2
"git_repository_path(_repo), ""hooks"", GIT_REPOSITORY_INIT_SHARED_GROUP | S_IFDIR",1,1,2
expected_str,1,1,2
"""just_a_dir/FILE3.txt"", entry->path",2,0,2
"""core.precomposeunicode"", false",1,1,2
path_out && file_path && path_out,1,1,2
"memcmp(expected_data, buf, bytes) == 0, file, line, ""file content mismatch"", path, 1",1,1,2
"git__prefixcmp(git_lasterror(), ""My Message"") == 0",1,1,2
show <= GIT_STATUS_SHOW_INDEX_THEN_WORKDIR,1,1,2
"port, ""1111""",1,1,2
"GIT_ERROR, ""53fc32d17276939fc79ed05badaef2db09990016"", GIT_OBJ_ANY",1,1,2
tracking_ref && branch_ref,1,1,2
"""refs/heads/foo"", git_reference_symbolic_target(ref)",2,0,2
out && repo && cherry_pick_commit && our_commit,1,1,2
"expected, newno - lastnewno",1,1,2
"expected_flags, flags",1,1,2
"!git_remote_supported_url(""https://git@github.com/libgit2/libgit2.git"")",1,1,2
"git_path_dirname_r(&modpath, modpath.ptr) >= 0",1,1,2
"&branch_list, ""refs/remotes/nulltoken/master""",1,1,2
" (int)GIT_SUBMODULE_IGNORE_UNTRACKED, (int)git_submodule_set_ignore(sm1, GIT_SUBMODULE_IGNORE_DEFAULT)",1,1,2
out && index,1,1,2
expected_len == git_status_list_entrycount(status_list),1,1,2
"46 + 1640, nobj",1,1,2
repo && out,2,0,2
"6, (int)num_d",1,1,2
e && index_entry,1,1,2
remote && bytes,1,1,2
"str, ""baz2""",1,1,2
db && refname,2,0,2
"0 == git_oid_cmp(oid, &oid2)",1,1,2
exp.file_untracked == 5,1,1,2
expected.line_adds == 9,1,1,2
"GIT_DIR_FETCH, ""master~1:refs/remotes/frotz/backup"", false",1,1,2
"GIT_DELTA_MODIFIED, git_patch_delta(p)->status",1,1,2
"55, git_pool__open_pages(&p)",1,1,2
"GIT_DIR_FETCH, ""refs/heads/ nitfol"", false",1,1,2
"2, branch_list.count",1,1,2
"""tags/c-"", ""HEAD^"", repo, &opts, &fmt_opts, true",1,1,2
string && patch,1,1,2
lov <= hiv,1,1,2
"""create!"", git_reflog_entry_message(entry)",1,1,2
tree && tree->object.source.open,1,1,2
"git_oid_cmp(git_reference_oid(ref1), git_reference_oid(ref2)) == 0",1,1,2
expected.line_dels == 4,1,1,2
content,1,1,2
"!GIT_PERMS_IS_EXEC(read_filemode(""a/b.txt""))",2,0,2
"git_oid_streq(&entry->oid_cur, br2_tip) == 0",1,1,2
exp.hunks == 5,1,1,2
"""refs/heads/*"", GIT_REF_LISTALL, 8",1,1,2
is_multiline_var(value->ptr),1,1,2
"true, git_repository_is_bare(repo)",2,0,2
"""even higher level"", var_contents.ptr",2,0,2
"6, git_index_entrycount(index)",1,1,2
type == GIT_OBJ_COMMIT,1,1,2
(dup1->flags_extended & GIT_IDXENTRY_ALLOCATED) != 0,1,1,2
"(expected & 0600), (actual & 0777), ""%07o""",1,1,2
"strcmp(sign->name, ""xx"") == 0",1,1,2
"GIT_DIR_FETCH, ""HEAD:"", true",1,1,2
refdb && name && target,1,1,2
repo && index,1,1,2
" GIT_EAMBIGUOUS, git_revparse(&oid, NULL, NULL, g_repo, ""e90"")",1,1,2
"git_attr_cache__is_cached(g_repo, "".git/info/attributes"")",1,1,2
"10, git_diff_num_deltas(diff)",2,0,2
"entry_count0, entry_paths0, entry_statuses0, repo, GIT_STATUS_SHOW_INDEX_AND_WORKDIR, GIT_STATUS_OPT_UPDATE_INDEX",1,1,2
"hunks, (int)git_diff_patch_num_hunks(patch)",1,1,2
"""c-"", ""HEAD"", repo, &opts, true",1,1,2
"""testrepo/A""",2,0,2
to,1,1,2
"count, 4",1,1,2
"""test-annotated-"", ""HEAD"", repo, &opts, &fmt_opts, true",1,1,2
"!strcmp(str, ""this is \ba phrase"")",1,1,2
challenge_len >= 9,1,1,2
"""don't find me!"", buf.ptr",2,0,2
"1, n",2,0,2
found_path,1,1,2
"GetShortPathNameW(dest, shortPath, IS_8DOT3_BUF_SIZE) > 0",1,1,2
"&expected, &entry->id",2,0,2
"GIT_MERGE_ANALYSIS_NORMAL, analysis",1,1,2
&output,2,0,2
" cl_fixture(""template""), git_repository_path(_repo), ""hooks/update.sample"", true",1,1,2
"0, git_reflog_entrycount(g_reflog)",1,1,2
"strcmp(e->path, test_entries[i].path) == 0",1,1,2
"out, path.ptr",1,1,2
exp.file_adds == 3,1,1,2
"strcmp(passcase->email, person.email) == 0",1,1,2
"""Branch: renamed refs/heads/master to refs/heads/master2"", git_reflog_entry_message(entry)",1,1,2
"24, st.st_size",2,0,2
repo && committer,1,1,2
"strlen(""refs/remotes/origin/master"") + 1, git_branch_tracking_name(tracking_name, 1024, g_repo_cloned, local_name)",1,1,2
"!strcmp(default_ref, GIT_NOTES_DEFAULT_REF)",1,1,2
iter,1,1,2
"""subdir.txt"", delta->new.path",1,1,2
out && ancestor && ours && theirs,1,1,2
"0, git_reflog_entrycount(reflog)",1,1,2
"18, (int)git_diff_patch_num_lines_in_hunk(patch, 1)",1,1,2
"1, refnames.count",1,1,2
"GIT_ENOTFOUND, git_reflog_entry_drop(g_reflog, entrycount, 0)",1,1,2
"""refs/heads/master"", git_reference_name(tracking)",1,1,2
((git_refcount *)odb)->refcount == 2,1,1,2
"git_oid_equal(&id, &index->tree->oid)",2,0,2
"GIT_ENOTFOUND, git_revparse(&oid, NULL, NULL, repo, ""refs/remotes/origin/bim_with_3d@11296"")",1,1,2
"GIT_MERGE_ANALYSIS_UP_TO_DATE, merge_analysis",2,0,2
"""R-"", ""HEAD^^"", repo, &opts, &fmt_opts, true",1,1,2
error == 0,1,1,2
"""\n"", git_commit_message(commit)",1,1,2
passcase->time == person.when.time,1,1,2
dir && n > 1,1,1,2
"0, range->new_lines",1,1,2
commit && author_sig,1,1,2
"6, index",1,1,2
" 13 + 3 , diff->stat_calls",1,1,2
"""Create 2"", git_reflog_entry_message(entry2)",1,1,2
filename && stack,1,1,2
"GIT_ENOTFOUND, git_repository_set_head_detached(repo, &oid, NULL, NULL)",1,1,2
" size_with_context, git_diff_patch_size(patch, 1)",1,1,2
((git_refcount *)new_odb)->refcount == 2,1,1,2
ref_database,1,1,2
"nonblobs, git_cache_size(&g_repo->objects) - start",1,1,2
"git_remote__urlfordirection(_remote, GIT_DIR_PUSH), ""git://github.com/libgit2/libgit2""",1,1,2
branch_name && target && ref_out,1,1,2
out && p && id,1,1,2
act == 0,1,1,2
" GIT_EINVALIDSPEC, git_reference_rename(looked_up_ref, ""Hello! I'm a very invalid name."", 0)",1,1,2
"!git_path_exists(TEST_REPO_PATH ""/.git/CHERRY_PICK_HEAD"")",2,0,2
"18, refnames.count",1,1,2
"1, exp.file_status[GIT_DELTA_CONFLICTED]",2,0,2
"GIT_EORPHANEDHEAD, git_checkout_head(g_repo, NULL)",1,1,2
"""foo@example.com"", git_reflog_entry_committer(entry3)->email",1,1,2
"&id, git_reference_target(looked_up_ref)",2,0,2
"GIT_DIR_FETCH, ""refs/heads*/for-linus:refs/remotes/mine/*"", false",1,1,2
packed_entry - (struct index_entry *)mem == entries,1,1,2
"!strcmp(git_reference_target(ref), ref_branch_name)",1,1,2
_gittest,1,1,2
(caps & GIT_HAS_HTTPS) != 0,1,1,2
mctx->state_log != NULL,2,0,2
"1, git_status_list_entrycount(status_list)",2,0,2
exp.line_dels == 5,1,1,2
tag && name,1,1,2
"tree, ""i-do-not-exist.txt"", 0, tree_with_subtrees_oid",1,1,2
"13, git_diff_patch_num_lines_in_hunk(p, 0)",1,1,2
"GIT_EORPHANEDHEAD, git_stash_save(&stash_tip_oid, repo, signature, NULL, GIT_STASH_DEFAULT)",1,1,2
exp.hunks == 6,1,1,2
"(int)expected, (int)st.st_mode",1,1,2
"4, git_pathspec_match_list_entrycount(matches)",1,1,2
"1, diff->submodule_lookups",1,1,2
zs.avail_in == 0,1,1,2
"!strcmp(looked_up_ref->name, ref_two_name_new)",1,1,2
"git_object_lookup(&obj, g_repo, &id, GIT_OBJ_BLOB) == GIT_EINVALIDTYPE",1,1,2
"13, git_diff_stats_insertions(_stats)",2,0,2
"""efad0b11c47cb2f0220cbd6f5b0f93bb99064b00\n"", 41, ""rebase/.git/rebase-merge/onto_name""",2,0,2
table->size_mask + 1 == 64,1,1,2
"git_repository_path(_repo), ""description"", (GIT_REPOSITORY_INIT_SHARED_GROUP | S_IFREG) & ~(S_ISGID | 0111)",1,1,2
subtree && root && subtree_path,1,1,2
from,1,1,2
"(int)expectedlen, (int)buf.size",1,1,2
git_diff_stats_insertions(stats) == 4,1,1,2
"""*"", GIT_REF_LISTALL, 18",1,1,2
"""*"", GIT_REF_LISTALL, 20",1,1,2
"git_attr_cache__is_cached( g_repo, GIT_ATTR_FILE__FROM_FILE, "".gitattributes"")",2,0,2
"""A-"", ""HEAD^"", repo, &opts, &fmt_opts, true",1,1,2
"GIT_DIR_FETCH, ""HEAD~4:refs/remotes/frotz/new"", false",1,1,2
path_out && file_path && base_path,1,1,2
"GIT_EINVALIDSPEC, git_branch_create(&branch, repo, ""inv@{id"", target, 0, NULL, NULL)",1,1,2
" expected_error, git_submodule_lookup(&sm, repo, name)",1,1,2
exp.line_adds == 24 + 1 + 5 + 5,1,1,2
"GIT_ERROR, ""refs/tags/point_to_blob"", GIT_OBJ_TAG",1,1,2
stage >= 0 && stage <= 3,1,1,2
git_oid_iszero(&delta->old_file.id),2,0,2
"error, GIT_EUSER",1,1,2
expected == (actual & 0777),1,1,2
"native_ignore_case ? testrepo2_subdir_paths_icase[i] : testrepo2_subdir_paths[i], status->index_to_workdir->old_file.path",2,0,2
"git_merge_head_id(branch), git_reflog_entry_id_new(reflog_entry)",1,1,2
"""one.txt""",2,0,2
repo && old_blob && new_blob && options,1,1,2
dest && src,1,1,2
"""....\n"", where.ptr",2,0,2
"git_repository_discover(repository_path, sizeof(repository_path), DISCOVER_FOLDER, 0, ceiling_dirs) == GIT_ENOTAREPO",1,1,2
"0, returned_entry->uid",2,0,2
"wt_mods, vals.wt_mods",1,1,2
"git__prefixcmp(out, path.ptr) == 0",1,1,2
"3, exp[1]",2,0,2
status,2,0,2
"1, (int)git_diff_patch_num_hunks(patch)",1,1,2
"0, entry->file_size",2,0,2
"GIT_EUSER, git_reference_foreach_glob( repo, ""*"", GIT_REF_LISTALL, interrupt_cb, &count) ",1,1,2
"2, exp.hunks",1,1,2
"0100755, read_filemode(""a/b.txt"")",1,1,2
"&oid, git_reference_target(looked_up_ref)",2,0,2
entry->mode == expect_mode,1,1,2
"git_buf_cmp(&out, &g_crlf_filtered[i]) == 0",1,1,2
"git_attr_cache__is_cached(g_repo, "".git/info/exclude"")",1,1,2
"expected_driver, actual.ptr",1,1,2
"strcmp(conflict_entry[0]->path, ""conflicts-two.txt"") == 0",1,1,2
"!git__suffixcmp(git_repository_path(_repo), ""root/b/my_repository/"")",2,0,2
"merge_test_index(index, merge_index_entries, 3)",2,0,2
"git_reference_target(ref1), git_reference_target(ref2)",2,0,2
"git_oid_streq(&id, ""deadbeef"") == -1",1,1,2
"passcase->time, person.when.time",1,1,2
"""7b4384978d2493e851f9cca7858815fac9b10980"", ""7b4384978d2493e851f9cca7858815fac9b10980"", GIT_OBJ_TAG",1,1,2
i == 13,1,1,2
"GIT_ENOTFOUND, git_config_get_multivar(cfg, _name, NULL, cb, &n)",1,1,2
exp.hunk_new_lines == 14,1,1,2
" GIT_EINVALIDSPEC, git_remote_create(&remote, _repo, """", ""git://github.com/libgit2/libgit2"", NULL)",1,1,2
"git_repository_path(_repo), ""info"", GIT_REPOSITORY_INIT_SHARED_GROUP | S_IFDIR",1,1,2
repo && name && oid,1,1,2
"GIT_ENOTFOUND, git_revparse_single(&g_obj, g_repo, "":/not found in any commit"")",1,1,2
"1, range->old_start",1,1,2
"str, ""foo""",1,1,2
buf->asize > buf->size,1,1,2
"git_oid_cmp(&ancestor_entry.id, &conflict_entry[0]->id) == 0",1,1,2
repo && signature,1,1,2
"GIT_EORPHANEDHEAD, git_repository_head_tree(&tree, repo)",1,1,2
"""*"", GIT_REF_LISTALL, 22",1,1,2
"GIT_DIR_FETCH, ""refs/heads/maste :refs/remotes/frotz/xyzzy"", false",1,1,2
out && repo && our_tree && their_tree,1,1,2
"4, (int)range->old_lines",1,1,2
"false, ""dir1/dir2/dir3/DiR1""",1,1,2
"""this!\n"", buf.ptr",2,0,2
db && db->backend && glob && callback,1,1,2
"GIT_NOTFOUND, git_repository_discover(found_path, sizeof(found_path), ALTERNATE_NOT_FOUND_FOLDER, 0, ceiling_dirs)",1,1,2
"""just_a_dir/file1.txt"", entry->path",2,0,2
"2, reserved_len",2,0,2
"""subdir.txt"", delta->old.path",1,1,2
"""B"", ""HEAD^^2^"", repo, &opts, &fmt_opts",2,0,2
location_status && submodule,1,1,2
rule->match.negative,1,1,2
"git_repository__reserved_names(&reserved, &reserved_len, repo, true)",2,0,2
v->_cmp != NULL,1,1,2
"GIT_MERGE_CONFIG_FASTFORWARD_ONLY, (analysis & GIT_MERGE_CONFIG_FASTFORWARD_ONLY)",1,1,2
"1, (int)i",1,1,2
len <= GIT_OID_HEXSZ,1,1,2
reset_type == GIT_RESET_SOFT || reset_type == GIT_RESET_MIXED || reset_type == GIT_RESET_HARD,1,1,2
repo && our_head,1,1,2
"diff, 2, false",2,0,2
id && repo && tree && parent_cb,1,1,2
"!git_remote_supported_url(""ssh://git@github.com/libgit2/libgit2.git"")",1,1,2
"(int)strlen(""refs/remotes/origin/master"") + 1U, git_branch_tracking_name(tracking_name, 1024, g_repo_cloned, local_name)",1,1,2
"""test2-lightweight-"", ""HEAD"", repo, &opts, &fmt_opts, true",1,1,2
expected_status[*index] == s,1,1,2
"1, _remote->refspec_strings.length",1,1,2
"expected_type, types[i]",1,1,2
"1, p_read(fd, &b, 1)",1,1,2
exp.lines == 7 + 24 + 1 + 6 + 6,1,1,2
"GIT_ERROR, ""0266163a49e280c4f5ed1e08facd36a2bd716bcf"", GIT_OBJ_COMMIT",1,1,2
" GIT_EUSER, git_tree_walk(tree, treewalk_stop_cb, GIT_TREEWALK_PRE, &ct)",1,1,2
"46, (int)range->new_start",1,1,2
"GIT_CREDTYPE_SSH_KEY | GIT_CREDTYPE_SSH_CUSTOM, allowed_types",1,1,2
git_vector_is_sorted(entries),1,1,2
"GIT_NOTFOUND, git_path_prettify(&p, NON_EXISTING_FILEPATH ""/so-do-i"", NULL)",1,1,2
"email, git_reflog_entry_committer(entry)->email",2,0,2
"file, line, msg, 1, ""%s"", expected_content, buf.ptr",1,1,2
"git_odb_exists_prefix(&id2, odb, &id, 8)",1,1,2
"""test2-lightweight-"", ""HEAD"", repo, &opts, true",1,1,2
tree && obj,1,1,2
"GIT_ENOTFOUND, git_stash_drop(repo, 3)",1,1,2
"GIT_EINVALIDSPEC, git_branch_move(&new_ref, original_ref, ""Inv@{id"", 0, NULL, NULL)",1,1,2
obj && db && id,1,1,2
git_diff_stats_deletions(stats) == 8,1,1,2
cpy,1,1,2
"GIT_BRANCH_LOCAL, 11",1,1,2
"6, (int)git_diff_patch_num_lines_in_hunk(patch, 0)",1,1,2
db && ids,1,0,1
out && _backend && name,1,0,1
contents_out && filename_out && mode_out && (source || !source_len) && patch,1,0,1
"git_blob_id(a), &delta->old_file.id",1,0,1
" git_remote_url(g_remote), ""https://github.com/libgit2/false.git""",1,0,1
ref && new_name && signature,1,0,1
"""modified_file"", status->index_to_workdir->new_file.path",1,0,1
"config, ""some.section.back"", ""this is \ba phrase""",1,0,1
"false, git_path_isvalid(NULL, "".\xe2\x80\x8fgIt"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"""Test_App2"", git_submodule_name(sm)",1,0,1
"git_attr_cache__is_cached( g_repo, GIT_ATTR_FILE__FROM_FILE, "".git/info/exclude"")",1,0,1
"0, status->index_to_workdir->old_file.mode",1,0,1
"true, ""dir1/dir2/twostars/child""",1,0,1
"""parent/file.txt""",1,0,1
out && url && local_path,1,0,1
out && path && repo,1,0,1
"p, a, c, 1, 13, 0, 0, 12, 1",1,0,1
git_remote_pushurl(mod) == NULL,1,0,1
tx && refname,1,0,1
iterator__has_been_accessed(i),1,0,1
"repo, 0, ""0000000000000000000000000000000000000000"", ""258f0e2a959a364e40ed6603d5d44fbb24765b10"", msg",1,0,1
"""baz2"", git_buf_cstr(&buf)",1,0,1
out != NULL && len > 0,1,0,1
"""HEAD"", refs[0]->name",1,0,1
"git_annotated_commit_id(branch_head), git_reflog_entry_id_old(reflog_entry)",1,0,1
refspec,1,0,1
"&expected_oid[i], &operation->id",1,0,1
assigns && !assigns->length,1,0,1
"expected_count, branch_list.count",1,0,1
" -100, git_tree_walk( tree, GIT_TREEWALK_POST, treewalk_stop_immediately_cb, NULL)",1,0,1
cte != NULL,1,0,1
"(ids = git__calloc(num, sizeof(git_odb_expand_id)))",1,0,1
0 != status->index_to_workdir->new_file.size,1,0,1
out && spec && ref,1,0,1
delta_is_split(tgt),1,0,1
"""refs/stash@{0}"", git_oid_tostr_s(&stash_tip_oid), GIT_OBJ_COMMIT",1,0,1
"true, git_path_isvalid(NULL, ""com1.asdf"", 0)",1,0,1
"git__strcmp(""foo"", ""FOO"") > 0",1,0,1
"strcasecmp(""et"", ""e\342\202\254ghi="") < 0",1,0,1
"""Debug/what/I/say""",1,0,1
"expected3, buf.ptr",1,0,1
"(numchunks * CHUNKSIZE), st.st_size",1,0,1
ceiling >= 0,1,0,1
path && cb,1,0,1
"""t3/b/f2""",1,0,1
"false, ""sub/aaa.html""",1,0,1
"true, ""dir1/parent1/kid1/file""",1,0,1
out && ref,1,0,1
"&zero_id, &status->head_to_index->new_file.id",1,0,1
"true, git_path_isvalid(NULL, ""aux.asdf"", 0)",1,0,1
"""[newsection]\n\tnewname = new_value\n"", n",1,0,1
"4, ""foo/one.txt"", ""foo/two.txt""",1,0,1
(buf = malloc(key_length)) != NULL,1,0,1
"!git_oid_equal(&zero_id, &status->head_to_index->old_file.id)",1,0,1
analysis_out && preference_out && repo && their_heads,1,0,1
"""A-*[0-9a-f].mod"", repo, &opts, &fmt_opts",1,0,1
(old = git__malloc(sizeof(mode_t))) != NULL,1,0,1
perfdata.mkdir_calls > 0,1,0,1
" GIT_ENOTFOUND, git_sysdir_find_global_file(temp, file)",1,0,1
"""rebase: Modification 3 to gravy"", git_reflog_entry_message(reflog_entry)",1,0,1
"(entry = git_index_get_bypath(newindex, ""C"", 0))",1,0,1
name_len > prefix_len,1,0,1
"""\n\n[section]\n\tname = value\n"", result.ptr",1,0,1
"git_index_get_bypath(index, ""other.txt"", 3) != NULL",1,0,1
"git__strcmp(entry->path, ""src/block-sha1/sha1.c"") == 0",1,0,1
"""update by push"", git_reflog_entry_message(entry)",1,0,1
"112, git_atomic_get(&_counts[1])",1,0,1
"(n), p",1,0,1
"""e-*"", ""HEAD^^"", repo, &opts, &fmt_opts",1,0,1
c == '[',1,0,1
"true, ""dir1/twostars/child""",1,0,1
callcount != 0,1,0,1
"""just_a_dir/a/b/Z/y/X/foo.txt"", entry->path",1,0,1
"""3\n"", 2, ""rebase/.git/rebase-merge/end""",1,0,1
"&commit_id, git_reference_target(head_ref)",1,0,1
"true, ""dir1/twostars""",1,0,1
"cts.untracked, g_typechange_expected_untracked[i]",1,0,1
depth < iter->frames.size,1,0,1
"git__suffixcmp(git_buf_cstr(&buf), ""new_workdir/"") == 0",1,0,1
"strcmp(buf, ""Wed, 9 Apr 2014 10:21:03 +0200"") == 0",1,0,1
"1, filter_for(""id.ident"", ""ident"")",1,0,1
"ad->old_file.path, bd->old_file.path",1,0,1
"new_id, id_str",1,0,1
"repository, ""branch.test.remote"", ""test""",1,0,1
"git_treebuilder_insert(NULL, builder, ""file.txt"", &invalid_blob_id, GIT_FILEMODE_BLOB)",1,0,1
"git__strcasecmp(""\303\215"", ""\303\255"") < 0",1,0,1
"-1, cache->entry_count",1,0,1
"git_index_path(index), cl_fixture(""gitgit.index"")",1,0,1
"git_path_exists(""foo/readme.txt"")",1,0,1
"git_annotated_commit_id(onto), git_reflog_entry_id_old(reflog_entry)",1,0,1
"git_strmap_valid_index(git__pack_cache, pos)",1,0,1
"(entry = git_index_get_bypath(index, ""more2.identcrlf"", 0))",1,0,1
ancestor_oid,1,0,1
"!git_path_exists(""stash/when"")",1,0,1
"""beef.txt"", status_entry->head_to_index->new_file.path",1,0,1
"git_treebuilder_insert(NULL, builder, ""folder"", &invalid_blob_id, GIT_FILEMODE_BLOB)",1,0,1
spec && spec->src,1,0,1
"10, returned_entry->file_size",1,0,1
"GIT_ENOTFOUND, git_merge_base_octopus(&oid, _repo, count, oids)",1,0,1
"st.st_mode & (S_IFMT | 07777), (GIT_FILEMODE_TREE | 0701) & ~um, ""%07o""",1,0,1
delta->status <= GIT_DELTA_CONFLICTED,1,0,1
"git__strcasecmp(""rt\303\202of"", ""rt dev\302\266h"") > 0",1,0,1
"""origin"", str",1,0,1
parser->content_length == 0,1,0,1
"i, 14",1,0,1
"false, git_path_isvalid(NULL, ""asdf|foo"", GIT_PATH_REJECT_NT_CHARS)",1,0,1
pb && walk,1,0,1
" ""8d1f13f93c4995760ac07d129246ac1ff64c0be9 2ac4fb7b74c1287f6c792acad759e1ec01e18dae\n"", 82, ""rebase/.git/rebase-merge/rewritten""",1,0,1
"""ignore_me""",1,0,1
"23, buf.size",1,0,1
" counts->file, counts->line, ""Status path mismatch"", 1, ""%s"", counts->expected_paths[idx], p",1,0,1
"false, git_path_isvalid(NULL, "".git\xe2\x80\x8c"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"fh = CreateFileA(in, FILE_READ_ATTRIBUTES | STANDARD_RIGHTS_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL)",1,0,1
"false, ""dir""",1,0,1
index && file,1,0,1
" file, line, ""Buffer len was not exact match"", 1, ""%d"", (int)stream.avail_out, (int)INFLATE_EXTRA",1,0,1
"git_index_get_bypath(index, "".header"", 0)",1,0,1
"(b = resolve_commit_oid_to_tree(repo, b_id)) != NULL",1,0,1
"3, git_strmap_num_entries(git__pack_cache)",1,0,1
"g_crlf_filtered[i].size, zeroed.size",1,0,1
"NULL, git_tree_entry_byname(tree, ""foo"")",1,0,1
"""untimely.txt"", diff_data.new_path",1,0,1
"""e-3-*"", ""HEAD"", repo, &opts, &fmt_opts",1,0,1
repo && config,1,0,1
"&id, &entry->oid_cur",1,0,1
mctx.input.offsets_needed == 0,1,0,1
"0, filter_for(""foo.lf"", ""ident"")",1,0,1
"true, git_path_isvalid(NULL, ""foo/."", 0)",1,0,1
"g_repo, ""bra\nch.duh""",1,0,1
"!git_repository_is_bare(repo), file, line",1,0,1
data && datasize && buf,1,0,1
"1, git_clone__should_clone_local(path, GIT_CLONE_LOCAL_NO_LINKS)",1,0,1
"""nulltoken w"", ""emeric.fermas@gmail.com"", ""nulltoken w."", ""emeric.fermas@gmail.com""",1,0,1
"""bZBXFAZc?TVqtS-AUHK3Wo~0{WMyOk"", buf.ptr",1,0,1
git_tree_owner(tree) == repo,1,0,1
"status_flags, git_status_file(&status, repo, path)",1,0,1
"GIT_EEXISTS, git_remote_rename(&problems, _repo, _remote_name, ""test"")",1,0,1
"sm_name, entry->path",1,0,1
"true, ""lala/../symlink""",1,0,1
def->free && def->parse,1,0,1
"GIT_DIFF_BINARY_DELTA, diff_data.new_binary_type",1,0,1
is_merge,1,0,1
(before == after),1,0,1
"git_path_isdir(""d1/foo/bar"")",1,0,1
"new_val, str",1,0,1
out && old_index && new_index,1,0,1
"&expected[i], &id",1,0,1
dfa->nodes_len > 0,1,0,1
1 == pb->nr_threads,1,0,1
"true, ""sub/_test/foo/bar/qux/file""",1,0,1
expected == status,1,0,1
"git__suffixcmp(out.ptr, path) == 0",1,0,1
error_code,1,0,1
"expected_status, git_path_make_relative(&buf, parent)",1,0,1
"strstr(buf.ptr, ""[submodule \""submodules/libgit2\""]"") != NULL",1,0,1
odb,1,0,1
"true, git_path_isvalid(NULL, "".git.. ."", 0)",1,0,1
"git__strcmp(""rt dev\302\266h"", ""rt\303\202of"") < 0",1,0,1
"NULL , "" \n Spaces around newlines \n are \n collapsed \n """,1,0,1
"true, git_path_exists(test_lock)",1,0,1
GIT_ATTR_TRUE(values[3]),1,0,1
"git_path_isfile(""submod2/"" ""sm_gitmodules_only"" ""/.git"")",1,0,1
"git_object_id(obj), git_reflog_entry_id_old(entry)",1,0,1
"entry = (git_index_entry *) git_index_get_bypath(repo_index, filename, 0)",1,0,1
"&x, expectedB, ARRAY_SIZE(expectedB)",1,0,1
"p, c, d, 2, 5, 9, 4, 6, 4",1,0,1
"GIT_EAPPLIED, error",1,0,1
((header_field_mark ? 1 : 0) + (header_value_mark ? 1 : 0) + (url_mark ? 1 : 0) + (body_mark ? 1 : 0)) <= 1,1,0,1
"1, 15, 3, 9, 3, &expected",1,0,1
"i, val",1,0,1
path_len > iter->root_len,1,0,1
"(entry = git_index_get_bypath(index, ""lame.name.txt"", 0))",1,0,1
"inflate(&stream, Z_FINISH)",1,0,1
"sm != NULL, file, line",1,0,1
"_repo, ""branch.mergeless.remote"", true",1,0,1
"cl_fixture(""attr/attr3""), file->entry->path",1,0,1
"&should_id, git_indexer_hash(idx)",1,0,1
t->current_stream,1,0,1
out && ctx,1,0,1
dfa->eclosures[node_idx].nelem != -1,1,0,1
mctx->state_log != NULL && mctx->state_log[str_idx] != NULL,1,0,1
"merge_test_index(repo_index, merge_index_entries + i * 3, 3)",1,0,1
str_a < buf->ptr || str_a >= buf->ptr + buf->size,1,0,1
"&x, expected7, ARRAY_SIZE(expected7)",1,0,1
"""f"", git_buf_cstr(&buf)",1,0,1
"refspec, refs.strings[0]",1,0,1
"strcmp(conflicting_buf.ptr, ""<<<<<<< ours\r\n"" ""this file is changed in master and branch\r\n"" ""=======\r\n"" ""this file is changed in branch and master\r\n"" "">>>>>>> theirs\r\n"") == 0",1,0,1
"""R-*"", ""HEAD^^"", repo, &opts, &fmt_opts",1,0,1
"email, git_buf_cstr(&buf)",1,0,1
"4, exp[1]",1,0,1
"old_id, id_str",1,0,1
"CONFLICTING_RECURSIVE_H1_TO_H2_WITH_DIFF3, conflicting_buf.ptr",1,0,1
"""refs/stash:why"", ""88c2533e21f098b89c91a431d8075cbdbe422a51""",1,0,1
"repo, ""untracked"", GIT_STATUS_WT_NEW",1,0,1
blob && path && out,1,0,1
" file, line, msg, 1, ""%d"", (int)stream.total_out, (int)e_len",1,0,1
"(entry = git_index_get_bypath(repo_index, ""a.txt"", 0))",1,0,1
"1, git_diff_stats_insertions(_stats)",1,0,1
"&expected_target_oid, annotated_obj_id",1,0,1
"git_strmap_value_at(g_table, pos), ""bbbbbbbbb""",1,0,1
"GIT_STATUS_CONFLICTED, status->status",1,0,1
_backend && old_name && new_name,1,0,1
"mixed_case, conflict_entry[0]->path",1,0,1
"GIT_EINVALIDSPEC, git_reference_symbolic_create(&head, g_repo, GIT_HEAD_FILE, ""refs/heads/inv@{id"", 1, NULL)",1,0,1
"g_repo, ""mismatch_path""",1,0,1
"g_repo, ""branc#.duh""",1,0,1
"""refs/notes/mydefaultnotesref"", default_ref.ptr",1,0,1
pstr->valid_len > 0,1,0,1
"oldname, expected->oldname",1,0,1
"true, ""dir1/dir2/parent2/kid2/file""",1,0,1
from_star && to_star,1,0,1
"&expected_oid, &entry->id",1,0,1
"sizeof(void *) == 8 ? 575 : 573, git_pool__open_pages(&p)",1,0,1
"true, git_path_isvalid(NULL, ""lptn"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
"expected[i], names[i]",1,0,1
"0, e->ctime.seconds",1,0,1
remote_head,1,0,1
"0, e->mtime.seconds",1,0,1
"NULL, git_index_get_bypath(index, ""other.txt"", 3)",1,0,1
"_repo, ""branch.mergeless.remote"", false",1,0,1
"GIT_FILEMODE_LINK, delta->new_file.mode",1,0,1
"GIT_REBASE_OPERATION_PICK, operation->type",1,0,1
""""", actual.ptr",1,0,1
"""both_sides-1.txt"", theirs->path",1,0,1
delta->new_file.mode == GIT_FILEMODE_BLOB,1,0,1
"fullpath+4, filename",1,0,1
""".git"", sub_reserved[0].ptr",1,0,1
st.st_size == i64len,1,0,1
"git_path_exists(""testrepo/other.txt"")",1,0,1
"strcasecmp(""\303\215"", ""\303\255"") < 0",1,0,1
"ENOENT, errno",1,0,1
"false, git_path_isvalid(NULL, ""foo/.GIT/bar"", GIT_PATH_REJECT_DOT_GIT_LITERAL)",1,0,1
file && backend && name,1,0,1
"""this/is/deep""",1,0,1
"false, git_path_isvalid(NULL, ""asdf\001foo"", GIT_PATH_REJECT_NT_CHARS)",1,0,1
odb && backend,1,0,1
"git_strmap_valid_index(g_table, pos)",1,0,1
their_oid,1,0,1
"2, pack->refcount.val",1,0,1
oid && file && file->compute_digest,1,0,1
"true, git_path_isvalid(NULL, ""com1\\foo"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
perfdata.stat_calls > 0,1,0,1
"NULL, ""One-liner with trailing newline\n""",1,0,1
"repo, ""ignored_directory/sub/some_file"", GIT_STATUS_WT_NEW",1,0,1
"false, git_path_isvalid(NULL, ""aux"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
"true, ""foo/bar/baz""",1,0,1
git_zstream_done(&z),1,0,1
GIT_SUBMODULE_RECURSE_ONDEMAND,1,0,1
ref_out && repo && branch_name,1,0,1
git_path_isdir(root.ptr),1,0,1
"""readme"", index_entry->path",1,0,1
"entry = git_index_get_bypath(g_idx, ""just_a_dir/FILE1.txt"", 0)",1,0,1
buf && sig,1,0,1
backend && out && short_id && len >= GIT_OID_MINPREFIXLEN,1,0,1
"NULL, git_index_get_bypath(index, ""other.txt"", 1)",1,0,1
"hunks, exp->hunks",1,0,1
"""both_sides-2.txt"", ours->path",1,0,1
""""", spec.dst",1,0,1
"true, b",1,0,1
repo && id && branch_name && remote_url,1,0,1
"""refs/remotes/renamed/master"", git_reference_symbolic_target(ref)",1,0,1
"""just_a_dir/fILEE.txt"", entry->path",1,0,1
S_ISLNK(idx_entry->mode),1,0,1
"false, git_path_isvalid(NULL, ""foo/"", 0)",1,0,1
"true, ""dir1/parent2/kid2/file/inside/parent""",1,0,1
"&x, expected2, ARRAY_SIZE(expected2)",1,0,1
"expected_patch_text[d], buf.ptr",1,0,1
"10, git_diff_stats_deletions(_stats)",1,0,1
" 96, git_atomic_get(&_counts[3])",1,0,1
"true, seen_paths.what",1,0,1
"false, git_path_isvalid(NULL, "".git.. ."", GIT_PATH_REJECT_DOT_GIT_NTFS)",1,0,1
"""dir/""",1,0,1
""":"", spec.string",1,0,1
"git__strcasecmp(""et"", ""e\342\202\254ghi="") < 0",1,0,1
"idstr, ""cd8fd12""",1,0,1
"strstr(buf.ptr, ""path = submodules/libgit2"") != NULL",1,0,1
"true, git_path_isvalid(NULL, ""lpt0"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
cur_nodes->nelem,1,0,1
"git_treebuilder_get(builder, ""apple"") == NULL",1,0,1
"git__strcasecmp(""rt dev\302\266h"", ""rt\303\202of"") < 0",1,0,1
" -123, git_tree_walk(tree, GIT_TREEWALK_POST, treewalk_stop_cb, &ct)",1,0,1
"""test"", remotename.ptr",1,0,1
&test_stream != stream,1,0,1
out && value,1,0,1
"1, filter_for(""id.binident"", ""ident"")",1,0,1
"false, ""dir1/kid1/file""",1,0,1
"false, index->ignore_case",1,0,1
"!git_oid_streq(&oid, ""9fd738e8f7967c078dceed8190330fc8648ee56a"")",1,0,1
"""are removed"", ""Trailing spaces \n\nare removed""",1,0,1
called_proxy_creds,1,0,1
"git__strcmp(""e\342\202\254ghi="", ""et"") > 0",1,0,1
"delta->status == GIT_DELTA_UNTRACKED, file, line",1,0,1
"""test1-lightweight-*"", ""HEAD"", repo, &opts, &fmt_opts",1,0,1
""" Spaces before newlines are collapsed"", "" \nSpaces before newlines \nare \ncollapsed \n""",1,0,1
"git__strcmp(""foo"", ""fOO"") > 0",1,0,1
" 1, git_note_foreach(_repo, ""refs/notes/i-can-see-dead-notes"", note_cancel_cb, &retrieved_notes)",1,0,1
"1234567890, st.st_mtime",1,0,1
"3, git_libgit2_init()",1,0,1
"!git_path_exists(""merge-resolve/.git/"" GIT_MERGE_MSG_FILE)",1,0,1
"0, git_clone__should_clone_local(path, GIT_CLONE_NO_LOCAL)",1,0,1
"""crlf\ncrlf\ncrlf\ncrlf\n"", write_target.buf.ptr",1,0,1
"false, git_path_isvalid(NULL, ""asdf*bar"", GIT_PATH_REJECT_NT_CHARS)",1,0,1
"""padded_parent/child8/bar.txt""",1,0,1
"""Newlines are replaced by spaces"", ""Newlines\nare\nreplaced by spaces\n""",1,0,1
"git_object_id(obj), git_reflog_entry_id_new(entry)",1,0,1
str_c < buf->ptr || str_c >= buf->ptr + buf->size,1,0,1
"delta->new_file.path, ""copy.txt""",1,0,1
cfg && file,1,0,1
ptr,1,0,1
"true, git_path_isvalid(NULL, ""foo./bar"", 0)",1,0,1
"""look-ma.txt""",1,0,1
"GIT_OBJ_BLOB, git_object_type((git_object *) blob)",1,0,1
"true, git_path_isvalid(NULL, ""git~1."", 0)",1,0,1
"true, ""dir1/parent2/kid2/file""",1,0,1
name && len > 0,1,0,1
(err = giterr_last()) != NULL,1,0,1
"NULL, git_index_get_bypath(index, "".header"", 0)",1,0,1
s->msg = git__strdup(msg),1,0,1
"0, git_graph_descendant_of(_repo, git_commit_id(commit), &oid)",1,0,1
"""sm_libgit2b"", ""https://github.com/libgit2/libgit2.git""",1,0,1
"false, git_path_isvalid(NULL, "".git."", GIT_PATH_REJECT_DOT_GIT_NTFS)",1,0,1
"entry_count0, entry_paths0, entry_statuses0, cl_git_sandbox_init(""status""), GIT_STATUS_SHOW_INDEX_AND_WORKDIR, 0",1,0,1
"git_path_isdir(""t3/b"")",1,0,1
out && repo && cherrypick_commit && our_commit,1,0,1
"strcmp(git_buf_cstr(&mergemsg_buf), ""Change all files\n"" ""\n"" ""Conflicts:\n"" ""\tfile2.txt\n"" ""\tfile3.txt\n"") == 0",1,0,1
!iterator__has_been_accessed(i),1,0,1
"""t3/c/d/f4""",1,0,1
"0, filter_for(""id.binident"", ""crlf"")",1,0,1
bld && id && filename,1,0,1
"entry = git_index_get_bypath(g_idx, ""hidden_file"", 0)",1,0,1
"false, git_path_isvalid(NULL, ""git~1."", GIT_PATH_REJECT_DOT_GIT_NTFS)",1,0,1
"""(There are more!)"", ""\nFirst paragraph only\n\n(There are more!)""",1,0,1
"""both_sides-1.txt"", ancestor->path",1,0,1
"expected, canonical",1,0,1
!backend->odb || backend->odb == odb,1,0,1
"true, ""dir/test""",1,0,1
len_p && type_p && backend && oid,1,0,1
"expected_len, result.len",1,0,1
array && repo,1,0,1
"false, git_path_isvalid(NULL, ""lpt1"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
index && source_entry && source_entry->path,1,0,1
"true, git_path_isvalid(NULL, "".\xe2gIt"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
backend && short_oid,1,0,1
"true, git_path_isvalid(NULL, ""aux1"", 0)",1,0,1
"false, git_path_isvalid(NULL, ""foo/bar."", GIT_PATH_REJECT_TRAILING_DOT)",1,0,1
"git_oid_cmp(&expected_blob_oid, &entry->id) == 0",1,0,1
repo && (upstream || onto),1,0,1
"""heads/master"", ""HEAD"", repo, &opts, &fmt_opts",1,0,1
"expected_count, git_rebase_operation_entrycount(rebase)",1,0,1
"git_annotated_commit_id(branch), git_reference_target(head_ref)",1,0,1
" 0, memcmp(zeroed.ptr, g_crlf_filtered[i].ptr, zeroed.size)",1,0,1
"nentries, entrycount(repo, GIT_HEAD_FILE)",1,0,1
"""Could not determine remote for 'refs/remotes/matching/master'"", giterr_last()->message",1,0,1
"""true"", git_buf_cstr(&buf)",1,0,1
ancestor_out && our_out && their_out && index,1,0,1
GIT_SUBMODULE_IGNORE_UNTRACKED,1,0,1
"(delta->flags & GIT_DIFF_FLAG_BINARY), is_binary",1,0,1
repo && workdir,1,0,1
"strlen(somestring) + 1, buf.size",1,0,1
size > 0,1,0,1
"SetEnvironmentVariableW(wide_name, wide_value)",1,0,1
"git__strcmp(entry->path, ""src/commit.c"") == 0",1,0,1
"true, git_path_isvalid(NULL, ""foo/bar/file.txt"", 0)",1,0,1
"false, git_path_isvalid(NULL, ""foo/.."", GIT_PATH_REJECT_TRAVERSAL)",1,0,1
"""e4f809f826c1a9fc929874bc0e4644dd2f2a1af4\n"", 41, ""rebase/.git/rebase-merge/cmt.2""",1,0,1
"SECTION_FOO, n, strlen(SECTION_FOO)",1,0,1
"!git_oid_streq(&oid, ""a65fedf39aefe402d3bb6e24df4d4f5fe4547750"")",1,0,1
"delta->new_file.path, ""file.txt""",1,0,1
git_blob_rawcontent(blob),1,0,1
"expected_reflog_msg, git_reflog_entry_message(entry)",1,0,1
fd > 0,1,0,1
"false, ""dir/aaa.html""",1,0,1
"0, git_commit_parentcount(old_commit)",1,0,1
"&expected->src, &updates[0]->src",1,0,1
"""GIT~1"", sub_reserved[1].ptr",1,0,1
out && repo && revert_commit && our_commit,1,0,1
out && ours && theirs,1,0,1
"git_reference_target(test), git_reference_target(trailing)",1,0,1
"git_strmap_exists(g_table, ""bbbbbbbbb"")",1,0,1
GIT_REPOSITORY_STATE_REVERT_SEQUENCE,1,0,1
"""\""C:/Program Files/Nonsense/bah.exe\"" \""--some option\"""", git_buf_cstr(&buf)",1,0,1
"GIT_NOTES_DEFAULT_REF, default_ref.ptr",1,0,1
"s = git__calloc(1, sizeof(*s))",1,0,1
"""bZBXF"", buf.ptr",1,0,1
session,1,0,1
"&expected, &actual",1,0,1
"GIT_ENOTFOUND == git_index_find_prefix(NULL, index, ""blah"")",1,0,1
"expected_message.ptr, git_reflog_entry_message(entry)",1,0,1
"""Foo: bar"", giterr_last()->message",1,0,1
"""http://example.com/git/abba"", git_buf_cstr(&buf)",1,0,1
"0, git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL_NO_LINKS)",1,0,1
status_flags && repo && path,1,0,1
"0, ids[i].length",1,0,1
"""parent/child3/foo.txt""",1,0,1
"3, counter",1,0,1
"GIT_ENOTFOUND, git_repository_discover(&found_path, ALTERNATE_NOT_FOUND_FOLDER, 0, ceiling_dirs)",1,0,1
"GIT_EBAREREPO, git_reset(bare, target, GIT_RESET_HARD, NULL)",1,0,1
"true, seen_paths.when",1,0,1
"5, ""/foo/one.txt"", ""/foo/two.txt""",1,0,1
"0, git_oid_streq(&entry->id, expected_sha)",1,0,1
pb && oid,1,0,1
" email, ""7ade76dd34bba4733cf9878079f9fd4a456a9189"", &opts",1,0,1
"1, git_clone__should_clone_local(path, GIT_CLONE_LOCAL)",1,0,1
delta->status == GIT_DELTA_ADDED || delta->status == GIT_DELTA_MODIFIED || delta->status == GIT_DELTA_DELETED,1,0,1
"""34734e478d6cf50c27c9d69026d93974d052c454"", buf.ptr",1,0,1
"git__strcmp("""", """") == 0",1,0,1
"""refs/stash^2:why"", ""88c2533e21f098b89c91a431d8075cbdbe422a51""",1,0,1
"git_treebuilder_insert(NULL, builder, ""folder_as_file.txt"", &valid_tree_id, GIT_FILEMODE_BLOB)",1,0,1
0 != status->index_to_workdir->new_file.mode,1,0,1
"!memcmp(&expected, &actual, 20)",1,0,1
"git__strcasecmp(""e\342\202\254ghi="", ""et"") > 0",1,0,1
"correct_case, conflict_entry[0]->path",1,0,1
"ctxt, (int)tc",1,0,1
"SECTION_BAR, n, strlen(SECTION_BAR)",1,0,1
"0, exp.file_status[GIT_DELTA_CONFLICTED]",1,0,1
"NULL, git_repository_workdir(repo)",1,0,1
git_object_owner((const git_object *)commit) == repository,1,0,1
"e->mtime.seconds, test_entries[i].mtime",1,0,1
"git_repository__reserved_names(&sub_reserved, &sub_reserved_len, sub_repo, true)",1,0,1
"new_commit, 2",1,0,1
giterr_last()->klass == GITERR_CONFIG,1,0,1
git_index_has_conflicts(index),1,0,1
"0 && ""unhandled state""",1,0,1
"""5\n"", 2, ""rebase/.git/rebase-merge/msgnum""",1,0,1
"strcmp(""et"", ""e\342\202\254ghi="") < 0",1,0,1
"0, status->head_to_index->new_file.mode",1,0,1
" ""diff --git a/zzz.textalphary b/zzz.textalphary\n"" ""index b435cd5..1604519 100644\n"" ""--- a/zzz.textalphary\n"" ""+++ b/zzz.textalphary\n"" ""@@ -3 +3 @@\n"" ""-0123456789\n"" ""+replace a line\n"", buf.ptr",1,0,1
"false, git_path_isvalid(NULL, ""foo\\file.txt"", GIT_PATH_REJECT_BACKSLASH)",1,0,1
"git__strcasecmp(""foo"", ""fOO"") == 0",1,0,1
"""refs/stash^2:where"", ""e08f7fbb9a42a0c5367cf8b349f1f08c3d56bd72""",1,0,1
"progress, GIT_STASH_APPLY_PROGRESS_DONE",1,0,1
out && given_repo && opts,1,0,1
called_proxy_creds == 0,1,0,1
"hunks, (int)git_patch_num_hunks(p)",1,0,1
"""refs/heads/*:refs/remotes/origin/*"", ""refs/heads/user/feature"", ""refs/remotes/origin/user/feature""",1,0,1
name && target,1,0,1
"false, git_path_isvalid(NULL, ""asdf?bar"", GIT_PATH_REJECT_NT_CHARS)",1,0,1
"7, ""/a/b/c/foo.txt"", ""/a/b/c/d/e/bar.txt""",1,0,1
"""just_a_dir/file2.txt"", entry->path",1,0,1
object && peeled,1,0,1
"old_commit, 1",1,0,1
"_repo, ""branch.mergeless.merge"", false",1,0,1
"entry = git_index_get_bypath(newindex, ""A"", 0)",1,0,1
"(in = fopen(in_f.ptr, ""rb"")) != NULL",1,0,1
"out, git_object_id(top_stash)",1,0,1
"0, counts.entry_count",1,0,1
repo && fetchhead_refs,1,0,1
"GIT_ENOTFOUND, err",1,0,1
"""2aa3ce842094e08ebac152b3d6d5b0fff39f9c6e\n"", 41, ""rebase/.git/rebase-merge/cmt.2""",1,0,1
ancestor || ours || theirs,1,0,1
repo && _remote,1,0,1
"expected[i], name",1,0,1
out && treeish && path,1,0,1
"true, git_path_isvalid(NULL, "".g"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"false, ""dir1/kid2/file""",1,0,1
"strcmp(git_buf_cstr(&mergemsg_buf), ""Merge commit '7cb63eed597130ba4abb87b3e544b85021905520'\n"" ""\n"" ""Conflicts:\n"" ""\tconflicting.txt\n"") == 0",1,0,1
_remote_ssh_fingerprint,1,0,1
"err->message, ""Cannot write object - unsupported in the loaded odb backends""",1,0,1
found_parent_child1_file,1,0,1
dot,1,0,1
"!git_path_exists(""stash/ignored_directory/sub/some_file"")",1,0,1
"delta->old_file.path, ""small.txt""",1,0,1
file && ref,1,0,1
"true, git_path_isvalid(NULL, ""foo/.git/bar"", 0)",1,0,1
one && two,1,0,1
"GIT_EINVALIDSPEC, ""0266163a49e280c4f5ed1e08facd36a2bd716bcf"", GIT_OBJ_TAG",1,0,1
"!git_path_exists(""stash/ignored_directory/sub"")",1,0,1
(caps & GIT_FEATURE_THREADS) != 0,1,0,1
"5, git_index_entrycount(new_index)",1,0,1
"""dir""",1,0,1
"&oid, &original_oid",1,0,1
"""ours.txt"", result.path",1,0,1
"new->ptr, result.ptr",1,0,1
"true, git_path_isvalid(NULL, ""comn"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
"""f87d14a4a236582a0278a916340a793714256864\n"", 41, ""rebase/.git/rebase-merge/cmt.5""",1,0,1
"false, git_path_isvalid(NULL, ""foo..."", GIT_PATH_REJECT_TRAILING_DOT)",1,0,1
"(a = resolve_commit_oid_to_tree(repo, a_id)) != NULL",1,0,1
"expected->src_refname, updates[0]->src_refname",1,0,1
"0, ids[i].type",1,0,1
(prot & GIT_PROT_WRITE) || (prot & GIT_PROT_READ),1,0,1
"entry = git_index_get_bypath(g_idx, ""just_a_dir/file1.txt"", 0)",1,0,1
input_out && odb_object_out && odb && entry,1,0,1
"""http://example.com/git/ab"", git_buf_cstr(&buf)",1,0,1
"true, ""Folder/Middle/More/More/Contained""",1,0,1
"git_index_get_bypath(index, ""other.txt"", 1) != NULL",1,0,1
"""one one one two two three three"", git_buf_cstr(&buf)",1,0,1
"root_reflog_message, git_reflog_entry_message(entry)",1,0,1
"true, git_path_isvalid(NULL, ""asdf<bar"", 0)",1,0,1
custom_transport_used == 1,1,0,1
"&expected_note_oid, blob_id",1,0,1
"1, filter_for(""foo.custom"", ""custom"")",1,0,1
"(error = p_fstat(fd, &st)) == 0",1,0,1
"""really/Debug/this/file""",1,0,1
"3, st.st_nlink",1,0,1
path_len > (size_t)(root_offset + 1),1,0,1
"GIT_ENOTFOUND, git_submodule_lookup(NULL, repo, ""subdir"")",1,0,1
"e->t, delta_to_add->status",1,0,1
current,1,0,1
" -123, git_tree_walk(tree, GIT_TREEWALK_PRE, treewalk_stop_cb, &ct)",1,0,1
"config, ""imm.multi"", ""foo""",1,0,1
"out1.size, out2.size",1,0,1
"(ret), git_array_search(&p, integers, int_lookup, &key)",1,0,1
"true, git_path_isvalid(NULL, ""lpt10"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
" 0, memcmp(reversed, out.ptr, out.size)",1,0,1
symbolic == NULL,1,0,1
dup,1,0,1
"""(Yes, unwrapped!)"", ""\nFirst paragraph\nwith unwrapped\ntrailing\tlines\n\n(Yes, unwrapped!)""",1,0,1
"591, git_pool__open_pages(&p)",1,0,1
"ad->new_file.path, bd->new_file.path",1,0,1
"git_repository_get_namespace(repo), ""some-namespace""",1,0,1
"expected2, actual.ptr",1,0,1
"0, filter_for(""foo.custom"", ""custom"")",1,0,1
oldname == NULL,1,0,1
"&our_entry.id, &conflict_entry[1]->id",1,0,1
"""this!"", buf.ptr",1,0,1
"false, git_path_isvalid(NULL, ""\xe2\x81\xab.\xe2\x80\xaaG\xe2\x81\xabI\xe2\x80\xact"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"!git_odb_exists(odb, &id)",1,0,1
"0100644, mode",1,0,1
g_table != NULL,1,0,1
"""Bar: foo"", giterr_last()->message",1,0,1
filename = malloc(MAX_PATH),1,0,1
"expected, git_commit_body(dummy)",1,0,1
"0, stream->current_chunk",1,0,1
!git_path_exists(root.ptr),1,0,1
"GITERR_NOMEMORY, err_state.error_msg.klass",1,0,1
"GIT_DIFF_BINARY_DELTA, diff_data.old_binary_type",1,0,1
"nlogs_after, nlogs + 1",1,0,1
end_idx <= v->length,1,0,1
"-123, git_odb_foreach(_odb, foreach_stop_first_cb, &nobj)",1,0,1
"!git_index_add(index, &new_entry), file, line, ""Cannot add index entry"", NULL, 1",1,0,1
len,1,0,1
"""c"", git_buf_cstr(&buf)",1,0,1
"(path_utf16len = git_win32_path_from_utf8(path_utf16, utf8_in)) >= 0",1,0,1
"""are preserved"", ""\tLeading\n\ttabs\n\nare preserved""",1,0,1
"GIT_EINVALIDSPEC, git_reference_create( &new_reference, g_repo, name, &id, 0, NULL)",1,0,1
"""gitdir: ../.git/modules/sm_gitmodules_only/"", dot_git_content.ptr",1,0,1
reflog && repo && name,1,0,1
"true, git_path_isvalid(NULL, ""aux:"", 0)",1,0,1
"!git_path_exists(""attr/.gitattributes"")",1,0,1
tree_cache,1,0,1
ancestor && commit,1,0,1
"GIT_ENOTFOUND, git_repository_discover(&found_path, SUB_REPOSITORY_FOLDER_SUB, 0, ceiling_dirs)",1,0,1
"""da9c51a23d02d931a486f45ad18cda05cf5d2b94\n"", 41, ""rebase/.git/rebase-merge/current""",1,0,1
"cts.ignored, 0",1,0,1
rebase->index,1,0,1
t->rpc || t->current_stream == *stream,1,0,1
out && result,1,0,1
"false, git_path_isvalid(NULL, ""com1"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
"true, ""dir/file1""",1,0,1
" sm2, ""submodule.""SM2"".url"", ""remote.origin.url""",1,0,1
"""Trailing tabs"", ""Trailing tabs\t\n\nare removed""",1,0,1
"expected_value, git_buf_cstr(&buf)",1,0,1
"true, ""dir/TeSt""",1,0,1
"git__suffixcmp(git_repository_path(repo), ""attr/.git/"") == 0, file, line",1,0,1
"!git_oid_streq(&oid, ""4a202b346bb0fb0db7eff3cffeb3c70babbd2045"")",1,0,1
"len, x->length",1,0,1
"1, exp->file_status[GIT_DELTA_MODIFIED]",1,0,1
"""untimely.txt"", diff_data.old_path",1,0,1
!git_buf_oom(&line),1,0,1
"true, ""dir1/dir2/twostars""",1,0,1
"""collapsed"" , "" \n Trailing newlines \n are \n\n collapsed \n """,1,0,1
" ""diff --git a/zzz.alphary b/zzz.alphary\n"" ""index 45141a7..75b0dbb 100644\n"" ""--- a/zzz.alphary\n"" ""+++ b/zzz.alphary\n"" ""@@ -1,0 +2,3 @@ Hello from the root\n"" ""+More lines\n"" ""+And more\n"" ""+Go here\n"", buf.ptr",1,0,1
"0, ""foo/bar.txt"", ""../foo.txt""",1,0,1
!create_tag_annotation || (tagger && message),1,0,1
stream && stream->open,1,0,1
"&x, expectedA, ARRAY_SIZE(expectedA)",1,0,1
"GIT_ENOTFOUND, git_odb_exists_prefix(&id2, odb, &id, 8)",1,0,1
"entry = git_index_get_bypath(index, fn, 0)",1,0,1
start + range >= 0 && start + range <= length,1,0,1
"""R-*"", ""HEAD^^^"", repo, &opts, &fmt_opts",1,0,1
"""root_test4.txt""",1,0,1
"ad->status, bd->status",1,0,1
"computed, parsed",1,0,1
"g_repo, parent_key, git_submodule_url(sm)",1,0,1
"false, git_path_isvalid(NULL, ""com1.asdf"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
"strcmp(mergemsg_buf.ptr, ""Revert \""automergeable changes\""\n"" ""\n"" ""This reverts commit 72333f47d4e83616630ff3b0ffe4c0faebcc3c45.\n"" ""\n"" ""Conflicts:\n"" ""\tfile1.txt\n"") == 0",1,0,1
our_oid,1,0,1
"git_oid_equal(&id, &id_cloned)",1,0,1
"false, git_path_isvalid(NULL, ""foo/bar/.Git"", GIT_PATH_REJECT_DOT_GIT_LITERAL)",1,0,1
"&id, git_reference_target(test_ref)",1,0,1
state->halt,1,0,1
"""One-liner with no trailing newline"", ""One-liner with no trailing newline""",1,0,1
"NULL, "" \n Trailing spaces \n are stripped \n\n \n \t """,1,0,1
"!git_oid_streq(&oid, ""c47800c7266a2be04c571c04d5a6614691ea99bd"")",1,0,1
file && path && file->buffer == NULL,1,0,1
"config, ""windows.path"", path",1,0,1
"entry_statuses0[i], entry->status",1,0,1
"git_treebuilder_insert(NULL, builder, ""invalid_folder"", &invalid_blob_id, GIT_FILEMODE_BLOB)",1,0,1
(caps & GIT_FEATURE_HTTPS) != 0,1,0,1
"git_attr_cache__is_cached( g_repo, GIT_ATTR_FILE__FROM_FILE, "".gitignore"")",1,0,1
"""JUST_A_DIR/file2.txt"", entry->path",1,0,1
v && src,1,0,1
"6, ""a/b/c/foo.txt"", ""a/b/c/d/e/bar.txt""",1,0,1
expect[info.expect_idx] == NULL,1,0,1
"!git_oid_streq(&oid, ""5b5b025afb0b4c913b4c338a42934a3863bf3644"")",1,0,1
repo && url && path,1,0,1
"idx_entry = git_index_get_bypath(index, ""link_to_new.txt"", 0)",1,0,1
annotated_commit,1,0,1
"&expected->dst, &updates[0]->dst",1,0,1
"g_repo, """"",1,0,1
"1, 13, 0, 12, 1, &expected",1,0,1
search_filename = git_path_basename(in),1,0,1
"expected, result.ptr, expected_len",1,0,1
(caps & GIT_FEATURE_SSH) == 0,1,0,1
"0, ""foo/bar.txt"", ""bar/foo.txt""",1,0,1
" ""diff --git a/zzz.normal b/zzz.normal\n"" ""index 45141a7..75b0dbb 100644\n"" ""--- a/zzz.normal\n"" ""+++ b/zzz.normal\n"" ""@@ -1,0 +2,3 @@ Hello from the root\n"" ""+More lines\n"" ""+And more\n"" ""+Go here\n"", buf.ptr",1,0,1
"git_path_exists(NON_EXISTING_FILEPATH), false",1,0,1
"false, ""sub""",1,0,1
out && date,1,0,1
"NULL, e = git_index_get_bypath(index, ""SRC/Common.h"", 0)",1,0,1
"_repo, ""branch.master.remote"", true",1,0,1
"sizeof(void *) == 8 ? 55 : 45, git_pool__open_pages(&p)",1,0,1
"""rebase finished: refs/heads/gravy onto f87d14a4a236582a0278a916340a793714256864"", git_reflog_entry_message(reflog_entry)",1,0,1
"""dea509d09"", shorty.ptr",1,0,1
"4, 9, 0, 4, 5, &expected",1,0,1
"true, git_path_isvalid(NULL, ""asdf\037bar"", 0)",1,0,1
"""\xE8\xBF\x99"", git_pathspec_match_list_entry(m, 12)",1,0,1
"true, filepath, __FILE__, __LINE__",1,0,1
existing,1,0,1
found_master,1,0,1
"""4cacc6f6e740a5bc64faa33e04b8ef0733d8a127\n"", 41, ""rebase/.git/rebase-merge/cmt.4""",1,0,1
"""refs/heads/not-good""",1,0,1
"0, filter_for(""not_in_gitattributes"", ""crlf"")",1,0,1
regs_allocated == REGS_FIXED,1,0,1
"&test_stream, stream",1,0,1
"""Test_App"", git_submodule_name(sm)",1,0,1
expanded,1,0,1
"true, git_path_isvalid(NULL, ""\xe2\x80\xaa.gi"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
pb,1,0,1
buf && ctx && ctx->configured && cred && cred->credtype == GIT_CREDTYPE_DEFAULT,1,0,1
"100, git_pqueue_size(&pq)",1,0,1
"""be3563a*"", ""HEAD^"", repo, &opts, &fmt_opts",1,0,1
"""refs/heads/master"", str",1,0,1
"_repo, ""branch.master.remote"", false",1,0,1
"1, ctor_called",1,0,1
"GIT_EINVALIDSPEC, ""0266163a49e280c4f5ed1e08facd36a2bd716bcf"", GIT_OBJ_TREE",1,0,1
"git_path_isdir(""t3/c/e"")",1,0,1
"true, git_path_isvalid(NULL, ""lpt1"", 0)",1,0,1
"""refs/heads/*:refs/remotes/origin/*"", ""refs/headz/master""",1,0,1
"""ed"", git_buf_cstr(&buf)",1,0,1
s->ref = git__strdup(ref),1,0,1
git_path_isfile(path),1,0,1
"""refs/stash^2:.gitignore"", ""ac4d88de61733173d9959e4b77c69b9f17a00980""",1,0,1
buf->ptr,1,0,1
found_parent_file,1,0,1
"(entry = git_index_get_bypath(newindex, ""A"", 0))",1,0,1
0 != e->ctime.seconds,1,0,1
db && db->backend && out && ref_name,1,0,1
repo && map,1,0,1
name && oid,1,0,1
"""and/Debug""",1,0,1
"git_reference_target(test), git_reference_target(chomped)",1,0,1
"git__strcasecmp(""foo"", ""FOO"") == 0",1,0,1
"true, git_path_isvalid(NULL, "".git/foo"", 0)",1,0,1
"*scan, git_tree_entry_name(cte)",1,0,1
outlen > 0,1,0,1
(type == GIT_REBASE_OPERATION_EXEC) == !!exec,1,0,1
"false, git_path_isvalid(NULL, ""aux:"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
"&zero_id, &status->index_to_workdir->old_file.id",1,0,1
"""nulltoken \xe2\x98\xba"", ""emeric.fermas@gmail.com"", ""nulltoken \xe2\x98\xba"", ""emeric.fermas@gmail.com""",1,0,1
"""4bed71df7017283cac61bbf726197ad6a5a18b84\n"", 41, ""rebase/.git/rebase-merge/cmt.1""",1,0,1
"NULL, ""One-liner with no trailing newline""",1,0,1
"""+refs/heads/*:refs/remotes/test/*"", array.strings[0]",1,0,1
"1, ""/one.txt"", ""/two.txt""",1,0,1
"GIT_EBAREREPO, git_reset(bare, target, GIT_RESET_MIXED, NULL)",1,0,1
name && email,1,0,1
search_dirname = git_path_dirname(in),1,0,1
"2, (int)git_treebuilder_entrycount(builder)",1,0,1
"adds, exp->line_adds",1,0,1
"""this is base 85 encoded"", buf.ptr",1,0,1
index_out,1,0,1
"input->ptr, input->size, out2.ptr, out2.size",1,0,1
"false, ""sub/sub2/aaa.html""",1,0,1
"super_repo, ""sm_unchanged""",1,0,1
"true, git_path_isvalid(NULL, "".git."", 0)",1,0,1
"git_oid_cmp(&binary_entry->id, &our_file_oid) == 0",1,0,1
"(mode & S_IRWXU), (st.st_mode & S_IRWXU)",1,0,1
"""yes"", git_buf_cstr(&buf)",1,0,1
"!git_path_exists(""stash/just.ignore"")",1,0,1
"false, git_path_isvalid(NULL, ""asdf>foo"", GIT_PATH_REJECT_NT_CHARS)",1,0,1
"config, ""some.section.test3"", ""welcome""",1,0,1
node->next == NULL,1,0,1
"expected, result.ptr",1,0,1
"true, git_path_isvalid(NULL, "".gi\x80\x8dT"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"true, git_path_isvalid(NULL, ""com0"", 0)",1,0,1
"-1000, git_reference_foreach_glob( repo, ""*"", interrupt_cb, &count) ",1,0,1
(new_iterator->flags & GIT_ITERATOR_DONT_IGNORE_CASE),1,0,1
"4, buf.size",1,0,1
"GIT_EEXISTS, git_reference_rename(&new_ref, ref, packed_test_head_name, 0, NULL)",1,0,1
"""both_sides-1.txt"", ours->path",1,0,1
"0 && ""Attempting to pause parser in error state""",1,0,1
"git_path_isfile(""submod2/.git/modules/"" ""sm_gitmodules_only"" ""/HEAD"")",1,0,1
"0, git_reflog_entrycount(log)",1,0,1
" GIT_EPEEL, git_revparse_single(&g_obj, g_repo, ""wrapped_tag^{blob}"")",1,0,1
"ref.ptr, ""refs/heads/master""",1,0,1
"expected_msg, err->message + (actual_len - expected_len)",1,0,1
" !git_oid_equal(&zero_id, &status->index_to_workdir->new_file.id) || !(status->index_to_workdir->new_file.flags & GIT_DIFF_FLAG_VALID_ID)",1,0,1
"false, git_path_isvalid(NULL, ""foo/bar/"", 0)",1,0,1
"cts.updates, 0",1,0,1
"git_index_get_bypath(index, ""new.txt"", 0) == NULL",1,0,1
"4, git_index_entrycount(_index)",1,0,1
"""test2-lightweight-*"", ""HEAD"", repo, &opts, &fmt_opts",1,0,1
"entry = git_index_get_bypath(g_idx, ""JUST_A_DIR/fILEE.txt"", 0)",1,0,1
"strcasecmp(""rt\303\202of"", ""rt dev\302\266h"") > 0",1,0,1
out && str,1,0,1
"!git_oid_cmp(&one, &two)",1,0,1
"!git_index_find(&pos, index, ""exec_off""), file, line, ""Cannot find original index entry"", NULL, 1",1,0,1
"""v1_0_1 release\n"", git_tag_message(tag)",1,0,1
out && repo && path,1,0,1
"false, git_path_isvalid(NULL, "".git/foo"", GIT_PATH_REJECT_DOT_GIT_LITERAL)",1,0,1
sm && subrepo,1,0,1
GIT_SUBMODULE_IGNORE_ALL,1,0,1
" git_remote_pushurl(g_remote), ""git@github.com:libgit2/libgit2""",1,0,1
"""no reference found for shorthand 'idontexist'"", giterr_last()->message",1,0,1
"true, ""refs/notes/foo""",1,0,1
"4, ahead",1,0,1
num >= 0,1,0,1
GIT_SUBMODULE_UPDATE_REBASE,1,0,1
cred && username && password,1,0,1
"""c-*"", ""HEAD"", repo, &opts, &fmt_opts",1,0,1
"NULL,""Newlines\nare\nreplaced by spaces\n""",1,0,1
"true, seen_paths.who",1,0,1
"0, git_strmap_num_entries(git__pack_cache)",1,0,1
"""gitdir: ../.git/modules/sm_libgit2/"", dot_git_content.ptr",1,0,1
NONE != t->last_cb,1,0,1
"git__strcmp(""\303\215"", ""\303\255"") < 0",1,0,1
out && sm,1,0,1
"GIT_REFS_HEADS_DIR ""\x41\xCC\x8A\x73\x74\x72\x6F\xCC\x88\x6D"", git_reference_name(new_ref)",1,0,1
"expected_noteness, git_reference_is_note(reference)",1,0,1
"merge_test_index(index, merge_index_entries, 7)",1,0,1
"20, git_pqueue_size(&pq)",1,0,1
"true, git_path_isvalid(NULL, ""com10"", 0)",1,0,1
fixed,1,0,1
"expected->dst_refname, updates[0]->dst_refname",1,0,1
"!git_path_exists(""testrepo/other.txt"")",1,0,1
"full_count, concurrent_count",1,0,1
pool && pool->item_size == sizeof(char),1,0,1
target_type == GIT_OBJ_TAG || target_type == GIT_OBJ_COMMIT || target_type == GIT_OBJ_TREE || target_type == GIT_OBJ_BLOB || target_type == GIT_OBJ_ANY,1,0,1
"NULL, git_index_get_bypath(index, ""other.txt"", 2)",1,0,1
"pCreateHardLink = (create_hardlink_func)GetProcAddress(module, ""CreateHardLinkA"")",1,0,1
"true, git_branch_is_head(branch2)",1,0,1
"1, git_clone__should_clone_local(path, GIT_CLONE_LOCAL_AUTO)",1,0,1
"e = git_index_get_bypath(index, ""copying"", 0)",1,0,1
"git_win32__stack(buf, sizeof(buf), 0, NULL, NULL) == 0",1,0,1
"true, git_path_isvalid(NULL, ""foo\\file.txt"", 0)",1,0,1
"false, ""dir/file3""",1,0,1
""""", ""\n \n""",1,0,1
"""b/ignoreme""",1,0,1
"entry_count0, max_i",1,0,1
oid && repo && tag_name && target && tagger && message,1,0,1
"12, exp[0]",1,0,1
!(sig->opt & GIT_HASHSIG_IGNORE_WHITESPACE) || !(sig->opt & GIT_HASHSIG_SMART_WHITESPACE),1,0,1
" ""diff --git a/zzz.binary b/zzz.binary\n"" ""index 45141a7..75b0dbb 100644\n"" ""Binary files a/zzz.binary and b/zzz.binary differ\n"", buf.ptr",1,0,1
"&x, expected4, ARRAY_SIZE(expected4)",1,0,1
GIT_SUBMODULE_UPDATE_CHECKOUT,1,0,1
opts != NULL,1,0,1
"e->file_size, test_entries[i].file_size",1,0,1
"""038d718"", shorty.ptr",1,0,1
"git_diff_num_deltas(diff1), 12",1,0,1
"!git_oid_streq(&oid, ""8496071c1b46c854b31185ea97743be6a8774479"")",1,0,1
config,1,0,1
"git_path_isfile(""submod2/.git/modules/"" ""sm_libgit2"" ""/HEAD"")",1,0,1
"git__suffixcmp(git_repository_workdir(repo), ""attr/"") == 0, file, line",1,0,1
"""33f915f9e4dbd9f4b24430e48731a59b45b15500\n"", 41, ""rebase/.git/rebase-merge/current""",1,0,1
"(entry = git_index_get_bypath(index, ""LAME.name.TXT"", 0))",1,0,1
"""newname.txt"", result.path",1,0,1
repo && name && url,1,0,1
values && repo && names,1,0,1
"true, ""dir/sub/sub2/aaa.html""",1,0,1
" (expected != 0) == (is_ignored != 0), file, line, ""expected != is_ignored"", filepath, 1",1,0,1
"!git_path_exists(""submod2/.git/modules/"" ""sm_libgit2b"")",1,0,1
_backend && length >= 0,1,0,1
"true, git_path_isvalid(NULL, ""."", 0)",1,0,1
"""A-*"", ""HEAD"", repo, &opts, &fmt_opts",1,0,1
" file,line,""wrong conflicts"", 1, ""%""PRIuZ, conflicts, vals.conflicts",1,0,1
"git_index_get_bypath(index, ""other.txt"", 2) != NULL",1,0,1
"name, p->first_alternate",1,0,1
repo && our_head && their_heads,1,0,1
"result, buf.ptr",1,0,1
reuc_out && path,1,0,1
len % 4 == 0,1,0,1
"false, ""dir1/dir2/onestar""",1,0,1
" ""diff --git a/zzz.numary b/zzz.numary\n"" ""index 45141a7..75b0dbb 100644\n"" ""--- a/zzz.numary\n"" ""+++ b/zzz.numary\n"" ""@@ -1,0 +2,3 @@\n"" ""+More lines\n"" ""+And more\n"" ""+Go here\n"", buf.ptr",1,0,1
"git_path_isdir(""t3/c"")",1,0,1
"git_remote_url(dup), git_remote_url(_remote)",1,0,1
"false, git_path_isvalid(NULL, ""prn"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
"dels, exp->line_dels",1,0,1
"fseek(f, 0, SEEK_SET) != -1",1,0,1
"lines, exp->lines",1,0,1
"ref.ptr, ""refs/remotes/test/master""",1,0,1
"1066, line->content_offset",1,0,1
parser->nread == 1,1,0,1
!test_driver_wildcard.shutdown,1,0,1
"expected[j], *val",1,0,1
expected[i] == x->contents[i],1,0,1
(caps & GIT_FEATURE_HTTPS) == 0,1,0,1
"i, 6",1,0,1
"2, sub_reserved_len",1,0,1
index && reuc && reuc->path != NULL,1,0,1
"true, git_path_isvalid(NULL, ""..git\xe2\x80\x8c"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"""dea509d0b"", shorty.ptr",1,0,1
"3, exp[2]",1,0,1
"entry_count6, entry_paths6, entry_statuses6, cl_git_sandbox_init(""status""), GIT_STATUS_SHOW_WORKDIR_ONLY, 0",1,0,1
"""new_side-1.txt"", theirs->path",1,0,1
!git_index_has_conflicts(repo_index),1,0,1
" ""diff --git a/zzz.textary b/zzz.textary\n"" ""index b435cd5..1604519 100644\n"" ""--- a/zzz.textary\n"" ""+++ b/zzz.textary\n"" ""@@ -3 +3 @@\n"" ""-0123456789\n"" ""+replace a line\n"", buf.ptr",1,0,1
"""new_side-2.txt"", theirs->path",1,0,1
ps && path,1,0,1
"expected_normal, buf.ptr",1,0,1
"e = git_index_get_bypath(index, ""src/common.h"", 0)",1,0,1
"merge_test_index(repo_index, merge_filesystem_entries, 3)",1,0,1
"""nulltoken"", ""emeric.fermas@gmail.com"", ""\""nulltoken\"""", ""\""emeric.fermas@gmail.com\""""",1,0,1
"true, git_path_isvalid(NULL, "".tig"", 0)",1,0,1
"dels, (int)td",1,0,1
"GIT_MERGE_PREFERENCE_NO_FASTFORWARD, (merge_pref & GIT_MERGE_PREFERENCE_NO_FASTFORWARD)",1,0,1
"git__prefixcmp(out.ptr, path) == 0",1,0,1
"expected_tracked_branch_name, buf.ptr",1,0,1
"b.ptr, git_reference_name(ref)",1,0,1
cfg && path,1,0,1
"""subdir_match/zzz_ignoreme""",1,0,1
"git_buf_grow(&buf, TOOBIG) == -1",1,0,1
"recurse, git_submodule_fetch_recurse_submodules(sm)",1,0,1
"""two"", git_buf_cstr(&buf)",1,0,1
"false, ""_test/foo/bar/code/file""",1,0,1
out && username && prompt_callback,1,0,1
"fread(buf, key_length, 1, f) == 1",1,0,1
"&x, expected6, ARRAY_SIZE(expected6)",1,0,1
db && id && out && len_p && type_p,1,0,1
"v, *(int *)p",1,0,1
"GIT_EINVALIDSPEC, ret",1,0,1
"kerneldll = LoadLibrary(""kernel32.dll"")",1,0,1
"""parent/nested/child5/bar.txt""",1,0,1
"git__strcasecmp("""", """") == 0",1,0,1
"cnt, git_diff_num_deltas(diff)",1,0,1
mctx->asub_tops > 0,1,0,1
"5, exp.line_adds",1,0,1
"""First paragraph with unwrapped trailing\tlines"", ""\nFirst paragraph\nwith unwrapped\ntrailing\tlines\n\n(Yes, unwrapped!)""",1,0,1
"true, git_path_isvalid(NULL, ""foo/bar\\"", 0)",1,0,1
"0, returned_entry->dev",1,0,1
"NULL, filename",1,0,1
"info->expect[info->expect_idx], path",1,0,1
"delta->nfiles, 1",1,0,1
"git_buf_grow_by(&buf, 50) == -1",1,0,1
"ident1.ptr, ""# $Id$"", 6",1,0,1
"ident1.ptr, ""# $Id: "", 7",1,0,1
"GIT_CREDTYPE_USERNAME, allowed_types",1,0,1
"&expected, &tree_oid",1,0,1
"ad->similarity, bd->similarity",1,0,1
"name, refnames[i]",1,0,1
"""yellow"", ce->value",1,0,1
wc_idx >= 0,1,0,1
"true, git_path_isvalid(NULL, ""asdf*bar"", 0)",1,0,1
out && path && *path,1,0,1
"exp_count, git_reflog_entrycount(log)",1,0,1
"&old_id, &diff_data.old_id",1,0,1
"expected_result, git_reference_has_log(g_repo, name)",1,0,1
"repo, 0, ""e90810b8df3e80c413d903f631643c716887138d"", ""258f0e2a959a364e40ed6603d5d44fbb24765b10"", msg",1,0,1
num_deltas > 0,1,0,1
username && cred && privatekey,1,0,1
"false, git_path_isvalid(NULL, ""foo/bar\\file.txt"", GIT_PATH_REJECT_BACKSLASH)",1,0,1
"git_index_get_bypath(index, ""new.txt"", 2) != NULL",1,0,1
action == INDEX_ACTION_UPDATE || action == INDEX_ACTION_ADDALL,1,0,1
"committer->name, git_reflog_entry_committer(entry)->name",1,0,1
"(*p)+1, progress",1,0,1
"p, b, c, 1, 15, 0, 3, 9, 3",1,0,1
rebase->last_commit,1,0,1
"1, index->tree->children_count",1,0,1
"0, count_config_entries_match(_repo, ""remote\\.test\\.+"")",1,0,1
"git_treebuilder_get(builder, ""aardvark"") == NULL",1,0,1
"true, git_path_isvalid(NULL, "".gi"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"false, ""aaa.html""",1,0,1
"!git_index_add_frombuffer(index, &new_entry, content, strlen(content)), file, line, ""Cannot add index entry from buffer"", NULL, 1",1,0,1
object_out && reference_out && repo && spec,1,0,1
"cts.conflicts, g_typechange_expected_conflicts[i]",1,0,1
git__pack_cache,1,0,1
"git_path_isdir(""testrepo/ab/4.txt"")",1,0,1
"32, diff_data.new_binary_inflatedlen",1,0,1
"&id, git_reflog_entry_id_old(entry)",1,0,1
writer.open == 0,1,0,1
"GIT_EINVALIDSPEC, ""53fc32d17276939fc79ed05badaef2db09990016"", GIT_OBJ_TAG",1,0,1
contents && path,1,0,1
"nlogs_master_after, nlogs_master",1,0,1
"repo, ""core.worktree"", ""../../../sm_gitmodules_only/""",1,0,1
"""barfoo"", values[1]",1,0,1
"subst_utf16_len, ret",1,0,1
"&x, expected3, ARRAY_SIZE(expected3)",1,0,1
"false, git_path_isvalid(NULL, ""foo/.git"", GIT_PATH_REJECT_DOT_GIT_LITERAL)",1,0,1
"!git_oid_streq(&oid, ""6dcf9bf7541ee10456529833502442f385010c3d"")",1,0,1
"GIT_MERGE_ANALYSIS_UNBORN, (merge_analysis & GIT_MERGE_ANALYSIS_UNBORN)",1,0,1
out && diff && opts,1,0,1
"true, git_path_isvalid(NULL, ""!git/bar"", 0)",1,0,1
"""Trailing tabs\tare removed"", ""Trailing tabs\tare removed\t\t""",1,0,1
"7, git_diff_stats_insertions(_stats)",1,0,1
"false, git_path_isvalid(NULL, ""foo/bar\\"", GIT_PATH_REJECT_BACKSLASH)",1,0,1
"2, (int)git_tree_entrycount(tree)",1,0,1
"&x, expected9, ARRAY_SIZE(expected9)",1,0,1
"false, git_path_isvalid(NULL, ""foo."", GIT_PATH_REJECT_TRAILING_DOT)",1,0,1
"""t3/c/f3""",1,0,1
"false, git_repository_is_bare(repo)",1,0,1
spec[*pos] == '^' || spec[*pos] == '~',1,0,1
cb,1,0,1
"ctxt, exp->line_ctxt",1,0,1
"0, s->status",1,0,1
"""ce01362"", shorty.ptr",1,0,1
tag_names && repo && pattern,1,0,1
"false, git_path_isvalid(NULL, "".g\xe2\x80\x8eIt"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"false, git_path_isvalid(NULL, ""foo:"", GIT_PATH_REJECT_TRAILING_COLON)",1,0,1
"expected, diff_buf.ptr",1,0,1
"GIT_PERMS_IS_EXEC(read_filemode(""a/b.txt""))",1,0,1
"somestring, buf.ptr",1,0,1
dir = opendir(search_dirname),1,0,1
"""tags/e"", ""HEAD^^^"", repo, &opts, &fmt_opts",1,0,1
"""subdir/file""",1,0,1
"true, git_path_isvalid(NULL, ""foo/.GIT/bar"", 0)",1,0,1
"git_path_exists(TEST_REPO_PATH ""/file4.txt"")",1,0,1
"input->ptr, input->size, out1.ptr, out1.size",1,0,1
name && driver,1,0,1
"GIT_EINVALIDSPEC, ""e90810b8df3e80c413d903f631643c716887138d"", GIT_OBJ_BLOB",1,0,1
"6, buf.size",1,0,1
delta->old_file.mode == GIT_FILEMODE_BLOB,1,0,1
"memcmp(result.ptr, ours.ptr, ours.size) == 0",1,0,1
"(binary_entry = git_index_get_bypath(repo_index, ""binary"", 0)) != NULL",1,0,1
"""refs/heads/*:refs/heads/*"", ""refs/heads/user/feature"", ""refs/heads/user/feature""",1,0,1
pb && id,1,0,1
iterator__has_been_accessed(&iter->base),1,0,1
"expected_rootlen, root_at",1,0,1
"SM_LIBGIT2_BRANCH, git_submodule_branch(sm)",1,0,1
"""rebase finished: returning to refs/heads/gravy"", git_reflog_entry_message(reflog_entry)",1,0,1
ancestor_out && our_out && their_out && iterator,1,0,1
"GIT_EINVALIDSPEC, git_reference_symbolic_create( &new_reference, g_repo, name, current_head_target, 0, NULL)",1,0,1
buf1.asize > 8,1,0,1
GIT_REPOSITORY_STATE_CHERRYPICK,1,0,1
!hidden,1,0,1
"""both_sides-2.txt"", ancestor->path",1,0,1
GIT_SUBMODULE_RECURSE_YES,1,0,1
"50, git_pqueue_size(&pq)",1,0,1
out && rebase,1,0,1
"repository, ""branch.test.remote"", "".""",1,0,1
"gpgsig, buf.ptr",1,0,1
"!git_path_isfile(""testrepo/readme"")",1,0,1
"true, git_path_isvalid(NULL, "".git\xe2\x80\xbf"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"!git_path_isfile(""testrepo/README"")",1,0,1
"""t3/f1""",1,0,1
"git_path_isfile(""submod2/"" ""sm_libgit2b"" ""/.git/HEAD"")",1,0,1
!git_atomic_get(&index->readers),1,0,1
"true, git_path_isvalid(NULL, ""foo..."", 0)",1,0,1
"git_treebuilder_insert(NULL, builder, ""invalid_file.txt"", &invalid_blob_id, GIT_FILEMODE_BLOB)",1,0,1
"true, git_path_isvalid(NULL, "".tig/bar"", 0)",1,0,1
out && reference && buffer && buffer_len,1,0,1
"""6b79e22d69bf46e289df0345a14ca059dfc9bdf6"", buf.ptr",1,0,1
"false, ""Folder/Middle/More/More/Contained/Not/Happy/Child""",1,0,1
diff_list && opts,1,0,1
"true, git_path_isvalid(NULL, ""foo/bar\\file.txt"", 0)",1,0,1
"strcasecmp(""e\342\202\254ghi="", ""et"") > 0",1,0,1
"true, git_path_isvalid(NULL, "".gi\x8dT"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
out && stats,1,0,1
"adds, (int)ta",1,0,1
"&oid, git_reflog_entry_id_old(entry)",1,0,1
"!git_oid_streq(&oid, ""a4a7dce85cf63874e984719f4fdd239f5145052f"")",1,0,1
"9, i",1,0,1
d->type == GIT_DIFF_TYPE_GENERATED,1,0,1
"""Unable to parse OID - contains invalid characters"", error->message",1,0,1
"2, st.st_nlink",1,0,1
"NULL , ""\n Spaces after newlines\n are\n collapsed\n """,1,0,1
"GIT_EINVALIDSPEC, ""53fc32d17276939fc79ed05badaef2db09990016"", GIT_OBJ_COMMIT",1,0,1
"1, entrycount(repo, ""refs/heads/foo"")",1,0,1
"false, git_path_isvalid(NULL, ""com1."", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
diriter->path_utf8.size > diriter->parent_utf8_len,1,0,1
delta_is_split(src),1,0,1
"""\tLeading tabs"", ""\tLeading\n\ttabs\n\nare preserved""",1,0,1
"&x, expected8, ARRAY_SIZE(expected8)",1,0,1
"git_remote_name(dup), git_remote_name(_remote)",1,0,1
c->privatekey,1,0,1
git_vector_length(&idx->deltas) > 0,1,0,1
"GIT_EINVALIDSPEC, git_reference_rename(&renamed_ref, looked_up_ref, ""i-will-sudo-you"", 0, NULL)",1,0,1
"GIT_REF_OID, git_reference_type(head_ref)",1,0,1
revspec && repo && spec,1,0,1
"""stash@{0}^2:who"", NULL",1,0,1
" counts->file, counts->line, ""Status code mismatch"", 1, ""%o"", counts->expected_statuses[idx], s",1,0,1
""""", ""\n""",1,0,1
"""B-0-*"", ""HEAD^^2^"", repo, &opts, &fmt_opts",1,0,1
"config, ""some.section.multi"", ""hi, this is a ; multiline comment # with ;\n special chars and other stuff !@#""",1,0,1
"false, git_path_isvalid(NULL, ""com1.asdf\\zippy"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
"AUTOMERGEABLE_MERGED_FILE, result.ptr, result.len",1,0,1
"&target_id, &entry->oid_cur",1,0,1
"""This is a commit note."", git_note_message(note)",1,0,1
"true, ""Folder/Middle/More/More/Contained/Happy/Child""",1,0,1
" GIT_EINVALIDSPEC, git_reference_rename(&renamed_ref, looked_up_ref, ""Hello! I'm a very invalid name."", 0, NULL)",1,0,1
remain < (MAX_PATH - 5),1,0,1
"expected_patience, buf.ptr",1,0,1
"""c-*"", ""HEAD^^2"", repo, &opts, &fmt_opts",1,0,1
"1, tree_cache->entry_count",1,0,1
"NULL, e = git_index_get_bypath(index, ""copying"", 0)",1,0,1
"expected_len, files_in_status",1,0,1
"entry_count5, entry_paths5, entry_statuses5, cl_git_sandbox_init(""status""), GIT_STATUS_SHOW_INDEX_ONLY, 0",1,0,1
"ignore, git_submodule_ignore(sm)",1,0,1
bld && filter,1,0,1
"0, git_oid_streq(&baseline->id, expectations->sha)",1,0,1
"0, git_odb_object_size(tree_odb)",1,0,1
repo && tag_name && target,1,0,1
index && source_entry->path,1,0,1
hint_path || !try_load_filters,1,0,1
"git_path_isdir(""submod2/"" ""sm_libgit2b"" ""/.git"")",1,0,1
"0 && ""Shouldn't get here.""",1,0,1
v && v->_cmp,1,0,1
pmatch[0].rm_so == start,1,0,1
"expected_result, result.ptr",1,0,1
"GIT_PERMS_IS_EXEC(read_filemode(""executable.txt""))",1,0,1
" template_path, git_repository_path(repo), ""hooks/link.sample"", filemode",1,0,1
"true, ""file1""",1,0,1
"&x, expected5, ARRAY_SIZE(expected5)",1,0,1
"0, (int)array.count",1,0,1
!index->entries.length,1,0,1
"true, git_path_isvalid(NULL, ""com10"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
"!GIT_ADD_SIZET_OVERFLOW(&out, SIZE_MAX-1, 1)",1,0,1
"GIT_CERT_HOSTKEY_LIBSSH2, cert->cert_type",1,0,1
"NULL, ""\n\nTrimmed leading&trailing newlines\n\n""",1,0,1
"GIT_REFS_HEADS_DIR ""\xC3\x85\x73\x74\x72\xC3\xB6\x6D"", git_reference_name(new_ref)",1,0,1
"0, returned_entry->ino",1,0,1
"delta->old_file.path, ""_file""",1,0,1
"git_win32_path_from_utf8(source_utf16, source) >= 0",1,0,1
(type == GIT_REBASE_OPERATION_EXEC) == !id,1,0,1
"""12c084412b952396962eb420716df01022b847cc\n"", 41, ""rebase/.git/rebase-merge/orig-head""",1,0,1
"false, git_path_isvalid(NULL, ""aux:asdf\\foobar"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
"the_paths[j], git_tree_entry_name(te)",1,0,1
"p, a, b, 1, 6, 0, 1, 5, 0",1,0,1
GIT_ATTR_FALSE(values[0]),1,0,1
"true, ""symlink""",1,0,1
" sm3, ""submodule.""SM3"".url"", ""remote.origin.url""",1,0,1
"GIT_FILEMODE_COMMIT, e->mode",1,0,1
actual = get_filename(expected),1,0,1
"0, """", ""bar.txt""",1,0,1
!test_driver_wildcard.initialized,1,0,1
"NULL, ""Trailing spaces are removed """,1,0,1
"repo, ""core.worktree"", ""../../../sm_libgit2/""",1,0,1
"0, p_mkdir(""symlink"", 0777)",1,0,1
S_ISDIR(iter->entry->mode),1,0,1
"true, git_path_isvalid(NULL, ""nul"", 0)",1,0,1
"true, git_path_isvalid(NULL, ""com1.asdf\\zippy"", 0)",1,0,1
git_index_has_conflicts(rebase_index),1,0,1
"false, git_path_isvalid(NULL, ""foo./bar"", GIT_PATH_REJECT_TRAILING_DOT)",1,0,1
"strcmp(buf, ""Wed, 9 Apr 2014 08:21:03 +0000"") == 0",1,0,1
" email, ""627e7e12d87e07a83fad5b6bfa25e86ead4a5270"", &opts",1,0,1
"""013cc32d341bab0e6f039f50f153c18986f16c58\n"", 41, ""rebase/.git/rebase-merge/cmt.4""",1,0,1
"GIT_EPEEL, ""7b4384978d2493e851f9cca7858815fac9b10980"", GIT_OBJ_BLOB",1,0,1
"""aa4c42aecdfc7cd989bbc3209934ea7cda3f4d88\n"", 41, ""rebase/.git/rebase-merge/cmt.1""",1,0,1
"0, giterr_state_capture(&err_state, 0)",1,0,1
"utf16_expected, path_utf16",1,0,1
repo && target,1,0,1
exists && refdb && refdb->backend,1,0,1
"git_note_id(note), note_oid",1,0,1
"2, delta->nfiles",1,0,1
"""both_sides-2.txt"", theirs->path",1,0,1
"&tree_id, &new_tree_id",1,0,1
"expected_current, git_rebase_operation_current(rebase)",1,0,1
"opts.pathspec.strings[i], delta->new_file.path, pathlen",1,0,1
"value, git_buf_cstr(&buf)",1,0,1
"""[section]\n\tname = value\n"", result.ptr",1,0,1
"(tree = resolve_commit_oid_to_tree(g_repo, commit)) != NULL",1,0,1
"git_path_isdir(""d0/other/dir"")",1,0,1
"""One-liner with trailing newline"", ""One-liner with trailing newline\n""",1,0,1
out && repo && name,1,0,1
0 != status->head_to_index->old_file.mode,1,0,1
newname != NULL,1,0,1
data && size,1,0,1
"1, problems.count",1,0,1
"""new_side-2.txt"", ancestor->path",1,0,1
"true, git_path_isvalid(NULL, "" "", 0)",1,0,1
buf && where <= buf->size && nb_to_remove <= buf->size - where,1,0,1
"7, exp[2]",1,0,1
"false, git_path_isvalid(NULL, ""foo/.git/bar"", GIT_PATH_REJECT_DOT_GIT_LITERAL)",1,0,1
branch_name && commit && ref_out,1,0,1
"git_index_get_bypath(index, ""new.txt"", 3) != NULL",1,0,1
"false, git_path_isvalid(NULL, ""git~1.. ."", GIT_PATH_REJECT_DOT_GIT_NTFS)",1,0,1
"0, entrycount(repo, ""refs/heads/foo"")",1,0,1
oid && index,1,0,1
"mode_expected, mode",1,0,1
"nentries, nentries_after",1,0,1
"git_remote_pushurl(dup), git_remote_pushurl(_remote)",1,0,1
"0, chdir(cwd)",1,0,1
"git__strcasecmp(""foo"", ""Foo"") == 0",1,0,1
"false, git_path_isvalid(NULL, ""/foo/bar"", 0)",1,0,1
"GITERR_INVALID, giterr_last()->klass",1,0,1
mctx->sub_tops != NULL,1,0,1
remove_len > 0,1,0,1
GIT_SUBMODULE_UPDATE_NONE,1,0,1
"fullpath, ""sub/"", 4",1,0,1
"strcmp(conflicting_buf.ptr, ""<<<<<<< ours\n"" ""this file is changed in master and branch\n"" ""=======\n"" ""this file is changed in branch and master\n"" "">>>>>>> theirs\n"") == 0",1,0,1
decoded_out && input,1,0,1
"7, git_index_entrycount(index)",1,0,1
"!""Unexpected state""",1,0,1
"""top/mid/btm/untracked""",1,0,1
"git_path_isdir(""t3/c/d"")",1,0,1
repo && id,1,0,1
"g_repo, name",1,0,1
"1414141414, st.st_mtime",1,0,1
"true, git_path_isvalid(NULL, ""aux.asdf\\zippy"", 0)",1,0,1
"custom_name, buf.ptr",1,0,1
"entry = git_index_get_bypath(g_idx, ""just_a_dir/A/b/Z/y/X/foo.txt"", 0)",1,0,1
check == NULL,1,0,1
"12, exp.lines",1,0,1
data && url,1,0,1
out && repo && name && new_name,1,0,1
"0 && ""Unknown header_state""",1,0,1
"""3e8989b5a16d5258c935d998ef0e6bb139cc4757\n"", 41, ""rebase/.git/rebase-merge/cmt.1""",1,0,1
"false, ""Folder/Middle/More/More/Contained""",1,0,1
"GIT_BRANCH_ALL, 14",1,0,1
"""modified_file"", status->head_to_index->old_file.path",1,0,1
regexp,1,0,1
"""8496071c1b46c854b31185ea97743be6a8774479"", 3, ""a65fed"", ""849607"", ""763d71""",1,0,1
"git__strcmp(""et"", ""e\342\202\254ghi="") < 0",1,0,1
"true, git_path_isvalid(NULL, ""foo:"", 0)",1,0,1
"1, exp->files",1,0,1
"true, git_path_isvalid(NULL, ""foo/.tig"", 0)",1,0,1
"git_remote_pushurl(mod), ""git://github.com/libgit2/notlibgit2""",1,0,1
oid && db,1,0,1
"g_repo, ""testrepo""",1,0,1
"true, ""dir1/dir2/dir3/twostars""",1,0,1
"true, git_path_isvalid(NULL, ""asdf|foo"", 0)",1,0,1
"newname, expected->newname",1,0,1
"""rebase: aborting"", git_reflog_entry_message(reflog_entry)",1,0,1
"8, git_diff_stats_insertions(_stats)",1,0,1
"str, buf.ptr",1,0,1
ignores && path,1,0,1
"""asparagus.txt"", status_entry->head_to_index->new_file.path",1,0,1
"&commit_id, &expected_commit_id",1,0,1
(st.st_mtime - curtime) < 5,1,0,1
"ad->flags, bd->flags",1,0,1
"4, exp[3]",1,0,1
"g_repo, git_buf_cstr(&key), url",1,0,1
"&x, NULL, 0",1,0,1
"""top/mid/btm/tracked""",1,0,1
"false, git_path_isvalid(NULL, "".git"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"false, ""Folder/Middle/Contained/Not/Happy/Child""",1,0,1
"0, git_config_foreach_match( config, pattern, count_config_entries_cb, &how_many)",1,0,1
"false, git_path_isvalid(NULL, ""asdf<bar"", GIT_PATH_REJECT_NT_CHARS)",1,0,1
"""refs/heads/master"", git_reference_symbolic_target(ref)",1,0,1
"""9539b2cc291d6a6b1b266df8474d31fdd344dd79\n"", 41, ""rebase/.git/rebase-merge/cmt.3""",1,0,1
"idstr, ""9432026""",1,0,1
"""Trimmed leading&trailing newlines"", ""\n\nTrimmed leading&trailing newlines\n\n""",1,0,1
"""c-7-*"", ""HEAD"", repo, &opts, &fmt_opts",1,0,1
"nentries +1, entrycount(repo, GIT_HEAD_FILE)",1,0,1
"""auto"", git_buf_cstr(&buf)",1,0,1
"4, conflicts",1,0,1
"""Vicent Marti <tanoku@gmail.com> 1273848544 +0200"", buf.ptr",1,0,1
"""test"", buf.ptr",1,0,1
nmatch > 1,1,0,1
(caps & GIT_FEATURE_THREADS) == 0,1,0,1
"""3e8989b5a16d5258c935d998ef0e6bb139cc4757\n"", 41, ""rebase/.git/rebase-merge/cmt.3""",1,0,1
"true, git_path_isvalid(NULL, ""com1:asdf\\foobar"", 0)",1,0,1
"CONFLICTING_RECURSIVE_F1_TO_F2, conflicting_buf.ptr",1,0,1
"GIT_REF_SYMBOLIC, git_reference_type(ref)",1,0,1
"1, st.st_nlink",1,0,1
"""/"", actual + (start - 1), 1",1,0,1
"""foo"", git_buf_cstr(&buf)",1,0,1
"repo, ""where"", GIT_ENOTFOUND",1,0,1
remote_name && branch,1,0,1
"""tags/c-*"", ""HEAD^"", repo, &opts, &fmt_opts",1,0,1
"_repo, ""remote.test.tagopt"", ""--no-tags""",1,0,1
idx && stream,1,0,1
""" Trailing spaces are stripped"", "" \n Trailing spaces \n are stripped \n\n \n \t """,1,0,1
"_repo, ""remote.just.renamed.fetch"", true",1,0,1
refspec && input,1,0,1
url_buf.size < 4096,1,0,1
use_fixed_size <= fixed_size,1,0,1
"4, git_diff_stats_deletions(_stats)",1,0,1
update_heads && fetchspec_src,1,0,1
"7, delta->new_file.id_abbrev",1,0,1
"config, ""some.sec\\tion.other"", ""foo""",1,0,1
"ours.size, result.len",1,0,1
"strcmp(""\303\215"", ""\303\255"") < 0",1,0,1
delta->status == GIT_DELTA_ADDED || delta->status == GIT_DELTA_MODIFIED || delta->status == GIT_DELTA_CONFLICTED || delta->status == GIT_DELTA_DELETED,1,0,1
"NULL, git_libgit2__user_agent()",1,0,1
"3, reserved_len",1,0,1
rebase && committer,1,0,1
"""libgit2"", git_submodule_name(sm)",1,0,1
"output->length, ARRAY_SIZE(refnames)",1,0,1
"expect_nsec, test_file_has_nsec",1,0,1
"ad->nfiles, bd->nfiles",1,0,1
"GIT_MERGE_ANALYSIS_NORMAL, merge_analysis",1,0,1
"false, git_path_isvalid(NULL, "":"", GIT_PATH_REJECT_TRAILING_COLON)",1,0,1
"""parent/child2/bar.txt""",1,0,1
actual_len >= expected_len,1,0,1
out && patch,1,0,1
regs->num_regs >= nregs,1,0,1
oldname != NULL,1,0,1
"_repo, ""branch.master.merge"", false",1,0,1
"2, index->tree->children_count",1,0,1
out && repo && commit,1,0,1
"true, ""dir1/dir2/dir3/parent2/kid2/file""",1,0,1
"GIT_EINVALIDSPEC, ""0266163a49e280c4f5ed1e08facd36a2bd716bcf"", GIT_OBJ_COMMIT",1,0,1
" 80, git_atomic_get(&_counts[2])",1,0,1
"true, git_path_isvalid(NULL, ""foo/bar/.Git"", 0)",1,0,1
"numchunks, git_blob_rawsize(blob)",1,0,1
"0, ""foo.txt"", """"",1,0,1
"patchfile, validated.ptr",1,0,1
"ident2.ptr, ""# $Id$"", 6",1,0,1
_backend && cb,1,0,1
"0, git_graph_descendant_of(_repo, git_commit_id(commit), git_commit_id(commit))",1,0,1
"&current_id, &entry->oid_old",1,0,1
"""f87d14a4a236582a0278a916340a793714256864\n"", 41, ""rebase/.git/rebase-merge/cmt.3""",1,0,1
"true, ""_test/foo/bar/crux/file""",1,0,1
"0, git_status_list_entrycount(status_list)",1,0,1
"g_repo, ""bra\nch""",1,0,1
"true, git_path_isvalid(NULL, ""com1."", 0)",1,0,1
"""refs/notes/fanout"", true",1,0,1
backend && cb,1,0,1
"expected, git_buf_cstr(&actual)",1,0,1
"EINVAL, errno",1,0,1
"true, git_path_isvalid(NULL, "":"", 0)",1,0,1
"true, git_path_isvalid(NULL, ""aux\\foo"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
branch && new_branch_name,1,0,1
"""hiya"", git_buf_cstr(&buf)",1,0,1
"GIT_FILEMODE_BLOB, entry->mode",1,0,1
(caps & GIT_FEATURE_SSH) != 0,1,0,1
"new_commit, 1",1,0,1
"""modified_file"", status->index_to_workdir->old_file.path",1,0,1
"!git_oid_equal(&initial, &first)",1,0,1
"&expected->oid, oid",1,0,1
"&their_entry.id, &conflict_entry[2]->id",1,0,1
"0, status & GIT_SUBMODULE_STATUS_WD_MODIFIED",1,0,1
zs->avail_in == 0,1,0,1
git_iterator_ignore_case(workdir) == git_iterator_ignore_case(baseline),1,0,1
"0, status->index_to_workdir->old_file.size",1,0,1
"expected4, buf.ptr",1,0,1
"true, git_path_isvalid(NULL, ""com1"", 0)",1,0,1
"git_repository__reserved_names(&reserved, &reserved_len, repo, false)",1,0,1
spec[*pos] == '^' || spec[*pos] == '@',1,0,1
"!git_path_isdir(""testrepo/A"")",1,0,1
" file, line, ""expected != is_ignored"", 1, ""%d"", (int)(expected != 0), (int)(is_ignored != 0)",1,0,1
"false, git_path_isvalid(NULL, ""foo//bar"", 0)",1,0,1
"git_reference_target(master_ref), git_reference_target(resolved_ref)",1,0,1
GIT_SUBMODULE_IGNORE_NONE,1,0,1
find_master_called,1,0,1
out && objects_dir,1,0,1
"""this/is/deep/too""",1,0,1
out && obj,1,0,1
"GIT_EINVALIDSPEC, ""e90810b8df3e80c413d903f631643c716887138d"", GIT_OBJ_TAG",1,0,1
sizeof(git_off_t) == 8,1,0,1
"pCreateSymbolicLink = (create_symlink_func)GetProcAddress(module, ""CreateSymbolicLinkA"")",1,0,1
"0, ctor_called",1,0,1
len > 0 && len <= (int)n,1,0,1
e,1,0,1
"mixed_case, conflict_entry[1]->path",1,0,1
"expected, git_commit_summary(dummy)",1,0,1
"99, giterr_last()->klass",1,0,1
(error == 0),1,0,1
"""sm_libgit2"", ""https://github.com/libgit2/libgit2.git""",1,0,1
"NULL, operation->exec",1,0,1
"""modified_file"", status->head_to_index->new_file.path",1,0,1
"""refs/heads/*:refs/remotes/origin/*"", ""refs/remotes/o/master""",1,0,1
"true, ""dir1/parent1/kid1/file/inside/parent""",1,0,1
git_submodule_update_strategy(sm) == GIT_SUBMODULE_UPDATE_CHECKOUT,1,0,1
repo && their_heads,1,0,1
"git_path_isfile(""testrepo/readme"")",1,0,1
"!git_index_find(&pos, index, name)",1,0,1
"GIT_SUBMODULE_STATUS_WD_MODIFIED, status & GIT_SUBMODULE_STATUS_WD_MODIFIED",1,0,1
"""branch: renamed refs/heads/master to refs/heads/master2"", git_reflog_entry_message(entry)",1,0,1
"backslashed_path, git_submodule_url(sm)",1,0,1
"!memcmp(out1.ptr, out2.ptr, out1.size)",1,0,1
spec[*pos] == ':',1,0,1
"""test2-lightweight-*"", ""HEAD^"", repo, &opts, &fmt_opts",1,0,1
"15, i",1,0,1
""" Spaces after newlines are collapsed"", ""\n Spaces after newlines\n are\n collapsed\n """,1,0,1
location && sm,1,0,1
"GIT_DIRECTION_FETCH, ""refs/pull/*/head:refs/remotes/origin/pr/*"", true",1,0,1
"1234567890, st.st_atime",1,0,1
"&new_id, &diff_data.new_id",1,0,1
old_commit,1,0,1
"true, git_path_isvalid(NULL, ""auxn"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
oom_error,1,0,1
idx && data && stats,1,0,1
"-321, git_odb_foreach(_odb, foreach_stop_cb, &nobj)",1,0,1
"repo, ""who"", GIT_STATUS_WT_NEW | GIT_STATUS_INDEX_DELETED",1,0,1
out && field && content,1,0,1
""" Spaces around newlines are collapsed"", "" \n Spaces around newlines \n are \n collapsed \n """,1,0,1
"GIT_EINVALIDSPEC, ""53fc32d17276939fc79ed05badaef2db09990016"", GIT_OBJ_ANY",1,0,1
(caps & GIT_FEATURE_NSEC) == 0,1,0,1
"GIT_EINVALIDSPEC, ""0266163a49e280c4f5ed1e08facd36a2bd716bcf"", GIT_OBJ_ANY",1,0,1
"""one.tmp""",1,0,1
"g_repo, ""sm_added_and_uncommited/""",1,0,1
"(dummy = git_index_get_bypath(index, ""dummy-file.txt"", 0))",1,0,1
"git_blob_id(b), &delta->new_file.id",1,0,1
"data, strlen(data) + 1, out.ptr, out.size",1,0,1
left > -1,1,0,1
"true, git_path_isvalid(NULL, "".g\xe2\x80It"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"true, git_path_isvalid(NULL, ""asdf\001foo"", 0)",1,0,1
error >= 0 || error == GIT_ENOTFOUND,1,0,1
newname == NULL,1,0,1
"expected, actual + start",1,0,1
"false, git_path_isvalid(NULL, ""foo/."", GIT_PATH_REJECT_TRAVERSAL)",1,0,1
"0, ""foo.txt"", ""bar.txt""",1,0,1
"true, git_path_isvalid(NULL, ""prn"", 0)",1,0,1
"!git_path_exists(""merge-resolve/.git/"" GIT_MERGE_MODE_FILE)",1,0,1
"true, git_path_isvalid(NULL, ""git~1.. ."", 0)",1,0,1
"g_repo, ""branc#""",1,0,1
"git_path_isdir(""submod2/.git/modules/"" ""sm_libgit2"")",1,0,1
"8, git_diff_stats_deletions(_stats)",1,0,1
"false, git_path_isvalid(NULL, ""aux.asdf"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
payload && db && refname,1,0,1
opts->summary && opts->id && opts->author,1,0,1
"root_path = git__calloc(1, root_offset + 2)",1,0,1
"name_len > strlen("".pack"")",1,0,1
"update, git_submodule_update_strategy(sm)",1,0,1
"true, ""dir1/onestar""",1,0,1
"8, buf.size",1,0,1
"NULL, 5, ""5b5b02"", ""763d71"", ""a4a7dc"", ""a65fed"", ""41bc8c""",1,0,1
"true, ""dir/file2/actual_file""",1,0,1
!(allowed_types & GIT_CREDTYPE_USERNAME),1,0,1
"true, git_path_isvalid(NULL, ""foo/!git"", 0)",1,0,1
"10, i",1,0,1
"true, git_path_isvalid(NULL, ""foo/bar."", 0)",1,0,1
"2, git_tree_entrycount(tree)",1,0,1
"""new_side-1.txt"", ours->path",1,0,1
tx && refname && reflog,1,0,1
"2, exp.file_status[GIT_DELTA_CONFLICTED]",1,0,1
out && _backend,1,0,1
"git_path_isdir(""testrepo/a"")",1,0,1
match_last != -1,1,0,1
" sm1, ""submodule.""SM1"".url"", ""remote.origin.url""",1,0,1
"""\tother = otherval\n"", n, strlen(""\tother = otherval\n"")",1,0,1
"git_annotated_commit_id(branch), git_reference_target(branch_ref)",1,0,1
"&oid, git_object_id(next_top_stash)",1,0,1
"git_note_id(note), &note_oid",1,0,1
(root_offset = git_path_root(sandbox_path)) >= 0,1,0,1
"true, git_path_isvalid(NULL, ""com1:"", 0)",1,0,1
"t = git__calloc(1, sizeof(*t))",1,0,1
"GIT_EINVALIDSPEC, git_remote_lookup(&_remote, _repo, ""Inv@{id"")",1,0,1
"0, buf.asize",1,0,1
"mixed_case, conflict_entry[2]->path",1,0,1
"git_object_id(obj), git_reference_target(cloned_head)",1,0,1
"false, ""refs/tags/foo""",1,0,1
"true, ""dir1/onestar/child""",1,0,1
"git_oid_equal(git_commit_id(c), git_commit_id(head)), file, line, ""Commit is not the HEAD"", NULL, 1",1,0,1
"false, git_reference_has_log(repo, ""refs/heads/track-local"")",1,0,1
"2, 14, 4, 6, 4, &expected",1,0,1
"1, refs.count",1,0,1
"strstr(git_buf_cstr(&logcontents), ""Reflog\nmessage"") != NULL",1,0,1
"strcmp(""rt dev\302\266h"", ""rt\303\202of"") < 0",1,0,1
len >= GIT_OID_MINPREFIXLEN && len <= GIT_OID_HEXSZ,1,0,1
"git__strcmp(""foo"", ""foo"") == 0",1,0,1
" GIT_EINVALIDSPEC, git_remote_rename(&problems, _repo, _remote_name, ""new@{name"")",1,0,1
"fseek(f, 0, SEEK_END) != -1",1,0,1
symbolic || signature,1,0,1
diriter,1,0,1
" file, line, ""expected diff did not match actual diff"", 1, ""%s"", expected[d], get_buf_ptr(&buf)",1,0,1
"giterr_last() == oom_error, ""static oom error not restored""",1,0,1
"true, ""refs/heads/foo""",1,0,1
"merge_test_index(repo_index, second_revert_entries, 6)",1,0,1
"0, mode",1,0,1
bytes_read == bytes_written,1,0,1
"count_config_entries_match(_repo, ""remote\\.test\\.+"") > 0",1,0,1
"absolute_url.ptr, git_submodule_url(sm)",1,0,1
rebase->current < rebase->operations.size,1,0,1
"""A-*[0-9a-f]"", repo, &opts, &fmt_opts",1,0,1
"""hard_tag"", ""HEAD"", repo, &opts, &fmt_opts",1,0,1
git_odb_object_data(tree_odb),1,0,1
"""refs/remotes/renamed/HEAD"", git_reference_name(ref)",1,0,1
file && file->path_original,1,0,1
"1, git_index_has_conflicts(repo_index)",1,0,1
"expected_len, ids[i].length",1,0,1
"true, git_path_isvalid(NULL, ""aux1"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
"""test/ignore_me/file""",1,0,1
"false, git_path_isvalid(NULL, ""/"", 0)",1,0,1
builder_p && repo,1,0,1
(leaks == 3),1,0,1
"0, git_clone__should_clone_local(buf.ptr, GIT_CLONE_LOCAL)",1,0,1
"l1, git_patch_num_lines_in_hunk(p, 1)",1,0,1
"!git_path_exists(""merge-resolve/.git/"" GIT_MERGE_HEAD_FILE)",1,0,1
"!git_path_exists(""stash/ignored_directory"")",1,0,1
"git_win32_path_from_utf8(dest_utf16, dest) >= 0",1,0,1
"strlen(AUTOMERGEABLE_MERGED_FILE), result.len",1,0,1
"""c-*"", ""HEAD^"", repo, &opts, &fmt_opts",1,0,1
inflateInit(&stream) == Z_OK,1,0,1
"3, git_diff_stats_files_changed(_stats)",1,0,1
"l0, git_patch_num_lines_in_hunk(p, 0)",1,0,1
"cl_fixture(""attr/attr2""), file->entry->path",1,0,1
"""GIT~2"", reserved[2].ptr",1,0,1
"true, ""_test/foo/bar/qux/file""",1,0,1
"GIT_EINVALIDSPEC, ""53fc32d17276939fc79ed05badaef2db09990016"", GIT_OBJ_BLOB",1,0,1
err->message != NULL,1,0,1
""""", spec.src",1,0,1
"4, git_diff_stats_insertions(_stats)",1,0,1
out && repo && stasher,1,0,1
ptr - buf->data >= 0,1,0,1
"""4cacc6f6e740a5bc64faa33e04b8ef0733d8a127\n"", 41, ""rebase/.git/rebase-merge/cmt.2""",1,0,1
oid && buffer,1,0,1
"file, line, ""Expected mode does not match index"", 1, ""%07o"", (unsigned int)entry->mode, (unsigned int)mode",1,0,1
"true, git_path_isvalid(NULL, "".gi\xe2\x80\x8dT."", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"git__strcasecmp(""foo"", ""foo"") == 0",1,0,1
"true, git_path_isvalid(NULL, ""foo/bar:"", 0)",1,0,1
fl && filter,1,0,1
"wcslen(utf16_expected), path_utf16len",1,0,1
id && commit_to_amend,1,0,1
right > -1,1,0,1
"""are removed"", ""Trailing tabs\t\n\nare removed""",1,0,1
"true, git_path_isvalid(NULL, ""com0"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
git_repository_head_detached(cloned_repo),1,0,1
"_repo, ""remote.test.tagopt"", false",1,0,1
!IS_EPSILON_NODE (node->token.type),1,0,1
"false, git_path_isvalid(NULL, ""."", GIT_PATH_REJECT_TRAVERSAL)",1,0,1
popped,1,0,1
"""Test User"", sign->name",1,0,1
"git_path_isdir(""submod2/.git/modules/"" ""sm_gitmodules_only"")",1,0,1
"(entry = git_index_get_bypath(newindex, ""B"", 0))",1,0,1
"true, git_path_isvalid(NULL, ""aux:asdf\\foobar"", 0)",1,0,1
"print_utf16_len, ret",1,0,1
"999, tmp",1,0,1
"2, git_index_entrycount(index)",1,0,1
"data, buf.ptr",1,0,1
"FOO_COMMENT, n, strlen(FOO_COMMENT)",1,0,1
GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE,1,0,1
"1, reserved_len",1,0,1
"_repo, ""remote.test.tagopt"", ""--tags""",1,0,1
"5, git_index_entrycount(_index)",1,0,1
"config, ""some.section.test2"", ""hello""",1,0,1
(val = git_pqueue_pop(&pq)) != NULL,1,0,1
"git_path_isdir(""testrepo/BRANCH_FILE.txt"")",1,0,1
backend && ref_name,1,0,1
" -111, git_status_foreach(repo, cb_status__interrupt, &count) ",1,0,1
"memcmp(input->ptr, inflated.ptr, inflated.size) == 0",1,0,1
"num_modified_deltas(a), num_modified_deltas(b)",1,0,1
"true, git_path_isvalid(NULL, ""asdf:foo"", 0)",1,0,1
" email, ""8d7523f6fcb2404257889abe0d96f093d9f524f9"", &opts",1,0,1
"false, git_path_isvalid(NULL, ""aux."", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
"1468, line->content_offset",1,0,1
"entry->value, ""newurl""",1,0,1
"false, seen_paths.how",1,0,1
"NULL, git_repository_path(repo)",1,0,1
"0, """", """"",1,0,1
zstream->in_len > 0 || zflush == Z_FINISH,1,0,1
"false, git_path_isvalid(NULL, ""com1:"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
"(out = fopen(out_f.ptr, ""wb"")) != NULL",1,0,1
"false, filepath, __FILE__, __LINE__",1,0,1
buf && repo && refname,1,0,1
"strcmp(buf, ""Wed, 9 Apr 2014 06:21:03 -0200"") == 0",1,0,1
"3, git_index_entry_stage(conflict_entry[2])",1,0,1
"true, ""foo/bar/baz/quux""",1,0,1
"config, ""some.section.multi2"", ""good, this is a ; multiline comment # with ;\n special chars and other stuff !@#""",1,0,1
"GIT_ENOTFOUND, git_remote_lookup(&_remote, _repo, ""just-left-few-minutes-ago"")",1,0,1
"44, (int)refnames.count",1,0,1
"strcasecmp(""rt dev\302\266h"", ""rt\303\202of"") < 0",1,0,1
status && repo && name,1,0,1
"false, git_path_isvalid(NULL, ""nul"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
git_path_exists(path.ptr),1,0,1
"git_treebuilder_get(builder, ""apple"") != NULL",1,0,1
"1, filter_for(""not_in_gitattributes"", ""crlf"")",1,0,1
" template_path, git_repository_path(repo), ""hooks/update.sample"", filemode",1,0,1
"""refs/heads/beef"", git_reference_symbolic_target(head_ref)",1,0,1
"42, giterr_last()->klass",1,0,1
out && cfg,1,0,1
"buffer.ptr, ""This is longer\nAnd multiline\n# with some comments still in\n""",1,0,1
"""First paragraph only"", ""\nFirst paragraph only\n\n(There are more!)""",1,0,1
"&hunk->final_commit_id, &hunk->orig_commit_id",1,0,1
" template_path, git_repository_path(repo), ""hooks/.dotfile"", filemode",1,0,1
err == REG_NOERROR,1,0,1
repo && odb,1,0,1
"true, git_path_isvalid(NULL, ""foo/.."", 0)",1,0,1
"32, (int)refnames.count",1,0,1
"0, chdir(""readonly"")",1,0,1
src->status == GIT_DELTA_DELETED,1,0,1
" memcmp(expanded, expected, e_len) == 0, file, line, ""uncompressed data did not match"", NULL, 1",1,0,1
"git_path_isdir(""d0/foo/bar"")",1,0,1
"git_path_isfile(""submod2/"" ""sm_libgit2"" ""/.git"")",1,0,1
"!""Wrong caching type in the global object cache""",1,0,1
" CANCEL_VALUE, git_attr_foreach( g_repo, 0, ""sub/subdir_test1"", &cancel_iteration, &count) ",1,0,1
"input->size, inflated.size",1,0,1
"true, git_path_isvalid(NULL, ""foo/bar/.file"", 0)",1,0,1
out && odb,1,0,1
"custom_name, git_libgit2__user_agent()",1,0,1
"16, git_status_list_entrycount(statuslist)",1,0,1
"GIT_EEXISTS, git_remote_rename(&problems, _repo, _remote_name, ""test_with_pushurl"")",1,0,1
"repo, ""refs/tags/some-tag""",1,0,1
"4, 9, 0, 5, 4, &expected",1,0,1
"""stash@{0}^0:who"", ""a0400d4954659306a976567af43125a0b1aa8595""",1,0,1
"git_index_entrycount(index), 1437",1,0,1
"""localhost"", host",1,0,1
"""12c084412b952396962eb420716df01022b847cc\n"", 41, ""rebase/.git/ORIG_HEAD""",1,0,1
"false, git_path_isvalid(NULL, "" "", GIT_PATH_REJECT_TRAILING_SPACE)",1,0,1
"true, git_path_isvalid(NULL, "".g\xe2i\x80T\x8e"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"false, git_path_isvalid(NULL, "".gi\xe2\x80\x8dT"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
start_path,1,0,1
"""works"", git_buf_cstr(&buf)",1,0,1
"entry = (git_index_entry *)git_index_get_bypath(index, ""A"", 0)",1,0,1
"""A-3-*"", ""HEAD^^2"", repo, &opts, &fmt_opts",1,0,1
"memcmp(new, result.ptr, new_len) == 0",1,0,1
"false, ""dir1/dir2/parent1/kid1/file""",1,0,1
"true, git_path_isvalid(NULL, ""aux."", 0)",1,0,1
"""refs/heads/master"", git_reference_name(branch2)",1,0,1
"0, filter_for(""binary.bin"", ""crlf"")",1,0,1
"0, exp[2]",1,0,1
"""ba!tca&BaE"", buf.ptr",1,0,1
"NULL , ""\n \n""",1,0,1
"2, git_libgit2_init()",1,0,1
"git_path_exists(""nasty/git~3/foobar"")",1,0,1
"strcmp(""e\342\202\254ghi="", ""et"") > 0",1,0,1
"git_annotated_commit_id(branch), git_reflog_entry_id_new(reflog_entry)",1,0,1
error != NULL,1,0,1
"false, git_path_isvalid(NULL, ""asdf\037bar"", GIT_PATH_REJECT_NT_CHARS)",1,0,1
"true, git_path_isvalid(NULL, ""."", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"1, git_index_entry_stage(conflict_entry[0])",1,0,1
"!git_index_find(&pos, index, ""filemodes/explicit_test""), file, line, ""Cannot find new index entry"", NULL, 1",1,0,1
(key_length = ftell(f)) != -1,1,0,1
"newname ? newname : oldname, filename",1,0,1
" 0, memcmp(flipped, out.ptr, out.size)",1,0,1
"18, i",1,0,1
"(star = strchr(git_buf_cstr(&logcontents), '*')) != NULL",1,0,1
"true, ""refs/tags/foo""",1,0,1
"true, git_path_isvalid(NULL, ""aux"", 0)",1,0,1
"expected_merge, strlen(expected_merge), ""rebase/asparagus.txt""",1,0,1
test_driver_custom.initialized,1,0,1
"entry = git_index_get_bypath(index, ""executable.txt"", 0)",1,0,1
"expected_type, ids[i].type",1,0,1
"0, git_tree_entrycount(tree)",1,0,1
(st.st_atime - curtime) < 5,1,0,1
0 != e->mtime.seconds,1,0,1
dfa->nexts[cur_node_idx] != -1,1,0,1
"false, git_path_isvalid(NULL, ""foo/bar:"", GIT_PATH_REJECT_TRAILING_COLON)",1,0,1
"false, git_path_isvalid(NULL, ""com1:asdf\\foobar"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
"""Yu V. Bin Haacked"", signature->name",1,0,1
out && buf,1,0,1
"""test@test.tt"", sign->email",1,0,1
"""github.com"", host",1,0,1
"git_pool_strndup(&p, ""foo"", (size_t)-1) == NULL",1,0,1
"""crlf\ncrlf\ncrlf\ncrlf\n"", buf.ptr",1,0,1
"expected[i], alt[i]",1,0,1
ignored && pathname,1,0,1
"git__strcmp(""Foo"", ""foo"") < 0",1,0,1
"exp_msg, git_reflog_entry_message(entry)",1,0,1
"i, 0",1,0,1
value && repo && name,1,0,1
"false, git_path_isvalid(NULL, "".git"", GIT_PATH_REJECT_DOT_GIT_LITERAL)",1,0,1
diriter->path.size > diriter->parent_len,1,0,1
"true, git_path_isvalid(NULL, ""con"", 0)",1,0,1
"getcwd(cwd, sizeof(cwd)) != NULL",1,0,1
"out.ptr, path",1,0,1
"info->expect[info->expect_idx], ""[CANCEL]""",1,0,1
(caps & GIT_FEATURE_NSEC) != 0,1,0,1
"true, git_path_isvalid(NULL, "".."", 0)",1,0,1
found_look_ma,1,0,1
"sm_head, git_oid_tostr_s(&entry->id)",1,0,1
"false, git_path_isvalid(NULL, ""\xe2\x80\xaa.gIt"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"correct_case, conflict_entry[1]->path",1,0,1
"""c%1vf+QYWt3zLL@hC)e3Vu?a>QDRl4f_G*?PG(-ZA}<#J$+QbW"", diff_data.new_binary_base85.ptr",1,0,1
"9, exp.files",1,0,1
"repo, ""ignored_directory/sub/some_file"", GIT_STATUS_IGNORED",1,0,1
"1, update_payload.checkout_notify_called",1,0,1
"g_repo, ""mismatch_name""",1,0,1
"NULL, ""Trailing tabs\tare removed\t\t""",1,0,1
"git_oid_cmp(&id, &index->tree->oid)",1,0,1
"true, git_path_isvalid(NULL, ""foo/.git"", 0)",1,0,1
"(f = fopen(path, ""r"")) != NULL",1,0,1
"""Debug""",1,0,1
data->transfer_progress_calls > 0,1,0,1
" email, ""6e05acc5a5dab507d91a0a0cc0fb05a3dd98892d"", &opts",1,0,1
"&base, &result.ids[0]",1,0,1
"2, git_index_entry_stage(conflict_entry[1])",1,0,1
" ""diff --git a/zzz.normal b/zzz.normal\n"" ""index b435cd5..1604519 100644\n"" ""Binary files a/zzz.normal and b/zzz.normal differ\n"", buf.ptr",1,0,1
" file, line, msg, 1, ""%i"", expected_error, (int)(git_submodule_lookup(NULL, repo, name))",1,0,1
"""e"", ""HEAD^^^"", repo, &opts, &fmt_opts",1,0,1
"NULL, git_index_get_bypath(repo_index, ""test-one.txt"", 0)",1,0,1
"delta->old_file.path, ""file.txt""",1,0,1
"NULL, 3, ""763d71"", ""a65fed"", ""e90810""",1,0,1
"GIT_FILEMODE_LINK, entry->mode",1,0,1
"GIT_ITEROVER, git_revwalk_next(&id, walk)",1,0,1
path[root_offset+1] != '/',1,0,1
"(error = p_ftruncate(fd, i64len)) == 0",1,0,1
"1, counts.entry_count",1,0,1
"!GIT_ADD_SIZET_OVERFLOW(&out, 42, 69)",1,0,1
"entry = git_index_get_bypath(g_idx, sm_name, 0)",1,0,1
"expected_remote_name, buf.ptr",1,0,1
"old_val, str",1,0,1
data,1,0,1
0x80 % BITSET_WORD_BITS == 0,1,0,1
"""refs/heads/gravy"", git_reference_symbolic_target(head_ref)",1,0,1
"&commit_id, git_reflog_entry_id_old(reflog_entry)",1,0,1
"&id, git_reflog_entry_id_new(entry)",1,0,1
"""bad"", signature.ptr",1,0,1
" ""diff --git a/zzz.textnumary b/zzz.textnumary\n"" ""index b435cd5..1604519 100644\n"" ""--- a/zzz.textnumary\n"" ""+++ b/zzz.textnumary\n"" ""@@ -3 +3 @@ 0123456789\n"" ""-0123456789\n"" ""+replace a line\n"", buf.ptr",1,0,1
"""A-*"", ""HEAD^"", repo, &opts, &fmt_opts",1,0,1
"git__utf8_to_16_alloc(&wide_value, value) >= 0",1,0,1
"""refs/heads/master"", refs[0]->symref_target",1,0,1
"found_path.ptr, expected_path->ptr",1,0,1
index && entry_ptr,1,0,1
"SM_LIBGIT2_URL, git_submodule_url(sm)",1,0,1
"""Trailing spaces"", ""Trailing spaces \n\nare removed""",1,0,1
"1, len",1,0,1
"entry = git_index_get_bypath(index, ""streamed_file"", 0)",1,0,1
c->username,1,0,1
"oneline_data, signed_data.ptr",1,0,1
count <= MAX_SHUTDOWN_CB && count > 0,1,0,1
"""new_side-1.txt"", ancestor->path",1,0,1
" ""da9c51a23d02d931a486f45ad18cda05cf5d2b94 776e4c48922799f903f03f5f6e51da8b01e4cce0\n"" ""8d1f13f93c4995760ac07d129246ac1ff64c0be9 ba1f9b4fd5cf8151f7818be2111cc0869f1eb95a\n"", 164, ""rebase/.git/rebase-merge/rewritten""",1,0,1
"true, git_path_isvalid(NULL, ""foo."", 0)",1,0,1
id && repo,1,0,1
data->pack_progress_calls > 0,1,0,1
"false, git_path_isvalid(NULL, ""/foo"", 0)",1,0,1
"""hello"", git_buf_cstr(&buf)",1,0,1
"filename_expected, filename",1,0,1
"""foobar"", buf.ptr",1,0,1
"""12c084412b952396962eb420716df01022b847cc\n"", 41, ""rebase/.git/rebase-merge/cmt.5""",1,0,1
"false, git_path_isvalid(NULL, ""com1/foo"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
"1461698487, sign->when.time",1,0,1
"GIT_FILEMODE_LINK, delta->old_file.mode",1,0,1
"&expected, &tag",1,0,1
"smrepo, child_key, git_submodule_url(sm)",1,0,1
git_repository_head_unborn(cloned_repo),1,0,1
fe->filter->stream || fe->filter->apply,1,0,1
" -100, git_tree_walk( tree, GIT_TREEWALK_PRE, treewalk_stop_immediately_cb, NULL)",1,0,1
"ident2.ptr, ""# $Id: "", 7",1,0,1
"st.st_mode & (S_IFMT | 07777), GIT_FILEMODE_BLOB_EXECUTABLE & ~um, ""%07o""",1,0,1
found_what_about,1,0,1
" CANCEL_VALUE, git_path_walk_up(&p, root[j], check_one_walkup_step, &info) ",1,0,1
found_parent_child2_file,1,0,1
"new_len, result.size",1,0,1
"(i), git_path_common_dirlen((p), (q))",1,0,1
" 0, memcmp(input, out.ptr, out.size)",1,0,1
wcslen(in) < MAX_PATH,1,0,1
"should, name.ptr",1,0,1
insert_len > 0 && idx <= v->length,1,0,1
"0, git_oid_streq(&id2, one.id)",1,0,1
bld && filename,1,0,1
"true, git_path_isvalid(NULL, ""foo:/bar"", 0)",1,0,1
"""WINDOWS"", (shortname = git_win32_path_8dot3_name(""C:\\WINDOWS""))",1,0,1
ref1 && ref2,1,0,1
entry && object_out,1,0,1
"git_path_isdir(""d2/other/dir"")",1,0,1
a->cmp == b->cmp,1,0,1
"288, git_atomic_get(&_counts[0])",1,0,1
"1, git_libgit2_shutdown()",1,0,1
"git_index_get_bypath(index, ""new.txt"", 1) != NULL",1,0,1
"(entry = git_index_get_bypath(index, ""lf.ident"", 0))",1,0,1
current_entry,1,0,1
"3, (int)git_reflog_entrycount(reflog)",1,0,1
out && rebase && rebase->index,1,0,1
"!git_oid_equal(&first, &second)",1,0,1
"(a_entry = git_index_get_bypath(index, ""A"", 0))",1,0,1
"GIT_ENOTFOUND, git_repository_discover(&repository_path, DISCOVER_FOLDER, 0, ceiling_dirs)",1,0,1
"true, ""Folder/Middle/Contained/Happy/Child""",1,0,1
"buffer.ptr, ""This is longer\nAnd multiline\n""",1,0,1
"7, delta->old_file.id_abbrev",1,0,1
"false, git_path_isvalid(NULL, ""foo:/bar"", GIT_PATH_REJECT_TRAILING_COLON)",1,0,1
"1, git_diff_foreach( diff, diff_stop_after_2_files, NULL, NULL, NULL, &exp) ",1,0,1
"false, git_path_isvalid(NULL, ""\xe2\x81\xad.\xe2\x80\xaeG\xef\xbb\xbfIT"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"strcmp(""rt\303\202of"", ""rt dev\302\266h"") > 0",1,0,1
"true, git_path_isvalid(NULL, "" .git"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"false, ""dir1/parent2/file""",1,0,1
"GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY, (merge_pref & GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY)",1,0,1
"expected_path, buf.ptr",1,0,1
repo && opts,1,0,1
"true, git_path_isvalid(NULL, ""com1\\foo"", 0)",1,0,1
"""Out of memory"", err_state.error_msg.message",1,0,1
"one_test->expected, one_test->path",1,0,1
"!git_oid_streq(&oid, ""be3563ae3f795b2b4353bcce3a527ad0a4f7f644"")",1,0,1
"git_oid_cmp(&oid, git_object_id(next_top_stash))",1,0,1
"""subdir/sub2/sub3/file""",1,0,1
GIT_SUBMODULE_RECURSE_NO,1,0,1
"&x, expected1, ARRAY_SIZE(expected1)",1,0,1
"true, git_path_isvalid(NULL, ""asdf?bar"", 0)",1,0,1
dfa->nexts[node_idx] != -1,1,0,1
(flags & GIT_MAP_FIXED) == 0,1,0,1
"!git_oid_streq(&oid, ""e90810b8df3e80c413d903f631643c716887138d"")",1,0,1
out && refname,1,0,1
"0, p_mkdir(""readonly"", 0555)",1,0,1
"""[section \""foo\""]\n\tname\n\tother = otherval\n[newsection]\n\tnewname = new_value\n"", newfile.ptr",1,0,1
"branch_oid, &commit_id",1,0,1
ptr - buf->data <= (int) buf->len,1,0,1
"2, behind",1,0,1
!result,1,0,1
"1, filter_for(""text.txt"", ""crlf"")",1,0,1
committish,1,0,1
"120, sign->when.offset",1,0,1
"""A-*[0-9a-f]-dirty"", repo, &opts, &fmt_opts",1,0,1
"NULL , ""\n""",1,0,1
"GIT_OBJ_TREE, git_object_type((git_object *) tree)",1,0,1
test_driver_custom.shutdown,1,0,1
"true, git_path_isvalid(NULL, "".git\xe2\xab\x81"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"index_entry = git_index_get_bypath(index, ""readme"", 0)",1,0,1
ctx && ctx->configured && challenge,1,0,1
(size_t)((int)min_length) == min_length,1,0,1
"&file1_id, &status_entry->head_to_index->new_file.id",1,0,1
""""", git_odb_object_data(tree_odb)",1,0,1
"false, ""dir1/parent1/file""",1,0,1
"""Trailing spaces are removed"", ""Trailing spaces are removed """,1,0,1
"false, git_path_isvalid(NULL, "".."", GIT_PATH_REJECT_TRAVERSAL)",1,0,1
"0, status->head_to_index->new_file.size",1,0,1
"1, filter_for(""id.ident"", ""crlf"")",1,0,1
"""refs/stash:.gitignore"", ""ac4d88de61733173d9959e4b77c69b9f17a00980""",1,0,1
"true, ""dir/sub/aaa.html""",1,0,1
"7, diff_data.old_binary_inflatedlen",1,0,1
"""are preserved"", "" Leading\n Spaces\n\nare preserved""",1,0,1
"""test-annotated-*"", ""HEAD"", repo, &opts, &fmt_opts",1,0,1
"git_treebuilder_insert(NULL, builder, ""file_as_folder"", &valid_blob_id, GIT_FILEMODE_TREE)",1,0,1
"GITERR_OBJECT, giterr_last()->klass",1,0,1
"true, git_path_isvalid(NULL, ""asdf>foo"", 0)",1,0,1
backend_out && objects_dir,1,0,1
"getfinalpathfn = (getfinalpathname)GetProcAddress(kerneldll, ""GetFinalPathNameByHandleA"")",1,0,1
"false, git_path_isvalid(NULL, ""aux.asdf\\zippy"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
iterator_out && index,1,0,1
"0, len",1,0,1
"true, index->ignore_case",1,0,1
"data, strlen(data) + 1, out, outlen",1,0,1
"committer->email, git_reflog_entry_committer(entry)->email",1,0,1
"GIT_REF_SYMBOLIC, git_reference_type(head_ref)",1,0,1
"git_buf_cstr(&path2), buf",1,0,1
"false, ""dir/sub""",1,0,1
"""refs/stash:where"", ""e3d6434ec12eb76af8dfa843a64ba6ab91014a0b""",1,0,1
"2, refs.length",1,0,1
"""+refs/*:refs/*"", problems.strings[0]",1,0,1
"git_path_exists(""stash/when"")",1,0,1
"correct_case, conflict_entry[2]->path",1,0,1
*out == NULL,1,0,1
"cts.dirty, 0",1,0,1
"""new_side-2.txt"", ours->path",1,0,1
"strcmp(git_buf_cstr(&mergemsg_buf), ""Renamed file3.txt -> file3.txt.renamed\n"" ""\n"" ""Conflicts:\n"" ""\tfile3.txt\n"" ""\tfile3.txt.renamed\n"" ""\tfile3.txt.renamed_on_branch\n"") == 0",1,0,1
"56, tmp",1,0,1
"""c%18D`@*{63ljhg(E~C7"", diff_data.old_binary_base85.ptr",1,0,1
"""two rnds"", buf.ptr",1,0,1
"""path/whatever.c""",1,0,1
"GIT_EINVALIDSPEC, ""refs/tags/point_to_blob"", GIT_OBJ_TAG",1,0,1
"0, exp->files_binary",1,0,1
out && repo && ours && theirs,1,0,1
"0, git_oid_streq(&target->id, expectations->sha)",1,0,1
current_frame,1,0,1
"""A-*"", ""HEAD^^2"", repo, &opts, &fmt_opts",1,0,1
"native_ignore_case ? testrepo2_subdir_paths_icase[i] : testrepo2_subdir_paths[i], status->head_to_index->old_file.path",1,0,1
"false, git_path_isvalid(NULL, ""asdf:foo"", GIT_PATH_REJECT_NT_CHARS)",1,0,1
"false, git_path_isvalid(NULL, ""con"", GIT_PATH_REJECT_DOS_PATHS)",1,0,1
"13, git_diff_stats_deletions(_stats)",1,0,1
"&should_id, &id",1,0,1
"1414141414, st.st_atime",1,0,1
"false, git_path_isvalid(NULL, ""\xe2\x80\xab.\xe2\x80\xacG\xe2\x80\xadI\xe2\x80\xaet"", GIT_PATH_REJECT_DOT_GIT_HFS)",1,0,1
"NULL, 3, ""763d71"", ""e90810"", ""a65fed""",1,0,1
"git__strcmp(""rt\303\202of"", ""rt dev\302\266h"") > 0",1,0,1
file && fetchhead_ref,1,0,1
"""bin/look-ma.txt""",1,0,1
"!git_strmap_exists(g_table, ""bbbbbbbbb"")",1,0,1
"NULL , "" \nSpaces before newlines \nare \ncollapsed \n""",1,0,1
"2, git_libgit2_shutdown()",1,0,1
"true, git_path_isvalid(NULL, ""!git"", 0)",1,0,1
""" Trailing newlines are"" , "" \n Trailing newlines \n are \n\n collapsed \n """,1,0,1
git_strmap_num_entries(g_table) == 0,1,0,1
