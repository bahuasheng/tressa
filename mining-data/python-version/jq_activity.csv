x_val,y_added,y_removed,y_combined
jv_get_kind(a) == JV_KIND_ARRAY,23,14,37
jv_get_kind(object) == JV_KIND_OBJECT,22,14,36
jv_get_kind(j) == JV_KIND_STRING,19,11,30
"jv_number_value(jv_array_get(jv_copy(a), 0)) == 42",15,12,27
jv_array_length(jv_copy(subarray)) == 1,15,12,27
jv_get_kind(subarray) == JV_KIND_ARRAY,15,12,27
"jv_number_value(jv_array_get(jv_copy(subarray), 0)) == 42",15,12,27
jv_get_kind(key) == JV_KIND_STRING,13,8,21
jv_array_length(jv_copy(a)) == 0,10,8,18
"jv_number_value(jv_object_get(jv_copy(o1), jv_string(""bar""))) == 24",10,8,18
"jv_number_value(jv_object_get(jv_copy(o1), jv_string(""foo""))) == 42",10,8,18
jv_array_length(jv_copy(a)) == 2,10,8,18
jv_get_kind(j) == JV_KIND_ARRAY,11,7,18
a.val.complex.ptr->count == 1,8,8,16
jq,8,7,15
block_is_single(binder),8,6,14
jv_is_valid(val),9,5,14
curr->bound_by == curr,8,6,14
"block_has_only_binders(binder, bindflags)",8,5,13
0,7,6,13
line < l->nlines,7,6,13
p->curr_buf_pos == p->curr_buf_length,7,5,12
c != -1,7,5,12
jv_get_kind(o) == JV_KIND_OBJECT,8,4,12
jv_get_kind(keys) == JV_KIND_ARRAY,8,4,12
jv_get_kind(a) == JV_KIND_OBJECT,7,4,11
opcode_describe(op)->flags & OP_HAS_BRANCH,6,4,10
target.last,6,4,10
p->stackpos > 1 && jv_get_kind(p->stack[p->stackpos-2]) == JV_KIND_OBJECT,6,4,10
"!jv_equal(jv_copy(a2), jv_copy(a))",5,4,9
"jv_equal(jv_copy(a), jv_copy(a))",5,4,9
jv_array_length(jv_copy(objects)) == jv_array_length(jv_copy(keys)),6,3,9
"jv_equal(jv_copy(a2), jv_copy(a))",5,4,9
0 <= start && start <= end && end <= len,6,3,9
"jv_equal(jv_string(""foo""), jv_string_sized(""foo"", 3))",5,4,9
jv_array_length(jv_copy(sub2)) == 2,5,4,9
"jv_number_value(jv_array_get(jv_copy(a3), 2)) == 19",5,4,9
jv_get_kind(objects) == JV_KIND_ARRAY,6,3,9
before == after,5,4,9
opcode_describe(op)->flags & OP_HAS_VARIABLE,5,4,9
"jv_number_value(jv_array_get(jv_copy(sub2), 0)) == 42",5,4,9
jv_string_hash(jv_copy(a1)) == jv_string_hash(jv_copy(a2)),5,4,9
"jv_number_value(jv_object_get(jv_copy(o2), jv_string(""bar""))) == 240",5,4,9
"jv_equal(jv_copy(a1), jv_copy(a2))",5,4,9
"jv_number_value(jv_object_get(jv_copy(o2), jv_string(""foo""))) == 420",5,4,9
"jv_number_value(jv_array_get(jv_copy(sub2), 1)) == 19",5,4,9
"jv_equal(jv_copy(a), jv_copy(a2))",5,4,9
jv_array_length(jv_copy(a3)) == 3,5,4,9
jv_string_hash(jv_copy(a1)) == jv_string_hash(jv_copy(a1)),5,4,9
"jv_equal(jv_copy(a2), jv_copy(a2))",5,4,9
"jv_array_length(jv_array_get(jv_copy(a), 1)) == 1",5,4,9
"!jv_equal(jv_copy(a), jv_copy(a2))",5,4,9
"jv_equal(jv_copy(a2), jv_copy(a1))",5,4,9
jv_string_hash(jv_copy(b)) != jv_string_hash(jv_copy(a1)),5,4,9
jv_get_kind(sub2) == JV_KIND_ARRAY,5,4,9
"jv_array_length(jv_array_get(jv_copy(a3), 1)) == 1",5,4,9
jv_get_refcnt(a) == 1,6,3,9
"!jv_equal(jv_copy(a1), jv_copy(b))",5,4,9
"jv_number_value(jv_array_get(jv_copy(a3), 0)) == 42",5,4,9
jv_array_length(jv_copy(a)) == 1,5,4,9
!forkable_stack_empty(&frame_stk),4,4,8
opcode_describe(op)->flags & OP_IS_CALL_PSEUDO,4,4,8
jvp_refcnt_unshared(object),4,4,8
!jv_is_valid(p->next),5,3,8
*pc == 1,4,4,8
nargs > 0,4,4,8
"0 && ""Invalid value""",4,3,7
"0 && ""Unknown type of parameter""",4,3,7
i >= 0,4,3,7
pos < l->length,4,3,7
curr->op == CALL_JQ,4,3,7
jv_get_kind(k) == JV_KIND_STRING,4,3,7
!nerrors,4,3,7
"jv_equal(jv_copy(expected), jv_copy(reparsed))",4,3,7
"!strcmp(big, jv_string_value(str))",4,3,7
closure >= 0,4,3,7
"jv_equal(jv_string(""hello42!""), jv_string_fmt(""hello%d%s"", 42, ""!""))",4,3,7
var >= 0,4,3,7
codepoint >= 0 && codepoint <= 0x10FFFF,4,3,7
i + a->i[0] < array->length,3,3,6
curr && opcode_describe(curr->op)->flags & OP_IS_CALL_PSEUDO,3,3,6
match,3,3,6
curr->bound_by->op == CLOSURE_CREATE_C,4,2,6
funcname,3,3,6
block_is_const(b),4,2,6
jv_is_valid(expected),3,3,6
!curr->arglist.first,4,2,6
state,3,3,6
curr->op == CALL_1_1,3,3,6
jv_is_valid(t),4,2,6
"0 && ""Unknown function type""",4,2,6
bc,3,3,6
curr->op != CLOSURE_REF && curr->op != CLOSURE_PARAM,4,2,6
jv_string_length(jv_copy(str)) == sizeof(big) - 1,3,3,6
"0&&""bad lookup""",3,3,6
jv_string_length(longstr) == sizeof(nasty),3,3,6
jv_string_length(shortstr) == strlen(nasty),3,3,6
jv_get_kind(a) == JV_KIND_STRING,4,2,6
jv_is_valid(input),3,3,6
i->op == CLOSURE_PARAM,4,2,6
jv_get_kind(b) == JV_KIND_OBJECT,4,2,6
fp->retaddr >= bc->code && fp->retaddr < bc->code + bc->codelen,3,2,5
!a->next,3,2,5
p->tokenpos <= p->tokenlen,3,2,5
size > 0 && (size & (size - 1)) == 0,3,2,5
iter != ITER_FINISHED,3,2,5
jv_get_kind(b) == JV_KIND_ARRAY,3,2,5
jv_get_kind(s) == JV_KIND_STRING,3,2,5
jv_is_valid(v),3,2,5
!b->prev,3,2,5
var < fr->bc->nlocals,3,2,5
"(p->curr_buf == 0 || p->curr_buf_pos == p->curr_buf_length) && ""previous buffer not exhausted""",3,2,5
jv_get_kind(str) == JV_KIND_STRING,3,2,5
block_is_single(b),3,2,5
slot,3,2,5
p->stackpos < p->stacklen,3,2,5
bc && bc == target->compiled,3,2,5
closure < fr->bc->nclosures,3,2,5
curr == b.last,3,2,5
slot == -1 || (slot >= 0 && slot < jvp_object_size(object)),3,2,5
bc->globals->ncfunctions == ncfunc,3,2,5
s->alloc_length >= jvp_string_length(s),3,2,5
p->stackpos <= p->stacklen,3,2,5
jv_get_kind(j) == JV_KIND_NUMBER,3,2,5
p->tokenpos < p->tokenlen,3,2,5
subfn_idx < fr->bc->nsubfunctions,3,2,5
"0 && ""invalid kind""",3,2,5
out - start == jvp_utf8_encode_length(codepoint),3,2,5
new_slot,3,2,5
"0 && ""codegen not implemented for this operation""",3,2,5
binder.first->bound_by == 0 || binder.first->bound_by == binder.first,3,2,5
curr->imm.target->bytecode_pos != -1,3,2,5
opcode_describe(op)->length == 1,3,2,5
curr->imm.target->bytecode_pos > pos,3,2,5
opcode_describe(b.first->op)->flags & OP_HAS_BRANCH,3,2,5
a && b,3,2,5
"0 && ""invalid instruction""",3,2,5
binder.first->symbol,3,2,5
fp->retaddr == 0,3,2,5
"!jvp_object_find_slot(&new_object, slot->string, new_bucket)",2,2,4
a->length_hashed & 1,2,2,4
jv_get_kind(objv.value) == JV_KIND_OBJECT,2,2,4
jv_is_valid(sv.value),2,2,4
(opcode_describe(binder.first->op)->flags & bindflags) == bindflags,2,2,4
start <= end,2,2,4
sz_size > 0 && sz_size % sizeof(struct forkable_stack_header) == 0,2,2,4
idx >= 1 && idx <= s->length,2,2,4
curr->symbol,2,2,4
s->stk,2,2,4
pos <= pathsize,2,2,4
s->savedlimit <= state->prevpos,2,2,4
found,2,2,4
elempos >= 0 && elempos < s->length,2,2,4
s->length > 0,2,2,4
s->savedlimit == s->length,2,2,4
closure < frame_self(fr)->bc->nclosures,2,2,4
!jv_is_valid(value),2,2,4
stackpos > 1 && jv_get_kind(stack[stackpos-2]) == JV_KIND_OBJECT,2,2,4
nargs - 1 == desired_params,2,2,4
a.val.nontrivial.ptr->count == 1,2,2,4
opcode_describe(op)->flags & OP_HAS_SYMBOL,2,2,4
"p->curr_buf && ""a buffer must be provided""",2,2,4
s->pos >= 0 && s->pos <= s->length,2,2,4
argc == 2,2,2,4
s,2,2,4
var < frame_self(fr)->bc->nlocals,2,2,4
frame_self(fp)->retaddr >= bc->code && frame_self(fp)->retaddr < bc->code + bc->codelen,2,2,4
"0 && ""Unknown type of argument""",2,2,4
b->length_hashed & 1,2,2,4
nclosures - 1 == frame_self(new_frame)->bc->nclosures,2,2,4
opcode_describe(op)->flags & OP_HAS_CONSTANT,2,2,4
opcode == EACH,2,2,4
"0 && ""bad mod""",2,2,4
forkable_stack_empty(&frame_stk),2,2,4
opcode_describe(op)->flags & OP_HAS_BLOCK,2,2,4
opcode_describe(op)->flags & OP_HAS_VARIABLE_LENGTH_ARGLIST,2,2,4
frame_self(fp)->retaddr == 0,2,2,4
pos >= 0,2,2,4
binder.first == binder.last,2,2,4
subfn_idx < frame_self(fr)->bc->nsubfunctions,2,2,4
function,2,2,4
newpos < s->pos,2,2,4
jv_get_kind(attr) == JV_KIND_STRING,2,2,4
s->savedlimit <= state->prevlimit,2,2,4
b.last,2,2,4
jv_is_valid(val.value),2,2,4
!(op->flags & OP_IS_CALL_PSEUDO),2,2,4
buckets == (int*)&jvp_object_ptr(o)->elements[jvp_object_size(o)],2,2,4
forkable_stack_empty(&fork_stk),2,2,4
!forkable_stack_empty(&jq->frame_stk),2,2,4
nargs < 100,2,2,4
s->savedlimit >= 0 && s->savedlimit <= s->length,2,2,4
forkable_stack_empty(s),2,2,4
c->ptr->count > 0,2,2,4
elempos + elem->next_delta <= s->length,2,2,4
slot->string,2,2,4
pos >= 0 && pos < s->length,2,2,4
"!jvp_object_find_slot(object, key, bucket)",2,2,4
a->i[1] + end < array->length,2,2,4
opcode_describe(curr->op)->flags & OP_IS_CALL_PSEUDO,2,2,4
forkable_stack_empty(&data_stk),2,2,4
!cc.is_backtrack_frame,2,2,4
bc && target->compiled,2,2,4
!forkable_stack_empty(s),2,2,4
binder.first,2,2,4
jv_get_kind(b) == JV_KIND_STRING,2,1,3
(opcode_describe(binder.first->op)->flags & bindflags) == (bindflags & ~OP_BIND_WILDCARD),2,1,3
opcode == EACH || opcode == EACH_OPT,2,1,3
jv_array_length(jv_copy(a5)) == 2,2,1,3
"!jvp_object_find_slot(*object, key, bucket)",2,1,3
in <= end,2,1,3
jq->subexp_nest > 0,2,1,3
len >= 0,2,1,3
jvp_refcnt_unshared(object.u.ptr),2,1,3
jv_string_length_bytes(jv_copy(shortstr)) == (int)strlen(nasty),2,1,3
break_distance >= 0,2,1,3
jv_get_kind(inv) == JV_KIND_INVALID,2,1,3
jv_get_kind(v) == JV_KIND_INVALID,2,1,3
!jv_is_valid(*out),2,1,3
jv_is_valid(k),2,1,3
jv_get_kind(sep) == JV_KIND_STRING,2,1,3
jv_get_kind(objv) == JV_KIND_OBJECT,2,1,3
jv_get_kind(path) == JV_KIND_STRING,2,1,3
jv_get_kind(*var) == JV_KIND_ARRAY,2,1,3
opcode_describe(LOADK)->flags & OP_HAS_CONSTANT,2,1,3
forkable_stack_empty(&old_jq->fork_stk),1,2,3
block_is_const(metadata) && block_const_kind(metadata) == JV_KIND_OBJECT,2,1,3
jv_string_length_bytes(jv_copy(longstr)) == (int)sizeof(nasty),2,1,3
c->count > 0,2,1,3
wargc == argc,2,1,3
"0 && ""invalid kind passed to jv_cmp""",2,1,3
arg->op == CLOSURE_REF && arg->bound_by->op == CLOSURE_CREATE,2,1,3
(opcode_describe(STORE_GLOBAL)->flags & (OP_HAS_CONSTANT | OP_HAS_VARIABLE | OP_HAS_BINDING)) == (OP_HAS_CONSTANT | OP_HAS_VARIABLE | OP_HAS_BINDING),2,1,3
left.first->next->next->op == LOADK,2,1,3
jv_get_kind(jq->error) == JV_KIND_NULL,2,1,3
jv_array_length(jv_copy(a4)) == 2,2,1,3
0 <= start && start <= end && end <= array_len,2,1,3
jv_get_kind(attrs) == JV_KIND_OBJECT,2,1,3
path_len == 0,2,1,3
out < s->data + maxlength,2,1,3
param->bound_by == param,2,1,3
jv_get_kind(search_path) == JV_KIND_ARRAY,2,1,3
!jv_is_valid(as) || jv_get_kind(as) == JV_KIND_STRING,2,1,3
jv_string_length_bytes(jv_copy(str)) == sizeof(big) - 1,2,1,3
pc,2,1,3
left.first->op == DUP,2,1,3
i->op == CLOSURE_CREATE,2,1,3
jv_array_length(jv_copy(a4)) == 1,2,1,3
opcode_describe(op)->flags & OP_HAS_BINDING,2,1,3
nargs == new_frame->bc->nclosures,2,1,3
jv_get_kind(x) == JV_KIND_INVALID,2,1,3
jq->curr_frame,2,1,3
left.first->next->op == SUBEXP_BEGIN,2,1,3
bc && target && target->compiled,2,1,3
jq->stk_top == frame_current(jq)->retdata,2,1,3
"jv_array_length(jv_array_get(jv_copy(paths), i)) > start",2,1,3
"s->limit == 0 && ""stack freed while not empty""",2,1,3
length > 0,2,1,3
jv_get_kind(args) == JV_KIND_ARRAY,2,1,3
i + jvp_array_offset(a) < array->length,2,1,3
"block_has_only_binders_and_imports(*answer, OP_IS_CALL_PSEUDO)",2,1,3
param->op == CLOSURE_PARAM,2,1,3
jv_get_kind(input) == JV_KIND_STRING,2,1,3
path_len >= 0,2,1,3
n2 == n1 + 1,2,1,3
jvp_refcnt_unshared(new_object.u.ptr),2,1,3
line-1 < l->nlines,2,1,3
s != NULL,2,1,3
k == JV_KIND_NULL,2,1,3
"!jvp_object_find_slot(new_object, slot->string, new_bucket)",2,1,3
!jv_is_valid(state->slurped),2,1,3
"!strcmp(fmt_s, ""tsv"")",2,1,3
jv_get_kind(n) == JV_KIND_NUMBER,2,1,3
"0 && ""jv_keys passed something neither object nor array""",2,1,3
forkable_stack_empty(&old_jq->data_stk),1,2,3
cb == jq_util_input_next_input_cb,2,1,3
forkable_stack_empty(&old_jq->frame_stk),1,2,3
actual_args == desired_args,2,1,3
opcode_describe(i->op)->flags & OP_IS_CALL_PSEUDO,2,1,3
block_is_single(import) && import.first->op == DEPS,2,1,3
curr->bound_by->op == CLOSURE_CREATE || curr->bound_by->op == CLOSURE_PARAM,2,1,3
jq->err_cb,2,1,3
*pc == CALL_JQ,2,1,3
"jv_get_kind(jvp_object_get_slot(object,iter)->string) == JV_KIND_STRING",2,1,3
pos <= jq->pathsize,1,1,2
block_is_single(curr->arglist),1,1,2
c > 0,1,1,2
nargs == 0,1,1,2
s->savedlimit <= s->length - state->prev_pos_delta,1,1,2
seq_end && seq_end->op == CALLSEQ_END,1,1,2
json_is_object(obj),1,1,2
"jq->stk_top == frame_self(frame_current(&jq->stk, jq->curr_frame))->retdata",1,1,2
*islast == 1,1,1,2
r >= 0,1,1,2
"strchr(jv_string_value(vdir), '.') != NULL",1,1,2
curr->next && curr->next->op == CALLSEQ_END,1,1,2
arglist.first->op == CLOSURE_REF,1,1,2
jv_array_length(a4) == 2,1,1,2
jv_string_length(shortstr) == (int)strlen(nasty),1,1,2
end <= jvp_array_length(a),1,1,2
"first_file != 0 && strcmp(first_file, ""-"") != 0",1,1,2
nargs == bc->globals->cfunctions[cfunc->bound_by->imm.intval].nargs,1,1,2
curr->op == CLOSURE_REF,1,1,2
"arglist.first && ""zeroth argument (function to call) must be present""",1,1,2
opcode_describe(binder.first->op)->flags & OP_HAS_VARIABLE,1,1,2
!(opcode_describe(op)->flags & OP_HAS_IMMEDIATE),1,1,2
jv_get_kind(lib_search_path) == JV_KIND_STRING,1,1,2
jq->stk_top == 0,1,1,2
"jq->stk_top == frame_current(&jq->stk, jq->curr_frame)->retdata",1,1,2
b.first == b.last,1,1,2
block_is_single(arglist),1,1,2
curr->bound_by->op == CLOSURE_CREATE,1,1,2
nargs - 1 == i->compiled->subfunctions[i->imm.intval]->nclosures,1,1,2
jq->curr_frame == 0,1,1,2
0 <= start && start <= end,1,1,2
op == CALL_1_1,1,1,2
reclaim_upto <= s->length,1,1,2
"0 && ""bad mod - not an object""",1,1,2
cb != NULL,1,1,2
cfunc && cfunc->bound_by->op == CLOSURE_CREATE_C,1,1,2
!forkable_stack_empty(&call_stk),1,1,2
"0 && ""key neither string nor int""",1,1,2
max_inputs > 0 && (uintmax_t)max_inputs * sizeof(const char*) < SIZE_MAX,1,1,2
binder.first->var_binding == 0,1,1,2
"0 && ""couldn't parse input""",1,1,2
i >= 0 && i < jvp_array_length(a),1,1,2
n > 0 && (size_t)n < tlen,1,1,2
jv_get_kind(dirs) == JV_KIND_ARRAY,1,1,2
"first_file != 0 && !strcmp(first_file, ""-"")",1,1,2
curr->imm.symbol,1,1,2
nargs >= 0 && nargs < 100,1,1,2
nargs == 1,1,1,2
"input_state->ninput_files > 0 && !strcmp(input_state->input_filenames[0], ""-"")",1,1,2
jv_is_valid(as) && jv_get_kind(as) == JV_KIND_STRING,1,1,2
state->ninput_files < state->alloced,1,1,2
stack_top(&old_jq->stk) == 0,1,1,2
json_is_object(objv.value),1,1,2
nerrors == 0,1,1,2
v,1,1,2
*pc == 4,1,1,2
jv_get_kind(lib_path) == JV_KIND_STRING,1,1,2
st == NORMAL,1,1,2
jv_string_length(longstr) == (int)sizeof(nasty),1,1,2
fp == forkable_stack_peek(stk),1,1,2
"curr->var_binding && ""unbound variable""",1,1,2
a->i[0] + end <= a->i[1],1,1,2
b.first,1,1,2
nclosures == frame_self(new_frame)->bc->nclosures,1,1,2
json_is_string(k),1,1,2
(reclaimed > 0) == forkable_stack_pop_will_free(s),1,1,2
"curr->bound_by && ""unbound term""",1,1,2
*pc == 2,1,1,2
jv_string_length_bytes(shortstr) == (int)strlen(nasty),1,1,2
nargs == i->compiled->subfunctions[i->imm.intval]->nclosures,1,1,2
!arglist.first,1,1,2
data,1,1,2
jv_array_length(a5) == 2,1,1,2
nargs > 0 && nargs < 100,1,1,2
jv_string_length_bytes(longstr) == (int)sizeof(nasty),1,1,2
curr->bound_by->compiled == bc,1,1,2
jv_get_kind(lib_name) == JV_KIND_STRING,1,1,2
opcode_length(*opcode_rewrite) == opcode_length(bc->globals->cfunctions[cfunc->bound_by->imm.intval].callop),1,1,2
s->savedlimit <= s->length - state->prev_limit_delta,1,1,2
nclosures == new_frame->bc->nclosures,1,1,2
metadata.first == NULL || block_is_const(metadata),1,1,2
frame_self(fp)->pc >= bc->code && frame_self(fp)->pc < bc->code + bc->codelen,1,1,2
0 <= reclaimed && s->pos + reclaimed <= s->length,1,1,2
jv_is_valid(d),1,1,2
jv_get_kind(origin) == JV_KIND_STRING,1,1,2
"0 && ""bad mod - seriously, wtf""",1,1,2
"0 && ""Unknown parameter type""",1,1,2
binder.first->imm.symbol,1,1,2
jq->fork_top == 0,1,1,2
jv_get_kind(lib_search_path) == JV_KIND_ARRAY,1,1,2
"0 && ""bad mod - not an array""",1,1,2
old_jq->stk_top == 0,1,0,1
old_jq->curr_frame == 0,1,0,1
forkable_stack_empty(&jq->data_stk),1,0,1
forkable_stack_empty(&jq->frame_stk),1,0,1
forkable_stack_empty(&jq->fork_stk),1,0,1
old_jq->fork_top == 0,1,0,1
