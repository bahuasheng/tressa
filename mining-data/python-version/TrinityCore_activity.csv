x_val,y_added,y_removed,y_combined
false,131,99,230
0,69,69,138
field < file.fieldCount,70,60,130
ptr != NULL,75,54,129
run->magic == ARENA_RUN_MAGIC,62,62,124
"index < m_valuesCount || PrintIndexError(index, false)",43,43,86
ckh->magic = CKH_MAGIG,30,30,60
binind < nbins,27,27,54
block->status & (BLOCK_READ | BLOCK_IN_USE),26,26,52
small_size2bin[i] == binind,25,25,50
config_prof,48,2,50
size != 0,31,18,49
mask.mCount <= mCount,24,24,48
CHUNK_ADDR2BASE(ptr) != ptr,26,21,47
ret != NULL,25,21,46
src == dst && srclen == dstlen,22,22,44
ckh != NULL,24,18,42
chunk->arena->magic == ARENA_MAGIC,19,19,38
block->hash_link,18,18,36
((uintptr_t)ptr & PAGE_MASK) == 0,19,17,36
tnode != &rbtree->rbt_nil,20,16,36
stringOffset < file.stringSize,17,15,32
_p != 0,16,16,32
block->prev_changed && *block->prev_changed == block,16,16,32
((uintptr_t)ptr - ((uintptr_t)run + (uintptr_t)run->bin->reg0_offset)) % run->bin->reg_size == 0,16,16,32
(mapbits & CHUNK_MAP_ALLOCATED) != 0,16,15,31
(size & PAGE_MASK) == 0,18,11,29
block->hash_link->file == file,14,14,28
node != NULL,16,12,28
!block->prev_used,14,14,28
arena->magic == ARENA_MAGIC,13,13,26
lg_range > 0,14,12,26
it,12,13,25
minbits <= 32 || (SIZEOF_PTR == 8 && minbits <= 64),12,12,24
x < N,12,12,24
!block->next_used,12,12,24
bit < (map)->n_bits,12,12,24
malloc_initialized || malloc_initializer == pthread_self(),12,12,24
bin->runcur->magic == ARENA_RUN_MAGIC,12,12,24
hash1 != NULL,12,12,24
hash2 != NULL,12,12,24
tbin->ncached < tbin->ncached_max,12,12,24
y < N,12,12,24
block->status & BLOCK_IN_USE,12,12,24
map->bitmap,11,11,22
offset < 4,10,10,20
block->hash_link && block->hash_link->block == block,10,10,20
initialized,10,10,20
item,10,9,19
size <= arena_maxclass,11,7,18
(uintptr_t)pathp > (uintptr_t)path,10,8,18
map->bitmap && bitmap_bit < map->n_bits,9,9,18
swap_enabled,9,9,18
ret != 0,9,8,17
effIndex < MAX_SPELL_EFFECTS,8,8,16
pageind + npages <= chunk_npages,9,7,16
!block->requests,8,8,16
stmt != 0,8,8,16
map->bitmap && map2->bitmap && map->n_bits==map2->n_bits,8,8,16
keycache->can_be_used,8,8,16
binind < nhbins,9,7,16
block->hash_link->diskpos == filepos,8,8,16
trailsize < alloc_size,8,8,16
max <= (1U << opt_lg_prof_bt_max),8,8,16
pos,8,8,16
block->hash_link->block == block,8,8,16
offset < alloc_size,8,8,16
node->size > size,8,8,16
(size & chunksize_mask) == 0,9,6,15
effect < MAX_SPELL_EFFECTS,8,7,15
rem <= tbin->ncached,8,6,14
sizeof(typename OutputByteStream::Ch) == 1,14,0,14
bin->runcur->nfree > 0,8,6,14
!m_aura && aura,7,7,14
oldsize > newsize,8,6,14
sizeof(typename InputByteStream::Ch) == 1,14,0,14
nope,7,7,14
lg_range <= 64,7,6,13
lg_range <= 32,7,6,13
malloc_initialized || IS_INITIALIZER,10,3,13
m_Map,7,6,13
mod->charges == 0,7,6,13
min_run_size <= arena_maxclass,7,6,13
good_hdr_size <= good_reg0_offset,6,6,12
 (intId < 8) ,6,6,12
"index + 1 < m_valuesCount || PrintIndexError(index, false)",6,6,12
m_procDeep,6,6,12
y < MAX_NUMBER_OF_GRIDS,6,6,12
ckh->magic == CKH_MAGIC,6,6,12
sizeof(dec1) == 4,6,6,12
ofs < file.recordSize,6,6,12
ops,6,6,12
(slen % 4) == 0,6,6,12
fd >= MY_FILE_MIN && fd < (int)my_file_limit,6,6,12
min_run_size >= PAGE_SIZE,6,6,12
x < MAX_NUMBER_OF_GRIDS,6,6,12
"my_memmem(haystack, 10, needle, 3) != NULL",6,6,12
arena_salloc(ret) == tcache->arena->bins[binind].reg_size,6,6,12
!(block->status & BLOCK_CHANGED),6,6,12
read_length > 0,6,6,12
(page_st == PAGE_TO_BE_READ) || (block->status & BLOCK_READ),6,6,12
to <= end,6,6,12
chunk->map[pageind].bits & CHUNK_MAP_ALLOCATED,6,6,12
alloc_root_inited(mem_root),6,6,12
chunk->map[pageind].bits & CHUNK_MAP_LARGE,6,6,12
!(block->status & BLOCK_REASSIGNED),6,6,12
IsObject(),11,0,11
m_currMap,6,5,11
m_uint32Values,6,5,11
GetType() == DYNOBJ_AURA_TYPE,6,5,11
IsArray(),11,0,11
ah,5,6,11
GetType() == UNIT_AURA_TYPE,6,5,11
offset < 2,5,5,10
run->nfree < run->bin->nregs,5,5,10
cs->casedn_multiply == 1,5,5,10
arena_salloc(ptr) <= tcache_maxclass,5,5,10
cs->caseup_multiply == 1,5,5,10
(uintptr_t)ret >= (uintptr_t)run + (uintptr_t)bin->reg0_offset,5,5,10
((uintptr_t)ret - ((uintptr_t)run + (uintptr_t)bin->reg0_offset)) % (uintptr_t)bin->reg_size == 0,5,5,10
alignment >= chunksize,5,5,10
sizeof(const_small_size2bin) == small_maxclass + 1,5,5,10
cmp != 0,6,4,10
arena_salloc(ptr) <= small_maxclass,5,5,10
((uintptr_t)ptr - ((uintptr_t)run + (uintptr_t)run->bin->reg0_offset)) % (uintptr_t)run->bin->reg_size == 0,5,5,10
(mapelm->bits & CHUNK_MAP_ALLOCATED) != 0,5,5,10
i_source,5,5,10
(uintptr_t)ret < (uintptr_t)run->next,5,5,10
((uintptr_t)ret & (alignment - 1)) == 0,5,5,10
SMALL_SIZE2BIN(i) == binind,5,5,10
arena_salloc(ptr) > small_maxclass,5,5,10
0 < i && i <= m->g->nsub,5,5,10
regind < bin->nregs,5,5,10
need_pages > 0,6,4,10
arena->ndirty > arena->npurgatory,5,5,10
map1->bitmap && map2->bitmap && map1->n_bits==map2->n_bits,5,5,10
opt_lg_qspace_max != LG_QSPACE_MAX_DEFAULT || opt_lg_cspace_max != LG_CSPACE_MAX_DEFAULT || sizeof(const_small_size2bin) != small_maxclass + 1,5,5,10
tcache->ev_cnt <= tcache_gc_incr,5,5,10
((uintptr_t)key & 0x7) == 0,5,5,10
src != dst || cs->casedn_multiply == 1,5,5,10
src != dst || cs->caseup_multiply == 1,5,5,10
small_size2bin[0] == 0xffU,5,5,10
pathp[-1].cmp < 0,5,4,9
arena != NULL,5,4,9
chunk->arena == arena,5,4,9
bit < binfo->nbits,6,3,9
"rbtn_red_get(a_type, a_field, pathp[1].node) == false",5,4,9
 mAitems.find(it->GetGUIDLow()) == mAitems.end(),4,5,9
nodep->node == node,5,4,9
size <= tcache_maxclass,5,4,9
run_ind < chunk_npages,5,4,9
fromObj,5,4,9
pathp->cmp != 0,5,4,9
"rbtn_red_get(a_type, a_field, rbtree->rbt_root) == false",5,4,9
leftright != &rbtree->rbt_nil,5,4,9
"rbtn_red_get(a_type, a_field, left)",5,4,9
"rbtn_red_get(a_type, a_field, node) == false",5,4,9
"!""Read not implemented for server packets.""",5,4,9
ndirty == arena->ndirty,5,4,9
block->hash_link == hash_link,4,4,8
dirp != NULL,4,4,8
(offset & chunksize_mask) == 0,4,4,8
chunk->dirtied,4,4,8
rc != ETIMEDOUT,4,4,8
QUANTUM_CEILING(size) <= arena_maxclass,4,4,8
cnt <= keycache->blocks_used,4,4,8
(mapelm->bits >> PAGE_SHIFT) == 0,4,4,8
!block->next_used && !block->prev_used,4,4,8
LG_QUANTUM >= LG_TINY_MIN,4,4,8
mysql != 0,4,4,8
((result - 1) & result) == 0,4,4,8
block->requests,4,4,8
chunksize >= PAGE_SIZE,4,4,8
scale >= 0 && precision > 0 && scale <= precision,4,4,8
field < file._fieldCount,8,0,8
(offset & PAGE_MASK) == 0,4,4,8
(tlen % 4) == 0,4,4,8
SIZEOF_PTR == 8,4,4,8
 i_holder != NULL ,4,4,8
pos_in_file == info->end_of_file,4,4,8
(tlen % 2) == 0,4,4,8
ntbins <= LG_QUANTUM,4,4,8
a != NULL,5,3,8
node->named,4,4,8
!block->prev_changed,4,4,8
"false && ""Unknown field format character in SQLStorage.cpp""",4,4,8
!(block->status & BLOCK_FOR_UPDATE) || fail_block(block),4,4,8
obj->GetGridRef().isValid(),4,4,8
tcache != (void *)(uintptr_t)1,4,4,8
"my_memmem(NULL, 10, needle, 3) == NULL",4,4,8
CHUNK_ADDR2BASE(chunk) == chunk,5,3,8
result != -1,4,4,8
ndirty == 0,4,4,8
(block->offset == keycache->key_cache_block_size) || fail_block(block),4,4,8
(length % 4) == 0,4,4,8
"false && ""unknown field name""",4,4,8
(slen % 2) == 0,4,4,8
tbin->ncached > 0 || tbin->avail == NULL,4,4,8
(a->bits & CHUNK_MAP_KEY) == CHUNK_MAP_KEY || (a->bits & CHUNK_MAP_DIRTY) == (b->bits & CHUNK_MAP_DIRTY),4,4,8
rc->state == ACTIVE,4,4,8
(_bnum2->top == 0) || (_bnum2->d[_bnum2->top - 1] != 0),4,4,8
param->buffer_length != 0,4,4,8
 holder != NULL && holder->i_referenceCount > 0,4,4,8
node->u.named.nchildren > 0,4,4,8
!obj->GetGridRef().isValid(),4,4,8
"arena_run_tree_search(&bin->runs, run_mapelm) == NULL",4,4,8
isalloc(ptr) == PAGE_SIZE,4,4,8
!block->next_changed,4,4,8
!info->share,4,4,8
addr == (void *)((uintptr_t)vaddr + voff),4,4,8
diff == regind * size,4,4,8
zero == false,4,4,8
sspace_min < PAGE_SIZE,4,4,8
ndirty >= npages,4,4,8
idx == N32,4,4,8
(block->status & ~BLOCK_CHANGED) == (BLOCK_READ | BLOCK_IN_USE),4,4,8
chunk != NULL,5,3,8
Count >= left_length,4,4,8
"!""Write not implemented for this packet.""",4,4,8
(block->length == 0) || fail_block(block),4,4,8
block->hash_link->requests,4,4,8
(block->requests > 0) || fail_block(block),4,4,8
b != NULL,5,3,8
"std::is_integral<T>::value || std::is_enum<T>::value, ""T must be an integer type""",4,4,8
(hash_link->file == file) && (hash_link->diskpos == filepos) && (block->hash_link == hash_link),4,4,8
keycomp != NULL,4,3,7
size() < 10000000,4,3,7
"ckh_search(ckh, key, NULL, NULL)",4,3,7
hash != NULL,4,3,7
node->addr == ptr,4,3,7
bt->vec != NULL,4,3,7
index < m_fieldCount,4,3,7
k2 != NULL,4,3,7
minitems > 0,4,3,7
need_pages <= total_pages,4,3,7
LG_CKH_BUCKET_CELLS > 0,4,3,7
size == s2u(size),4,3,7
CHUNK_ADDR2BASE(ret) == ret,4,3,7
bt->len == 0,4,3,7
minsize != 0,4,3,7
pageind == chunk_npages,4,3,7
cell->key != NULL,4,3,7
run->nfree > 0,4,3,7
k1 != NULL,4,3,7
size < oldsize,4,3,7
tbin->ncached == 0,4,3,7
(uintptr_t)cnt == (uintptr_t)1U,4,3,7
(TCACHE_NSLOTS_SMALL_MAX & 1U) == 0,4,3,7
ret == NULL || (addr == NULL && ret != addr) || (addr != NULL && ret == addr),4,3,7
usize != 0,5,1,6
(alignment & PAGE_MASK) == 0,3,3,6
arena->ndirty > chunk_npages,3,3,6
"false && ""SQL storage has a field type that does not match what is in the core. Check SQLStorage.cpp or your database.""",3,3,6
(g & (1LU << (bit & BITMAP_GROUP_NBITS_MASK))) == 0,4,2,6
 iter->second != NULL ,3,3,6
"(mp)->count > 0 && pthread_equal(pthread_self(), (mp)->thread)",3,3,6
(uintptr_t)ptr >= (uintptr_t)run + (uintptr_t)bin_info->reg0_offset,4,2,6
"header == PacketHeader(CMSG_REALID_FRIEND_INVITE, FRIENDS) && ""Invalid packet header for RealIdFriendInvite""",3,3,6
(A) != 0,3,3,6
"bitmap_get(bitmap, binfo, bit) == false",4,2,6
(chunk->map[run_ind+total_pages-1].bits & CHUNK_MAP_DIRTY) == flag_dirty,3,3,6
"bitmap_get(bitmap, binfo, bit)",4,2,6
OP(m->g->strip[esub]) == OOR1,3,3,6
i_data,3,3,6
sizeof(LARGE_INTEGER) == sizeof(query_performance_frequency),3,3,6
g & (1LU << (bit & BITMAP_GROUP_NBITS_MASK)),4,2,6
tbin->ncached < tbin_info->ncached_max,4,2,6
_instance != 0,3,3,6
src,3,3,6
oldsize == (chunk->map[pageind].bits & ~PAGE_MASK),3,3,6
(narenas & 1) == 0,3,3,6
displayInfo,3,3,6
run_ind >= arena_chunk_header_npages,3,3,6
*fmt == '%',3,3,6
obj,3,3,6
_lock == 0,3,3,6
binind < NBINS,6,0,6
_owner == ThreadOps::self(),3,3,6
rest != NULL,3,3,6
cs->mbmaxlen == 2,3,3,6
stp >= sp,3,3,6
(chunk->map[run_ind].bits & ~PAGE_MASK) == prun_size,3,3,6
l_rc == 0,3,3,6
size > 0,3,3,6
ops->_tid == 0,3,3,6
size > oldsize,3,3,6
cs->multis == NULL,3,3,6
(chunk->map[run_ind+run_pages-1].bits & ~PAGE_MASK) == nrun_size,3,3,6
usize == isalloc(ret),3,3,6
nignore + 1 == NIGNORE,3,3,6
size == isalloc(ptr),3,3,6
(chunk->map[arena_chunk_header_npages].bits & CHUNK_MAP_DIRTY) != 0,3,3,6
"! (mp)->count || ! pthread_equal(pthread_self(), (mp)->thread)",3,3,6
tcache == tcache_tls,3,3,6
modelData,3,3,6
"header == PacketHeader(CMSG_GET_FRIENDS_OF_FRIEND, FRIENDS) && ""Invalid packet header for GetFriendsOfFriend""",3,3,6
(arena->nactive >> opt_lg_dirty_mult) < arena->ndirty,3,3,6
m_rowPosition < m_rowCount,4,2,6
trie && key && keylen,3,3,6
((uintptr_t)ptr - ((uintptr_t)run + (uintptr_t)bin_info->reg0_offset)) % bin_info->reg_size == 0,3,3,6
dst <= end,3,3,6
usize_promoted != 0,3,2,5
index < MAX_ITEM_PROTO_STATS,5,0,5
"size == isalloc(ptr, true)",3,2,5
keycache->blocks_used < (ulong) keycache->disk_blocks,2,2,4
"arena_mapbits_unallocated_size_get(chunk, map_bias) == arena_maxclass",3,1,4
page_status != -1,2,2,4
rc->waiter_count,2,2,4
do_left || (dec->len * DIG_PER_DEC1 - end) >= r_mini_shift,2,2,4
"my_memmem(haystack, 0, needle, 3) == NULL",2,2,4
rc,2,2,4
info->post_write == NULL,2,2,4
err == FALSE,2,2,4
"pos + sizeof(T) <= size() || PrintPosError(false, pos, sizeof(T))",2,2,4
keycache->blocks_available != 0,2,2,4
get_key ? !key_offset && !key_length : key_length,2,2,4
prec2 > 0,2,2,4
MORE(),2,2,4
map->bitmap && map2->bitmap,2,2,4
fd >= 0,2,2,4
_owner == 0,2,2,4
idx % 2 == 0,2,2,4
"header == PacketHeader(CMSG_LOGOUT_REQUEST, CONNECTION) && ""Invalid packet header for LogoutRequest""",2,2,4
"header == PacketHeader(CMSG_UPDATE_REQUEST, PRESENCE) && ""Invalid packet header for UpdateRequest""",2,2,4
row,2,2,4
!(block->status & (BLOCK_IN_FLUSH | BLOCK_CHANGED)),2,2,4
_owner == ThreadOps::INVALID,2,2,4
sizeof(LF_PINS) == 64,2,2,4
sizeof(intptr) == sizeof(void *),2,2,4
"header == PacketHeader(CMSG_LOGON_REQUEST, AUTHENTICATION) && ""Invalid packet header for LogonRequest""",2,2,4
intg > 0,2,2,4
&keycache->cache_lock,2,2,4
OP(s) == OOR2,2,2,4
(optp->var_type & GET_TYPE_MASK) == GET_LL,2,2,4
(chunk->map[pageind+head_npages+tail_npages-1-map_bias].bits & ~PAGE_MASK) == 0,2,2,4
packet_length,2,2,4
(chunk->map[pageind-map_bias].bits & CHUNK_MAP_ALLOCATED) != 0,2,2,4
entry,3,1,4
!(block->status & (BLOCK_REASSIGNED | BLOCK_CHANGED | BLOCK_FOR_UPDATE)),2,2,4
block->requests == 1,2,2,4
_owner == ThreadOps::INVALID || _owner == self,2,2,4
(d)->len >0 && ((d)->buf[0] | (d)->buf[(d)->len-1] | 1),2,2,4
"*p == NULL || strcmp(*p, str) == 0",2,2,4
"header == PacketHeader(CMSG_SOCIAL_NETWORK_CHECK_CONNECTED, FRIENDS) && ""Invalid packet header for SocialNetworkCheckConnected""",2,2,4
block->next_used && block->prev_used && (block->next_used->prev_used == &block->next_used) && (*block->prev_used == block),2,2,4
*to_len >= 2+from->sign,2,2,4
!write_cache || (write_cache->type == WRITE_CACHE),2,2,4
"arena_mapbits_dirty_get(chunk, run_ind) == arena_mapbits_dirty_get(chunk, run_ind+run_pages-1)",3,1,4
(uint) (field - result) < fields,2,2,4
p->pend[subno] != 0,2,2,4
(optp->var_type & GET_TYPE_MASK) == GET_ULL,2,2,4
(block->status & BLOCK_IN_USE) && !(block->status & (BLOCK_IN_EVICTION | BLOCK_IN_SWITCH | BLOCK_REASSIGNED | BLOCK_IN_FLUSH | BLOCK_CHANGED | BLOCK_FOR_UPDATE)),2,2,4
count <= lock->read_no_write_count,2,2,4
choose_arena()->bins[small_size2bin[ oldsize]].reg_size == oldsize,2,2,4
cursor.prev != &node->link,2,2,4
(carry) <= 1,2,2,4
"arena_mapbits_dirty_get(chunk, map_bias) == arena_mapbits_dirty_get(chunk, chunk_npages-1)",3,1,4
"arena_mapbits_allocated_get(chunk, chunk_npages-1) == 0",3,1,4
end < dec->buf + dec->len,2,2,4
vio->sd >= 0,2,2,4
(large && binind == BININD_INVALID) || (large == false && binind != BININD_INVALID),2,2,4
((ulonglong)(intptr)ptr) >= SIZEOF_INT,2,2,4
strlen (dirname) < MAX_PATH,2,2,4
"arena_mapbits_allocated_get(chunk, pageind) != 0",4,0,4
(block->status & ~(BLOCK_FOR_UPDATE | BLOCK_IN_EVICTION)) == (BLOCK_READ | BLOCK_IN_FLUSH | BLOCK_CHANGED | BLOCK_IN_USE),2,2,4
"arena_mapbits_allocated_get(chunk, map_bias) == 0",3,1,4
FILE_BEGIN == SEEK_SET && FILE_CURRENT == SEEK_CUR && FILE_END == SEEK_END,2,2,4
key_cache_block_size >= 512,2,2,4
((block->hash_link != hash_link) && (block->status & (BLOCK_IN_EVICTION | BLOCK_IN_SWITCH))) || ((block->hash_link == hash_link) && !(block->status & BLOCK_READ)) || ((block->status & BLOCK_READ) && !(block->status & (BLOCK_IN_EVICTION | BLOCK_IN_SWITCH))),2,2,4
!cshare->source_cache,2,2,4
row <= row_end,2,2,4
block->hash_link && (block->hash_link->block == block),2,2,4
x < N && y < N,3,1,4
"info->end_of_file == my_tell(info->file,MYF(0))",2,2,4
width > 0 && to != NULL,2,2,4
precision && precision >= frac,2,2,4
!hash_link->block->next_used,2,2,4
"my_memmem(haystack, 1, needle, 3) == NULL",2,2,4
"header == PacketHeader(CMSG_PROOF_RESPONSE, AUTHENTICATION) && ""Invalid packet header for ProofResponse""",2,2,4
"header == PacketHeader(CMSG_ENABLE_ENCRYPTION, CONNECTION) && ""Invalid packet header for EnableEncryption""",2,2,4
((block->status & ~(BLOCK_REASSIGNED | BLOCK_FOR_UPDATE)) == BLOCK_IN_USE) || fail_block(block),2,2,4
type != READ_NET && info->type != READ_NET && type != WRITE_NET && info->type != WRITE_NET && type != SEQ_READ_APPEND && info->type != SEQ_READ_APPEND,2,2,4
((block->hash_link != hash_link) && (block->status & (BLOCK_IN_EVICTION | BLOCK_IN_SWITCH))) || ((block->hash_link == hash_link) && !(block->status & BLOCK_READ)),2,2,4
!block->next_changed && !block->prev_changed,2,2,4
size >= sizeof(void*) + free_ptr_offset,2,2,4
(block->status & ~BLOCK_IN_EVICTION) == (BLOCK_READ | BLOCK_IN_SWITCH | BLOCK_IN_FLUSH | BLOCK_IN_FLUSHWRITE | BLOCK_CHANGED | BLOCK_IN_USE) || fail_block(block),2,2,4
!keycache->changed_blocks[idx],2,2,4
"header == PacketHeader(CMSG_SOCIAL_NETWORK_CONNECT, FRIENDS) && ""Invalid packet header for SocialnetworkConnect""",2,2,4
(flag & (O_WRONLY | O_RDWR)) != (O_WRONLY | O_RDWR),2,2,4
!block->hash_link,2,2,4
(chunk->map[pageind-map_bias].bits & CHUNK_MAP_LARGE) != 0,2,2,4
(flag & (O_TRUNC | O_APPEND)) != (O_TRUNC | O_APPEND),2,2,4
(block->status & (BLOCK_READ | BLOCK_IN_USE | BLOCK_REASSIGNED)) && !(block->status & (BLOCK_IN_EVICTION | BLOCK_IN_SWITCH | BLOCK_IN_FLUSH | BLOCK_CHANGED | BLOCK_FOR_UPDATE)),2,2,4
(d)->len > 0,2,2,4
!keycache->file_blocks[idx],2,2,4
(block->status & ~BLOCK_IN_EVICTION) == (BLOCK_READ | BLOCK_IN_FLUSH | BLOCK_CHANGED | BLOCK_IN_USE),2,2,4
buflen > 0,2,2,4
"_rpos + len <= size() || PrintPosError(false, _rpos, len)",2,2,4
_hMutex != NULL,2,2,4
arena->ndirty > chunk_npages || all,2,2,4
thr_client_alarm,2,2,4
fill <= 0xFFFF,2,2,4
!block->status,2,2,4
queue->elements < queue->max_elements,2,2,4
pins->pin[i] == 0,2,2,4
trie,2,2,4
info->append_read_pos <= info->write_pos,2,2,4
to->intg >=0,2,2,4
OP(m->g->strip[esub]) == O_CH,2,2,4
block->next_used && block->prev_used && *block->prev_used == block,2,2,4
frac0+intg0 > 0,2,2,4
intg0 <= ROUND_UP(from2->intg),2,2,4
end >= dec->buf,2,2,4
!do_left || l_mini_shift <= beg,2,2,4
fd != -1,2,2,4
str && str <= strend,2,2,4
old_lock_type == TL_WRITE_ONLY,2,2,4
r == BZ_OK,2,2,4
"EQ(step(m->g, startst, stopst, st, NOTHING, st), st)",2,2,4
m && prefix_size <= map->n_bits,2,2,4
"my_memmem(haystack, 10, NULL, 3) == NULL",2,2,4
(page_st == PAGE_READ) && (read_length + offset <= block->length),2,2,4
map->bitmap && (prefix_size <= map->n_bits || prefix_size == (uint) ~0),2,2,4
data_len == SCRAMBLE_LENGTH_323 + 1,2,2,4
num_threads > 1,2,2,4
map,2,2,4
cache_empty(keycache),2,2,4
buf1 < stop1,2,2,4
a,2,2,4
vio->read_end == vio->read_pos,2,2,4
count<= keycache->blocks_used,2,2,4
hash_link->block->hash_link == hash_link,2,2,4
PIN < LF_NUM_PINS_IN_THIS_FILE,2,2,4
buflen >= sizeof(struct hostent_data),2,2,4
start2[1]*guess <= (x-guess*start2[0])*DIG_BASE+y,2,2,4
"header == PacketHeader(CMSG_AUTH_CHALLENGE, AUTHENTICATION) && ""Invalid packet header for AuthChallenge""",2,2,4
c != OUT,2,2,4
valid == TRUE,2,2,4
thread_safe == 0,2,2,4
mysql->status != MYSQL_STATUS_READY,2,2,4
read_cache->type == READ_CACHE,2,2,4
barier + d_shift < dec->buf + dec->len,2,2,4
to >= dec->buf,2,2,4
M,2,2,4
last_in_switch->status & (BLOCK_IN_EVICTION | BLOCK_IN_SWITCH | BLOCK_REASSIGNED),2,2,4
rwp,2,2,4
_bf || _workshopId < WG_MAX_WORKSHOP,2,2,4
"arena_mapbits_unallocated_size_get(chunk, chunk_npages-1) == arena_maxclass",3,1,4
old_lock_type > new_lock_type,2,2,4
!info->share || !info->share->total_threads,2,2,4
dst < end,2,2,4
(hash_link->file == file) && (hash_link->diskpos == filepos),2,2,4
!*alarmed || found == 1,2,2,4
p < end,2,2,4
free_ptr_offset % sizeof(void *) == 0,2,2,4
seek_offset == 0,2,2,4
buf != end,2,2,4
new_point >= 0,2,2,4
hash_link->block->requests,2,2,4
!(block->status & (BLOCK_IN_EVICTION | BLOCK_IN_SWITCH)),2,2,4
!thread->next,2,2,4
_count == 0,2,2,4
"pendingCommands.open(""pendingCommands"", ACE_SV_Semaphore_Simple::ACE_CREATE, 0) != -1",2,2,4
(block->status & ~BLOCK_IN_EVICTION) == (BLOCK_READ | BLOCK_IN_SWITCH | BLOCK_IN_FLUSH | BLOCK_IN_FLUSHWRITE | BLOCK_CHANGED | BLOCK_IN_USE),2,2,4
size % 4 == 0,2,2,4
(ulong) keycache->blocks_available <= keycache->blocks_used,2,2,4
&(M)->m_prlock,2,2,4
to < dec->buf + dec->len,2,2,4
mysql->field_count,2,2,4
orientation > -100 && orientation < 100,2,2,4
(n % 4) == 0,2,2,4
frac0+intg0 >= 0,2,2,4
*end == NULL,2,2,4
dirname != NULL,2,2,4
OP(g->strip[pc+OPND(s)]) == OOR2,2,2,4
(chunk->map[pageind+head_npages+tail_npages-1-map_bias].bits & CHUNK_MAP_ALLOCATED) != 0,2,2,4
right.GetCount() <= GetCount(),2,2,4
SIZE_T_MAX - size >= extra,3,1,4
size >= N64,2,2,4
(uintptr_t)ptr >= (uintptr_t)run + (uintptr_t)run->bin->reg0_offset,2,2,4
"header == PacketHeader(CMSG_RESUME_REQUEST, AUTHENTICATION) && ""Invalid packet header for ResumeRequest""",2,2,4
Count > left_length,2,2,4
argc && *argc >= 1,2,2,4
!alarm_queue.elements,2,2,4
&(M)->m_mutex,2,2,4
file != NULL,2,2,4
(arena->nactive >> opt_lg_dirty_mult) < arena->ndirty || all,2,2,4
sizeof(buff) > SCRAMBLE_LENGTH_323,2,2,4
buflen == 4,2,2,4
!thread->prev,2,2,4
mysql->status != MYSQL_STATUS_READY || (mysql->server_status & SERVER_STATUS_LAST_ROW_SENT),2,2,4
next == next_hash_link->block,2,2,4
prec1 > 0,2,2,4
nOut == nIn,2,2,4
block,2,2,4
hash_link->requests == 0,2,2,4
buf0 == to->buf || buf0 == to->buf+1,2,2,4
stmt->field_count,2,2,4
state && c,2,2,4
!thread->next && !thread->prev,2,2,4
(page_status == PAGE_WAIT_TO_BE_READ) || ((block->hash_link->file == file) && (block->hash_link->diskpos == filepos)),2,2,4
thread->next && thread->prev,2,2,4
precision >= 0 && precision < NOT_FIXED_DEC && to != NULL,2,2,4
"pos + cnt <= size() || PrintPosError(true, pos, cnt)",2,2,4
to == orig_to + orig_fsize0 + orig_isize0,2,2,4
last_for_update->status & BLOCK_FOR_UPDATE,2,2,4
idx < queue->max_elements,2,2,4
dp == rest,2,2,4
"my_memmem(haystack, 10, needle, 0) == NULL",2,2,4
"header == PacketHeader(CMSG_STATISTIC_SUBSCRIBE, PRESENCE) && ""Invalid packet header for StatisticSubscribe""",2,2,4
barier - d_shift >= dec->buf,2,2,4
my_errno != ESPIPE,2,2,4
mysql,2,2,4
!hash_link->block->prev_used,2,2,4
buf0 + (stop1 - start1) <= to->buf + to->len,2,2,4
"my_memmem(haystack, 9, needle, 3) == NULL",2,2,4
((block->status & ~BLOCK_FOR_UPDATE) == BLOCK_IN_USE) || fail_block(block),2,2,4
argv && *argv,2,2,4
found <= keycache->blocks_used,2,2,4
!(MyFlags & (MY_FNABP | MY_NABP)),2,2,4
(size_t) buflen >= sizeof(*result),2,2,4
node->link != (intptr)node,2,2,4
OP(m->g->strip[esub]) == OOR2,2,2,4
index < sizeof(uint64),2,2,4
(uintptr_t)ptr < (uintptr_t)run->next,2,2,4
cnt <= keycache->hash_links_used,2,2,4
from >= dec->buf,2,2,4
"header == PacketHeader(CMSG_JOIN_REQUEST_V2, WOWREALM) && ""Invalid packet header for RealmJoinRequest""",2,2,4
from < dec->buf + dec->len,2,2,4
"header == PacketHeader(CMSG_LIST_SUBSCRIBE_REQUEST, WOWREALM) && ""Invalid packet header for ListSubscribeRequest""",2,2,4
"my_memmem(haystack, 10, needle, 2) == NULL",2,2,4
hash_link->requests,2,2,4
"header == PacketHeader(CMSG_PING, CONNECTION) && ""Invalid packet header for Ping""",2,2,4
block->hash_link && block->hash_link->block == block && block->prev_changed,2,2,4
(chunk->map[pageind+head_npages+tail_npages-1-map_bias].bits & CHUNK_MAP_LARGE) != 0,2,2,4
size >= N32,2,2,4
deadlock->count > 0,2,2,4
pos != MY_FILEPOS_ERROR,2,2,4
size % 2 == 0,2,2,4
THR_thread_count != 0,2,2,4
"info->end_of_file - (info->append_read_pos-info->write_buffer) == (res=my_tell(info->file,MYF(0)))",2,2,4
cshare->source_cache == write_cache,2,2,4
!block->condvar,2,2,4
spellInfo,2,1,3
"!""Write not allowed for client packets.""",2,1,3
pointer,2,1,3
this != &other,2,1,3
(x),2,1,3
ctx->cnt_merged.curbytes == 0,2,1,3
"bitmap_full(bitmap, &bin_info->bitmap_info) == false",2,1,3
internal::is_name_start(*s),2,1,3
sizeof(Ch) >= 4,3,0,3
"std::is_same<Player, T>::value || std::is_same<Transport, T>::value, ""Only Player and Transport can be registered in global HashMapHolder""",2,1,3
ctx->cnt_merged.accumbytes == 0,2,1,3
run->nfree < bin_info->nregs,2,1,3
arenas[0] != NULL,2,1,3
index < _fieldCount,2,1,3
x < CELL_NUMBER && y < CELL_NUMBER,2,1,3
regind < run->nextind,2,1,3
nbits <= (ZU(1) << LG_BITMAP_MAXBITS),2,1,3
merged_stats == false,2,1,3
"size == PAGE || arena_mapbits_large_size_get(chunk, run_ind+(size>>LG_PAGE)-1) == 0",2,1,3
config_dss,3,0,3
(arena->nactive >> opt_lg_dirty_mult) < (arena->ndirty - arena->npurgatory) || all,2,1,3
run_ind >= map_bias,2,1,3
"arena_mapbits_dirty_get(chunk, map_bias) != 0",2,1,3
config_tcache,3,0,3
codepoint <= 0x10FFFF,3,0,3
(uintptr_t)prof_tdata > (uintptr_t)PROF_TDATA_STATE_MAX,2,1,3
binind != BININD_INVALID,3,0,3
nbits > 0,2,1,3
"false, ""invalid argument type""",2,1,3
malloc_initialized,3,0,3
ctx->cnt_merged.accumobjs == 0,2,1,3
'0' <= *s && *s <= '9',2,1,3
i < BITMAP_MAX_LEVELS,2,1,3
arena->ndirty > arena->npurgatory || all,2,1,3
"usize == isalloc(ret, config_prof)",3,0,3
"bitmap_full(bitmap, binfo) == false",2,1,3
"usize == ((alignment == 0) ? s2u(usize) : sa2u(usize, alignment))",2,1,3
IsString(),3,0,3
config_fill,3,0,3
player,2,1,3
chunk->ndirty != 0,2,1,3
"bitmap_get(bitmap, &bin_info->bitmap_info, regind)",2,1,3
regind < bin_info->nregs,2,1,3
"arena_mapbits_dirty_get(chunk, chunk_npages-1) != 0",2,1,3
sizeof(Ch) >= 2,3,0,3
itr == appenderFactory.end(),2,1,3
arena_bin_info[SMALL_SIZE2BIN(oldsize)].reg_size == oldsize,2,1,3
"sa2u(SMALL_MAXCLASS+1, alignment) != 0",2,1,3
type() == TYPE_LENGTH_DELIMITED,3,0,3
T* pointer,2,1,3
rsize != NULL,2,1,3
*ptr != NULL,2,1,3
data->GetOpcode() != MSG_NULL_ACTION,1,1,2
interest != ANYTHING,1,1,2
rwp->state != 0,1,1,2
alloc_size >= leadsize + size,2,0,2
cs->mbmaxlen <= 4,1,1,2
!NONCHAR(ch) || ch != (char)OPND(s),1,1,2
"std::is_pointer<T>::value, ""T for ProducerConsumerQueue must be a pointer""",1,1,2
"pthread_equal(_owner, pthread_self()) != 0",1,1,2
npurgatory >= arena->nactive >> opt_lg_dirty_mult,1,1,2
packet.GetOpcode() == CMSG_LEARN_TALENT,1,1,2
type() == TYPE_GROUP,2,0,2
cp == g->must + g->mlen,1,1,2
rc->cond_mutex,1,1,2
HERE() == sn+1,1,1,2
*fmt == 'X' || *fmt =='x',1,1,2
alignment != 0,2,0,2
(*mapbitsp & (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED)) == 0,1,1,2
script,1,1,2
m->lastpos != NULL,1,1,2
begin <= end,1,1,2
!_canceled,1,1,2
rwp->state == 0,1,1,2
*fmt == '$',1,1,2
sizeof(typename OutputStream::Ch) >= 2,2,0,2
messageTemplate->GetOpcode() != MSG_NULL_ACTION,1,1,2
!_queue.empty() || !_canceled,1,1,2
"usize == isalloc(ptr, true)",2,0,2
"my_isalpha(charset,ch)",1,1,2
path && stream,1,1,2
type == kStringType,2,0,2
p->next == bracket+3,1,1,2
"arena_mapbits_large_size_get(chunk, pageind+head_npages+tail_npages-1) == 0",2,0,2
_bf || _workshopId < BattlefieldWG::WG_MAX_WORKSHOP,1,1,2
p.second,1,1,2
sizeof(typename InputStream::Ch) >= 2,2,0,2
depth < 2,1,1,2
"header == PacketHeader(CMSG_AUTH_RECONNECT, AUTHENTICATION) && ""Invalid packet header for AuthResumeInfo""",1,1,2
opnd < 1<<OPSHIFT,1,1,2
0 == _owner,1,1,2
i_file,1,1,2
dstlen >= srclen * cs->caseup_multiply,1,1,2
"header == PacketHeader(CMSG_GET_STREAM_ITEMS_REQUEST, CACHE) && ""Invalid packet header for GetStreamItemsRequest""",1,1,2
_bf,1,1,2
(chunk->map[run_ind+run_pages+nrun_pages-1-map_bias].bits & CHUNK_MAP_DIRTY) == flag_dirty,1,1,2
level_stack_.GetSize() >= sizeof(Level),2,0,2
index < m_rowCount,1,1,2
len <= sizeof(epbuf),1,1,2
(chunk->map[run_ind-map_bias].bits & ~PAGE_MASK) == (chunk->map[run_ind+run_pages-1-map_bias].bits & ~PAGE_MASK),1,1,2
(chunk->map[0].bits & ~PAGE_MASK) == arena_maxclass,1,1,2
(uint) i <= p->g->nsub,1,1,2
keycache->used_last,1,1,2
my_uuid_inited,1,1,2
charset,1,1,2
"header == PacketHeader(CMSG_DISCONNECT_REQUEST, CONNECTION) && ""Invalid packet header for DisconnectRequest""",1,1,2
opt_lg_prof_tcmax < 0 || ckh_count(&prof_tdata->bt2cnt) < (ZU(1) << opt_lg_prof_tcmax),1,1,2
! (!hot && keycache->waiting_for_block.last_thread),1,1,2
value < 1<<OPSHIFT,1,1,2
"resid->type->compare(&thd->waiting_for->id, resid) == 0",1,1,2
size <= small_maxclass,1,1,2
i < NPAREN,1,1,2
arena < narenas,1,1,2
cp < g->must + g->mlen,1,1,2
"othercase(p->charset, ch) != ch",1,1,2
(chunk->map[run_ind+run_pages+nrun_pages-1-map_bias].bits & CHUNK_MAP_ALLOCATED) == 0,1,1,2
coldp != NULL,1,1,2
&LOCK_load_client_plugin,1,1,2
cs->multis != NULL,1,1,2
fp != NULL,1,1,2
Initialized(),2,0,2
arg->last_locked_rc == found->waiting_for,1,1,2
"header == PacketHeader(CMSG_CONNECTION_CLOSING, CONNECTION) && ""Invalid packet header for ConnectionClosing""",1,1,2
stringOffset < file._stringSize,2,0,2
!this->_queue.empty(),1,1,2
*optend,1,1,2
m->pmatch[i].rm_so == -1,1,1,2
data_.o.members != 0,2,0,2
arg.last_locked_rc == thd->waiting_for,1,1,2
interest != INVALID,1,1,2
"(A)->state == -1 && pthread_equal(pthread_self(), (A)->write_thread)",1,1,2
row < _gtEntry->NumRows,1,1,2
"(A)->active_writer && pthread_equal(pthread_self(), (A)->writer_thread)",1,1,2
data[SCRAMBLE_LENGTH_323] == 0,1,1,2
tmp,1,1,2
!wasLocked || _owner == ThreadOps::self(),1,1,2
arena->ndirty - arena->npurgatory > chunk_npages || all,1,1,2
p->next == bracket+2,1,1,2
my_thread_basic_global_init_done,1,1,2
rc->owners.elements == 0,1,1,2
type() == TYPE_VARINT,2,0,2
cs->state & MY_CS_BINSORT,1,1,2
len == '?' || len == 'l',2,0,2
!(g->iflags&BAD),1,1,2
"info->end_of_file == mysql_file_tell(info->file, MYF(0))",1,1,2
messageTemplate->GetOpcode() != NULL_OPCODE,1,1,2
GetOpcode() == CMSG_CHAR_ENUM || GetOpcode() == CMSG_CHAR_UNDELETE_ENUM,1,1,2
p->g->sets != NULL,1,1,2
column < _gtEntry->NumColumns,1,1,2
strlen(efbuf) < sizeof(efbuf),1,1,2
node,2,0,2
_queue == 0,1,1,2
end != NULL && ((str != NULL && *end != NULL) || (str == NULL && *end == NULL)) && error != NULL,1,1,2
OP(p->strip[p->pbegin[i]]) == OLPAREN,1,1,2
p[i] == 0,2,0,2
"arena_mapbits_large_size_get(chunk, pageind) == oldsize",2,0,2
(size_t) (stop - m->beginp) >= len,1,1,2
"header == PacketHeader(CMSG_LIST_UNSUBSCRIBE, WOWREALM) && ""Invalid packet header for ListUnsubscribe""",1,1,2
shared_memory_base_name != NULL,1,1,2
j < rc->owners.elements,1,1,2
retval == 0,1,1,2
!this->_canceled,1,1,2
size == PAGE_SIZE || (chunk->map[run_ind+(size>>PAGE_SHIFT)-1-map_bias].bits & ~PAGE_MASK) == 0,1,1,2
CR_OK == -1,1,1,2
(alignment & chunksize_mask) == 0,2,0,2
s != NULL,2,0,2
str != NULL && end != NULL && *end != NULL && error != NULL,1,1,2
!_queue.empty(),1,1,2
first <= last,2,0,2
vio->type == VIO_TYPE_TCPIP || vio->type == VIO_TYPE_SOCKET || vio->type == VIO_TYPE_SSL,1,1,2
!_queue.empty() || !this->_canceled,1,1,2
sep == rest,1,1,2
type != FLUSH_KEEP_LAZY,1,1,2
block->hash_link->requests == 0,1,1,2
thd->waiting_for == 0,1,1,2
optend > *pos,1,1,2
arena_salloc(ret) == arena_bin_info[binind].reg_size,1,1,2
ret == true,2,0,2
m->pmatch[i].rm_eo == -1,1,1,2
OP(p->strip[p->pend[i]]) == ORPAREN,1,1,2
obj->IsInGrid(),2,0,2
p->pbegin[i] != 0,1,1,2
rc->lock.write_locked == 0,1,1,2
(chunk->map[0].bits & CHUNK_MAP_DIRTY) == (chunk->map[chunk_npages-1-map_bias].bits & CHUNK_MAP_DIRTY),1,1,2
Base::level_stack_.GetSize() >= sizeof(typename Base::Level),2,0,2
rc->lock.readers == 0,1,1,2
index < sizeof(uint64) * 2,2,0,2
mbl == 1,1,1,2
reshash.alloc.constructor != wt_resource_init,1,1,2
i == 0 || wt_wait_table[i-1] != wt_wait_table[i],1,1,2
"usize == sa2u(usize, alignment, NULL)",1,1,2
data_.o.size > 0,2,0,2
(res_length % 4) == 0,1,1,2
packet.GetOpcode() == expectedOpcode,1,1,2
optend >= cur_arg,1,1,2
(chunk->map[chunk_npages-1-map_bias].bits & ~PAGE_MASK) == arena_maxclass,1,1,2
(flags & CHUNK_MAP_DIRTY) == flags,2,0,2
pc == stop-1,1,1,2
SSL_INITERR_NOERROR < e && e < SSL_INITERR_LASTERR,1,1,2
oldsize == (chunk->map[pageind-map_bias].bits & ~PAGE_MASK),1,1,2
(chunk->map[run_ind+(size>>PAGE_SHIFT)-1-map_bias].bits & CHUNK_MAP_ALLOCATED) != 0,1,1,2
"false && ""SQL storage does not have sort field types!""",1,1,2
"arena_run_tree_search(&bin->runs, &chunk->map[ (((uintptr_t)run-(uintptr_t)chunk)>>PAGE_SHIFT)-map_bias]) == NULL",1,1,2
"sa2u(small_maxclass+1, alignment, NULL) != 0",1,1,2
sizeof(off_t) >= sizeof(intptr),1,1,2
arg_type == 'X' || arg_type =='x',1,1,2
(chunk->map[pageind+head_npages+tail_npages-1-map_bias] .bits & CHUNK_MAP_DIRTY) == flag_dirty,1,1,2
_workshopId < WG_MAX_WORKSHOP,1,1,2
m->pmatch[i].rm_so != -1,1,1,2
fp_ != 0,2,0,2
start <= stop,1,1,2
*fmt == '$' && print_arr[idx].width < MAX_ARGS,1,1,2
"sizeof(uint64) == sizeof(unsigned long long), sizeof_uint64_is_not_sizeof_long_long",2,0,2
state != INVALID,1,1,2
nc % CHAR_BIT == 0,1,1,2
index < MAX_ITEM_PROTO_SOCKETS,2,0,2
p->ssize >= p->slen + len,1,1,2
type() == TYPE_FIXED32,2,0,2
"!""Write not implemented for client packets.""",1,1,2
HA_ERR_FIRST + array_elements(handler_error_messages) == HA_ERR_LAST + 1,1,1,2
found,1,1,2
(chunk->map[run_ind+total_pages-1-map_bias].bits & CHUNK_MAP_DIRTY) == flag_dirty,1,1,2
(mapbits & (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED)) == 0,2,0,2
pos > 0,1,1,2
"header == PacketHeader(CMSG_LOGON_REQUEST_3, AUTHENTICATION) && ""Invalid packet header for LogonRequest3""",1,1,2
type >= kUTF8 && type <= kUTF32BE,2,0,2
(chunk->map[run_ind-map_bias].bits & CHUNK_MAP_DIRTY) == flag_dirty,1,1,2
bf,1,1,2
g->nplus == 0 || m->lastpos != NULL,1,1,2
name.IsString(),2,0,2
prof_tdata != NULL,1,1,2
node->nchildren > 0,2,0,2
"npages == (arena_mapbits_unallocated_size_get(chunk, pageind) >> LG_PAGE)",2,0,2
interest != CANCELED,1,1,2
lev+1 <= m->g->nplus,1,1,2
"! has_old_lock(lock->write.data, data->owner) || ((lock_type <= lock->write.data->type || (lock_type == TL_WRITE && lock->write.data->type == TL_WRITE_LOW_PRIORITY)) && lock->write.data->type != TL_WRITE_DELAYED)",1,1,2
!m_currMap,1,1,2
m_procDeep>=0,1,1,2
m->coldp < m->endp,1,1,2
(tv > uuid_time) && (nanoseq > 0),1,1,2
mask != INVALID,1,1,2
packet.GetOpcode() == CMSG_CHANNEL_LIST || packet.GetOpcode() == CMSG_CHANNEL_DISPLAY_LIST,1,1,2
"(A)->state >= 0 || ! pthread_equal(pthread_self(), (A)->write_thread)",1,1,2
"pthread_equal(_owner, pthread_self())",1,1,2
"arena_mapbits_large_get(chunk, pageind) == 0",2,0,2
"! (A)->active_writer || ! pthread_equal(pthread_self(), (A)->writer_thread)",1,1,2
!_entered,1,1,2
opt_quarantine,2,0,2
ptr_ != NULL,2,0,2
"false && ""SQL storage has a field type that is not allowed. Check your SQLStorage.cpp!""",1,1,2
keycache->cnt_for_resize_op == 0,1,1,2
"slow(charset, m, ssp, sep, ssub, esub) == rest",1,1,2
rc->cond_mutex == mutex,1,1,2
sizeof(uint64_t) == sizeof(unsigned long),2,0,2
type >= 0 && type < MYSQL_CLIENT_MAX_PLUGINS,1,1,2
"usize == ((alignment == 0) ? s2u(usize) : sa2u(usize, alignment, NULL))",1,1,2
data_len <= 255,1,1,2
::bgs::protocol::account::v1::IdentityVerificationStatus_IsValid(value),2,0,2
len != 'l',2,0,2
finish >= start,1,1,2
reshash.count == 0,1,1,2
packet.GetOpcode() == CMSG_CAST_SPELL || packet.GetOpcode() == CMSG_PET_CAST_SPELL,1,1,2
sp == rest,1,1,2
usize == isalloc(p),1,1,2
thd->my_resources.elements == 0,1,1,2
(chunk->map[run_ind-map_bias].bits & CHUNK_MAP_ALLOCATED) == 0,1,1,2
"header == PacketHeader(CMSG_SOCIAL_NETWORK_CONNECT, FRIENDS) && ""Invalid packet header for SocialNetworkConnect""",1,1,2
!MORE() || SEE(stop),1,1,2
usize == isalloc(result),1,1,2
data->GetOpcode() != NULL_OPCODE,1,1,2
mutex,1,1,2
maximum >= 1 && maximum <= MY_STRXFRM_NLEVELS,1,1,2
never,1,1,2
CR_ERROR == 0,1,1,2
alignment > chunksize,1,1,2
dp == NULL || dp == endp,1,1,2
"sizeof(int64) == sizeof(long long), sizeof_int64_is_not_sizeof_long_long",2,0,2
opt_lg_qspace_max != LG_QSPACE_MAX_DEFAULT || opt_lg_cspace_max != LG_CSPACE_MAX_DEFAULT || (sizeof(const_small_size2bin) != ((small_maxclass-1) >> LG_TINY_MIN) + 1),1,1,2
thd->waiting_for->id.type == resid->type,1,1,2
conn,1,1,2
g->backrefs,1,1,2
"offsetof(WT_RESOURCE_ID, type) == sizeof(ulonglong)",1,1,2
atomic_read(&_value) == 1,1,1,2
t >= 0.f && t <= 1.f,2,0,2
! (keycache->waiting_for_hash_link.last_thread),1,1,2
len < MAX_BUF,1,1,2
"header == PacketHeader(CMSG_AUTH_PROOF_RESPONSE, AUTHENTICATION) && ""Invalid packet header for ProofResponse""",1,1,2
thd == blocker,1,1,2
(uintptr_t)ctx == (uintptr_t)1U,1,1,2
!(flag_dsc & src_bit) && !(flag_rev & src_bit),1,1,2
x != 0,2,0,2
trie && state,1,1,2
optend <= *pos + strlen(*pos),1,1,2
(chunk->map[run_ind+(size>>PAGE_SHIFT)-1-map_bias].bits & CHUNK_MAP_LARGE) != 0,1,1,2
MYSQL_USERNAME_LENGTH == USERNAME_LENGTH,1,1,2
strlen(convbuf) < sizeof(convbuf),1,1,2
(chunk->map[run_ind-map_bias].bits & ~PAGE_MASK) == prun_size,1,1,2
((uintptr_t)ptr - ((uintptr_t)run + (uintptr_t)bin_info->reg0_offset)) % (uintptr_t)bin_info->reg_size == 0,1,1,2
doomed,1,1,2
_count != 0,1,1,2
"arena_mapbits_dirty_get(chunk, pageind+head_npages+tail_npages-1) == flag_dirty",2,0,2
m->coldp != NULL,1,1,2
"header.Channel == AUTHENTICATION && (header.Opcode == CMSG_AUTH_CHALLENGE || header.Opcode == CMSG_AUTH_CHALLENGE_NEW) && ""Invalid packet header for AuthChallenge""",1,1,2
copy == finish+4,1,1,2
"std::is_fundamental<T>::value, ""append(compound)""",2,0,2
from <= to,1,1,2
(chunk->map[0].bits & CHUNK_MAP_DIRTY) != 0,1,1,2
height * bits_per_level >= bits,1,1,2
sizeof(typename InputStream::Ch) >= 4,2,0,2
dp == sep,1,1,2
baseObject != NULL,1,1,2
chunk->map[i-map_bias].bits == unzeroed,1,1,2
dstlen >= srclen * cs->casedn_multiply,1,1,2
"isalloc(ptr, false) == PAGE",2,0,2
sp == stop,1,1,2
(chunk->map[run_ind+run_pages+nrun_pages-1-map_bias].bits & ~PAGE_MASK) == nrun_size,1,1,2
"header == PacketHeader(CMSG_JOIN_REQUEST, WOW) && ""Invalid packet header for RealmJoinRequest""",1,1,2
type() == TYPE_FIXED64,2,0,2
*fmt == '$' && print_arr[idx].length < MAX_ARGS,1,1,2
(chunk->map[run_ind-map_bias].bits & CHUNK_MAP_DIRTY) == (chunk->map[run_ind+run_pages-1-map_bias].bits & CHUNK_MAP_DIRTY),1,1,2
p->slen < p->ssize,1,1,2
m->pmatch != NULL,1,1,2
"STEPS_PER_SEGMENT > 0, ""shouldn't be lesser than 1""",1,1,2
FALSE,1,1,2
"isalloc(ptr, true) == size",1,0,1
plus_space == false,1,0,1
bits > 0 && bits <= (sizeof(uintptr_t) << 3),1,0,1
"arena_run_tree_search(&bin->runs, mapelm) == NULL",1,0,1
opt_lg_prof_sample != 0,1,0,1
"false && ""Not implemented Battleground score type!""",1,0,1
!(parseFlags & kParseInsituFlag),1,0,1
plus_plus == false,1,0,1
!Base::level_stack_.template Top<typename Base::Level>()->inArray,1,0,1
flags_ & kIntFlag,1,0,1
"oldsize == arena_mapbits_large_size_get(chunk, pageind)",1,0,1
chunk->ndirty == 0 || all == false,1,0,1
npages > 0,1,0,1
arena->spare == NULL,1,0,1
"ObjectGuidTraits<type>::Global || ObjectGuidTraits<type>::RealmSpecific, ""Only global guid can be generated in ObjectMgr context""",1,0,1
((uintptr_t)ptr - ((uintptr_t)run + (uintptr_t)bin_info->reg0_offset)) % bin_info->reg_interval == 0,1,0,1
length <= 0xFFFFFFFF,1,0,1
is.Peek() == 't',1,0,1
chunk->nruns_avail > chunk->nruns_adjac || (chunk->nruns_avail == 0 && chunk->nruns_adjac == 0),1,0,1
"arena_run_tree_search(&bin->runs, mapelm) != NULL",1,0,1
"ObjectGuidTraits<high>::MapSpecific, ""Only map specific guid can be generated in Map context""",1,0,1
run_ind == map_bias,1,0,1
id < _indexTableSize,1,0,1
CHUNK_CEILING(oldsize) == oldsize,1,0,1
m->name.IsString(),1,0,1
ret.v != NULL,1,0,1
level_stack_.template Top<Level>()->inArray,1,0,1
"usize == sa2u(usize, alignment)",1,0,1
type <= kNumberType,1,0,1
!Empty(),1,0,1
"column < _gtEntry->NumColumns, ""Requested column %u from GameTable %s but there are only %u columns!"", column, _gtEntry->Name->Str[0], _gtEntry->NumColumns",1,0,1
ncleanups < MALLOC_TSD_CLEANUPS_MAX,1,0,1
flags_ & kUintFlag,1,0,1
data->GetSize() == 0,1,0,1
"ALIGNMENT_ADDR2BASE(ret, alignment) == ret",1,0,1
"arena_run_tree_search(&bin->runs, arena_mapp_get(chunk, ((uintptr_t)run-(uintptr_t)chunk)>>LG_PAGE)) == NULL",1,0,1
arena == arenas[newind],1,0,1
quarantine->curobjs < (ZU(1) << quarantine->lg_maxobjs),1,0,1
"arena_mapbits_large_size_get(chunk, pageind) == PAGE",1,0,1
adjustment >= 0 && adjustment < 7,1,0,1
((uintptr_t)ptr - ((uintptr_t)run + (uintptr_t)bin_info->reg0_offset)) % (uintptr_t)bin_info->reg_interval == 0,1,0,1
is.Peek() == '[',1,0,1
"arena_mapbits_large_get(chunk, pageind) != 0 || arena_ptr_small_binind_get(ptr, arena_mapbits_get(chunk, pageind)) == binind",1,0,1
count_ + offset <= kCapacity,1,0,1
pageind - runind >= map_bias,1,0,1
prev_length <= new_length,1,0,1
is.Peek() == '{',1,0,1
dst == IterativeParsingValueState,1,0,1
" int8 , sizeof(SOPHIST_int8 ) == 1",1,0,1
left_justify == false,1,0,1
x,1,0,1
b->nruns_adjac == 0,1,0,1
GetType() == kNumberType,1,0,1
IsNumber(),1,0,1
"ret == PAGE || arena_mapbits_large_size_get(chunk, pageind+(ret>>LG_PAGE)-1) == 0",1,0,1
opt_junk,1,0,1
sizeof(B) != 0,1,0,1
(height-1) * bits_per_level + bits_in_leaf >= bits,1,0,1
n >= 0 && n <= 308,1,0,1
index < index_hi,1,0,1
" int64, sizeof(SOPHIST_int64 ) == 8",1,0,1
ctx->cnt_summed.curobjs == 0,1,0,1
"row < _gtEntry->NumRows, ""Requested row %u from GameTable %s but there are only %u rows!"", row, _gtEntry->Name->Str[0], _gtEntry->NumRows",1,0,1
"arena_mapbits_dirty_get(chunk, run_ind+total_pages-1) == flag_dirty",1,0,1
dst_ != 0,1,0,1
GetOpcode() == CMSG_ENUM_CHARACTERS || GetOpcode() == CMSG_ENUM_CHARACTERS_DELETED_BY_CLIENT,1,0,1
token == ColonToken,1,0,1
GetSize() >= count * sizeof(T),1,0,1
uprec != UINTMAX_MAX || get_errno() != ERANGE,1,0,1
"strpbrk(_format, ""nd"") == nullptr, ""Only non-indexed storages can be sorted""",1,0,1
"!_threads && !_acceptor && !_threadCount, ""StopNetwork must be called prior to SocketMgr destruction""",1,0,1
"usize == isalloc(p, config_prof)",1,0,1
diff == regind * interval,1,0,1
ctx->cnt_summed.curbytes == 0,1,0,1
"arena_mapbits_unzeroed_get(chunk, i) == unzeroed",1,0,1
(flags_ & kUint64Flag) != 0,1,0,1
(mapbits & (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED)) == (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED),1,0,1
::Battlenet::JSON::Login::FormType_IsValid(value),1,0,1
config_stats,1,0,1
::google::protobuf::FieldDescriptorProto_Type_IsValid(value),1,0,1
IsInGrid(),1,0,1
itr != m_resetTimeByMapDifficulty.end(),1,0,1
prof_dump_fd != -1,1,0,1
IsBool(),1,0,1
"obj->usize == isalloc(obj->ptr, config_prof)",1,0,1
pageind + (ret>>LG_PAGE) <= chunk_npages,1,0,1
base >= 2 && base <= 36,1,0,1
usize <= SMALL_MAXCLASS,1,0,1
chunk->nruns_avail > chunk->nruns_adjac,1,0,1
_thread,1,0,1
"ivsalloc(ptr, config_prof) == size",1,0,1
spellId < GetSpellInfoStoreSize(),1,0,1
stackCapacity > 0,1,0,1
pageind >= map_bias,1,0,1
config_prof || demote == false,1,0,1
mapbits == actual_mapbits,1,0,1
Base::level_stack_.template Top<typename Base::Level>()->inArray,1,0,1
last <= MemberEnd(),1,0,1
flags_ & kInt64Flag,1,0,1
node->size >= leadsize + size,1,0,1
indentChar == ' ' || indentChar == '\t' || indentChar == '\n' || indentChar == '\r',1,0,1
(flags & (CHUNK_MAP_DIRTY|CHUNK_MAP_UNZEROED)) == flags,1,0,1
::Battlenet::JSON::Login::AuthenticationState_IsValid(value),1,0,1
empty_string_ != NULL,1,0,1
tcache->ev_cnt <= TCACHE_GC_INCR,1,0,1
codepoint < 0xD800 || codepoint > 0xDFFF,1,0,1
array_ != NULL,1,0,1
!HasParseError(),1,0,1
"intptr, sizeof(SOPHIST_intptr) == sizeof(char *)",1,0,1
arena_ind < ctl_stats.narenas,1,0,1
m >= MemberBegin() && m < MemberEnd(),1,0,1
binind <= BININD_INVALID,1,0,1
!hasRoot_,1,0,1
chunksize >= PAGE,1,0,1
ckh_count(&prof_tdata->bt2cnt) > 0,1,0,1
f == NULL || dynamic_cast<To>(f) != NULL,1,0,1
stack_.GetSize() == sizeof(ValueType),1,0,1
run != bin->runcur,1,0,1
tcache_salloc(ptr) <= tcache_maxclass,1,0,1
objectList != NULL,1,0,1
tcache_salloc(ptr) > SMALL_MAXCLASS,1,0,1
ptr != NULL || (uintptr_t)cnt <= (uintptr_t)1U,1,0,1
"uint16, sizeof(SOPHIST_int16) == 2",1,0,1
(void*)this != (void const*)&rhs,1,0,1
"ret == false || arena_mapbits_dirty_get(chunk, pageind) != arena_mapbits_dirty_get(chunk, pageind+npages)",1,0,1
::bgs::protocol::account::v1::PrivacyInfo_GameInfoPrivacy_IsValid(value),1,0,1
is.Peek() == 'f',1,0,1
tcache_salloc(ptr) <= SMALL_MAXCLASS,1,0,1
index < 0x20,1,0,1
prof_interval != 0,1,0,1
prof_tdata->enq,1,0,1
first >= Begin(),1,0,1
" int32, sizeof(SOPHIST_int32 ) == 4",1,0,1
name,1,0,1
binind < BININD_INVALID,1,0,1
pageind < chunk_npages,1,0,1
d >= 0.0,1,0,1
count_ < kCapacity,1,0,1
stats_chunks.curchunks >= (size / chunksize),1,0,1
"arena_mapbits_small_runind_get(chunk, pageind) == 0",1,0,1
index < data_.a.size,1,0,1
run_pages == (arena_maxclass >> LG_PAGE),1,0,1
"usize == isalloc(result, config_prof)",1,0,1
data_.a.size > 0,1,0,1
config_fill && opt_quarantine,1,0,1
bufferSize >= 4,1,0,1
!empty(),1,0,1
sizeof(D) != 0,1,0,1
tcache_salloc(ret) == arena_bin_info[binind].reg_size,1,0,1
"arena_mapbits_unallocated_size_get(chunk, run_ind+run_pages+nrun_pages-1) == nrun_size",1,0,1
::bgs::protocol::channel::v1::ChannelState_PrivacyLevel_IsValid(value),1,0,1
sizeof(typename OutputStream::Ch) >= 4,1,0,1
alignment != 0 && ((alignment - 1) & alignment) == 0,1,0,1
min_run_size >= PAGE,1,0,1
m_attacking,1,0,1
"value >= 0, ""negative value""",1,0,1
(mapbits & (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED)) == CHUNK_MAP_ALLOCATED,1,0,1
last <= End(),1,0,1
length >= 1,1,0,1
(flags & ~CHUNK_MAP_FLAGS_MASK) == 0,1,0,1
size <= SMALL_MAXCLASS,1,0,1
slot >= 0,1,0,1
"isalloc(ptr, true) == PAGE",1,0,1
this != &rhs,1,0,1
flags_ & kUint64Flag,1,0,1
"arena_mapbits_dirty_get(chunk, pageind) == arena_mapbits_dirty_get(chunk, pageind+npages-1)",1,0,1
!IsRessurectRequested(),1,0,1
index < count_,1,0,1
"i->second == obj, ""Object with certain key already in but objects are different!""",1,0,1
"uint64, sizeof(SOPHIST_uint64) == 8",1,0,1
tcache != TCACHE_STATE_PURGATORY,1,0,1
::bgs::protocol::AttributeFilter_Operation_IsValid(value),1,0,1
good_hdr_size <= good_redzone0_offset,1,0,1
alt_form == false,1,0,1
chunk->nruns_adjac == 0,1,0,1
"uint32, sizeof(SOPHIST_uint32) == 4",1,0,1
narenas_auto == narenas_total_get(),1,0,1
opt_zero == false,1,0,1
packet.GetOpcode() == CMSG_LEARN_TALENTS,1,0,1
ctx->cnt_summed.accumobjs == 0,1,0,1
"binind == arena_mapbits_binind_get(chunk, pageind+(ret>>LG_PAGE)-1)",1,0,1
ckh_count(&prof_tdata->bt2cnt) < PROF_TCMAX,1,0,1
nignore <= 3,1,0,1
::google::protobuf::FieldOptions_CType_IsValid(value),1,0,1
"pointer64, sizeof(void*) == 8",1,0,1
"STEPS_PER_SEGMENT > 0, ""STEPS_PER_SEGMENT shouldn't be lesser than 1""",1,0,1
codepoint >= 0x010000 && codepoint <= 0x10FFFF,1,0,1
"arena_mapbits_dirty_get(chunk, run_ind) == flag_dirty",1,0,1
!Sign(),1,0,1
data_.a.elements != 0,1,0,1
threadCount > 0,1,0,1
binind == actual_binind,1,0,1
"ret == false || arena_mapbits_dirty_get(chunk, pageind-1) != arena_mapbits_dirty_get(chunk, pageind)",1,0,1
size > sizeof(ChunkHeader),1,0,1
first >= MemberBegin(),1,0,1
size + extra > oldsize,1,0,1
"arena_mapbits_unallocated_size_get(chunk, run_ind) == arena_mapbits_unallocated_size_get(chunk, run_ind+run_pages-1)",1,0,1
"(internal::IsSame<bool,T>::Value)",1,0,1
pageind+npages < chunk_npages,1,0,1
"arena_mapbits_unallocated_size_get(chunk, run_ind) == prun_size",1,0,1
GetOpcode() == expectedOpcode,1,0,1
_threads,1,0,1
prof_tdata->enq == false,1,0,1
length > 0,1,0,1
newBuffer != 0,1,0,1
::google::protobuf::FieldDescriptorProto_Label_IsValid(value),1,0,1
bin_info->reg0_offset - bin_info->redzone_size + (bin_info->nregs * bin_info->reg_interval) + pad_size == bin_info->run_size,1,0,1
arena->spare != NULL,1,0,1
rhs.IsString(),1,0,1
"arena_mapbits_dirty_get(chunk, run_ind) == arena_mapbits_dirty_get(chunk, run_ind+npages-1)",1,0,1
GetSize() >= sizeof(T),1,0,1
"arena_mapbits_dirty_get(chunk, pageind) == arena_mapbits_dirty_get(chunk, pageind+(ret>>LG_PAGE)-1)",1,0,1
result == NULL,1,0,1
"rtree_get_locked(rtree, key) == ret",1,0,1
min_alignment != 0,1,0,1
uwidth != UINTMAX_MAX || get_errno() != ERANGE,1,0,1
"(PLAYER_FIELD_BYTES_2_OFFSET_OVERRIDE_SPELLS_ID & 1) == 0, ""PLAYER_FIELD_BYTES_2_OFFSET_OVERRIDE_SPELLS_ID must be aligned to 2 byte boundary""",1,0,1
map_bias > 0,1,0,1
buffer != 0,1,0,1
!Base::hasRoot_,1,0,1
cast_ai,1,0,1
"arena_mapbits_large_get(chunk, pageind) != 0",1,0,1
::bgs::protocol::presence::v1::FieldOperation_OperationType_IsValid(value),1,0,1
binind < NBINS || binind == BININD_INVALID,1,0,1
sizeof(u.v) == sizeof(u.i),1,0,1
npurgeable != 0,1,0,1
alignment > 0 && (alignment & chunksize_mask) == 0,1,0,1
ctx->cnt_summed.accumbytes == 0,1,0,1
!level_stack_.template Top<Level>()->inArray,1,0,1
size > 0 && (size & chunksize_mask) == 0,1,0,1
!IsInGrid(),1,0,1
"arena_mapbits_dirty_get(chunk, run_ind+run_pages+nrun_pages-1) == flag_dirty",1,0,1
x < MAX_NUMBER_OF_GRIDS && y < MAX_NUMBER_OF_GRIDS,1,0,1
is.Peek() == 'n',1,0,1
codepoint <= 0x7F,1,0,1
*p >= '0' && *p <= '9',1,0,1
"arena_ptr_small_binind_get(ptr, arena_mapbits_get(chunk, pageind)) != BININD_INVALID",1,0,1
::google::protobuf::FileOptions_OptimizeMode_IsValid(value),1,0,1
i >= 0,1,0,1
quarantine->curbytes == 0,1,0,1
LookupEntry(id),1,0,1
"pointer64, sizeof(void*) <= 4",1,0,1
