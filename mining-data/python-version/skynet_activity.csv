x_val,y_added,y_removed,y_combined
0,41,14,55
"KERN_SUCCESS == task_info(mach_task_self(), TASK_THREAD_TIMES_INFO, (task_info_t )&aTaskInfo, &aTaskInfoCount)",11,11,22
e,6,4,10
ctx,5,5,10
"stack > getstackbase(L, ptop) && (stack - 1)->s != NULL",6,3,9
r==0,4,4,8
ms.matchdepth == MAXCCALLS,3,3,6
context->handle!=0,3,3,6
"stack > getstackbase(L, ptop)",4,2,6
GET_OPCODE(fs->f->code[list]) == OP_JMP && (GETARG_A(fs->f->code[list]) == 0 || GETARG_A(fs->f->code[list]) >= level),3,3,6
err == sz +2,3,3,6
harbor_id != 0,3,3,6
lua->L == L,3,3,6
s->tail != NULL,3,2,5
s->type != SOCKET_TYPE_RESERVE,3,2,5
numsiblings[tree->tag] == 0,4,1,5
GET_OPCODE(fs->f->sp->code[list]) == OP_JMP && (GETARG_A(fs->f->sp->code[list]) == 0 || GETARG_A(fs->f->sp->code[list]) >= level),3,2,5
s->tail->next == NULL,3,2,5
issweepphase(g),3,2,5
node->queue == NULL,2,2,4
from->offset == 0,2,2,4
traceback_index == 1,2,2,4
from->next >= 0,2,2,4
reply[0] == ':',2,2,4
ci->top <= L->stack_last,4,0,4
type == PTYPE_RESPONSE,2,2,4
context->cb == NULL,2,2,4
msg,2,2,4
context->forward == 0 && context->forward_address == NULL,2,2,4
uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv,2,2,4
context,2,2,4
b->w[id].init == 0,2,2,4
blk->offset == 0,2,2,4
id < server->max_connection,2,2,4
g->gcstate == GCSpropagate,2,2,4
remote_id > 0 && remote_id <= REMOTE_MAX,2,2,4
err == sz,2,2,4
des > 0,2,2,4
harbor_id > 0,2,2,4
message->destination != 0,2,2,4
session == 0,2,2,4
type != 0,2,2,4
c->read_complete == 0,2,2,4
sz == sizeof(rmsg->destination),2,2,4
cl->nupvalues == cl->p->sizeupvalues,2,2,4
id > 0 && id <= DEFAULT_NUMBER,2,2,4
ctx->in_global_queue,2,2,4
sz < tmp->size,2,2,4
type == PTYPE_TEXT,2,2,4
err == 0,2,2,4
id == i,2,2,4
conn->uid == uid,2,2,4
session > 0 && session <= DEFAULT_NUMBER,2,2,4
sz <= 65535,2,2,4
rule->tag == TTrue,4,0,4
q->in_global == MQ_DISPATCHING,2,2,4
queue->in_global,2,2,4
destination!=0,2,2,4
sz >= 4,2,2,4
c,3,1,4
p->current == NULL,2,2,4
des != 0,2,2,4
len < 0x10000,2,2,4
diffsec>=0,2,2,4
s->tail == NULL,2,1,3
"stack == getstackbase(L, ptop)",2,1,3
new_slot[hash] == NULL,2,1,3
type == 0 && session == 0,2,1,3
"stack > getstackbase(L, ptop) && (stack - 1)->s == NULL",2,1,3
status == L->status,2,1,3
m == NULL && M->count < MAX_MODULE_TYPE,2,1,3
queue->next == NULL,2,1,3
dest != NO_JUMP,2,1,3
sz <= size-SIZEOF_LENGTH,2,1,3
argv[i][0] == '-',2,1,3
t<SPROTO_TSTRUCT,2,1,3
base <= L->top && L->top < L->stack + L->stacksize,2,1,3
e1->f == NO_JUMP,2,1,3
(s->slot_size*2 - 1) <= HANDLE_MASK,2,1,3
captop > 0,2,1,3
ctx->init,2,1,3
e1->t == NO_JUMP,2,1,3
H==NULL,2,1,3
base == ci->u.l.base,2,1,3
c->next == NULL,2,1,3
s->head == NULL,2,1,3
"stack == getstackbase(L, ptop) + 1",2,1,3
!q->flag[tail],1,1,2
(*sz & 0xffffff) == *sz,1,1,2
q->lock_session == 0,1,1,2
1 <= precision && precision <= 14,1,1,2
cl->nupvalues == cl->p->sp->sizeupvalues,2,0,2
tm != NULL || !ttistable(t),1,1,2
postable != 0,1,1,2
!isfinalized(curr),1,1,2
backtop == 0,1,1,2
"os.getenv(name), name",1,1,2
align_length <= old_length,1,1,2
q->in_global,1,1,2
g->gray == NULL,1,1,2
ret,1,1,2
gch(o)->tt != LUA_TTABLE,1,1,2
q->in_global == MQ_LOCKED,1,1,2
"os.getenv(name), \'os.getenv failed\' .. name",1,1,2
isfinalized(o),1,1,2
param[i],1,1,2
p->i.code == IChoice,1,1,2
g->sweepgc == NULL && g->sweepfin == NULL,1,1,2
type != PTYPE_SYSTEM && type != PTYPE_HARBOR,1,1,2
luai_numisnan(n) || l_mathop(fabs)(n) == HUGE_VAL,1,1,2
inst,1,1,2
ref > 0,2,0,2
p1->i.code == IAny,1,1,2
base[0].kind == Cruntime && base[0].siz == 0,1,1,2
GP(tail+1) != GP(q->head),1,1,2
c->size >= sz,1,1,2
align_length < old_length,1,1,2
!iswhite(obj2gco(g->mainthread)),1,1,2
number == 0,1,1,2
c->tail == NULL,1,1,2
s->status != STATUS_INVALID,1,1,2
"op[start - 1].i.code == IChoice && dest(op, start - 1) == target(op, i + 1)",1,1,2
isfixcheck(p + start) && iscapture(p + i),1,1,2
!isold(o) || isold(obj2gco(L)),1,1,2
len > 0,1,1,2
err == sz + header,1,1,2
c->in_epoll,1,1,2
aux <= MAXAUX,1,1,2
backtop > 0 && p->i.offset > 0,1,1,2
(p + 1)->i.code != IRet,1,1,2
code_sz == *sz,1,1,2
ls->fs->f->maxstacksize >= ls->fs->freereg && ls->fs->freereg >= ls->fs->nactvar,1,1,2
ci->u.c.k != NULL,1,1,2
!isdummy(n),1,1,2
s->status == SOCKET_POLLIN,1,1,2
!ISK(GETARG_B(inst)),1,1,2
s->head == NULL && s->tail == NULL,1,1,2
(hashcap & (hashcap-1))==0,1,1,2
cl->l.nupvalues == cl->l.p->sizeupvalues,1,1,2
!isgenerational(g),1,1,2
HARBOR != 0,1,1,2
!isblack(o) && uv->v != &uv->u.value,1,1,2
e->k == VVOID || e->k == VJMP,1,1,2
L->nny == 0,1,1,2
m->connected[id] == false,1,1,2
session,1,1,2
*narray/2 <= na && na <= *narray,1,1,2
ci->u.c.status != LUA_OK,1,1,2
t->session == 0 && session !=0,1,1,2
id > 0,1,1,2
tostore != 0,1,1,2
ttisnil(slot),2,0,2
iscollectable(t1),1,1,2
"testbit(gch(curr)->marked, SEPARATED)",1,1,2
rc >= 0,1,1,2
"!iscollectable(obj) || (righttt(obj) && !isdead(g,gcvalue(obj)))",1,1,2
(*sz & HANDLE_MASK) == *sz,1,1,2
filename != NULL,1,1,2
L->top == oci->u.l.base + getproto(ofunc)->maxstacksize,1,1,2
"ttisequal(t1, t2)",1,1,2
length == skip,1,1,2
index >=0 && index < self->max_connection,1,1,2
prealloc > sizeof(struct skynet_lalloc),1,1,2
des >= 0,1,1,2
!hasjumps(t),1,1,2
lua_gettop(L) == 1,2,0,2
(Opcode)(p - 1)->i.code == IChoice,1,1,2
hi->cap <= hashcap,1,1,2
h->connected[id] == false,1,1,2
var->k == VLOCAL || var->k == VUPVAL,1,1,2
GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG,2,0,2
list_uncomplete(&s->low),1,1,2
p1->i.offset != 0,1,1,2
!ttisstring(p1) && !ttisnumber(p1),1,1,2
isLua(ci),2,0,2
ls->fs != NULL || ls->t.token == TK_EOS,1,1,2
g->gcstate != GCSpause,1,1,2
origkind != KGC_EMERGENCY,1,1,2
isfixcheck(p) && (p + lc)->i.code == IChoice,1,1,2
msg[0] == 'C',1,1,2
ttistable(t) && ttisnil(oldval),1,1,2
message->type == SKYNET_SOCKET_TYPE_CONNECT,1,1,2
i < SEPLEN,1,1,2
p->current == NULL && session > 0,1,1,2
handle != 0,1,1,2
msg.sz == 0,1,1,2
"GETARG_A(getcode(fs,&e)) == fs->nactvar",1,1,2
blk->length >= sizeof(struct ringbuffer_block),1,1,2
chunk != NULL,1,1,2
_block_id(blk) == id,1,1,2
ttisnumber(t1) && ttisnumber(t2),1,1,2
GP(tail+1) != GP(head),1,1,2
session == SESSION_CLIENT,1,1,2
isblack(obj2gco(p)),1,1,2
backtop > 0,1,1,2
address != 0,1,1,2
head < q->tail,1,1,2
msg->sz == 0,1,1,2
sz == 9,1,1,2
session !=0,1,1,2
"token == cast(unsigned char, token)",1,1,2
id,1,1,2
message->session >= 0,1,1,2
c->tail == m,1,1,2
"__sync_lock_test_and_set(&ctx->calling,1) == 0",1,1,2
context->forward == 0 && context->forward_address[0] == '\0',1,1,2
session >= 0,1,1,2
p->v != &p->u.value,1,1,2
ttisnil(oldval),1,1,2
"e1->u.info == GETARG_B(getcode(fs, e2))-1",1,1,2
source[0] == ':',1,1,2
ttisnumber(io_),1,1,2
conn->uid == 0,1,1,2
captype(open) == Cruntime,1,1,2
sz == sizeof(*rmsg),1,1,2
sep == ':',1,1,2
op >= OP_ADD,1,1,2
q->in_global == MQ_IN_GLOBAL,1,1,2
!isold(o),1,1,2
"luaS_eqstr(gt->name, label->name)",1,1,2
type == PTYPE_SOCKET,1,1,2
key->tsv.tt == LUA_TSHRSTR,1,1,2
server->poll >= 0,1,1,2
m->n == m->cap,1,1,2
source == 0,1,1,2
op[i - 1].i.code == IRet,1,1,2
!ttisnil(gkey(n)),2,0,2
context->forward == 0,1,1,2
p->current == t,1,1,2
id>=0,1,1,2
!list_uncomplete(&s->high),1,1,2
!isblack(o),1,1,2
(Opcode)(p - 1)->i.code == IFail,1,1,2
lalloc == skynet_lua_alloc,1,1,2
"isblack(o) && !isdead(g, o) && gch(o)->tt == LUA_TTABLE",1,1,2
actual >= nfixargs,1,1,2
harbor_id > 0 && harbor_id< REMOTE_MAX,1,1,2
s->type != SOCKET_TYPE_PLISTEN && s->type != SOCKET_TYPE_LISTEN,1,1,2
(msg.sz & HANDLE_MASK) == 0,1,1,2
n <= MAXOFF && start <= i && i < end,1,1,2
t->session == 0,1,1,2
t->session == 0 && session > 0,1,1,2
sz == sizeof(*message),1,1,2
ischeck(p) && n != 0,1,1,2
align_length + head < rb->size,1,1,2
real_rd == size,1,1,2
a->tsv.tt == LUA_TLNGSTR && b->tsv.tt == LUA_TLNGSTR,1,1,2
g->allgc == o,1,1,2
!ttisdeadkey(gkey(n)) || ttisnil(gval(n)),1,0,1
"load(code,\'=(load)\',\'t\',result)",1,0,1
a <= MAXARG_Ax,1,0,1
tb > 0,1,0,1
ttisnil(gval(mp)),1,0,1
newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE,1,0,1
x <= 0x10FFFF,1,0,1
tostore != 0 && tostore <= LFIELDS_PER_FLUSH,1,0,1
isgray(o),1,0,1
db->size >= sz,1,0,1
tree->tag == TChoice || tree->tag == TSeq,1,0,1
L != NULL,1,0,1
"os.getenv(name), \'os.getenv() failed: \' .. name",1,0,1
current,1,0,1
ts->tt == LUA_TLNGSTR,1,0,1
set[2] == '\0',1,0,1
sz < 0x10000,1,0,1
err == LUA_OK,1,0,1
g->listen_id == message->id,1,0,1
io.open(config_name),1,0,1
!iswhite(g->mainthread),1,0,1
source,1,0,1
n == len+2,1,0,1
"!iscollectable(obj) || (righttt(obj) && (L == NULL || !isdead(G(L),gcvalue(obj))))",1,0,1
sib2(call)->tag == TRule,1,0,1
"isblack(t) && !isdead(g, t)",1,0,1
HARBOR != ~0,1,0,1
stackidx(ptop) + ndyncap == lua_gettop(L) && ndyncap <= captop,1,0,1
message,1,0,1
!L->allowhook,1,0,1
q->next == NULL,1,0,1
a->tt == LUA_TLNGSTR && b->tt == LUA_TLNGSTR,1,0,1
!funcstate.prev && funcstate.nups == 1 && !lexstate.fs,1,0,1
iswhite(funcstate.f),1,0,1
i == to,1,0,1
n > 0,1,0,1
*session == 0,1,0,1
event <= TM_EQ,1,0,1
ls->lookahead.token == TK_EOS,1,0,1
ls->fs->f->sp->maxstacksize >= ls->fs->freereg && ls->fs->freereg >= ls->fs->nactvar,1,0,1
"op == ITestSet || sizei(&getinstr(compst, i)) == 2",1,0,1
ms->matchdepth == MAXCCALLS,1,0,1
estimate > 0,1,0,1
g->gray,1,0,1
reg == fs->freereg,1,0,1
wb.head == &temp,1,0,1
e->u.ind.vt == VUPVAL,1,0,1
getOpMode(o) == iABx || getOpMode(o) == iAsBx,1,0,1
obj->copy,1,0,1
n,1,0,1
nb < MAX_ITEM,1,0,1
p == sizeof(buff),1,0,1
"lua_getinfo(L, ""lS"", ar)",1,0,1
L->stack_last - L->stack == L->stacksize - EXTRA_STACK,1,0,1
ttisfloat(io),1,0,1
obj->copy == NULL,1,0,1
ttisfunction(ci->func),1,0,1
L1->openupval == NULL,1,0,1
g->GCestimate == gettotalbytes(g),1,0,1
getCMode(o) != OpArgN || c == 0,1,0,1
nret == fs->freereg - first,1,0,1
currIsNewline(ls),1,0,1
f:read \'*a\',1,0,1
L->nci == 0,1,0,1
ttisinteger(io),1,0,1
g->strt.nuse == 0,1,0,1
fs->bl == NULL,1,0,1
(realosize == 0) == (block == NULL),1,0,1
0 <= tree->u.n && tree->u.n <= UCHAR_MAX,1,0,1
fd != 0,1,0,1
getOpMode(o) == iABC,1,0,1
a <= MAXARG_A && bc <= MAXARG_Bx,1,0,1
"e1->u.info == GETARG_B(getinstruction(fs, e2))-1",1,0,1
var->k != VVOID,1,0,1
g->gckind == KGC_NORMAL,1,0,1
GET_OPCODE(i) == OP_TFORLOOP,1,0,1
luai_numisnan(n) || l_mathop(fabs)(n) == cast_num(HUGE_VAL),1,0,1
ttisnumber(obj),1,0,1
idx < fs->nlocvars,1,0,1
g->gcstate == GCSinsideatomic || th->openupval == NULL || isintwups(th),1,0,1
GET_OPCODE(*((ci)->u.l.savedpc - 1)) == OP_CALL,1,0,1
ttisfloat(&obj),1,0,1
upisopen(uv),1,0,1
"GETARG_C(getinstruction(fs, e)) == 2",1,0,1
!isdummy(f),1,0,1
tofinalize(curr),1,0,1
lo + r4 <= p && p <= up - r4,1,0,1
q->release == 0,1,0,1
s == '[' || s == ']',1,0,1
sb->tail == NULL,1,0,1
!hasjumps(t) && (vkisinreg(t->k) || t->k == VUPVAL),1,0,1
ci->callstatus & CIST_HOOKED,1,0,1
nresults == LUA_MULTRET,1,0,1
s->type == SOCKET_TYPE_RESERVE,1,0,1
rule == from || code[rule - 1].i.code == IRet,1,0,1
uv->refcount > 0,1,0,1
high->head == NULL,1,0,1
!ttistable(t),1,0,1
uc->read == -1,1,0,1
p->f,1,0,1
nsize > realosize,1,0,1
g->tobefnz == NULL,1,0,1
extra != NULL,1,0,1
ci->u.c.k != NULL && L->nny == 0,1,0,1
tb->hash[newsize] == NULL && tb->hash[tb->size - 1] == NULL,1,0,1
isintwups(L) || L->openupval == NULL,1,0,1
e->k == VJMP,1,0,1
GET_OPCODE(*ci->u.l.savedpc) == OP_TFORLOOP,1,0,1
"GETARG_A(getinstruction(fs,&e)) == fs->nactvar",1,0,1
GET_OPCODE(*ci->u.l.savedpc) == OP_JMP,1,0,1
bl->nactvar == fs->nactvar,1,0,1
g->sweepgc == NULL,1,0,1
ss,1,0,1
L->top == oci->u.l.base + getproto(ofunc)->sp->maxstacksize,1,0,1
!g->tobefnz || g->gcfinnum > 0,1,0,1
n == sz,1,0,1
db->tail == NULL,1,0,1
"lua_isnil(L, -1)",1,0,1
numsiblings[t->tag] == 0,1,0,1
token == cast_uchar(token),1,0,1
code[i - 1].i.code == IEnd,1,0,1
a <= MAXARG_A && b <= MAXARG_B && c <= MAXARG_C,1,0,1
(optimal == 0 || optimal / 2 < na) && na <= optimal,1,0,1
tofinalize(o),1,0,1
mq == q->tail,1,0,1
(nsize == 0) == (newblock == NULL),1,0,1
!list_uncomplete(&s->low),1,0,1
fs->freereg == fs->nactvar,1,0,1
ss->recvctrl_fd < FD_SETSIZE,1,0,1
total >= 2,1,0,1
f->k == VNONRELOC,1,0,1
str != NULL,1,0,1
captype(open) == Cgroup,1,0,1
sib2(t)->tag == TRule,1,0,1
!ttisdeadkey(key),1,0,1
cc.v.k == VVOID || cc.tostore > 0,1,0,1
upisopen(p),1,0,1
base[0].kind == Cgroup && base[0].siz == 0,1,0,1
L->nCcalls == ((from) ? from->nCcalls : 0),1,0,1
e.k == VNONRELOC,1,0,1
(ci->callstatus & CIST_YPCALL) || status == LUA_YIELD,1,0,1
ci == L->ci,1,0,1
!upisopen(uv),1,0,1
!iscollectable(obj) || righttt(obj),1,0,1
type != PTYPE_SYSTEM && type != PTYPE_HARBOR && REMOTE,1,0,1
nCcalls == L->nCcalls,1,0,1
op == OP_LE,1,0,1
count == CHARSETSIZE * BITSPERCHAR,1,0,1
s->name_cap <= MAX_SLOT_SIZE,1,0,1
g->finobj == NULL,1,0,1
size == -1,1,0,1
L->ci->next == NULL,1,0,1
target < fs->pc,1,0,1
lisdigit(ls->current),1,0,1
q == ctx->queue,1,0,1
b->next == NULL,1,0,1
gettotalbytes(g) == sizeof(LG),1,0,1
getCMode(o) == OpArgN,1,0,1
protocol == IPPROTO_UDP,1,0,1
getBMode(o) != OpArgN || b == 0,1,0,1
"eqstr(gt->name, label->name)",1,0,1
db->tail == m,1,0,1
key->tt == LUA_TSHRSTR,1,0,1
top == 2,1,0,1
message->type == SKYNET_SOCKET_TYPE_DATA,1,0,1
gnext(f) == 0,1,0,1
n < sz,1,0,1
!isblack(thread),1,0,1
testTMode(GET_OPCODE(*pc)) && GET_OPCODE(*pc) != OP_TESTSET && GET_OPCODE(*pc) != OP_TEST,1,0,1
GETARG_C(i) - 1 == LUA_MULTRET,1,0,1
g->ephemeron == NULL && g->weak == NULL,1,0,1
ttisnil(gval(n)),1,0,1
dyd->actvar.n == 0 && dyd->gt.n == 0 && dyd->label.n == 0,1,0,1
"isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o)",1,0,1
