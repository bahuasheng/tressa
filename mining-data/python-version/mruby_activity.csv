x_val,y_added,y_removed,y_combined
mrb->gc_state == GC_STATE_NONE,11,11,22
mrb->gray_list == NULL,8,8,16
mrb->gc_state == GC_STATE_SWEEP,6,6,12
gc->gc_state == GC_STATE_ROOT,5,5,10
diff >= 0,5,5,10
gc->state == GC_STATE_ROOT,5,5,10
mrb->gc_state == GC_STATE_ROOT,5,5,10
(size_t)diff <= SIZE_MAX,5,5,10
obj->color & mrb->current_white_part,5,5,10
is_gray(obj),6,3,9
len >= 0,4,4,8
len <= SIZE_MAX,4,4,8
(size_t)len <= SIZE_MAX,4,4,8
mrb->gc_full == FALSE,4,4,8
"ptrdiff_t, diff, size_t, SIZE_MAX",8,0,8
diff <= SIZE_MAX,4,4,8
is_generational(mrb) || mrb->gc_state != GC_STATE_NONE,4,4,8
"mrb_int, len, size_t, SIZE_MAX",6,1,7
"mrb_int, tlen, uint16_t, UINT16_MAX",4,3,7
0,6,1,7
diff >=0 && (size_t)diff <= SIZE_MAX,3,3,6
len >= 0 && (size_t)len <= SIZE_MAX,3,3,6
is_gray(value),4,2,6
mrb->gc_state == GC_STATE_MARK,3,3,6
tlen >= 0,3,3,6
"!is_dead(mrb, obj)",3,3,6
tlen <= INT16_MAX,3,3,6
gc->state == MRB_GC_STATE_ROOT,5,0,5
"!is_dead(mrb, value) && !is_dead(mrb, obj)",2,3,5
value->color & mrb->current_white_part,2,2,4
width >= 0,2,2,4
mrb->free_heaps->next->next == NULL,2,2,4
gc->gray_list == NULL,4,0,4
mrb->live >= mrb->gc_live_after_mark,2,2,4
mrb->gray_list == obj1,2,2,4
mrb_fixnum(res) == 300,2,2,4
mrb->heaps->next == NULL,2,2,4
finished_file,2,2,4
mrb->live == live,2,2,4
sizeof(void*) == 4,2,2,4
mrb->heaps->next->next == NULL,2,2,4
is_generational(mrb),2,2,4
is_generational(mrb) || mrb->gc_state != GC_STATE_ROOT,2,2,4
gc->state == GC_STATE_SWEEP,2,2,4
mrb->gc_state != GC_STATE_NONE,2,2,4
mrb->majorgc_old_threshold > 0,2,2,4
gc->gc_state == GC_STATE_SWEEP,2,2,4
diff <= UINT32_MAX,2,2,4
ret->start_pos <= pc && pc < (((ret + 1 - f->line_flat_map) < f->line_entry_count) ? (ret+1)->start_pos : irep->debug_info->pc_count),2,2,4
mrb->gc_full == TRUE,2,2,4
mrb->gray_list->gcnext == obj1,2,2,4
is_major_gc(mrb),2,2,4
mrb->live == total-freed,2,2,4
mrb->gray_list == obj2,2,2,4
is_minor_gc(mrb),2,2,4
mrb_fixnum(res) == 200,2,2,4
mrb->atomic_gray_list == obj,2,2,4
mrb->heaps == mrb->free_heaps,2,2,4
i + 1 == p->nlocals,2,1,3
(*ret)->start_pos <= pc && pc < (((ret + 1 - info->files) < info->flen) ? (*(ret+1))->start_pos : info->pc_count),2,1,3
is_black(mrb_basic_ptr(obj_v)),2,1,3
is_gray(mrb_basic_ptr(value_v)),2,1,3
!irep->debug_info,2,1,3
is_gray(obj2),2,1,3
s->irep,2,1,3
sym_idx != -1,2,1,3
is_gray(obj1),2,1,3
gray_num == 1,2,1,3
gc->state == MRB_GC_STATE_SWEEP,3,0,3
(ret - f->line_flat_map) < f->line_entry_count,1,2,3
is_black(obj),2,1,3
gray_num > 1,2,1,3
is_gray(mrb_basic_ptr(value)),2,1,3
base >= 2 && base <= 36,2,1,3
(obj)->tt != MRB_TT_FREE,2,1,3
!n->cdr,2,1,3
mrb->variable_gray_list == obj,1,1,2
ret->start_pos <= pc && pc < (((ret + 1 - f->lines.flat_map) < f->line_entry_count) ? (ret+1)->start_pos : irep->debug_info->pc_count),1,1,2
!ARY_EMBED_P(ary),1,1,2
len <= MRB_INT_MAX,1,1,2
width > 0,2,0,2
is_generational(gc) || mrb->gc.gc_state != GC_STATE_ROOT,1,1,2
filename_idx <= UINT16_MAX,1,1,2
ret >= 0,1,1,2
ARY_EMBED_P(tmp),1,1,2
is_generational(gc) || mrb->gc.state != GC_STATE_ROOT,1,1,2
gc->state == GC_STATE_MARK,1,1,2
mrb_fixnum_p(seed),2,0,2
gc->full == FALSE,2,0,2
(uint32_t)diff <= UINT32_MAX,1,1,2
mrb->c->prev->prev,1,1,2
!ARY_SHARED_P(tmp),1,1,2
is_generational(gc) || gc->state != GC_STATE_ROOT,1,1,2
ret <= info->files && ret < (info->files + info->flen),1,1,2
(size_t)ret <= SIZE_MAX,1,1,2
is_black(RBASIC(obj_v)),1,1,2
filename_idx >= 0,1,1,2
obj->color & gc->current_white_part,2,0,2
!ARY_EMBED_P(tmp),1,1,2
ret < (info->files + info->flen),1,1,2
i == (p->nlocals - 1),1,1,2
filename_len <= UINT16_MAX,1,1,2
ret <= SIZE_MAX,1,1,2
"sizeof(void*) == 4, ""when using NaN boxing sizeof pointer must be 4 byte""",1,1,2
len > 0,1,1,2
"size == (int)get_debug_record_size(mrb, irep)",1,1,2
is_generational(gc) || gc->gc_state != GC_STATE_ROOT,1,1,2
gc->gc_state == GC_STATE_MARK,1,1,2
is_generational(gc) || gc->state != MRB_GC_STATE_ROOT,2,0,2
irep->ilen <= INT_MAX,1,1,2
is_gray(RBASIC(value)),1,1,2
total <= MRB_INT_MAX,1,1,2
irep->ilen <= UINT32_MAX,1,1,2
mrb_symbol_p(iv_name) || mrb_string_p(iv_name),1,1,2
n >= 0,1,1,2
mrb->gc.state == GC_STATE_SWEEP,1,1,2
ret <= UINT32_MAX,1,1,2
(n) <= MRB_INT_MAX,1,1,2
size_t_len <= MRB_INT_MAX,1,1,2
args != 0,1,1,2
"int, tlen, uint16_t, UINT16_MAX",1,1,2
"(cur - bin) == (int)get_debug_record_size(mrb, irep)",1,1,2
filename_idx != -1,1,1,2
mrb->gc.gc_state == GC_STATE_SWEEP,1,1,2
len <= UINT16_MAX,1,1,2
!(!p && len),1,1,2
is_black(mrb_basic(obj_v)),1,1,2
ret >= 0 && (size_t)ret <= SIZE_MAX,1,1,2
f->line_flat_map <= ret && ret < (f->line_flat_map + f->line_entry_count),1,1,2
is_gray(mrb_basic(value)),1,1,2
len > 0 && (size_t)len <= SIZE_MAX,1,1,2
mrb_symbol_p(RARRAY_PTR(ary)[i]),1,1,2
is_gray(RBASIC(value_v)),1,1,2
"!is_dead(gc, value) && !is_dead(gc, obj)",1,1,2
is_gray(mrb_basic(value_v)),1,1,2
ret >= 0 && (uint32_t)ret <= UINT32_MAX,1,1,2
cmd,2,0,2
mrb->c->prev,1,1,2
diff >= 0 && (size_t)diff <= UINT32_MAX,1,1,2
gc->live >= gc->gc_live_after_mark,1,1,2
mrb_symbol_p(iv_name),1,1,2
section_size <= UINT32_MAX,1,1,2
pc < (f->start_pos + f->line_entry_count),1,1,2
section_size <= INT32_MAX,1,0,1
irep->filename,1,0,1
gc->gray_list == obj2,1,0,1
is_minor_gc(gc),1,0,1
"size_t, filename_len, uint16_t, UINT16_MAX",1,0,1
mrdb && mrdb->dbg,1,0,1
d->files[i],1,0,1
ret->start_pos <= pc && pc < (((uint32_t)(ret + 1 - f->lines.flat_map) < f->line_entry_count) ? (ret+1)->start_pos : irep->debug_info->pc_count),1,0,1
gc->state == MRB_GC_STATE_MARK,1,0,1
"size == get_debug_record_size(mrb, irep)",1,0,1
gc->gray_list->gcnext == obj1,1,0,1
"gc->state == MRB_GC_STATE_MARK || (!is_dead(gc, value) && !is_dead(gc, obj))",1,0,1
filename_idx < filenames_len,1,0,1
i < (irep->nlocals-1),1,0,1
mrb_type(v) == MRB_TT_DATA,1,0,1
"ptrdiff_t, ret, size_t, SIZE_MAX",1,0,1
f->tt == MRB_TT_FIBER,1,0,1
"!is_dead(gc, obj)",1,0,1
"mrb->gc_state == GC_STATE_MARK || (!is_dead(mrb, value) && !is_dead(mrb, obj))",1,0,1
"RSTRING_EMBED_LEN_MAX < (1 << 5), ""pointer size too big for embedded string""",1,0,1
"size_t, section_size, uint32_t, UINT32_MAX",1,0,1
mrb_array_p(ary),1,0,1
info->files <= ret && ret < (info->files + info->flen),1,0,1
lp,1,0,1
!MRB_PROC_CFUNC_P(ci[-1].proc),1,0,1
gc->heaps->next->next == NULL,1,0,1
gc->majorgc_old_threshold > 0,1,0,1
"mrb_int, len, uint16_t, UINT16_MAX",1,0,1
value->color & gc->current_white_part,1,0,1
gc->live == total-freed,1,0,1
is_major_gc(gc),1,0,1
"x != h->n_buckets && !__ac_iseither(h->ed_flags, x)",1,0,1
(ret - f->line_flat_map) < (ptrdiff_t)f->line_entry_count,1,0,1
gc->gray_list == obj1,1,0,1
is_generational(gc),1,0,1
irep->lines,1,0,1
"size_t, irep->ilen, uint32_t, UINT32_MAX",1,0,1
"int, filename_idx, uint16_t, UINT16_MAX",1,0,1
gc->heaps == gc->free_heaps,1,0,1
"ptrdiff_t, diff, uint32_t, UINT32_MAX",1,0,1
"size_t, total, mrb_int, MRB_INT_MAX",1,0,1
sym,1,0,1
"ptrdiff_t, ret, uint32_t, UINT32_MAX",1,0,1
gc->live == live,1,0,1
gc->free_heaps->next->next == NULL,1,0,1
f->start_pos <= pc && pc < (f->start_pos + f->line_entry_count),1,0,1
dbg,1,0,1
f->lines.flat_map <= ret && ret < (f->lines.flat_map + f->line_entry_count),1,0,1
gc->atomic_gray_list == obj,1,0,1
binary_size <= UINT32_MAX,1,0,1
gc->full == TRUE,1,0,1
gc->live >= gc->live_after_mark,1,0,1
gc->heaps->next == NULL,1,0,1
