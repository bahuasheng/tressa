x_val,y_added,y_removed,y_combined
err,21,10,31
initialized,5,5,10
t->initialized,8,1,9
ret == 1,4,4,8
ret == 2,4,4,8
0,6,2,8
entry->flag & REF_DIR,4,3,7
chunk->off1 >= 0,3,3,6
len < sb->alloc,3,3,6
len <= size,3,3,6
chunk->off2 >= 0,3,3,6
h != NULL,3,2,5
len >= 0,5,0,5
branch,2,2,4
p <= pend,2,2,4
!FAIL_STACK_EMPTY (),2,2,4
bufp->regs_allocated == REGS_FIXED,2,2,4
p - 1 > pattern,2,2,4
p + *p < pend,2,2,4
line >= 0 && line < info->num_lines,2,2,4
GET_PTR_TYPE(entry) == 0,3,1,4
reg_no > 0 && reg_no <= MAX_REGNUM,2,2,4
!p,2,2,4
!sl->threadid,4,0,4
mcnt >= 0,2,2,4
p1[1] == **p,2,2,4
p < pend,2,2,4
compile_stack.avail != 0,2,2,4
fixed_preimage.nr == preimage->nr,2,2,4
opts,4,0,4
fail_stack.avail >= NUM_NONREG_ITEMS,2,2,4
*p == ' ',2,2,4
beg_interval,2,2,4
"!strncmp(buf, ""@@ -"", 4)",2,2,4
"!strcmp(type, ""blob"")",2,2,4
fastmap != NULL && p != NULL,2,2,4
"ok_address(m, p)",3,0,3
path,2,1,3
start <= b->bytes,2,1,3
rs->nr == 0 || rs->ranges[rs->nr-1].end <= a,2,1,3
i == n && parent_stack[i] == tree,2,1,3
!state->msg,3,0,3
b->offset + 1 < b->bytes,2,1,3
dir1->sorted == dir1->nr,2,1,3
"sha1, OBJ_COMMIT",2,1,3
!mi->filter_stage,2,1,3
patch->is_new <= 0,2,1,3
tree && parent,2,1,3
pos >= 0,2,1,3
(is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD),3,0,3
opt,3,0,3
!(opts->signoff || opts->no_commit || opts->record_origin || opts->edit),2,1,3
dir2->sorted == dir2->nr,2,1,3
dir->sorted == dir->nr,2,1,3
!state->author_email,3,0,3
"!check_overflow(view->off, view->buf.len)",1,2,3
!state->author_name,3,0,3
commit,2,1,3
opts->revs,2,1,3
!state->author_date,3,0,3
name[len - 1] == '/',2,1,3
orig_path_len != 0,2,1,3
CLR_PTR_TYPE(parent->a[index]) == tree,2,1,3
parents,2,0,2
i2 == chunk->off2,1,1,2
GET_PTR_TYPE(entry) == PTR_TYPE_NULL,1,1,2
par_column,2,0,2
util->pathname,1,1,2
"!check_offset_overflow(view->off, view->buf.len)",2,0,2
GET_PTR_TYPE(p) == PTR_TYPE_NOTE || GET_PTR_TYPE(p) == PTR_TYPE_SUBTREE,1,1,2
rlw_get_run_bit(self->rlw) == v,2,0,2
d,1,1,2
!is_null_sha1(p->remote),2,0,2
type == 'D',1,1,2
!is_mmapped(p),2,0,2
state->rebasing,2,0,2
state->msg,2,0,2
!IS_EPSILON_NODE (type),2,0,2
"!verbose && ""--column and --verbose are incompatible""",1,1,2
*pp == NULL,1,1,2
strlen(buf) == rv,1,1,2
*comp_start == '/',1,1,2
"!strncmp(line, ""@@ -"", 4)",1,1,2
buf,1,1,2
"0 && ""This case must be handled by git-read-tree""",1,1,2
chunksize(p) == small_index2size(i),2,0,2
rlw_get_literal_words(self->rlw) == 0,2,0,2
!is_null_sha1(new_sha1),1,1,2
!is_null_sha1(p->local),2,0,2
array->sorted == array->nr,1,1,2
table->size == 0 && table->nr == 0 && table->array == NULL,1,1,2
pinuse(p),2,0,2
t1 || t2,1,1,2
!tc->freeInCache,2,0,2
!batch,1,1,2
(flags & EXC_FLAG_NEGATIVE) && !(flags & EXC_FLAG_NODIR),1,1,2
idx<=THREADCACHEMAXBINS,2,0,2
r,2,0,2
"!hashcmp(mp->obj, obj)",2,0,2
"cache_name_pos(src, strlen(src)) >= 0",1,1,2
sargv - argv0_path - 1 >= 0,1,1,2
err == REG_ESPACE,2,0,2
msg,1,1,2
MB_LEN_MAX >= pstr->mb_cur_max,2,0,2
(!o_sha && a_sha && !b_sha) || (!o_sha && !a_sha && b_sha),1,1,2
rg->spec->path,1,1,2
P != B,2,0,2
!batch_check,1,1,2
data[sz] == '\0',2,0,2
delta && preimage && postimage,1,1,2
chunksize(p) == small_index2size(idx),2,0,2
chunksize(P) == small_index2size(I),2,0,2
(sz & CHUNK_ALIGN_MASK) == 0,2,0,2
bitmap_git.result,2,0,2
P != F,2,0,2
"!strcmp(type, blob_type)",1,1,2
child->real_type == OBJ_REF_DELTA,1,1,2
path_len < 40 + 19,1,1,2
mctx->state_log != NULL,2,0,2
is_aligned(chunk2mem(p)),2,0,2
chunksize(v) == rsize + nb,2,0,2
poly >= 0x100,1,1,2
util,1,1,2
(long) tc->freeInCache>=0,2,0,2
array2->sorted == array2->nr,1,1,2
cinuse(p),2,0,2
!initialized,1,1,2
array1->sorted == array1->nr,1,1,2
memsize,2,0,2
option_with_implicit_dot && short_option_with_implicit_dot,1,1,2
sl->l != 0,2,0,2
sl->threadid == CURRENT_THREAD,2,0,2
blksize>=*size,2,0,2
ret->spec,1,1,2
!status,1,1,2
!is_null_sha1(old_sha1),1,1,2
empty,2,0,2
"tree, OBJ_TREE",1,0,1
pmatch[0].rm_so == start,1,0,1
u->child[0]->parent == u,1,0,1
sp != 0,1,0,1
fanout < 20,1,0,1
start + range >= 0 && start + range <= length,1,0,1
filename,1,0,1
head != 0,1,0,1
!(ce->ce_flags & CE_STRIP_NAME),1,0,1
lastq == 0 || cinuse(lastq),1,0,1
graph->new_mapping[i - 3] == target,1,0,1
"memchr(path + 3 * n, '/', path_len - (3 * n)) == NULL",1,0,1
list->strdup_strings,1,0,1
"chunk_plus_offset(p, sz+SIZE_T_SIZE)->head == 0",1,0,1
graph->new_mapping[i - 1] > target,1,0,1
pinuse(q),1,0,1
m,1,0,1
nedblksize(ptr[0])>=sizeof(threadcacheblk),1,0,1
delta_len,1,0,1
u->fd->bk == u,1,0,1
mctx.input.offsets_needed == 0,1,0,1
data || obj_entry,1,0,1
state->halt,1,0,1
note_path_len <= 40 + 19,1,0,1
S_OK==GetLastError(),1,0,1
tsize >= minsize_for_tree_index(idx),1,0,1
rs->ranges[i-1].end < rs->ranges[i].start,1,0,1
u->parent != u,1,0,1
"!filter->verbose && ""--column and --verbose are incompatible""",1,0,1
"*(unsigned int *) ""NEDN""==ptr[0]->magic",1,0,1
save_restore_env_balance == 0,1,0,1
*arg == ':',1,0,1
p->fd->bk == p,1,0,1
S >= MIN_CHUNK_SIZE,1,0,1
cb_data == NULL,1,0,1
*delta_len >= 0,1,0,1
argv0_path,1,0,1
instructions && *instructions,1,0,1
o_sha && a_sha,1,0,1
head == 0,1,0,1
sz == SIZE_T_SIZE,1,0,1
d->spec && d->spec->data,1,0,1
small_index(size) == i,1,0,1
bestsize>=*size,1,0,1
result,1,0,1
*msg_id,1,0,1
dfa->nexts[node_idx] != -1,1,0,1
err == REG_NOERROR,1,0,1
pinuse(oldfirst),1,0,1
opts->subcommand == REPLAY_ROLLBACK,1,0,1
remainder_size == element_size,1,0,1
u->child[1] != u,1,0,1
p->one->mode == p->two->mode,1,0,1
rr->items[i].util != RERERE_RESOLVED,1,0,1
child->real_type == OBJ_OFS_DELTA,1,0,1
rlw_get_running_len(self->rlw) == 1,1,0,1
is_mmapped(p) || pinuse(p) || next_chunk(prev_chunk(p)) == p,1,0,1
(char*)oldfirst > (char*)q,1,0,1
remainder_size == request2size(sizes[i]),1,0,1
!is_small(sz),1,0,1
d && line <= d->lines,1,0,1
"segment_holds(sp, (char*)sp)",1,0,1
!next_pinuse(u),1,0,1
lov < hiv,1,0,1
tsize >= MIN_LARGE_SIZE,1,0,1
(colopts & COL_ENABLE_MASK) != COL_AUTO,1,0,1
it->literals < it->lw,1,0,1
o <= rs->nr,1,0,1
!next_pinuse(p),1,0,1
pair->two->sha1_valid,1,0,1
stk->baselen == dir->basebuf.len,1,0,1
qsize >= MIN_CHUNK_SIZE,1,0,1
next->prev_foot == sz,1,0,1
!ob || b->prev==ob,1,0,1
rg,1,0,1
chunksize(u) == tsize,1,0,1
values->nr > 0,1,0,1
ca.drv->clean,1,0,1
!*binsptr || (*binsptr)->size==tck->size,1,0,1
!ptr[0]->prev,1,0,1
tindex == idx,1,0,1
view->width <= view->buf.len,1,0,1
m->dvsize == chunksize(m->dv),1,0,1
"!hashcmp(p->one->sha1, mp->base)",1,0,1
commit == suspect->commit,1,0,1
0x80 % BITSET_WORD_BITS == 0,1,0,1
!(dryrun && repair),1,0,1
replaced == NULL,1,0,1
size>=sizeof(threadcacheblk) && size<=THREADCACHEMAX+CHUNK_OVERHEAD,1,0,1
"*(unsigned int *) ""NEDN""==(*tcb)->magic",1,0,1
path_len < FANOUT_PATH_MAX - 1,1,0,1
rs->ranges[0].start < rs->ranges[0].end,1,0,1
x->node == GREP_NODE_OR,1,0,1
(long)(size_t)CURRENT_THREAD==(*tc)->threadid,1,0,1
!t->initialized,1,0,1
r == -1,1,0,1
graph->num_parents >= 3,1,0,1
p->bk->fd == p,1,0,1
is_absolute_path(argv0_path),1,0,1
hide_dotfiles == HIDE_DOTFILES_DOTGITONLY,1,0,1
mctx->asub_tops > 0,1,0,1
data->info.typep,1,0,1
!ptr[0]->next,1,0,1
graph->new_mapping[i - 2] < 0,1,0,1
attr_stack->origin,1,0,1
is_small(DVS),1,0,1
is_null_sha1(mp->base),1,0,1
cur_nodes->nelem,1,0,1
nmatch > 1,1,0,1
"q == m->dv || bin_find(m, q)",1,0,1
nfences >= 2,1,0,1
mem,1,0,1
!tws->next,1,0,1
regs_allocated == REGS_FIXED,1,0,1
is_aligned(ss),1,0,1
"is_null_sha1(mp->local) || !hashcmp(mp->local, uninitialized)",1,0,1
response,1,0,1
nedblksize(blk)>=sizeof(threadcacheblk) && nedblksize(blk)<=THREADCACHEMAX+CHUNK_OVERHEAD,1,0,1
tws->path[0] == '\0' && tws->path[1] == '\0',1,0,1
p->bk == b || chunksize(p->bk) == chunksize(p),1,0,1
blksize<=nedblksize(f),1,0,1
prefix_len * 2 >= n,1,0,1
"!hashcmp(mp->local, uninitialized)",1,0,1
ctx,1,0,1
blksize,1,0,1
"!""Invalid existing change recorded""",1,0,1
dir && subdir && *dir && *subdir,1,0,1
0 <= graph->expansion_row && graph->expansion_row < num_expansion_rows,1,0,1
"chunk_plus_offset(p, sz)->head == FENCEPOST_HEAD",1,0,1
chunksize(p) >= nb,1,0,1
!ob || ob->next==b,1,0,1
rs->ranges[i].start < rs->ranges[i].end,1,0,1
curr_branch_remote,1,0,1
"&ai, author_ident",1,0,1
rg->path,1,0,1
m->dvsize >= MIN_CHUNK_SIZE,1,0,1
rlw_get_run_bit(self->rlw) == 0,1,0,1
"*(unsigned int *) ""NEDN""==ptr[1]->magic",1,0,1
i >= self->bit_size,1,0,1
offset < total_len,1,0,1
next_pinuse(p),1,0,1
"&author, author_ident",1,0,1
a <= b,1,0,1
pair->two->path,1,0,1
rlw_get_literal_words(self->rlw) == current_num + 1,1,0,1
mctx->state_log != NULL && mctx->state_log[str_idx] != NULL,1,0,1
left > -1,1,0,1
u->child[0] == 0,1,0,1
u->child[1] == 0,1,0,1
u->index == tindex,1,0,1
sz >= s,1,0,1
use_mmap(m),1,0,1
bitmap_git.map && !bitmap_git.loaded,1,0,1
nedblksize(blk)>=blksize,1,0,1
m->topsize > 0,1,0,1
save_restore_env_balance == 1,1,0,1
!bitmap_git.map && !bitmap_git.loaded,1,0,1
data->o,1,0,1
pack_to_stdout,1,0,1
chunksize(u->child[0]) < chunksize(u->child[1]),1,0,1
*name_ != '\0',1,0,1
!cinuse(u),1,0,1
!is_null_sha1(p->two->sha1),1,0,1
data_pos,1,0,1
"!threads_active && ""This should only be reached when all threads are gone""",1,0,1
right > -1,1,0,1
"&ci, &committer_ident",1,0,1
u->parent->child[0] == u || u->parent->child[1] == u || *((tbinptr*)(u->parent)) == u,1,0,1
sz > 0,1,0,1
GET_PTR_TYPE(*p) == PTR_TYPE_NOTE || GET_PTR_TYPE(*p) == PTR_TYPE_SUBTREE,1,0,1
(ptr[0] && ptr[1]) || (!ptr[0] && !ptr[1]),1,0,1
"!signed_add_overflows(preimage.max_off, 1)",1,0,1
!ptr[1]->prev,1,0,1
"strcmp(p->path, n->path) == 0",1,0,1
m->footprint <= m->max_footprint,1,0,1
packed_entry - (struct index_entry *)mem == entries,1,0,1
!pair2 == !dst_entry2,1,0,1
u->bk->fd == u,1,0,1
!IS_EPSILON_NODE (node->token.type),1,0,1
insertions == 0 && deletions == 0,1,0,1
num >= 0,1,0,1
it->pointer < it->buffer_size,1,0,1
out->target.nr == 0,1,0,1
"!strcmp(p->one->path, p->two->path)",1,0,1
(((size_t)(chunk2mem(p))) % alignment) == 0,1,0,1
src != dst,1,0,1
regs->num_regs >= nregs,1,0,1
type == OBJ_TAG,1,0,1
(len & (mparams.page_size-SIZE_T_ONE)) == 0,1,0,1
dir,1,0,1
postlen ? fixed_preimage.nr == preimage->nr : fixed_preimage.nr <= preimage->nr,1,0,1
mctx->sub_tops != NULL,1,0,1
is_null_sha1(mp->remote),1,0,1
tc->bins[idx*2+1]==tck || binsptr[0]->next->prev==tck,1,0,1
total <= m->footprint,1,0,1
pstr->valid_len > 0,1,0,1
*mymspace>=0,1,0,1
dfa->nexts[cur_node_idx] != -1,1,0,1
local && remote,1,0,1
p->field < ARRAY_SIZE(header_field),1,0,1
out->nr == 0,1,0,1
sz == m->topsize,1,0,1
is_null_sha1(p->two->sha1),1,0,1
u->child[0] != u,1,0,1
s->branch && !s->is_initial,1,0,1
*ptr == '\n',1,0,1
!display_notes_trees,1,0,1
rlw_get_running_len(self->rlw) == 0,1,0,1
tck==tc->bins[idx*2],1,0,1
"!strcmp(o->local_ref, local_tree->ref)",1,0,1
!is_null_sha1(state->orig_commit),1,0,1
is_mmapped(p),1,0,1
"bin_find(m, m->top) == 0",1,0,1
item->nowildcard_len <= item->len && item->prefix <= item->len,1,0,1
graph,1,0,1
u->child[1]->parent == u,1,0,1
"*(unsigned int *) ""NEDN""==b->magic",1,0,1
t || tp,1,0,1
diff->parent.nr == diff->target.nr,1,0,1
"!bin_find(m, q)",1,0,1
id->variant >= 0,1,0,1
o->local_ref && o->remote_ref,1,0,1
msg_id >= 0 && msg_id < FSCK_MSG_MAX,1,0,1
*size<=THREADCACHEMAX,1,0,1
match_last != -1,1,0,1
(idx == NTREEBINS-1) || (tsize < minsize_for_tree_index((idx+1))),1,0,1
display_notes_trees,1,0,1
"!pinuse(chunk_plus_offset(p, sz))",1,0,1
nedblksize(ptr[1])>=sizeof(threadcacheblk),1,0,1
sz >= MIN_CHUNK_SIZE,1,0,1
is_null_sha1(p->one->sha1),1,0,1
dfa->nodes_len > 0,1,0,1
reuse_packfile_objects,1,0,1
!ptr[1]->next,1,0,1
"bin_find(m, m->dv) == 0",1,0,1
would_convert_to_git_filter_fd(path),1,0,1
old_data,1,0,1
malloc_usable_size(p) >= 256,1,0,1
!*p,1,0,1
delta && preimage && postimage && delta_len >= 0,1,0,1
!is_null_sha1(p->one->sha1),1,0,1
dfa->eclosures[node_idx].nelem != -1,1,0,1
"data && ""data can only be NULL for large _blobs_""",1,0,1
sz == ((sp->base + sp->size) - (char*)p) - TOP_FOOT_SIZE,1,0,1
node->next == NULL,1,0,1
graph->new_mapping[i] == -1,1,0,1
index_name,1,0,1
next == m->top || cinuse(next),1,0,1
rlw_get_running_len(self->rlw) == run_len + 1,1,0,1
"!__builtin_types_compatible_p(__typeof__(arr), __typeof__(&(arr)[0]))",1,0,1
!cinuse(p),1,0,1
(flags & (COMMIT_LOCK | CLOSE_LOCK)) != (COMMIT_LOCK | CLOSE_LOCK),1,0,1
*p == ':',1,0,1
graph->revs->boundary,1,0,1
is_mmapped(p) || sz < (s + MIN_CHUNK_SIZE),1,0,1
x->baselen == 0 || x->base[x->baselen - 1] == '/',1,0,1
state->istate,1,0,1
binsptr[0]!=blk && binsptr[1]!=blk,1,0,1
wc_idx >= 0,1,0,1
target * 2 <= i,1,0,1
ca.drv,1,0,1
view,1,0,1
