x_val,y_added,y_removed,y_combined
false,443,415,858
allow_macro_instructions_,311,207,518
!rd.IsZero(),169,112,281
IsValidKey(k),130,115,245
!rn.IsZero(),144,97,241
!empty(),109,92,201
 cursorHoldsMutex(pCur) ,100,100,200
 rc==SQLITE_OK ,91,91,182
 sqlite3_mutex_held(pBt->mutex) ,87,87,174
 sqlite3_mutex_held(db->mutex) ,86,86,172
 pOp->p1>=0 && pOp->p1<p->nCursor ,80,80,160
 pFile ,72,72,144
pPager,72,72,144
 sqlite3_mutex_held(pCtx->s.db->mutex) ,68,68,136
 sqlite3_mutex_held(pPage->pBt->mutex) ,68,68,136
 assert_pager_state(pPager) ,64,64,128
" sqlite3SchemaMutexHeld(db, iDb, 0) ",60,60,120
 pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) ,55,55,110
p,54,54,108
IsValid(),64,44,108
 p!=0 ,53,53,106
!rm.IsZero(),61,40,101
key->m_type != KindOfRef,54,44,98
" !ExprHasProperty(pExpr, EP_IntValue) ",48,48,96
s,51,44,95
 v!=0 ,47,47,94
0,50,44,94
m_top != m_base,57,34,91
valid(),48,38,86
 pCur->eState==CURSOR_VALID ,40,40,80
 sqlite3PagerIswriteable(pPage->pDbPage) ,40,40,80
 sqlite3_mutex_held(p->db->mutex) ,40,40,80
 (pMem->flags & MEM_RowSet)==0 ,40,40,80
 sqlite3_mutex_held(mem3.mutex) ,39,39,78
val->m_type != KindOfRef,41,36,77
is(KindOfArray),38,38,76
is(KindOfString) || is(KindOfStaticString),38,38,76
 argc==1 ,38,38,76
 !db->mallocFailed ,36,36,72
opc == DefConst || opc == LdConst,36,36,72
m_top != m_elms,43,29,72
is_refcount_realistic(_count),36,36,72
 p->magic==VDBE_MAGIC_INIT ,35,35,70
id != 0,34,33,67
is_refcount_realistic(m_count),33,33,66
 iDb>=0 && iDb<db->nDb ,32,32,64
ret,32,30,62
 db!=0 ,31,31,62
 !MEMDB ,31,31,62
 sqlite3BtreeHoldsMutex(p) ,31,31,62
 !pagerUseWal(pPager) ,30,30,60
ret >= 0,30,30,60
s1 && s2,32,27,59
!m_isSpilled,29,29,58
 EIGHT_BYTE_ALIGNMENT(pMem) ,28,28,56
 v ,28,28,56
 pEList!=0 ,28,28,56
 pOp->p1>=0 && pOp->p1<db->nDb ,27,27,54
 sqlite3BtreeHoldsAllMutexes(db) ,26,26,52
kindIsValid(),37,11,48
" !ExprHasProperty(pExpr, EP_xIsSelect) ",24,24,48
 isOpen(pPager->jfd) ,24,24,48
m_count,24,24,48
 sqlite3_mutex_held(pCur->pBtree->db->mutex) ,24,24,48
 pOp->p3>0 && pOp->p3<=p->nMem ,24,24,48
 rc!=SQLITE_DONE ,23,23,46
 db->mallocFailed ,22,22,44
tvIsPlausible(tv),22,22,44
m_magic == kMagic,24,19,43
 p->nRef>0 ,21,21,42
 pWal->writeLock ,21,21,42
!arrayData()->hasMultipleRefs(),24,18,42
m_type == KindOfArray,21,21,42
 p->pSegments==0 ,21,21,42
index < size(),22,20,42
 pPage->isInit ,20,20,40
 pOp->p4type==P4_INT32 ,20,20,40
 pTab!=0 ,20,20,40
 p->pEList ,20,20,40
m_pos != ArrayData::invalid_index,20,20,40
name && *name,20,19,39
 iDb>=0 ,19,19,38
m_count > 0,19,17,36
_count > 0,18,18,36
ad,19,17,36
 pPager->errCode==SQLITE_OK ,18,18,36
!MemoryManager::sweeping(),20,16,36
 pPager->eState!=PAGER_ERROR ,18,18,36
!fail,18,18,36
code < kNumberOfFPRegisters,21,14,35
!rt.IsZero(),21,14,35
type() == GP,20,15,35
 pParse->nErr==0 ,17,17,34
 pH!=0 ,17,17,34
canMutateBuffer(),20,14,34
 rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 ,16,16,32
 pList!=0 ,16,16,32
 p->inTrans==TRANS_WRITE ,16,16,32
 nColumn==1 ,16,16,32
m_data,17,15,32
 pTabList->nSrc==1 ,16,16,32
 pIn1->flags&MEM_Int ,16,16,32
 pBt->inTransaction==TRANS_WRITE ,16,16,32
 sqlite3BtreeHoldsAllMutexes(pParse->db) ,16,16,32
 IsVirtual(pTab) ,16,16,32
 pOp->p3>0 ,16,16,32
OpLowInvalid == 0,16,16,32
 sqlite3PagerIswriteable(pParent->pDbPage) ,16,16,32
 pOp->p2>0 ,16,16,32
!isPacked(),16,16,32
 pOp->p3<=p->nMem ,15,15,30
 (p->btreeMask & (((yDbMask)1)<<pOp->p1))!=0 ,15,15,30
lsb + width <= rn.size(),18,12,30
 iDb<db->nDb ,15,15,30
 iIndex>=0 && iIndex<p->nIndex ,15,15,30
 eFileLock<=SHARED_LOCK ,15,15,30
 unixMutexHeld() ,15,15,30
declared,15,15,30
 p->nOp>0 ,15,15,30
 nByte>0 ,15,15,30
a->checkInvariants(),16,14,30
width >= 1,18,12,30
 pParse!=0 ,15,15,30
 pPager->eState==PAGER_OPEN ,15,15,30
!ra.IsZero(),18,12,30
is(KindOfObject),17,13,30
getState() == STATE_WAITING,15,13,28
idx < m_size,14,14,28
tvIsPlausible(fr),14,13,27
isSpecialized(),15,12,27
tvIsPlausible(*tv),17,10,27
 p->nPendingData==0 ,13,13,26
tv->m_type == KindOfRef,14,12,26
cls,17,9,26
 rc!=SQLITE_OK ,13,13,26
hhvm,13,13,26
f,14,12,26
m_px,13,13,26
code < kNumberOfRegisters,15,10,25
 n>=0 ,13,12,25
 i>0 ,12,12,24
 (pH->htsize & (pH->htsize-1))==0 ,12,12,24
rc==SQLITE_OK || rc==SQLITE_NOMEM,12,12,24
 isOpen(pPager->fd) ,12,12,24
tvScratch.m_data.pstr->isStatic(),12,12,24
 isOpen(pPager->fd) || pPager->tempFile ,12,12,24
b_ < e_,12,12,24
Sign() > 0,12,12,24
 pPage->nOverflow==0 ,12,12,24
 pOrTerm->eOperator==WO_EQ ,12,12,24
 omitTable==0 ,12,12,24
 p->db!=0 ,12,12,24
 i>=1 ,12,12,24
 pPg->flags&PGHDR_DIRTY ,12,12,24
 pParse->pNewTable==0 ,12,12,24
 pTab->pSelect==0 ,12,12,24
 iCol>=0 ,12,12,24
 pBt!=0 ,12,12,24
 pName->nSrc==1 ,12,12,24
 pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell ,12,12,24
m_top->m_type != KindOfRef,15,9,24
 hHeap!=INVALID_HANDLE_VALUE ,12,12,24
 op>=0 && op<ArraySize(wsdStat.nowValue) ,12,12,24
obj,13,11,24
 ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 ,12,12,24
isValid(),13,11,24
 pBt->autoVacuum ,12,12,24
 hHeap!=0 ,12,12,24
 pCur->aiIdx[pCur->iPage]<pPage->nCell ,12,12,24
 pIdx->pSchema==pTab->pSchema ,12,12,24
 argc==1 || argc==2 ,12,12,24
 pOp->p2<=p->nMem ,12,12,24
 pPage->pBt!=0 ,12,12,24
subtypeOf(Gen),12,12,24
 pOp->p1>=0 ,12,12,24
!retval || (int(reg) >= 0 && int(reg) < 64),12,12,24
ad && m_pos != ArrayData::invalid_index,12,12,24
!hhvm,12,12,24
 z!=0 ,12,12,24
 sqlite3BtreeCursorIsValid(pCur) ,12,12,24
is(KindOfInt64),12,11,23
 pH->htsize>0 ,11,11,22
ret == 0,12,10,22
 pList->nExpr>0 ,11,11,22
index >= 0,11,11,22
check_refcount(m_hdr.count),11,11,22
isFullyConstructed(),14,8,22
 p->nRef==0 ,11,11,22
 pOp[-1].opcode==OP_CollSeq ,11,11,22
 nCell<nMaxCells ,11,11,22
" !ExprHasAnyProperty(pExpr, EP_TokenOnly|EP_Reduced) ",11,11,22
 argc==3 ,11,11,22
 pNew!=0 ,11,11,22
(n & 0x7fffffff) == n,11,10,21
iter_valid(pos),12,9,21
tv->m_type != KindOfRef,11,10,21
 pPrior!=0 ,10,10,20
acc,10,10,20
!xn.IsZero(),12,8,20
canSpecializeArray(),10,10,20
other.type() == type_,12,8,20
 count>=0 ,10,10,20
 locktype<=SHARED_LOCK ,10,10,20
IsComplete(),12,8,20
 id ,10,10,20
m_data.parr,10,10,20
m_cls,10,10,20
 p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE ,10,10,20
 size>=2 ,10,10,20
isInContext(),11,9,20
cellIsPlausible(fr),14,6,20
success,10,10,20
uintptr_t(this) % sizeof(TypedValue) == 0,10,10,20
isPhys(),10,9,19
len > 0,11,8,19
!isFinished(),11,8,19
" sqlite3MemdebugHasType(p, MEMTYPE_DB) ",9,9,18
 pShmNode->pInode==pDbFd->pInode ,9,9,18
" sqlite3MemdebugHasType(p, MEMTYPE_LOOKASIDE|MEMTYPE_HEAP) ",9,9,18
 p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX) ,9,9,18
 db==0 || sqlite3_mutex_held(db->mutex) ,9,9,18
s == sz::byte || s == sz::word || s == sz::dword,10,8,18
 (z-zBuf)==n ,9,9,18
 iLogsize>=0 && iLogsize<=LOGMAX ,9,9,18
 pCur->pgnoRoot==0 || pCur->apPage[pCur->iPage]->nCell==0 ,9,9,18
 pPager->eState>=PAGER_WRITER_LOCKED ,9,9,18
!m_instrs.empty(),10,8,18
tx64->m_savedRegMaps.top().saver == this,9,9,18
 pHdr->iForeGuard==FOREGUARD ,9,9,18
 p->eLock!=UNKNOWN_LOCK ,9,9,18
 *pPgno!=PENDING_BYTE_PAGE(pBt) ,9,9,18
 pPager->useJournal ,9,9,18
event_type == EV_READ,9,9,18
"opc == op() && ""ExtraData type error""",10,8,18
 i>=0 && i<mem5.nBlock ,9,9,18
" sqlite3SchemaMutexHeld(db, j, 0) ",9,9,18
 iLangid>=0 ,9,9,18
 pWal->nWiData>0 && pWal->apWiData[0] ,9,9,18
 isOpen(p->jfd) || p->journalMode==PAGER_JOURNALMODE_OFF || p->journalMode==PAGER_JOURNALMODE_WAL ,9,9,18
value() > 0.0,9,9,18
 !db->init.busy ,9,9,18
getState() == State::Running,9,9,18
e,9,9,18
 sqlite3_mutex_held(pCache->pGroup->mutex) ,9,9,18
 n>0 && n<=4 ,9,9,18
 pKeyInfo->aSortOrder!=0 ,9,9,18
 pPager->pInJournal==0 ,9,9,18
 pPager->eState==PAGER_WRITER_CACHEMOD || pPager->eState==PAGER_WRITER_DBMOD ,9,9,18
 pList ,9,9,18
 nKey>=0 ,9,9,18
rc == 0,9,9,18
 pPager!=0 ,9,9,18
 pPage->pCache==pCache ,9,9,18
strlen(buf) == 16,10,8,18
 nBytes>=0 ,9,9,18
getType() == KindOfInt64,10,8,18
 pPager->journalHdr<=pPager->journalOff ,9,9,18
getCount() == 0,9,9,18
!tx64->m_savedRegMaps.empty(),9,9,18
m_vals && toInt<uint32_t>(pos) < m_capacity,9,9,18
 (pBt->btsFlags & BTS_READ_ONLY)==0 ,9,9,18
true || (m_expectedCount = 0),9,9,18
(uintptr_t)m_top <= (uintptr_t)m_base,10,8,18
 iLevel<FTS3_SEGDIR_MAXLEVEL ,9,9,18
m_node.m_p == NULL,9,9,18
rn1 != reg::noreg && rn2 != reg::noreg,8,8,16
 p->inTrans>TRANS_NONE ,8,8,16
 (f & (MEM_Dyn|MEM_Ephem))==0 ,8,8,16
 (rc&0xff)==rc ,8,8,16
 pTable ,8,8,16
 pTable!=0 ,8,8,16
 aiCol || pFKey->nCol==1 ,8,8,16
 pTerm!=0 ,8,8,16
" ExprHasProperty(pExpr, EP_xIsSelect) ",8,8,16
leafCorrection==4,8,8,16
 p->magic==VDBE_MAGIC_RUN ,8,8,16
 (pFrom->flags & MEM_RowSet)==0 ,8,8,16
 (f & (MEM_Static|MEM_Ephem))==0 ,8,8,16
canEmit(n),8,8,16
cellIsPlausible(cell),10,6,16
 p->pOffset==0 ,8,8,16
 rc==SQLITE_OK || pStmt==0 ,8,8,16
 TK_NOTNULL==OP_NotNull ,8,8,16
 pParse->db->mallocFailed ,8,8,16
 pcacheCheckSynced(p) ,8,8,16
 z2==(char*)sqlite3_value_text(argv[0]) ,8,8,16
 rc!=SQLITE_OK || isOpen(pPager->jfd) ,8,8,16
 onError==OE_Replace ,8,8,16
IS_REFCOUNTED_TYPE(m_type),8,8,16
 rc==SQLITE_NOMEM || rc==SQLITE_OK ,8,8,16
 nVal==1 ,8,8,16
"sum < OOR && ""Assumption: string only has digits""",8,8,16
 pX->op==TK_IN ,8,8,16
 pzErrMsg!=0 ,8,8,16
 keyClass==FTS3_HASH_BINARY ,8,8,16
 pSrc!=0 ,8,8,16
 p==0 ,8,8,16
 pBt->pPage1->aData ,8,8,16
 TK_GT==OP_Gt ,8,8,16
 TK_LT==TK_GT+2 ,8,8,16
 pMem->flags & MEM_Blob ,8,8,16
 sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)) ,8,8,16
 p->db->mallocFailed ,8,8,16
 pPage->leaf ,8,8,16
 target>0 && target<=pParse->nMem ,8,8,16
 pOp[-1].p4type==P4_COLLSEQ ,8,8,16
m_type == KindOfObject,8,8,16
 size==mem3.aPool[i+size-1].u.hdr.prevSize ,8,8,16
 pSrc ,8,8,16
m_data.pobj,8,8,16
 pParse ,8,8,16
val->m_type != KindOfUninit,8,8,16
 pSelect==0 ,8,8,16
 amt>0 ,8,8,16
m_flags == 0,8,8,16
 n==pPage->pgno && e==PTRMAP_BTREE ,8,8,16
 iVar>0 ,8,8,16
 jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 ,8,8,16
 sqlite3_mutex_held(p->pSrc->pBt->mutex) ,8,8,16
 pOp->p4.z!=0 ,8,8,16
 pIn3->flags&MEM_Int ,8,8,16
 x>='a' && x<='z' ,8,8,16
 p->pOrderBy==0 ,8,8,16
 mem.disallow==0 ,8,8,16
 (pIn1->flags & MEM_Dyn)==0 ,8,8,16
 TK_NE==OP_Ne ,8,8,16
 xHash!=0 ,8,8,16
 pTrigger->zName==0 || pTab==tableOfTrigger(pTrigger) ,8,8,16
 pOp->p4type==P4_VTAB ,8,8,16
 (pTerm->eOperator&(pTerm->eOperator-1))==0 ,8,8,16
 pExpr->u.zToken[1]=='\'' ,8,8,16
" !ExprHasProperty(pF->pExpr, EP_xIsSelect) ",8,8,16
" hasSharedCacheTableLock(p, pCur->pgnoRoot, pCur->pKeyInfo!=0, 2) ",8,8,16
i < m_size,9,7,16
 (f & (MEM_Static|MEM_Dyn))==0 ,8,8,16
 pMem->z!=0 ,8,8,16
 TK_ISNULL==OP_IsNull ,8,8,16
c == isMedium || c == isLarge,8,8,16
 pExpr->pLeft==0 && pExpr->pRight==0 ,8,8,16
 TK_LT==OP_Lt ,8,8,16
(mask & (mask+1)) == 0,8,8,16
 target>0 ,8,8,16
 pTab ,8,8,16
size <= 0xffffu,8,8,16
 seenReplace==0 ,8,8,16
!isShared(),8,8,16
SQLITE_IOCAP_ATOMIC64K==(65536>>8),8,8,16
 j<nMaxCells ,8,8,16
 pCur->iPage>=0 && pCur->apPage[pCur->iPage] ,8,8,16
 sqlite3PagerIswriteable(pRoot->pDbPage) ,8,8,16
"!""Invalid flags argument""",8,8,16
 esc==0 ,8,8,16
 pE->op!=TK_DOT || pE->pRight!=0 ,8,8,16
 sqlite3PagerGetExtra(pPage->pDbPage) == (void*)pPage ,8,8,16
 pOut!=pIn1 ,8,8,16
 pX!=0 ,8,8,16
 pPage->pBt ,8,8,16
 pLeft ,8,8,16
 TK_EQ==OP_Eq ,8,8,16
ret == staticEmptyMixedArray() || ret->isMixed(),8,8,16
is_int19(imm19),10,6,16
 pCur->skipNext!=SQLITE_OK ,8,8,16
 iCol==-1 || (iCol>=0 && iCol<pTab->nCol) ,8,8,16
m_shouldCache == false,8,8,16
 !pPager->tempFile ,8,8,16
 pToRelease==0 || sqlite3PagerIswriteable(pToRelease->pDbPage) ,8,8,16
 pA->pRight==0 || pA->v<=pA->pRight->v ,8,8,16
 pIn1->flags & MEM_Str || db->mallocFailed ,8,8,16
 pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' ,8,8,16
 iLookAhead!=YYNOCODE ,8,8,16
 pNC!=0 ,8,8,16
 isWriteLock==0 || isWriteLock==1 ,8,8,16
 op>0 && op<0xff ,8,8,16
" !ExprHasProperty(pNew, EP_xIsSelect) ",8,8,16
 db->init.busy ,8,8,16
 pPg->pPager==pPager ,8,8,16
 pParse->pNewTrigger==0 ,8,8,16
 p->addrOpenEphm[0] == -1 ,8,8,16
 TK_GE==OP_Ge ,8,8,16
 eLock==READ_LOCK || eLock==WRITE_LOCK ,8,8,16
 pFrom->pTab==0 ,8,8,16
 p->pBt->pPager!=0 ,8,8,16
 pOp->p1>0 ,8,8,16
 op==SAVEPOINT_RELEASE || op==SAVEPOINT_ROLLBACK ,8,8,16
pCur,8,8,16
 (rc&db->errMask)==rc ,8,8,16
 TK_LE==OP_Le ,8,8,16
 p->locked==0 ,8,8,16
TranslatorX64::canWrite(),8,8,16
m_type == KindOfString || m_type == KindOfStaticString,8,8,16
check_refcount(m_count),8,8,16
 mem1.zMalloc==0 ,8,8,16
capacity() >= minCapacity,8,8,16
" !ExprHasAnyProperty(p, EP_TokenOnly|EP_Reduced) ",8,8,16
 (mem3.aPool[i-1].u.hdr.size4x & 1)==0 ,8,8,16
 (pageSize & 7)==0 ,8,8,16
 j==1 ,8,8,16
SQLITE_IOCAP_ATOMIC512==(512>>8),8,8,16
 onError==OE_Rollback || onError==OE_Abort || onError==OE_Fail || onError==OE_Ignore || onError==OE_Replace ,8,8,16
 p && p->pFunc ,8,8,16
(reg_size == kWRegSize) || (reg_size == kXRegSize),9,6,15
inst->marker().valid(),9,6,15
(0 < n) && (n < 64),9,6,15
hasArrayData(),8,7,15
checkValid(),9,6,15
*dest == nullptr,8,7,15
 pFile->locktype!=NO_LOCK || locktype==SHARED_LOCK ,7,7,14
info,7,7,14
 rc2==SQLITE_OK ,7,7,14
m_data.pstr,7,7,14
m_magic == Magic::kMagic,7,7,14
 pH->first==0 ,7,7,14
m_isSpilled,7,7,14
m_type == KindOfRef ? m_data.pref->var()->m_data.parr : m_data.parr,8,6,14
 pOp->p1>0 && pOp->p1<=p->nMem ,7,7,14
m_acquires > 0,8,6,14
m_kind == TransKind::Proflogue,7,7,14
 iType-2 >= 0 ,7,7,14
 pFile!=0 ,7,7,14
(void*)px == (void*)cur,7,7,14
wantClass(),8,6,14
i < size(),7,7,14
 db ,7,7,14
 locktype!=RESERVED_LOCK || pFile->locktype==SHARED_LOCK ,7,7,14
 !IsVirtual(pTab) ,7,7,14
spc == This,7,7,14
 pLhs->aNode && pRhs->aNode ,7,7,14
getType() == KindOfDouble,8,6,14
 p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE ,7,7,14
arch() == Arch::ARM,7,7,14
key != 0,8,6,14
m_writeOwner == InvalidThread,8,6,14
 locktype!=PENDING_LOCK ,7,7,14
 rc==SQLITE_NOMEM ,7,7,14
canEmit(sz::dword),7,7,14
 db->mallocFailed==0 ,7,7,14
tv->m_type == KindOfObject,8,6,14
offset < m_vector.size(),7,7,14
 (pIn2->flags & MEM_Int)!=0 ,7,7,14
(sz & (sizeof(TypedValue) - 1)) == 0,7,7,14
 sizeof(Mem3Block)==8 ,7,7,14
data && data == getContainer(),8,6,14
 EIGHT_BYTE_ALIGNMENT(p) ,7,7,14
!isPtr(),7,7,14
m_type == KindOfRef ? m_data.pref->var()->m_data.pobj : m_data.pobj,8,6,14
op.flags & IF_JCC,8,6,14
(op.flags & IF_JCC) == 0,8,6,14
 n>0 ,7,7,14
canEmit(sz::qword),7,7,14
 db->lookaside.bEnabled==0 ,7,7,14
 i>=0 ,7,7,14
 n>=1 ,7,7,14
HPHP::Util::isPowerOfTwo(kNumLines),7,7,14
canEmit(sz::byte),7,7,14
m_address,8,6,14
 sizeof(u32)==4 ,7,7,14
 nTerm>0 ,7,7,14
px,8,6,14
m_size > 0,8,6,14
 pH->count==0 ,7,7,14
 eType==SQLITE_TEXT || eType==SQLITE_BLOB ,7,7,14
 zColl!=0 ,7,7,14
index >= 0 && index < m_data->m_len,8,6,14
s_writeLease.amOwner(),7,7,14
canEmit(sz::word),7,7,14
id >= 0 && id < MAX_SHARED_STORE,7,7,14
m_type == KindOfRef ? m_data.pref->var()->m_data.pstr : m_data.pstr,8,6,14
static_cast<bool>(m_magic = Magic::kMagic),7,7,14
 pExpr->pLeft && pExpr->pRight ,7,7,14
index == 0,8,6,14
opFunc,7,6,13
m_type == KindOfDouble,7,6,13
!hasMultipleRefs(),8,5,13
 a ,7,6,13
m_filepath,7,6,13
nProps == propInitVec->size(),7,6,13
k->isStatic(),7,6,13
fr->m_type == KindOfRef,7,6,13
i < m_stkArgs.size(),7,6,13
v1,13,0,13
m_top->m_type == KindOfRef,7,6,13
nProps == cls->declPropInit().size(),7,6,13
 p->eLock>=RESERVED_LOCK ,6,6,12
tvIsPlausible(m_top),6,6,12
 (mem5.aCtrl[i] & CTRL_LOGSIZE)==iLogsize ,6,6,12
 sqlite3_mutex_held(pGroup->mutex) ,6,6,12
 sqlite3BtreeCursorIsValid(u.ao.pCrsr) ,6,6,12
m_next,6,6,12
current->m_type == KindOfObject,6,6,12
HphpArray::ElmIndEmpty == -1,6,6,12
m_name != NULL,6,6,12
 szRegion==pShmNode->szRegion || pShmNode->nRegion==0 ,6,6,12
IsValidOrNone(),6,6,12
 p->aSample!=0 ,6,6,12
dd_->guardCount_ > 0,6,6,12
 p->wantToLock>0 ,6,6,12
 (PAGER_JOURNALMODE_PERSIST & 5)==1 ,6,6,12
s_inited,8,4,12
current->m_data.pobj->instanceof(c_WaitHandle::classof()),6,6,12
index < m_count,6,6,12
(flags&0x0F)==SQLITE_SYNC_NORMAL || (flags&0x0F)==SQLITE_SYNC_FULL ,6,6,12
compressed != NULL,6,6,12
 ofst>=0 && ofst+n<=SQLITE_SHM_NLOCK ,6,6,12
 zDb!=0 || sqlite3BtreeHoldsAllMutexes(db) ,6,6,12
 pParse->db!=0 ,6,6,12
 WAL_FRAME_HDRSIZE==24 ,6,6,12
sd,6,6,12
 p->mxSavepoint >= iSavepoint ,6,6,12
 pPager->eState==PAGER_WRITER_DBMOD ,6,6,12
stats.maxBytes > 0,6,6,12
 0!=pFile->eFileLock ,6,6,12
pCsr->pNode,6,6,12
 pWal->readLock>=0 || pWal->lockError ,6,6,12
 p->bFts4==0 ,6,6,12
 (SQLITE_PTR_TO_INT(ptr)&1)==0 ,6,6,12
 pShmNode->nRef>0 ,6,6,12
sd->isStatic(),7,5,12
 pMem->n>=0 ,6,6,12
h < RuntimeOption::EvalJitTargetCacheSize,6,6,12
 p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) ,6,6,12
"sizeof(Resource) == sizeof(ResourceBase), ""Fix this.""",6,6,12
"deltaFits(imm, sz::dword)",6,6,12
 u.bc.oc==OP_SeekGe || u.bc.oc==OP_SeekGt ,6,6,12
 pWal->writeLock==0 ,6,6,12
length,6,6,12
" sqlite3MemdebugHasType(p, MEMTYPE_PCACHE) ",6,6,12
data,6,6,12
 pPager->eState==PAGER_OPEN || pPager->eState==PAGER_READER ,6,6,12
 pPager->eState>=PAGER_WRITER_CACHEMOD ,6,6,12
 p->op==RTREE_MATCH ,6,6,12
 pWal->readLock>=0 ,6,6,12
 lockType==F_WRLCK ,6,6,12
" p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld2(p, tid) ",6,6,12
size() == n,6,6,12
 p->inTransaction ,6,6,12
 pBt->pageSize>=512 && pBt->pageSize<=65536 ,6,6,12
 pKey!=0 ,6,6,12
 sqlite3_data_count(pCsr->pStmt)==0 ,6,6,12
 (PAGER_JOURNALMODE_TRUNCATE & 5)==1 ,6,6,12
 sz<=pBt->maxLocal+23 ,6,6,12
 rc!=SQLITE_IOERR_SHORT_READ ,6,6,12
 (pX->exclMask & (p->exclMask|p->sharedMask))==0 ,6,6,12
 pCsr->pNode==pRoot ,6,6,12
 errcode!=SQLITE_OK ,6,6,12
ret >= 0 || errno == ENOENT,6,6,12
 sqlite3_mutex_notheld(pcache1.grp.mutex) ,6,6,12
 nDoclist>0 ,6,6,12
m_transfer_fname.empty(),6,6,12
 pFile->pUnused==0 || offset>=PENDING_BYTE+512 || offset+amt<=PENDING_BYTE ,6,6,12
 pPager->eState>=PAGER_READER ,6,6,12
 *pbEof==0 ,6,6,12
 (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_JOURNAL ,6,6,12
is(KindOfString),6,6,12
 sqlite3_mutex_held(pcache1.mutex) ,6,6,12
ptr != NULL,6,6,12
 cnt==(cnt&0x1ffff) ,6,6,12
acc && acc->m_type == KindOfArray,6,6,12
 pWinMemData->hHeap!=INVALID_HANDLE_VALUE ,6,6,12
hasVar(),6,6,12
" db!=0 || sqlite3MemdebugNoType(p, MEMTYPE_LOOKASIDE) ",6,6,12
 pShmNode->h>=0 || pDbFd->pInode->bProcessLock==1 ,6,6,12
 eType==SQLITE_OPEN_MAIN_DB || eType==SQLITE_OPEN_TEMP_DB || eType==SQLITE_OPEN_MAIN_JOURNAL || eType==SQLITE_OPEN_TEMP_JOURNAL || eType==SQLITE_OPEN_SUBJOURNAL || eType==SQLITE_OPEN_MASTER_JOURNAL || eType==SQLITE_OPEN_TRANSIENT_DB || eType==SQLITE_OPEN_WAL ,6,6,12
 iLevel==FTS3_SEGCURSOR_ALL || iLevel==FTS3_SEGCURSOR_PENDING || iLevel>=0 ,6,6,12
 u<=LARGEST_INT64 ,6,6,12
 pInode->eFileLock==0 ,6,6,12
size_t(pos) < m_used,7,5,12
 pPager->setMaster==0 ,6,6,12
fr->m_type != KindOfRef,6,6,12
" sqlite3MemdebugHasType(p, MEMTYPE_HEAP) ",6,6,12
 n>1 || mask==(1<<ofst) ,6,6,12
 u.bi.pC->isTable ,6,6,12
src != scratch,6,6,12
 (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_DB ,6,6,12
 pPager->dbOrigSize==pPager->dbFileSize ,6,6,12
child->instanceof(c_WaitableWaitHandle::classof()),6,6,12
 aRegIdx ,6,6,12
 pFile->eFileLock!=NO_LOCK || eFileLock==SHARED_LOCK ,6,6,12
 pSorter ,6,6,12
isDelete==0 || isCreate,6,6,12
 u.bg.pC->rowidIsValid==0 ,6,6,12
p->op==RTREE_LE || p->op==RTREE_LT || p->op==RTREE_GE || p->op==RTREE_GT || p->op==RTREE_EQ || p->op==RTREE_MATCH ,6,6,12
 pShmNode->h<0 || pDbFd->pInode->bProcessLock==0 ,6,6,12
 eFileLock==SHARED_LOCK ,6,6,12
isCreate==0 || isReadWrite,6,6,12
sz == sizeof(VectorData),6,6,12
i <= m_numSrcs,6,6,12
(TypedValue*)ar - stack.top() == ar->numArgs(),6,6,12
"KindOfUninit == 0 && KindOfInvalid < 0, """"",6,6,12
 rc==SQLITE_OK || pCsr==0 ,6,6,12
" sqlite3SchemaMutexHeld(db, pOp->p1, 0) ",6,6,12
 c==i ,6,6,12
 iPg<=pCheck->nPage && sizeof(pCheck->aPgRef[0])==1 ,6,6,12
 pShmNode==pDbFd->pInode->pShmNode ,6,6,12
ret == staticEmptyArray() || ret->isPacked(),6,6,12
 pIn->nSdst==1 ,6,6,12
 p->inTransaction!=0 ,6,6,12
 iFirst>=0 ,6,6,12
" osHeapValidate(pWinMemData->hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) ",6,6,12
(isReadonly==0 || isReadWrite==0) && (isReadWrite || isReadonly),6,6,12
 pDbFd->pShm==0 ,6,6,12
check_refcount(count),6,6,12
 p->nRef>0 || p->owner==0 ,6,6,12
run->magic == ARENA_RUN_MAGIC,6,6,12
sizeof(*pc_) == 1,6,6,12
 pInode->nShared!=0 ,6,6,12
!is_finalized() && position_ < buffer_.length(),6,6,12
IsNone(),6,6,12
" sqlite3MemdebugNoType(p, MEMTYPE_DB) ",6,6,12
isExclusive==0 || isCreate,6,6,12
static_cast<uint32_t>(ra) < 32,12,0,12
 pCsr->isRequireSeek==0 ,6,6,12
 p!=0 && (p->rsFlags & ROWSET_NEXT)==0 ,6,6,12
acc && acc->m_type == KindOfObject,6,6,12
 (!isDelete && zName) || eType!=SQLITE_OPEN_WAL ,6,6,12
 pInode->nShared==0 ,6,6,12
!(m_flags & RefVarArgs) || !(m_flags & MixedVarArgs),6,6,12
naryDst(),7,5,12
this != &src,6,6,12
 eFileLock!=PENDING_LOCK ,6,6,12
 pInode->nShared>0 ,6,6,12
"sizeof(Object) == sizeof(ObjectBase), ""Fix this.""",6,6,12
arch() == Arch::X64,6,6,12
" sqlite3SchemaMutexHeld(db, 0, pDb->pSchema) ",6,6,12
 pPager->eState==PAGER_WRITER_LOCKED ,6,6,12
 (sqlite3FtsUnicodeIsalnum(iCode) & 0xFFFFFFFE)==0 ,6,6,12
time != NULL,6,6,12
 pPager->dbOrigSize==pPager->dbHintSize ,6,6,12
 eFileLock!=RESERVED_LOCK || pFile->eFileLock==SHARED_LOCK ,6,6,12
argNum >= r.m_vals.size(),6,6,12
 pLevel->p5==0 ,6,6,12
!wantClass(),7,5,12
 aHash[iKey]==i ,6,6,12
 p || *piDocid==0 ,6,6,12
 pInode->nLock>=0 ,6,6,12
size >= 0,6,6,12
 pDb->pSchema!=0 ,6,6,12
 memIsValid(pIn1) ,6,6,12
eb != NULL,6,6,12
 (p->sharedMask & mask)==0 ,6,6,12
!IsSpecial(),6,6,12
 memIsValid(&aMem[pOp->p3]) ,6,6,12
 flags==(SQLITE_SHM_LOCK | SQLITE_SHM_SHARED) || flags==(SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE) || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED) || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE) ,6,6,12
" osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) ",6,6,12
 (!isDelete && zName) || eType!=SQLITE_OPEN_MASTER_JOURNAL ,6,6,12
 pPager->eLock>=SHARED_LOCK ,6,6,12
cellIsPlausible(&fr),6,6,12
 u.bc.oc==OP_SeekLt || u.bc.oc==OP_SeekLe ,6,6,12
 pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK ,6,6,12
 pInode->eFileLock==pFile->eFileLock ,6,6,12
m_ref,6,6,12
inst.op == name,8,4,12
!IS_REFCOUNTED_TYPE(m_tv.m_type),6,6,12
 pPager->eState==PAGER_READER ,6,6,12
!isFull(),8,4,12
 n==1 || (flags & SQLITE_SHM_EXCLUSIVE)!=0 ,6,6,12
 p->eLock==EXCLUSIVE_LOCK ,6,6,12
 pPager->eLock==EXCLUSIVE_LOCK ,6,6,12
ad->kind() == kMixedKind,6,6,12
this != &v,7,5,12
checkInvariants(),11,1,12
 level>=1 && level<=3 ,6,6,12
 pFile->eFileLock==0 ,6,6,12
 offset <= (int)pBt->usableSize-5 ,6,6,12
" osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) ",6,6,12
idx < size(),7,4,11
"std::is_base_of<ObjectData,T>::value, """"",6,5,11
tv->m_type == KindOfString,6,5,11
checkVarEnv(),7,4,11
"bit < (sizeof(unsigned) * CHAR_BIT - 1), ""Too many bits""",6,5,11
!isImmutable(),7,4,11
ar,6,5,11
m_cert,6,5,11
"std::is_base_of<ResourceData,T>::value, """"",7,4,11
transId < m_translations.size(),6,5,11
size != 0,6,5,11
value,6,5,11
m_extra != nullptr,6,5,11
!m_srcs && !m_numSrcs,6,5,11
!m_extra,6,5,11
!hasArrayData(),6,5,11
isFailed(),6,5,11
m_node.m_p == nullptr,7,4,11
m_id != kTransient,6,5,11
hasDst(),6,5,11
isSucceeded(),6,5,11
tv->m_type == KindOfArray,6,5,11
hasTypeHint(),6,5,11
!naryDst(),6,5,11
ei >= -1,6,5,11
m_type == KindOfInt64,6,5,11
ad->isStatic(),6,5,11
 pPager->journalOff==JOURNAL_HDR_SZ(pPager) ,5,5,10
RegAliasesMatch(code),6,4,10
 pE!=0 ,5,5,10
regN != reg::noreg,5,5,10
base && frontier,5,5,10
frontier >= base,5,5,10
m_type == KindOfObject && m_data.pobj,6,4,10
sizeT == sizeof(T),5,5,10
 pBt->pPage1 ,5,5,10
bound(),10,0,10
isQueryOp(opc),5,5,10
m_name,5,5,10
cflagsPtr,5,5,10
IsShiftedRegister() || IsExtendedRegister(),6,4,10
check_refcount_ns(m_hdr.count),5,5,10
idx >= 0,6,4,10
*this <= Gen,5,5,10
size2bin[i] == binind,5,5,10
frontierOff <= size,5,5,10
"memset(obj, kSmartFreeFill, m_itemSize)",5,5,10
pos + 1 < posLimit(),6,4,10
 (p->btreeMask & (1<<pOp->p1))!=0 ,5,5,10
"std::is_pod<T>::value, ""Constant data wasn't a pod?""",5,5,10
pos < posLimit,6,4,10
!m_edges || hasEdges(),6,4,10
isGP() || n == -1,5,5,10
other.size() == size_,6,4,10
op[0] == OpCreateCont,5,5,10
 pageInJournal(pPg) || pPg->pgno>pPager->dbOrigSize ,5,5,10
isSF(),6,4,10
"IMPLIES(cap() == 0, !b)",6,4,10
m_type == KindOfString,5,5,10
start,6,4,10
 pCsr ,5,5,10
 p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed ,5,5,10
!candidate.Is(target),6,4,10
 !p->locked || p->wantToLock>0 ,5,5,10
"!""called extra on an opcode without extra data""",6,4,10
SPRegAliasesMatch(),6,4,10
(uintptr_t(frontier) & (align - 1)) == 0,5,5,10
((reg_size == kXRegSize) && is_uint6(immr)) || ((reg_size == kWRegSize) && is_uint5(immr)),6,4,10
!isSmall(),5,5,10
"SetOp_invalid == 11, ""SetOpOp enum must fit in 4 bits""",5,5,10
m_count.load(),5,5,10
checkRefCount(),5,5,10
"IncDec_invalid == 4, ""IncDecOp enum must fit in 2 bits""",5,5,10
inst->block() == this,6,4,10
frontier <= base + size,5,5,10
iter_valid(ipos),5,5,10
pDb==&db->aDb[0],5,5,10
 p->sharable ,5,5,10
 nVal>=1 ,5,5,10
sizeT <= size_t(a->getItemSize()),5,5,10
size_t(idx) < m_list.size(),6,4,10
m_count.load() == 1,5,5,10
 pFile->locktype==SHARED_LOCK ,5,5,10
val != reg::noreg,5,5,10
tv->m_type == KindOfVariant,5,5,10
t == KindOfObject,5,5,10
FPRegAliasesMatch(code),6,4,10
 pPager->state>=PAGER_RESERVED ,5,5,10
 pOp!=0 ,5,5,10
op[1] == OpPopC,5,5,10
 pFile->locktype==NO_LOCK ,5,5,10
inst,5,5,10
shift < rd.size(),6,4,10
m_vec->hasExactlyOneRef(),10,0,10
 sqlite3PcacheRefCount(pPager->pPCache)==0 ,5,5,10
my_pid == master_pid,5,5,10
i < m_regArgs.size(),5,5,10
other.RegisterSizeInBits() == size_,6,4,10
 pCur->apPage[pCur->iPage] ,5,5,10
"CPURegister(code, size_, type_).IsValid()",6,4,10
 pFile->locktype>=SHARED_LOCK ,5,5,10
!m_obj || m_obj->getCount() > 0,5,5,10
T,5,5,10
 p->nOp>0 || p->aOp==0 ,5,5,10
sym,6,4,10
m_name != nullptr,6,3,9
i == neededSize,5,4,9
m_safeToRead,6,3,9
jmp[0] == 0xE9,5,4,9
m_type == KindOfBoolean,5,4,9
len >= 0 && len <= capacity() && !isImmutable(),5,4,9
"m_a && m_address && ""Label had jumps but was never set""",5,4,9
flags() == Flags::None,5,4,9
size_t(pos) <= m_used,5,4,9
len >= 0,5,4,9
propInitVec != nullptr,5,4,9
cls->isCollectionClass(),6,3,9
(intptr_t(obj) & 1) == 0,5,4,9
!m_anchorTranslation,5,4,9
!warn || !unset,5,4,9
jmp[0] == 0x0F && (jmp[1] & 0xF0) == 0x80,5,4,9
jmp[0] == 0xEB,5,4,9
this != other,5,4,9
strlen(str) == 32,5,4,9
" std::is_pointer<Fun>::value && std::is_function<typename std::remove_pointer<Fun>::type>::value, ""You can only register pointers to function.""",5,4,9
call[0] == 0xE8,5,4,9
"PTRMAP_PTR_SIZE % PTRMAP_LEVEL_BITS == 0, ""PTRMAP_PTR_SIZE must be a multiple of PTRMAP_LEVEL_BITS""",5,4,9
!(uintptr_t(ptr) >> 48),5,4,9
(jmp[0] & 0xF0) == 0x70,5,4,9
"IMPLIES(!arrayData()->hasMultipleRefs(), m_immCopy.isNull())",5,4,9
is(KindOfDouble),5,4,9
cellIsPlausible(c),6,3,9
is(KindOfBoolean),5,4,9
from != this,5,4,9
cls->attrs() & AttrFinal,6,3,9
(intptr_t(ad) & 1) == 0,5,4,9
!isTombstoneType(frE.data.m_type),5,4,9
m_tailFallbackJumps.empty(),5,4,9
pos + sizeof(T) <= m_bclen,5,4,9
m_len <= m_cap,5,4,9
 idx >= end+2 ,4,4,8
 pLeft!=0 ,4,4,8
 z && pColl && pColl->xCmp ,4,4,8
isPtr(),4,4,8
fixup.m_spOffset >= 0,4,4,8
 pCur->apPage[pCur->iPage]->nOverflow==0 ,4,4,8
(cond != al) && (cond != nv),8,0,8
 op!=TK_ISNULL || c==WO_ISNULL ,4,4,8
 sqlite3_value_type(argv[0])==SQLITE_NULL ,4,4,8
 ppStmt!=0 ,4,4,8
 idx1==szHdr1 && rc ,4,4,8
 !pIdx || pIdx->pTable==pTab ,4,4,8
 isIgnoreEmpty || (isRequirePos && !isColFilter) ,4,4,8
 nearby>0 ,4,4,8
 p->pOrderBy!=0 ,4,4,8
si.isValid(),4,4,8
tl_regState == REGSTATE_DIRTY,4,4,8
rc==SQLITE_NOMEM || pMem->enc==desiredEnc,4,4,8
 pTab->iPKey<0 ,4,4,8
 pPager->pPCache!=0 ,4,4,8
 pIn2->flags & MEM_Blob ,4,4,8
"(scale == 0x1 || scale == 0x2 || scale == 0x4 || scale == 0x8) && ""Invalid index register scaling (must be 1,2,4 or 8).""",5,3,8
 iOfst+iAmt<=p->endpoint.iOffset ,4,4,8
VM::OpLowInvalid == 0,4,4,8
 PAGER_LOCKINGMODE_EXCLUSIVE==1 ,4,4,8
 nRef==sqlite3PagerRefcount(pPager) ,4,4,8
 (MEM_Blob>>3) == MEM_Str ,4,4,8
 pName==0 ,4,4,8
n != 0xffffffff,4,4,8
 u.bm.pC->deferredMoveto==0 ,4,4,8
 pInt[nReserve/sizeof(int)]==(int)REARGUARD ,4,4,8
 pParent->pOrderBy==0 ,4,4,8
!tvWillBeReleased(tv),4,4,8
n < size(),4,4,8
b_ <= e_,4,4,8
 pPrior->pRightmost!=pPrior ,4,4,8
 pNew==0 ,4,4,8
 pIn1<=&aMem[p->nMem] ,4,4,8
 i<(int)sizeof(p->btreeMask)*8 ,4,4,8
 p->pPrev==0 || p->pPrev->pBt<p->pBt ,4,4,8
 zP4!=0 ,4,4,8
 iVal-*piPrev > 0 || (*piPrev==0 && iVal==0) ,4,4,8
 sqlite3PagerIswriteable(pChild->pDbPage) ,4,4,8
 n==(db->nSavepoint + db->isTransactionSavepoint) ,4,4,8
 1==sqlite3BtreeIsInTrans(pTemp) ,4,4,8
 pTo!=0 ,4,4,8
 pExpr->affinity==OE_Rollback || pExpr->affinity==OE_Abort || pExpr->affinity==OE_Fail || pExpr->affinity==OE_Ignore ,4,4,8
 iCol>=0 && iCol<pEList->nExpr ,4,4,8
 !SAVEPOINT_BEGIN && SAVEPOINT_RELEASE==1 && SAVEPOINT_ROLLBACK==2 ,4,4,8
 pOrTerm->eOperator==0 ,4,4,8
 (nVal==0)==(idxNum==FTS3_FULLSCAN_SEARCH) ,4,4,8
"Empty == -1, """"",4,4,8
 nReserve>=0 && nReserve<1000 ,4,4,8
 sqlite3IsNaN(y) ,4,4,8
 db==0 || p->pBlockingConnection!=db ,4,4,8
 rc==SQLITE_BUSY || rc==SQLITE_OK || rc==SQLITE_ERROR ,4,4,8
 !isRowid ,4,4,8
 p->eType!=FTSQUERY_PHRASE ,4,4,8
 p->pNext==0 || p->pNext->pBt>p->pBt ,4,4,8
 eLock==READ_LOCK || pBt->inTransaction==TRANS_WRITE ,4,4,8
 p->pBt->inTransaction>=p->inTrans ,4,4,8
 pParse->nTab>iCur+i+1 ,4,4,8
 pFile->inNormalWrite==0 || pFile->dbUpdate==0 || pFile->transCntrChng==1 ,4,4,8
 !(fg&MEM_Zero) ,4,4,8
 isPrepareV2==1 || isPrepareV2==0 ,4,4,8
 pOp->p5<db->nDb ,4,4,8
 srcType==MEM_Ephem || srcType==MEM_Static ,4,4,8
" !ExprHasProperty(pExpr, EP_xIsSelect) && pExpr->x.pList ",4,4,8
size==0,4,4,8
 (pTab->tabFlags & TF_Virtual)!=0 ,4,4,8
 pParse->checkSchema ,4,4,8
sizeof(Bucket) == 24,4,4,8
 p->rc!=SQLITE_ROW && p->rc!=SQLITE_DONE ,4,4,8
 pOp->p1 <= SQLITE_MAX_LENGTH ,4,4,8
 yy_lookahead[i]==iLookAhead ,4,4,8
 (p->flags & MEM_Agg)==0 ,4,4,8
m_p + sizeof(T) <= m_last,4,4,8
 pLater->pNext==0 || pLater->pNext->pBt>pLater->pBt ,4,4,8
 sqlite3PagerIswriteable(pPage1->pDbPage) ,4,4,8
 sqlite3_mutex_held(pCsr->pBtree->db->mutex) ,4,4,8
 u.bj.pC!=0 ,4,4,8
 pOp>aOp ,4,4,8
 TK_GE==TK_GT+3 ,4,4,8
 p->inTrans>0 ,4,4,8
 db->activeVdbeCnt>0 || db->autoCommit==0 || db->nStatement==0 ,4,4,8
m_value.innerType != KindOfRef,4,4,8
 p->l_whence==SEEK_SET ,4,4,8
 pPager->pInJournal!=0 ,4,4,8
 xConstruct ,4,4,8
 pOp->opcode==OP_InsertInt ,4,4,8
 pOffset==0 || pLimit!=0 ,4,4,8
 maxRootPgno!=PENDING_BYTE_PAGE(pBt) ,4,4,8
 nBuf>=0 ,4,4,8
 -1-pOp->p2<p->nLabel ,4,4,8
 op==TK_DELETE || op==TK_UPDATE || op==TK_INSERT ,4,4,8
 i<pTab->nCol ,4,4,8
inst != NULL,4,4,8
 sizeof(x)==8 && sizeof(pMem->r)==8 ,4,4,8
 pFrom->pSelect==0 ,4,4,8
 !p || p->xCmp ,4,4,8
 PAGER_LOCKINGMODE_QUERY<0 ,4,4,8
" SQLITE_OK==querySharedCacheTableLock(p, iTable, eLock) ",4,4,8
 isOpen(pPager->fd) || tempFile ,4,4,8
 info.nHeader==nHeader ,4,4,8
 p->bDestLocked ,4,4,8
 p->sharable==0 || p->locked==0 || p->wantToLock>0 ,4,4,8
 pIdx->zName || (pIdx->nColumn==1 && pIdx->aiColumn[0]==-1) ,4,4,8
 p2->xUnlockNotify==p->xUnlockNotify || !seen ,4,4,8
 pItem->notIndexed==0 && pItem->zIndex==0 ,4,4,8
 eAuto>=0 && eAuto<=2 ,4,4,8
m_class == nullptr && other.m_class == nullptr,4,4,8
 db->u1.isInterrupted ,4,4,8
s != kInvalidSlot,5,3,8
 WO_LT==SQLITE_INDEX_CONSTRAINT_LT ,4,4,8
 pPrior->pOrderBy==0 ,4,4,8
 pRoot->pgno==pCur->pgnoRoot ,4,4,8
 zFilename ,4,4,8
ret->isStatic(),4,4,8
 isSavepnt ,4,4,8
 pCol->affinity==SQLITE_AFF_NONE || pCol->affinity==sqlite3AffinityType(zType) ,4,4,8
 pOp->p1>0 && pOp->p1<=p->nVar ,4,4,8
 pCur->apPage[1]->nOverflow ,4,4,8
isAligned(r),4,4,8
 TK_GT<TK_LE ,4,4,8
 info.nKey==nKey ,4,4,8
 nOut<SQLITE_MAX_LENGTH ,4,4,8
 db->init.busy==0 || saveSqlFlag==0 ,4,4,8
 p->pPrior==0 ,4,4,8
" wrFlag==0 || !hasReadConflicts(p, iTable) ",4,4,8
rc==SQLITE_OK || pMem->enc!=desiredEnc,4,4,8
 f2&MEM_Int ,4,4,8
 pBt->pPage1==0 ,4,4,8
 pCur->eState==CURSOR_INVALID || pCur->eState==CURSOR_VALID ,4,4,8
 enc==SQLITE_UTF8 || enc==SQLITE_UTF16LE || enc==SQLITE_UTF16BE ,4,4,8
" !ExprHasAnyProperty(pEq, EP_TokenOnly|EP_Reduced) ",4,4,8
 pTest!=0 ,4,4,8
 pColl->enc==SQLITE_UTF8 ,4,4,8
 db->activeVdbeCnt>=db->writeVdbeCnt ,4,4,8
 p->db==0 || sqlite3_mutex_held(p->db->mutex) ,4,4,8
 pRes ,4,4,8
 bestPlan.plan.u.pIdx==pIdx ,4,4,8
 p->nRef || (p->flags&PGHDR_NEED_SYNC) ,4,4,8
 pExpr->u.zToken!=0 ,4,4,8
 OP_SeekGe == OP_SeekLt+2 ,4,4,8
 b.rc!=SQLITE_OK ,4,4,8
 pgno<=PAGER_MAX_PGNO && pgno!=PAGER_MJ_PGNO(pPager) ,4,4,8
 pBt->autoVacuum || iMeta==0 ,4,4,8
 db->pSavepoint==0 || db->autoCommit==0 ,4,4,8
m_value.outerType == KindOfRef || m_value.innerType == KindOfInvalid,4,4,8
 apNew[0]->nFree == (get2byte(&apNew[0]->aData[5])-apNew[0]->cellOffset-apNew[0]->nCell*2) ,4,4,8
 ((VTable *)zP4)->db==p->db ,4,4,8
 pSel ,4,4,8
 pPage->nFree>=nByte ,4,4,8
 desiredEnc==SQLITE_UTF8 || desiredEnc==SQLITE_UTF16LE || desiredEnc==SQLITE_UTF16BE ,4,4,8
!o_attribute && m_kind == HeaderKind::Object && !m_count,4,4,8
 pE->op!=TK_DOT || (pE->pLeft!=0 && pE->pLeft->op==TK_ID) ,4,4,8
 pc>=0 && pc<p->nOp ,4,4,8
 0==(p->db->flags&SQLITE_ReadUncommitted) || eLock==WRITE_LOCK ,4,4,8
 sizeof(res.azResult[0])>= sizeof(res.nData) ,4,4,8
 pMem1->enc==pMem2->enc ,4,4,8
 pPage->cellOffset == hdr + 12 - 4*pPage->leaf ,4,4,8
 pExpr->u.zToken[0]!=0 ,4,4,8
p->iSize<=p->nBuf,4,4,8
 EIGHT_BYTE_ALIGNMENT(aSpace1) ,4,4,8
 (nCellKey & SQLITE_MAX_U32)==(u64)nCellKey ,4,4,8
 zTab==0 && zDb==0 ,4,4,8
 start>=pPage->hdrOffset+6+pPage->childPtrSize ,4,4,8
newMask <= std::numeric_limits<uint32_t>::max(),4,4,8
" SQLITE_OK==querySharedCacheTableLock(p, MASTER_ROOT, READ_LOCK) ",4,4,8
 iDb<SQLITE_MAX_ATTACHED+2 ,4,4,8
 u.bg.pC->isTable ,4,4,8
 pParse==sqlite3ParseToplevel(pParse) ,4,4,8
"e, file, line, func",4,4,8
 sizeof(u64)==8 || sizeof(u64)==4 ,4,4,8
 pFrom->nSrc==1 ,4,4,8
 pList->a!=0 ,4,4,8
 MX_CELL_SIZE(pBt) >= nCell ,4,4,8
nNumberOfBytesToUnlockLow == (DWORD)SHARED_SIZE || nNumberOfBytesToUnlockLow == 1,4,4,8
 pPg->nRef>0 || pPg->pPager->memDb ,4,4,8
 pOp->p3<pOp->p1 || pOp->p3>=pOp->p1+pOp->p2 ,4,4,8
 !isOpen(pPager->jfd) ,4,4,8
nNumberOfBytesToUnlockLow == (DWORD)SHARED_SIZE,4,4,8
 n>0 && tokenType!=TK_ILLEGAL ,4,4,8
 (addr>=0 && addr<p->nOp) || p->db->mallocFailed ,4,4,8
 pLevel->plan.wsFlags & WHERE_IN_ABLE ,4,4,8
" (x = va_arg(ap,int))!=0 ",4,4,8
 pExcept==0 || pExcept->pBt==pBt ,4,4,8
 pOp->p2>0 && pOp->p2<p->nOp ,4,4,8
 nFarg>=2 ,4,4,8
 pName2!=0 ,4,4,8
 nKey==4 ,4,4,8
 p->pNext==0 || p->pNext->db==p->db ,4,4,8
isValid(position),4,4,8
acc->m_type == KindOfInt64,4,4,8
n2 >= 0,4,4,8
 sqlite3GlobalConfig.nRefInitMutex==0 ,4,4,8
 pPage->nCell==0 ,4,4,8
 to_op==OP_ToInt || aff!=SQLITE_AFF_INTEGER ,4,4,8
 (pLevel->plan.wsFlags & WHERE_IDX_ONLY)==0 || (pLevel->plan.wsFlags & WHERE_INDEXED)!=0 ,4,4,8
 useTempTable==0 ,4,4,8
 !pBt->pPage1 && !pBt->pCursor ,4,4,8
 p2==0 ,4,4,8
 pOther!=pDef && pOther->pNext!=pDef ,4,4,8
 pOrTerm->leftCursor==iCursor ,4,4,8
 pVar->flags & MEM_Blob ,4,4,8
 pColl ,4,4,8
 db2 ,4,4,8
 pNew->nCol>0 ,4,4,8
Segment,4,4,8
 pExpr->op!=TK_NOTNULL || op==OP_IsNull ,4,4,8
 pExpr->flags&EP_xIsSelect ,4,4,8
 pExpr->op==TK_EQ || pExpr->op==TK_IN || pExpr->op==TK_LT || pExpr->op==TK_GT || pExpr->op==TK_GE || pExpr->op==TK_LE || pExpr->op==TK_NE || pExpr->op==TK_IS || pExpr->op==TK_ISNOT ,4,4,8
 db->activeVdbeCnt>0 ,4,4,8
 N>0 ,4,4,8
 pPage->intKey==(pIdxKey==0) ,4,4,8
 pVdbe!=0 ,4,4,8
 pParse->nested<10 ,4,4,8
 sqlite3_value_type(argv[1])!=SQLITE_NULL ,4,4,8
!block->empty(),4,4,8
 pToken ,4,4,8
 p->iStatement==0 || db->flags&SQLITE_CountRows ,4,4,8
 sqlite3Isdigit(zRawSql[1]) ,4,4,8
 pId->nRef>0 ,4,4,8
 pExpr->x.pSelect==0 ,4,4,8
 pCell<pPage->aData || pCell>=&pPage->aData[pBt->pageSize] || sqlite3PagerIswriteable(pPage->pDbPage) ,4,4,8
 pCur->apPage[0]->intKey || pIdxKey ,4,4,8
 pTabList ,4,4,8
 pPager->tempFile && rc==SQLITE_OK ,4,4,8
 pgno==MASTER_ROOT+1 ,4,4,8
 i!=YY_REDUCE_USE_DFLT ,4,4,8
 nBlock>=2 ,4,4,8
 pTab==pOld ,4,4,8
 pSrc->a[iRight].pTab ,4,4,8
 !p->pFirst ,4,4,8
 db->aDb==db->aDbStatic ,4,4,8
 pStepList ,4,4,8
 db->init.busy==0 ,4,4,8
 pPrev && pPrev->pLeft && pPrev->pRight==0 ,4,4,8
!mr.empty(),4,4,8
s_.isSane(),4,4,8
pDest->eDest==SRT_Exists || pDest->eDest==SRT_Union || pDest->eDest==SRT_Except || pDest->eDest==SRT_Discard,4,4,8
 pHdr->pNext->pPrev==pHdr ,4,4,8
 p->pRightmost==p ,4,4,8
 op!=TK_GT || c==WO_GT ,4,4,8
 pMem1->enc==SQLITE_UTF8 || pMem1->enc==SQLITE_UTF16LE || pMem1->enc==SQLITE_UTF16BE ,4,4,8
 sqlite3_mutex_held(mutexOpen) ,4,4,8
 pPager->state == (tempFile ? PAGER_EXCLUSIVE : PAGER_UNLOCK) ,4,4,8
capacity() >= size(),4,4,8
 pOrderBy ,4,4,8
 p->zErrMsg==0 ,4,4,8
 TK_LE==TK_GT+1 ,4,4,8
 pCur->eState>=CURSOR_REQUIRESEEK ,4,4,8
 TK_CONCAT==OP_Concat ,4,4,8
isSane(),4,4,8
 encnames[SQLITE_UTF16BE].enc==SQLITE_UTF16BE ,4,4,8
 zBlob==sqlite3_value_blob(argv[0]) ,4,4,8
!s_singleton || s_singleton == (T*)&s_storage,4,4,8
 pId2 ,4,4,8
 cursorHoldsMutex(pCsr) ,4,4,8
 enc!=0 ,4,4,8
 z[0]=='?' ,4,4,8
 pageSize==0 || (pageSize>=512 && pageSize<=SQLITE_MAX_PAGE_SIZE) ,4,4,8
 to_op==OP_ToText || aff!=SQLITE_AFF_TEXT ,4,4,8
 pzOriginTab && pzOriginCol ,4,4,8
 pOp->p4type==P4_COLLSEQ ,4,4,8
 pSel!=0 ,4,4,8
 pPager->pTmpSpace!=0 ,4,4,8
 WO_MATCH==SQLITE_INDEX_CONSTRAINT_MATCH ,4,4,8
m_kind == kMixedKind || m_kind == kPackedKind,4,4,8
!isView || pTrigger,4,4,8
sizeof(x)==sizeof(y),4,4,8
 (pIn3->flags & MEM_Real)!=0 ,4,4,8
 opcode==OP_OpenWrite || opcode==OP_OpenRead ,4,4,8
 !isOpen(pPager->jfd) && !isOpen(pPager->sjfd) ,4,4,8
 pSplit->pParent->pRight==pSplit ,4,4,8
 !sqlite3IsNaN(value) ,4,4,8
!fp->hasInvName(),4,4,8
 p->pFirst ,4,4,8
 pChild->nCell==pRoot->nCell ,4,4,8
" szNew==cellSizePtr(pPage, newCell) ",4,4,8
 j==nCell ,4,4,8
 pBt->db ,4,4,8
 TK_GT>TK_EQ && TK_GT<TK_GE ,4,4,8
 allowedOp(op) ,4,4,8
 db->nDb>iDb ,4,4,8
 TK_OR==OP_Or ,4,4,8
 pFrom->nFree>=iToHdr ,4,4,8
 pTab && (pTab->tabFlags & TF_Virtual)!=0 && !pTab->pVTable ,4,4,8
 iOfst==p->endpoint.iOffset ,4,4,8
 PTF_LEAF == 1<<3 ,4,4,8
 (pBt->pageSize & 7)==0 ,4,4,8
 pPage ,4,4,8
 pNew ,4,4,8
 rcauth==SQLITE_OK || rcauth==SQLITE_DENY || rcauth==SQLITE_IGNORE ,4,4,8
 &((char*)&likeInfoAlt)[2] == (char*)&likeInfoAlt.matchSet ,4,4,8
 u.be.pC!=0 ,4,4,8
 WRITE_LOCK>READ_LOCK ,4,4,8
 EIGHT_BYTE_ALIGNMENT(SQLITE_INT_TO_PTR(journalFileSize)) ,4,4,8
 (pOrTerm->wtFlags & (TERM_ANDINFO|TERM_ORINFO))==0 ,4,4,8
 nData+nReq<=pWriter->nSize ,4,4,8
 u.bp.pC!=0 ,4,4,8
 pName2!=0 || pName1==0 ,4,4,8
IS_STRING_TYPE(m_type) && m_data.pstr,4,4,8
 TK_GE==TK_EQ+4 ,4,4,8
 idx>=0 && idx<=15 ,4,4,8
 sqlite3BtreeHoldsMutex(pBtree) ,4,4,8
 pTab->pVTable==p && p->pNext==0 ,4,4,8
"unsigned(S) <= SLAB_SIZE, ""slab too small""",4,4,8
 pSrcList && pSrcList->nSrc==1 ,4,4,8
 p->wantToLock==0 && p->locked==0 ,4,4,8
 !pLater->locked || pLater->wantToLock>0 ,4,4,8
 pTab->iPKey<0 || pExpr->iColumn!=pTab->iPKey ,4,4,8
 p->iForeGuard==(int)FOREGUARD ,4,4,8
 pSelect->pEList ,4,4,8
 mem3.aPool[i-1].u.hdr.size4x/4==nBlock ,4,4,8
"IMPLIES(m_data == mixedData(staticEmptyMixedArray()), !b)",4,4,8
 MEM_Str==(MEM_Blob>>3) ,4,4,8
m_type != KindOfRef,5,3,8
 iCol<pTab->nCol ,4,4,8
sizeof(x)==8,4,4,8
 wrFlag==0 || p->inTrans==TRANS_WRITE ,4,4,8
 rc ,4,4,8
 enc>=SQLITE_UTF8 && enc<=SQLITE_UTF16BE ,4,4,8
 pAlias!=0 ,4,4,8
irName != reg::rsp,4,4,8
 pExpr->op!=TK_EQ || op==OP_Ne ,4,4,8
 mem.pLast==pHdr ,4,4,8
 pPager->nSavepoint>0 ,4,4,8
r->tv()->m_type != KindOfRef,4,4,8
 pRight->op==TK_DOT ,4,4,8
 ovflPgno==0 || nOvfl>0 ,4,4,8
 iSavepoint>=0 || (iSavepoint==-1 && op==SAVEPOINT_ROLLBACK) ,4,4,8
!tl.base.isValid() && !tl.index.isValid() && tl.seg == Vptr::FS,4,4,8
slot >= 0 && slot <= m_nLastSlot,4,4,8
 pTab && pExpr->pTab==pTab ,4,4,8
 addr<p->nOp ,4,4,8
 db->nStatement>0 ,4,4,8
 (*ppPage)->pgno==pgno ,4,4,8
 i>=0 && i<YY_ACTTAB_COUNT ,4,4,8
" iDb==sqlite3SchemaToIndex(db, pIdx->pSchema) ",4,4,8
 u.bd.pC->isTable ,4,4,8
 db->mallocFailed || !pOffset || pLimit ,4,4,8
 sizeof(Pgno)==4 ,4,4,8
 newi > mem3.iMaster+1 ,4,4,8
 pOrTerm->u.leftColumn==iColumn ,4,4,8
"IMPLIES(isParent(), m_type.m_dt == KindOfObject)",4,4,8
 nCol==pSelect->pEList->nExpr || db->mallocFailed ,4,4,8
 pEnd->leftCursor==iCur ,4,4,8
 *ppDb || rc==SQLITE_NOMEM ,4,4,8
 start<=iLast ,4,4,8
 pLock->eLock==READ_LOCK || pLock->pBtree==p ,4,4,8
 pPage->pBt->usableSize <= SQLITE_MAX_PAGE_SIZE ,4,4,8
 (pMem->flags & (MEM_Blob|MEM_Str))!=0 ,4,4,8
 pCache->nRef==0 && pCache->pDirty==0 ,4,4,8
 db->writeVdbeCnt>0 || db->autoCommit==0 || db->nDeferredCons==0 ,4,4,8
 !pPager->aSavepoint && !pPager->pInJournal ,4,4,8
 p->nRef==1 ,4,4,8
 pParent->pHaving==0 ,4,4,8
 pTopNC!=0 ,4,4,8
"ssize_t(Empty) == ssize_t(-1), """"",4,4,8
 pFrom->a[0].pOn==0 ,4,4,8
 affinity==SQLITE_AFF_INTEGER || affinity==SQLITE_AFF_REAL || affinity==SQLITE_AFF_NUMERIC ,4,4,8
m_type == KindOfArray && m_data.parr,4,4,8
id < Id(m_namedInfo.size()),4,4,8
 pParse->pVdbe || pParse->db->mallocFailed ,4,4,8
 pCsr->isIncrblobHandle ,4,4,8
 db->aDb[iDb].pBt!=0 ,4,4,8
 pTab->nCol>0 ,4,4,8
 pBt && pBt->pPager ,4,4,8
 d<nMaxCells ,4,4,8
 pOp[-1].opcode==OP_Integer ,4,4,8
 pExpr->op!=TK_LE || op==OP_Gt ,4,4,8
 isDeferred==0 || isDeferred==1 ,4,4,8
" sz==cellSize(pPage, idx) ",4,4,8
(l.space == Location::Stack || l.space == Location::Local || l.space == Location::Iter),4,4,8
 iSrcPg!=PENDING_BYTE_PAGE(p->pSrc->pBt) ,4,4,8
 encnames[SQLITE_UTF8].enc==SQLITE_UTF8 ,4,4,8
 p->pLimit==0 ,4,4,8
 pPrg || pParse->nErr || pParse->db->mallocFailed ,4,4,8
m_kind == VALUE || m_kind == ITER,4,4,8
 pOp->p4type==P4_FUNCDEF || pOp->p4type==P4_VDBEFUNC ,4,4,8
 pSchema ,4,4,8
 db->aLimit[SQLITE_LIMIT_LENGTH]>=0 ,4,4,8
 pPager->dbSize>=nPage ,4,4,8
 pMem->zMalloc ,4,4,8
 p==0 || sqlite3_mutex_held(p->db->mutex) ,4,4,8
 pNC ,4,4,8
!pCur->aOverflow[iIdx] || pCur->aOverflow[iIdx]==nextPage,4,4,8
 pOut->zMalloc==pOut->z ,4,4,8
!(reinterpret_cast<intptr_t>(parent) & 7),4,4,8
firstSet >= begin.bitOffset(),4,4,8
 countWriteCursors(pBt)==0 ,4,4,8
 i>=0 && i<db->nDb ,4,4,8
isRefcountedType(m_type),4,4,8
 !p || p->iLastDocid<=iDocid ,4,4,8
 p->aData[p->nData]==0 ,4,4,8
 isDirectMode==0 ,4,4,8
!(m_attribute & IsRedeclared),4,4,8
 p1>=0 && p2>=0 ,4,4,8
 pParse->pTriggerTab && pParse->pToplevel ,4,4,8
 pcacheCheckSynced(pCache) ,4,4,8
 action==OE_None ,4,4,8
 pOp->opcode==OP_IdxGE ,4,4,8
 pFrom->isInit ,4,4,8
 n==4-4*pPage->leaf ,4,4,8
 pgno!=0 ,4,4,8
 pPage->pLruPrev==0 && pPage->pLruNext==0 ,4,4,8
 pSelect!=0 ,4,4,8
 aArg==aDyn || (aDyn==0 && aArg==aStatic) ,4,4,8
 pPager->journalMode==PAGER_JOURNALMODE_MEMORY ,4,4,8
 rc==SQLITE_OK || rc==SQLITE_LOCKED_SHAREDCACHE ,4,4,8
 TK_BITNOT==OP_BitNot ,4,4,8
 pzBuffer==0 || isReduced ,4,4,8
 db->pDfltColl!=0 ,4,4,8
!hasImmutableBuffer(),4,4,8
 sqlite3_mutex_held(p->s.db->mutex) ,4,4,8
 p->iReg==0 || p->iTable!=iTab || p->iColumn!=iCol ,4,4,8
 0==pCur->pKey ,4,4,8
 p->pSchema!=0 ,4,4,8
 p->iStatement==(db->nStatement+db->nSavepoint) ,4,4,8
 nPrefix<nTerm ,4,4,8
 TRANS_WRITE==pBt->inTransaction ,4,4,8
 allowedOp(pExpr->op) && pExpr->op!=TK_IN ,4,4,8
 pBt->usableSize>32 ,4,4,8
 cbrk+size<=usableSize && cbrk>=iCellFirst ,4,4,8
 nSize==debuginfo.nSize ,4,4,8
 (pVal->flags & (MEM_Ephem|MEM_Static))!=0 ,4,4,8
 pSrc->nSrc>0 ,4,4,8
 iStart>=0 ,4,4,8
 (combined_flags & MEM_RowSet)==0 ,4,4,8
 rc==SQLITE_ERROR ,4,4,8
 (pVal->flags & MEM_RowSet)==0 ,4,4,8
 (pIdxKey==0)==(pCur->pKeyInfo==0) ,4,4,8
 (piTab==0)==(piCol==0) ,4,4,8
 p && p->pPrior ,4,4,8
 i<=p->iSize ,4,4,8
 db->mallocFailed || pParse->nErr>0 || pParse->iCacheLevel==iCacheLevel ,4,4,8
 p->usesStmtJournal ,4,4,8
p || db->mallocFailed,4,4,8
 sqlite3PagerGetData(pPage->pDbPage)==pPage->aData ,4,4,8
 MAX_SECTOR_SIZE>=512 ,4,4,8
 (pExpr->iTable&0x0000FFFF)==pExpr->iTable ,4,4,8
 zSql!=0 ,4,4,8
 (isMainJrnl&~1)==0 ,4,4,8
 TK_LT>TK_EQ && TK_LT<TK_GE ,4,4,8
 sqlite3_mutex_held(pBt->db->mutex) ,4,4,8
 TK_LE>TK_EQ && TK_LE<TK_GE ,4,4,8
 j+nStr-i+1==nOut ,4,4,8
isNull() || is(KindOfArray),4,4,8
pParse->nTab==1,4,4,8
 p->iTable>=0 ,4,4,8
code != 500 || (info && *info),4,4,8
 pExpr->pRight==0 ,4,4,8
 op==TK_UPDATE || op==TK_INSERT || op==TK_DELETE ,4,4,8
 op!=TK_GE || c==WO_GE ,4,4,8
 i+size<=usableSize ,4,4,8
 sqlite3BtreeHoldsMutex(p->pSrc) ,4,4,8
 var<COLNAME_N ,4,4,8
m_chunk != m_list->m_head,4,4,8
 op==TK_CASE ,4,4,8
 (pVal->flags&MEM_Blob)==0 ,4,4,8
 (pLevel->plan.wsFlags & WHERE_IDX_ONLY)==0 || j<pIdx->nColumn ,4,4,8
 pPage->intKey || nKey>=0 ,4,4,8
 pParse->nVar==0 ,4,4,8
 pTo->db==0 || sqlite3_mutex_held(pTo->db->mutex) ,4,4,8
 pBlob==sqlite3_value_blob(argv[0]) ,4,4,8
 nExtra>=1 ,4,4,8
 pPage->pDirtyNext || pPage==p->pDirtyTail ,4,4,8
 pExpr->pTab && j<pExpr->pTab->nCol ,4,4,8
 db->nStatement>=0 && db->nSavepoint>=0 ,4,4,8
 pRight==0 || p->zMalloc==0 ,4,4,8
 sqlite3_value_type(argv[1])==SQLITE_NULL || sqlite3_context_db_handle(context)->mallocFailed ,4,4,8
 pSrc->a!=0 ,4,4,8
 checkSavepointCount(db) ,4,4,8
 createFlag==1 || createFlag==0 ,4,4,8
 p->op==TK_UNION ,4,4,8
 pRoot->nOverflow>0 ,4,4,8
 k<=n ,4,4,8
 pEnd!=0 ,4,4,8
 zRawSql[0]==':' || zRawSql[0]=='$' || zRawSql[0]=='@' ,4,4,8
 pCur->apPage[pCur->iPage]->leaf ,4,4,8
 pNode->pNext==0 ,4,4,8
 db->aDb[iDb].pBt!=0 || iDb==1 ,4,4,8
 pCur->aiIdx[pCur->iPage]==pCur->apPage[pCur->iPage]->nCell-1 ,4,4,8
 p==pIndex ,4,4,8
 (new_size & (new_size-1))==0 ,4,4,8
 !pSelect && pCons && pEnd ,4,4,8
 pParent->nOverflow==0 || pParent->nOverflow==1 ,4,4,8
 pWriter->zTerm==pWriter->zMalloc ,4,4,8
 pPage->pDirtyNext->pDirtyPrev==0 ,4,4,8
!IS_REFCOUNTED_TYPE(tDest.m_type),4,4,8
!on_create || on_create->instanceof(c_Closure::classof()),4,4,8
 iDb==1 || sqlite3BtreeHoldsMutex(db->aDb[iDb].pBt) ,4,4,8
 pc>=iCellFirst && pc<=iCellLast ,4,4,8
 pParse->pTriggerTab==0 ,4,4,8
 aData ,4,4,8
 cbrk>=iCellFirst ,4,4,8
 pPage->iKey==iOld ,4,4,8
 pExpr->op!=TK_NE || op==OP_Eq ,4,4,8
 SizeofArray(azSql)==SizeofArray(p->aStmt) ,4,4,8
 pTable->pSchema==pTrigger->pSchema || iDb==1 ,4,4,8
 !pPrior->pLimit ,4,4,8
preHash < 0 || preHash == hash(key),4,4,8
 next==0 || rc==SQLITE_DONE ,4,4,8
 db->aDb[iDb].pSchema ,4,4,8
 !db->xCollNeeded || !db->xCollNeeded16 ,4,4,8
 pWC->op==TK_AND ,4,4,8
 zSrcData ,4,4,8
 !db->init.busy || !pSelect ,4,4,8
"opc == op() && ""getExtra type error""",4,4,8
 sqlite3PagerPageRefcount(pData)>0 ,4,4,8
 i<=usableSize-4 ,4,4,8
 pgnoRoot>=3 ,4,4,8
 nKey==(i64)(int)nKey ,4,4,8
pPgnoNext,4,4,8
 pFrom->zErrMsg==0 || pFrom->nErr ,4,4,8
 !p->pGroupBy ,4,4,8
 iCur>=0 ,4,4,8
 p->locked==1 ,4,4,8
 pCsr->apPage[pCsr->iPage]->intKey ,4,4,8
"sizeof(Unaligned<T>) == sizeof(T), ""Invalid unaligned size""",4,4,8
 pLock->iTable!=1 || pLock==&p->lock ,4,4,8
 pBt->pPage1!=0 ,4,4,8
 p->nMem>9 ,4,4,8
 pDest->pTable!=pSrc->pTable ,4,4,8
 rc!=0 ,4,4,8
 iStatement>p->db->nSavepoint ,4,4,8
 tr_tm==TRIGGER_BEFORE || tr_tm==TRIGGER_AFTER ,4,4,8
" p->pRight==0 || ExprHasProperty(p->pRight, EP_IntValue) || p->pRight->u.zToken==0 || p->pRight->u.zToken[0]!=0 ",4,4,8
tv->m_type != KindOfVariant,4,4,8
!IS_REFCOUNTED_TYPE(tv.m_type),4,4,8
 argc==3 || argc==2 ,4,4,8
 pMatch->iCursor==pExpr->iTable ,4,4,8
 pPrior->pRightmost==p->pRightmost ,4,4,8
"std::has_trivial_destructor<RegSet>::value, ""RegSet must have a trivial destructor""",4,4,8
 (offset-c)<JOURNAL_HDR_SZ(pPager) ,4,4,8
 pOp->p2>0 && pOp->p2+pOp->p3<=p->nMem+1 ,4,4,8
 ppStmt && *ppStmt==0 ,4,4,8
 TK_GE==TK_LE+2 ,4,4,8
" !hasReadConflicts(pCsr->pBtree, pCsr->pgnoRoot) ",4,4,8
 isNew==1 || isNew==0 ,4,4,8
 bestJ>=0 ,4,4,8
 p1==p2 ,4,4,8
 pPager->errCode==SQLITE_FULL || pPager->errCode==SQLITE_OK || (pPager->errCode & 0xff)==SQLITE_IOERR ,4,4,8
 OP_SeekGt == OP_SeekLt+3 ,4,4,8
 iFreePg<iLastPg ,4,4,8
 (isSavepnt&~1)==0 ,4,4,8
"IMPLIES(isSelf(), m_type.m_dt == KindOfObject)",4,4,8
 TK_SLASH==OP_Divide ,4,4,8
 pStep->op==TK_SELECT ,4,4,8
 pExpr->iTable==0 || pExpr->iTable==1 ,4,4,8
 p->rc==SQLITE_OK || p->rc==SQLITE_BUSY || p->rc==SQLITE_NOMEM ,4,4,8
 nTemp>=20 ,4,4,8
 nCell==get2byte(&data[hdr+3]) ,4,4,8
" memcmp(&info, &pCur->info, sizeof(info))==0 ",4,4,8
 EIGHT_BYTE_ALIGNMENT(*ppFrom) ,4,4,8
 pSem ,4,4,8
" get4byte(findCell(pParent, iIdx))==iChild ",4,4,8
 pBt->maxLeaf + 23 <= MX_CELL_SIZE(pBt) ,4,4,8
 j<nOld ,4,4,8
 j==0 || j>i+size ,4,4,8
 encnames[SQLITE_UTF16LE].enc==SQLITE_UTF16LE ,4,4,8
 matchSet<0x80 ,4,4,8
 (pSelect->selFlags & SF_Resolved)!=0 ,4,4,8
" chngToIN==getMask(pMaskSet, iCursor) ",4,4,8
 p==pOld ,4,4,8
 pMem->db->mallocFailed || flags&(MEM_Str|MEM_Blob) ,4,4,8
 i<nMaxCells ,4,4,8
 pRet && pPrev ,4,4,8
 (rc & p->db->errMask)==rc ,4,4,8
 (m-1)==toTheLeft ,4,4,8
 (p->locked==0 && p->sharable) || p->pBt->db==p->db ,4,4,8
 idx<p->nResColumn ,4,4,8
 !pPager->tempFile && isOpen(pPager->fd) ,4,4,8
m_tag == Tag::Stack,4,4,8
 pPrior<pPage->aData || pPrior>=&pPage->aData[pBt->pageSize] || sqlite3PagerIswriteable(pPage->pDbPage) ,4,4,8
 pCache!=0 ,4,4,8
 mem1.flags & MEM_Int ,4,4,8
" !ExprHasAnyProperty(pA, EP_TokenOnly|EP_Reduced) ",4,4,8
 pp && p ,4,4,8
 pList!=0 || db->mallocFailed!=0 ,4,4,8
 i<nTemp ,4,4,8
" ExprHasProperty(p, EP_Reduced)==0 ",4,4,8
 pCur->apPage[pCur->iPage]->nCell>0 ,4,4,8
 db->nDb<=2 ,4,4,8
 iLeft<iRight ,4,4,8
 rc==SQLITE_CORRUPT ,4,4,8
 sqlite3VdbeDb(v)==db ,4,4,8
 pFKey->isDeferred==0 || pFKey->isDeferred==1 ,4,4,8
 pVtab!=0 ,4,4,8
bitOffset_ < bitsPerBlock(),4,4,8
 pCur->iPage>0 ,4,4,8
 (pMem->flags & MEM_Null)!=0 || pFunc==pMem->u.pDef ,4,4,8
reg.isXMM(),4,4,8
 j<=nOut ,4,4,8
 p->explain ,4,4,8
 rc!=SQLITE_OK || (nByte>0 && nByte<=nIn) ,4,4,8
 pCol->iMem>0 ,4,4,8
 rc==SQLITE_OK || p->rc==SQLITE_CONSTRAINT ,4,4,8
 zTabName ,4,4,8
t >= KindOfString && t <= KindOfRef,4,4,8
 pPage->leaf || !pPage->intKey ,4,4,8
 p->pGroupBy==0 ,4,4,8
 (balance_deeper_called++)==0 ,4,4,8
" sqlite3GetVTable(pParse->db, pTab) ",4,4,8
nData>=1,4,4,8
 (p->selFlags & SF_Resolved)==0 ,4,4,8
 zRawSql[0] || nToken==0 ,4,4,8
writer,4,4,8
 rc!=SQLITE_OK || *ppTok ,4,4,8
id < m_info.size(),4,4,8
 pExpr->op>=TK_GT && pExpr->op<=TK_GE ,4,4,8
" sizeof(r1)==sizeof(t2) && memcmp(&r1, &t2, sizeof(r1))==0 ",4,4,8
magicDispatch(),5,3,8
 pIdx->onError!=OE_None ,4,4,8
 eType==PTRMAP_OVERFLOW2 || eType==PTRMAP_OVERFLOW1 || eType==PTRMAP_BTREE || eType==PTRMAP_ROOTPAGE ,4,4,8
 pDest->eDest==SRT_Output ,4,4,8
 sqlite3_mutex_held(sqlite3VdbeDb(p)->mutex) ,4,4,8
 !pSubParse->pAinc && !pSubParse->pZombieTab ,4,4,8
 pPage == sqlite3PagerGetExtra(pPage->pDbPage) ,4,4,8
hasValue(),4,4,8
bytes <= kMaxSmartSize,4,4,8
 pBt->pPage1 && pBt->pPage1->aData ,4,4,8
 iSavepoint>=0 || op==SAVEPOINT_ROLLBACK ,4,4,8
 pSelect->pOffset==0 ,4,4,8
 pTo->zErrMsg==0 || pTo->nErr ,4,4,8
 iSortOrder==0 || iSortOrder==1 ,4,4,8
 wrFlag==0 || wrFlag==1 ,4,4,8
 iStatement>0 ,4,4,8
 iFromCol>=0 ,4,4,8
 p->sharable || (p->pNext==0 && p->pPrev==0) ,4,4,8
"sizeof(T) <= SLAB_SIZE, ""slab too small""",4,4,8
 pDatabase==0 || pTable!=0 ,4,4,8
 pPage->aData == sqlite3PagerGetData(pPage->pDbPage) ,4,4,8
 len<=(u32)nBuf ,4,4,8
 pcache1.isInit==0 ,4,4,8
cap <= kMaxPackedCap,4,4,8
 gap+nByte<=top ,4,4,8
 z[n]=='\'' ,4,4,8
nextKeyMode_ == NextKeyMode::NONE,4,4,8
 !pSubParse->pTriggerPrg && !pSubParse->nMaxArg ,4,4,8
 pExpr->op==TK_OR ,4,4,8
 pEList!=0 && pExpr->iColumn<pEList->nExpr ,4,4,8
m_ptr > 0,4,4,8
 pTrigger || tmask==0 ,4,4,8
 sqlite3BtreeHoldsMutex(pBt) ,4,4,8
 pRes!=0 ,4,4,8
(pExpr->x.pList->nExpr % 2) == 0,4,4,8
 sqlite3_mutex_notheld(pBt->mutex) ,4,4,8
 pMem->flags & MEM_Real ,4,4,8
 pOp->p3<SQLITE_N_BTREE_META ,4,4,8
 pPage==p->pDirtyTail ,4,4,8
 *pPgno==iTrunk ,4,4,8
 !isFatalError(p->rc) ,4,4,8
 pFunc->nArg==-1 || (pFunc->nArg&0xff)==pFunc->nArg ,4,4,8
 pOp->p3==0 ,4,4,8
" sz==cellSizePtr(pPage, pCell) || (sz==8 && iChild>0) ",4,4,8
 (pKey==0)==(pCur->pKeyInfo==0) ,4,4,8
fp,5,3,8
 stateno<=YY_REDUCE_COUNT ,4,4,8
 nAlloc>=pNew->nCol && nAlloc%8==0 && nAlloc-pNew->nCol<8 ,4,4,8
 p && p->pMem && p->pFunc && p->pFunc->xStep ,4,4,8
!(*ppStmt),4,4,8
 pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT ,4,4,8
m_value.innerType != KindOfStaticString && m_value.outerType != KindOfStaticString,4,4,8
 db->pVdbe==p ,4,4,8
 TK_BITAND==OP_BitAnd ,4,4,8
 pCur->apPage[0]->intKey==1 || pCur->apPage[0]->intKey==0 ,4,4,8
 OP_SeekLe == OP_SeekLt+1 ,4,4,8
 pB!=0 ,4,4,8
dynamic_cast<Instance*>(tv->m_data.pobj),4,4,8
pExpr->x.pList->nExpr > 0,4,4,8
 zAbsoluteName[0]=='/' ,4,4,8
 pIdx->autoIndex ,4,4,8
 isOpen(pPager->fd) || pPager->noSync ,4,4,8
vfsList,4,4,8
" 0==strcmp(sqlite3_errmsg(db), ""unknown tokenizer: nosuchtokenizer"") ",4,4,8
rhs.m_data.pstr,4,4,8
pList || pParse->db->mallocFailed ,4,4,8
 i>=0 && i<=pPage->nCell+pPage->nOverflow ,4,4,8
 pNew->nCell>0 || (nNew==1 && cntNew[0]==0) ,4,4,8
 1 >= ((pMem->zMalloc && pMem->zMalloc==pMem->z) ? 1 : 0) + (((pMem->flags&MEM_Dyn)&&pMem->xDel) ? 1 : 0) + ((pMem->flags&MEM_Ephem) ? 1 : 0) + ((pMem->flags&MEM_Static) ? 1 : 0) ,4,4,8
"(boost::is_same<T,ObjectData>::value || boost::is_same<T,StringData>::value || boost::is_same<T,ArrayData>::value || boost::is_same<T,Variant>::value)",4,4,8
 p && p->pFunc && p->pFunc->xStep ,4,4,8
 pCur->cachedRowid==iRowid ,4,4,8
 pTokenizer ,4,4,8
 &((char*)&likeInfoAlt)[1] == (char*)&likeInfoAlt.matchOne ,4,4,8
 pParse->ckBase>0 ,4,4,8
 !pTrigger ,4,4,8
 i<nNew-1 || j==nCell ,4,4,8
 pVal->db==0 || sqlite3_mutex_held(pVal->db->mutex) ,4,4,8
 pTable->nCol>=0 ,4,4,8
m_arrSpec != ArraySpec::Bottom,5,3,8
 pTerm->pExpr ,4,4,8
 zPattern==sqlite3_value_text(argv[1]) ,4,4,8
 CURSOR_VALID < CURSOR_REQUIRESEEK ,4,4,8
 pName1!=0 ,4,4,8
 pTo->nVar==pFrom->nVar ,4,4,8
 pSrc->a[iLeft].pTab ,4,4,8
 cnt==db->activeVdbeCnt ,4,4,8
 iMeta==0 || iMeta==1 ,4,4,8
 pSrcIdx ,4,4,8
 p->iAddr<nOp ,4,4,8
 pbegin>addr || pbegin==0 ,4,4,8
nPage>0,4,4,8
 pcache1.isInit!=0 ,4,4,8
 db->nStatement==0 ,4,4,8
 sizeof(v)==sizeof(pMem->r) ,4,4,8
 sqlite3PagerIswriteable(pNew->pDbPage) ,4,4,8
 idxNum>=0 && idxNum<=(FTS3_FULLTEXT_SEARCH+p->nColumn) ,4,4,8
 v || db->mallocFailed ,4,4,8
 pBt->inTransaction==TRANS_WRITE && p->inTrans==TRANS_WRITE ,4,4,8
 pCur->iPage<BTCURSOR_MAX_DEPTH ,4,4,8
offset != 0u,4,4,8
 rc!=SQLITE_OK || pPage->nCell>0 || pPage->nOverflow>0 ,4,4,8
 pPage->intKey ,4,4,8
ad->kind() == kSharedKind,4,4,8
 pCur!=0 && pCur->iPage>=0 && pCur->apPage[pCur->iPage],4,4,8
 pOp->p5==0 || pOp->p5==1 ,4,4,8
!retval || (reg.n >= 0 && reg.n < 64),4,4,8
 pTerm->eOperator & (WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE|WO_MATCH) ,4,4,8
 idx<pPage->nCell ,4,4,8
 !(fg&(MEM_Str|MEM_Blob)) ,4,4,8
 (info.nData+(pPage->intKey?0:info.nKey))==info.nPayload ,4,4,8
 zName!=0 ,4,4,8
isBoxed(),4,4,8
 pTable->pSelect ,4,4,8
 (sizeof(struct MemBlockHdr)&7) == 0 ,4,4,8
" !pParse->isMultiWrite || sqlite3VdbeAssertMayAbort(v, pParse->mayAbort)",4,4,8
 pIn1 <= &p->aMem[p->nMem] ,4,4,8
 nArg==1 ,4,4,8
 op!=TK_LE || c==WO_LE ,4,4,8
 p->inTrans!=TRANS_NONE ,4,4,8
 pOp->p4type==P4_COLLSEQ || pOp->p4.pColl==0 ,4,4,8
fp->func()->isNonAsyncGenerator(),5,3,8
 to_op==OP_ToBlob || aff!=SQLITE_AFF_NONE ,4,4,8
 pPage->leaf==0 || pPage->leaf==1 ,4,4,8
 eType!=PTRMAP_FREEPAGE ,4,4,8
 flags==EXPRDUP_REDUCE || flags==0 ,4,4,8
!isVirt(),4,4,8
pos + 1 < m_used,4,4,8
 (p->flags2 & EP2_MallocedToken)==0 ,4,4,8
m_spOffset >= 0,4,4,8
 pSrc->nSrc>iRight ,4,4,8
 0==(1&SQLITE_PTR_TO_INT(pVal->z)) ,4,4,8
 rc==SQLITE_ROW || rc==SQLITE_DONE || rc==SQLITE_ERROR || rc==SQLITE_BUSY || rc==SQLITE_MISUSE ,4,4,8
 zIn==sqlite3_value_text(argv[0]) ,4,4,8
!elm->m_tv,4,4,8
 pc>=-1 && pc<p->nOp ,4,4,8
" std::is_same<LeftValue, RightValue>::value, ""Generators may ony be combined if Values are the exact same type.""",4,4,8
 (size&1)==0 ,4,4,8
 TK_PLUS==OP_Add ,4,4,8
 TK_RSHIFT==OP_ShiftRight ,4,4,8
Util::isPowerOfTwo(tab->capac),4,4,8
 pOp->p4type==P4_KEYINFO ,4,4,8
pos >= 0,4,4,8
 p->sharable==0 || p->locked==0 || p->db==p->pBt->db ,4,4,8
 mem.nCurrent[i]>=0 ,4,4,8
tv->m_type == KindOfIndirect,4,4,8
 !pPager->pTmpSpace ,4,4,8
 TOKEN.z[0] ,4,4,8
Util::isPowerOfTwo(newCapac),4,4,8
 rc==SQLITE_OK || !MEMDB ,4,4,8
 pLevel->plan.wsFlags & WHERE_INDEXED ,4,4,8
" !ExprHasProperty(p, EP_FromJoin) ",4,4,8
 a!=0 ,4,4,8
&count,4,4,8
l.isLocal(),4,4,8
 iPage>1 ,4,4,8
subtypeOf(Cell),4,4,8
 u.bi.pC->pCursor!=0 ,4,4,8
 newPgno>0 ,4,4,8
 WO_GE==SQLITE_INDEX_CONSTRAINT_GE ,4,4,8
 TK_REM==OP_Remainder ,4,4,8
 pOrWc->nTerm>=2 ,4,4,8
 pOp->p4type==P4_INTARRAY ,4,4,8
" xCmp(apSegment[i], apSegment[i+1])<0 ",4,4,8
 p->apCsr[pOp->p1]!=0 ,4,4,8
ret != NULL,4,4,8
 rc!=0 || !zName || (pColName->flags&MEM_Term)!=0 ,4,4,8
 u.bg.pC!=0 ,4,4,8
it->op() == Marker,4,4,8
 pAndTerm->pExpr ,4,4,8
 rc!=SQLITE_OK || isOpen(pFile) ,4,4,8
" !ExprHasAnyProperty(pB, EP_TokenOnly|EP_Reduced) ",4,4,8
nOverflow>0 || iOverflow<i ,4,4,8
 p->pEList && pPrior->pEList ,4,4,8
SQLITE_MAX_DEFAULT_PAGE_SIZE<=65536,4,4,8
 i==0 ,4,4,8
 autoInc==0 || autoInc==1 ,4,4,8
 !pS ,4,4,8
 pKeyDup==0 ,4,4,8
pct <= 100.0,4,4,8
 !pColl || pColl->xCmp ,4,4,8
 p->wantToLock==0 ,4,4,8
 pPage==p->pDirty ,4,4,8
 ppDb ,4,4,8
 p->sharable==0 || p->locked==0 || sqlite3_mutex_held(p->db->mutex) ,4,4,8
 nReserve>=-1 && nReserve<=255 ,4,4,8
 pDel==0 || pDel==pColl ,4,4,8
 0==pTable->pIndex ,4,4,8
 WO_LE==SQLITE_INDEX_CONSTRAINT_LE ,4,4,8
 (*ppLast)->pRight==0 ,4,4,8
 CURSOR_INVALID < CURSOR_REQUIRESEEK ,4,4,8
 pPrior!=0 && nByte>0 ,4,4,8
 pParse->pNewTrigger==pTrigger ,4,4,8
 pSrc->nSrc==1 ,4,4,8
 pTab->nCol>cnum ,4,4,8
 to_op==OP_ToReal || aff!=SQLITE_AFF_REAL ,4,4,8
 idx>0 && idx<=p->nVar ,4,4,8
 0==(pMem->flags&MEM_Dyn) && !pMem->xDel ,4,4,8
 offset%JOURNAL_HDR_SZ(pPager)==0 ,4,4,8
 pTokenizer && pModule ,4,4,8
 !pParse->pNewTrigger ,4,4,8
 eMode==PAGER_LOCKINGMODE_QUERY || eMode==PAGER_LOCKINGMODE_NORMAL || eMode==PAGER_LOCKINGMODE_EXCLUSIVE ,4,4,8
 nExtra>=nColl ,4,4,8
n != 0,4,4,8
pDup,4,4,8
 !db || pRet ,4,4,8
 pOp->p2!=0 ,4,4,8
 pParse==pWalker->pParse ,4,4,8
 EIGHT_BYTE_ALIGNMENT(pPager->jfd) ,4,4,8
 SQLITE_UTF8==1 && SQLITE_UTF16LE==2 && SQLITE_UTF16BE==3 ,4,4,8
 pSrcList->a[i].iCursor>=0 && pSrcList->a[i].iCursor<pParse->nTab,4,4,8
 pExpr->op!=TK_LT || op==OP_Ge ,4,4,8
m_pcOffset >= 0,4,4,8
 pTab && !pTab->pSelect && pExpr ,4,4,8
 iCur<p->nCursor ,4,4,8
static_cast<uint32_t>(rb) < 32,8,0,8
 fg & MEM_Real ,4,4,8
!on_create || on_create->instanceof(c_Closure::s_cls),4,4,8
 db->lookaside.nOut==0 ,4,4,8
 argc>1 ,4,4,8
pEList == 0 || pSelect == 0,4,4,8
 bRev==0 || bRev==1 ,4,4,8
 nExtra<1000 ,4,4,8
 pPager->dbFileSize>0 ,4,4,8
 pB->pRight==0 || pB->v<=pB->pRight->v ,4,4,8
 pTerm->leftCursor==iCur ,4,4,8
m_frame,4,4,8
v && v->isStatic(),4,4,8
 pCur->aiIdx[ii]==pCur->apPage[ii]->nCell ,4,4,8
 pB==0 || pB->pRight==0 || pB->v<=pB->pRight->v ,4,4,8
 pPg->nRef>0 ,4,4,8
 p->aCol==0 ,4,4,8
g_vmContext->m_stack.isValidAddress((uintptr_t)vmsp()),4,4,8
 nOld>0 ,4,4,8
 PENDING_BYTE+1==RESERVED_BYTE ,4,4,8
 rc==SQLITE_OK || db->nDeferredCons>0 ,4,4,8
 n<=pTab->nCol ,4,4,8
" !ExprHasAnyProperty(pExpr, EP_IntValue|EP_Reduced|EP_TokenOnly) ",4,4,8
 p->aColName!=0 ,4,4,8
 pReader->aNode ,4,4,8
m_clsSpec != ClassSpec::Bottom,5,3,8
 iPos>p->iLastPos || (iPos==0 && p->iLastPos==0) ,4,4,8
 pOp->p1+pOp->p2<=p->nMem+1 ,4,4,8
 zStr==sqlite3_value_text(argv[0]) ,4,4,8
 to_op==OP_ToNumeric || aff!=SQLITE_AFF_NUMERIC ,4,4,8
 pPgHdr==0 || rc==SQLITE_OK ,4,4,8
 (p->flags&MEM_RowSet)==0 ,4,4,8
 p->rc==SQLITE_OK || p->rc==SQLITE_BUSY ,4,4,8
 pParse->iCacheLevel>=N ,4,4,8
"offsetof(MInstrState, tvScratch) % 16 == 0, ""MInstrState members require 16-byte alignment for SSE""",4,4,8
 eStmt<SizeofArray(azSql) && eStmt>=0 ,4,4,8
 pPrevTrunk==0 ,4,4,8
 db->aDb[iDb].pSchema==pTab->pSchema ,4,4,8
" !hasReadConflicts(p, pCur->pgnoRoot) ",4,4,8
 nReserve>=0 && nReserve<=255 ,4,4,8
 chngRowid || pTrigger || hasFK || regOldRowid==regNewRowid ,4,4,8
 nByte < usableSize-8 ,4,4,8
 eLock==READ_LOCK || (p==pBt->pWriter && p->inTrans==TRANS_WRITE) ,4,4,8
ne.first,4,4,8
 pOp->opcode==OP_Eq || pOp->opcode==OP_Ne ,4,4,8
 pTableName->nSrc==1 ,4,4,8
m_kind == HeaderKind::Ref,4,4,8
 p->sharable || p->wantToLock==0 ,4,4,8
numProbes++ < m_tabMask + 1,4,4,8
 pIter->eLock==READ_LOCK || pIter->eLock==WRITE_LOCK ,4,4,8
 iHeight>=1 && iHeight<128 ,4,4,8
 sizeof(db->aLimit)==sizeof(aHardLimit) ,4,4,8
 sz > (int)sizeof(LookasideSlot*) ,4,4,8
 (*p1&0xFE)==0 && (*p2&0xFE)==0 ,4,4,8
 sqlite3PagerGetData(pPage->pDbPage) == data ,4,4,8
 pBt->usableSize > 4 ,4,4,8
 pOrig->flags & EP_Resolved ,4,4,8
 zCol ,4,4,8
" !usedAsColumnCache(pParse, i, i+n-1) ",4,4,8
 iDb==1 ,4,4,8
 pPage->pDirtyNext==0 && pPage->pDirtyPrev==0 && p->pDirty!=pPage ,4,4,8
k->m_type != KindOfRef,4,4,8
 f1&MEM_Int ,4,4,8
 pIn3->flags & MEM_Blob ,4,4,8
!ad->isStatic(),4,4,8
 pStart->leftCursor==iCur ,4,4,8
 pOut<=&aMem[p->nMem] ,4,4,8
pEList != 0 || pSelect != 0 || db->mallocFailed,4,4,8
 !pMemPage || pMemPage->pgno==iPage ,4,4,8
 p2==p1 ,4,4,8
 sizeof(*p)==BITVEC_SZ ,4,4,8
 pBt->autoVacuum==1 || pBt->autoVacuum==0 ,4,4,8
 TK_BITOR==OP_BitOr ,4,4,8
end.n_ == -1,4,4,8
 ppIdx && *ppIdx==0 ,4,4,8
 pItem->zName==0 ,4,4,8
 pCell!=0 ,4,4,8
 op==TK_INSERT || op==TK_UPDATE || op==TK_DELETE ,4,4,8
 db == v->db ,4,4,8
 !pPrior->pOrderBy ,4,4,8
 p->isTable ,4,4,8
 iTarget>0 ,4,4,8
" hasSharedCacheTableLock(pCsr->pBtree, pCsr->pgnoRoot, 0, 2) ",4,4,8
 nCell<=nMaxCell ,4,4,8
 pExpr->op!=TK_GE || op==OP_Lt ,4,4,8
 pBt->incrVacuum==1 || pBt->incrVacuum==0 ,4,4,8
 sqlite3PagerPagenumber(pPage->pDbPage)==pPage->pgno ,4,4,8
 pNC->nRef>=nRef ,4,4,8
 iFreePg==iLastPg ,4,4,8
 eDest==SRT_Output || eDest==SRT_Coroutine ,4,4,8
 pOp>p->aOp ,4,4,8
 regOld==0 && regNew!=0 ,4,4,8
 pOp->p4.pVtab!=0 ,4,4,8
 sizeof(u16)==2 ,4,4,8
 pLoop->addrOpenEphm[1]<0 ,4,4,8
 azCols[i]!=0 ,4,4,8
 p->nResColumn==pOp->p2 ,4,4,8
 pExpr->pLeft ,4,4,8
 p->addrOpenEphm[1] == -1 ,4,4,8
 pNC->pSrcList!=0 ,4,4,8
address,4,4,8
 p1>=0 && p1<(pTab->nCol*2+2) ,4,4,8
" hasSharedCacheTableLock(p, iTable, pKeyInfo!=0, wrFlag+1) ",4,4,8
 p->op==TK_INTERSECT ,4,4,8
"alignof(Unaligned<T>) == 1, ""Invalid alignment""",4,4,8
 pSrc && iFrom>=0 && iFrom<pSrc->nSrc ,4,4,8
 pSubSrc ,4,4,8
m_fullName != NULL,4,4,8
 (regOld==0)!=(regNew==0) ,4,4,8
r.n != -1,4,4,8
" 0==PTRMAP_ISPAGE(pBt, PENDING_BYTE_PAGE(pBt)) ",4,4,8
 !paiCol || *paiCol==0 ,4,4,8
 pTable->aCol==0 ,4,4,8
 aOp && !p->db->mallocFailed ,4,4,8
 pDb!=0 ,4,4,8
 (pTerm->wtFlags & TERM_ORINFO)!=0 ,4,4,8
 pCache->bPurgeable || createFlag!=1 ,4,4,8
 iDb>=2 ,4,4,8
 pIdx->nColumn==1 ,4,4,8
 pNew->nOverflow==0 ,4,4,8
 pPager->memDb==0 ,4,4,8
 iCol>=-1 && iCol<32768 ,4,4,8
 WO_EQ==SQLITE_INDEX_CONSTRAINT_EQ ,4,4,8
t == KindOfArray,4,4,8
 pCur->wrFlag ,4,4,8
 rc!=SQLITE_BUSY && rc!=SQLITE_LOCKED ,4,4,8
 pTab!=0 && pTab->zName!=0 ,4,4,8
 u.bi.pC!=0 ,4,4,8
not(Uninit) || equals(Cell),4,4,8
 yyact == YYNSTATE + YYNRULE + 1 ,4,4,8
 pParent!=p ,4,4,8
 pFrom->a[0].pUsing==0 ,4,4,8
 p1>=0 && p1<db->nDb ,4,4,8
 z && zName ,4,4,8
zType[i-1]==' ',4,4,8
 p->inTrans>TRANS_NONE && pBt->inTransaction>TRANS_NONE ,4,4,8
 zCsr <= &((char *)p)[nByte] ,4,4,8
 eLock==READ_LOCK || pIter->pBtree==p || pIter->eLock==READ_LOCK,4,4,8
 WO_GT==SQLITE_INDEX_CONSTRAINT_GT ,4,4,8
 db->init.iDb==0 || db->init.busy ,4,4,8
 pExpr->op==TK_COLUMN || pExpr->op==TK_TRIGGER ,4,4,8
 pEList->nExpr==nColumn ,4,4,8
 !pPgOld || pPgOld->nRef==1 ,4,4,8
 nIncr==1 ,4,4,8
 pRoot->isInit && (pCur->pKeyInfo==0)==pRoot->intKey ,4,4,8
 sz==info.nPayload ,4,4,8
 (rc & (v->db->errMask))==rc ,4,4,8
 nArg<=(int)ArraySize(aStatic) || aArg==aDyn ,4,4,8
 pParent==p ,4,4,8
 pParent->pGroupBy==0 ,4,4,8
 (balance_quick_called++)==0 ,4,4,8
 p->selFlags & SF_Resolved ,4,4,8
category() == isMedium || category() == isLarge,4,4,8
 iStart<=pSrc->nSrc ,4,4,8
eMode==PAGER_LOCKINGMODE_NORMAL||eMode==PAGER_LOCKINGMODE_EXCLUSIVE,4,4,8
 offset>=c ,4,4,8
 pOrig!=0 ,4,4,8
 pSub!=0 ,4,4,8
nBytes % sizeof(Cell) == 0,4,4,8
 p->sharable==0 || p->locked==0 || sqlite3_mutex_held(p->pBt->mutex) ,4,4,8
 aff1==0 || aff2==0 ,4,4,8
 db->mutex!=0 || isThreadsafe==0 || sqlite3GlobalConfig.bFullMutex==0 ,4,4,8
 pList==0 || IsVirtual(pTab)==0 ,4,4,8
"sizeof(Array) == sizeof(ArrayBase), ""Fix this.""",4,4,8
 pCol->zType==0 ,4,4,8
 (enc&3)==(enc&~SQLITE_UTF16_ALIGNED) ,4,4,8
 p==pColl ,4,4,8
 iIdx<=pParent->nCell ,4,4,8
 iReg>0 ,4,4,8
 op!=TK_IN || c==WO_IN ,4,4,8
 p->pSchema==p->pTabSchema || p->pSchema==pParse->db->aDb[1].pSchema ,4,4,8
 zB==sqlite3_value_text(argv[0]) ,4,4,8
 iDb<pParse->db->nDb ,4,4,8
 CURSOR_FAULT > CURSOR_REQUIRESEEK ,4,4,8
 !pBt->pWriter ,4,4,8
elm->m_tv,4,4,8
 TK_MINUS==OP_Subtract ,4,4,8
 !isOpen(pJournal) ,4,4,8
!isHandlerRegistered(),4,4,8
 sqlite3PagerRefcount(pBt->pPager)==1 ,4,4,8
 pBt->pCursor==0 || pBt->inTransaction>TRANS_NONE ,4,4,8
 pBt->nRef>0 ,4,4,8
 pIdx->nColumn>=nEq ,4,4,8
 pgno>0 ,4,4,8
 p->pUnlockConnection || p->pBlockingConnection ,4,4,8
 k<nNew ,4,4,8
 pIndexedBy!=0 ,4,4,8
 (isTemp & 1)==isTemp ,4,4,8
 pPage->aData ,4,4,8
 pOrTerm->wtFlags & (TERM_COPIED|TERM_VIRTUAL) ,4,4,8
 pOp->p4.i>0 && pOp->p4.i<=p->nMem ,4,4,8
 isOpen(pPager->jfd) || pPager->pInJournal==0 ,4,4,8
 pWInfo->untestedTerms ,4,4,8
 (WO_EQ<<(op-TK_EQ)) < 0x7fff ,4,4,8
 pTo->db==pFrom->db ,4,4,8
 pPager->dbSizeValid ,4,4,8
 pPayload<pPage->aData || pPayload>=&pPage->aData[pBt->pageSize] || sqlite3PagerIswriteable(pPage->pDbPage) ,4,4,8
 mem3.aPool[i+nBlock-1].u.hdr.prevSize==nBlock ,4,4,8
 (chngToIN&(chngToIN-1))==0 ,4,4,8
 nNew>0 ,4,4,8
 p->xUnlockNotify ,4,4,8
isNull() || is(KindOfString) || is(KindOfStaticString),4,4,8
 pOp->opflags==sqlite3OpcodeProperty[pOp->opcode] ,4,4,8
 p->explain==0 ,4,4,8
 u.bo.pC!=0 ,4,4,8
 pPage->aData[0]==(PTF_INTKEY|PTF_LEAFDATA|PTF_LEAF) ,4,4,8
ml_.size_ >= delta,4,4,8
 zData!=0 ,4,4,8
 pCache->nPage==nPage ,4,4,8
m_top->m_type != KindOfVariant,4,4,8
 pFKey->nCol==1 || (aiFree && pIdx) ,4,4,8
 pLeft->iColumn!=(-1) ,4,4,8
 ppStmt ,4,4,8
 !zName || xDel!=SQLITE_DYNAMIC ,4,4,8
 pTab->addColOffset>0 ,4,4,8
 get4byte(&pParent->aData[pParent->hdrOffset+8])==iChild ,4,4,8
 READ_LOCK+1==WRITE_LOCK ,4,4,8
 yyact == YY_ERROR_ACTION ,4,4,8
 db==0 || p->pUnlockConnection!=db ,4,4,8
 nLocal<=nKey ,4,4,8
 z[0]!=0 ,4,4,8
 pVTab->nRef>0 ,4,4,8
(disp & (sizeof(TypedValue) - 1)) == TVOFF(m_type),4,4,8
 pLock->pBtree->inTrans>=pLock->eLock ,4,4,8
ad->isHphpArray(),4,4,8
newInst->naryDst(),4,4,8
j < nsize,4,4,8
" !ExprHasProperty(pColExpr, EP_IntValue) ",4,4,8
 pParse->iCacheLevel==0 ,4,4,8
!getResetFlag() && data->validFullPos(*this),4,4,8
 pPage->nCell>0 ,4,4,8
 u.bn.pC!=0 ,4,4,8
 pEType!=0 ,4,4,8
 pDbPage->pBt==pBt ,4,4,8
 useJournal || pPager->tempFile ,4,4,8
 pbegin>addr ,4,4,8
 !isSavepnt ,4,4,8
 TK_AND==OP_And ,4,4,8
 q - (unsigned char *)p <= FTS3_VARINT_MAX ,4,4,8
 tempFile==PAGER_LOCKINGMODE_NORMAL || tempFile==PAGER_LOCKINGMODE_EXCLUSIVE ,4,4,8
 pName1->z ,4,4,8
 pPage->nOverflow==1 ,4,4,8
 nCellKey>intKey ,4,4,8
 !(p->db->flags&SQLITE_ReadUncommitted)||eLock==WRITE_LOCK||iTab==1 ,4,4,8
 TK_GT>TK_EQ ,4,4,8
 *pp==pId ,4,4,8
 idx>=0 && idx<pPage->nCell ,4,4,8
 (p->selFlags & SF_Expanded)!=0 ,4,4,8
 p->owner==tid ,4,4,8
 pOut->flags & MEM_Dyn ,4,4,8
 isSavepnt || pDone==0 ,4,4,8
pBt[0],4,4,8
m_main == nullptr,4,4,8
 pOp->p4.ai ,4,4,8
pX->pLeft,4,4,8
keyType.notBoxed(),4,4,8
 iTrigDb==iDb || iTrigDb==1 ,4,4,8
 pNextTo->pPrevTo==0 ,4,4,8
 (char*)&likeInfoAlt == (char*)&likeInfoAlt.matchAll ,4,4,8
 pOrderBy!=0 ,4,4,8
 j<=usableSize-4 ,4,4,8
 &pKey->aSortOrder[nCol]==&(((u8 *)pKey)[nBytes]) ,4,4,8
 rc==SQLITE_OK || pFile->pMethods==0 ,4,4,8
canSpecializeArrayKind(),4,4,8
 pOp->p4.pI64!=0 ,4,4,8
 db->flags&SQLITE_CountRows ,4,4,8
 u<=pKeyInfo->nField + 1 ,4,4,8
 idx>=1 && idx<=15 ,4,4,8
 (nBytes&(nBytes-1))==0 ,4,4,8
 TK_LSHIFT==OP_ShiftLeft ,4,4,8
BtCursor *pCur,4,4,8
 pVtab->pModule!=0 ,4,4,8
 pTerm->eOperator==WO_OR ,4,4,8
 op!=TK_LT || c==WO_LT ,4,4,8
cellIsPlausible(&cell),4,4,8
 1==sqlite3BtreeIsInTrans(pMain) ,4,4,8
 zColl ,4,4,8
 pItem && pSrc->nSrc==1 ,4,4,8
 pBt->usableSize<=pBt->pageSize && pBt->usableSize+255>=pBt->pageSize,4,4,8
 p->pTabSchema!=0 ,4,4,8
this && m_magic == kMagic,4,4,8
 pRight->op==TK_VARIABLE || pRight->op==TK_REGISTER ,4,4,8
front()->op() == DefLabel,4,4,8
ad->kind() == kVectorKind,4,4,8
e >= b,4,4,8
 pList->nExpr==2 ,4,4,8
" pCur->apPage[pCur->iPage-1], pCur->aiIdx[pCur->iPage-1], pCur->apPage[pCur->iPage]->pgno ",4,4,8
 p->nOp - i >= 3 ,4,4,8
 nByte>=0 ,4,4,8
" sqlite3ExprIsInteger(pE, &i)==0 ",4,4,8
 (p->flags2 & EP2_Irreducible)==0 ,4,4,8
 pParse->nErr==0 || rc ,4,4,8
 (*ppPage)->pPager==pPager || (*ppPage)->pPager==0 ,4,4,8
 p->pPrev==0 || p->pPrev->db==p->db ,4,4,8
 !pBt->pCursor ,4,4,8
 sizeof(zMagicHeader)==16 ,4,4,8
 pCol->affinity-SQLITE_AFF_TEXT >= 0 ,4,4,8
 p->eType==FTSQUERY_AND ,4,4,8
 pIx->pSchema==pTab->pSchema ,4,4,8
 cntNew[0]>0 || (pParent->pgno==1 && pParent->nCell==0) ,4,4,8
 sqlite3_mutex_held(p->pBt->mutex) ,4,4,8
 pBt->nTransaction>0 ,4,4,8
" !ExprHasProperty(sAggInfo.aFunc[i].pExpr, EP_xIsSelect) ",4,4,8
 pLater->sharable ,4,4,8
 pOp->p1<=p->nMem ,4,4,8
"false && ""addr was not part of any known assembler""",4,4,8
 nWrite==db->writeVdbeCnt ,4,4,8
 pStart==0 || pEnd!=0 ,4,4,8
 isMainJrnl || pDone ,4,4,8
 pIndex->onError!=OE_None ,4,4,8
 pEList->a[0].pExpr ,4,4,8
 pIn!=0 ,4,4,8
 !pReader->pOffsetList ,4,4,8
pArg->z < p->z,4,4,8
"sizeof(RefData::m_count) == TypedValueAux::auxSize, """"",4,4,8
" !ExprHasProperty(pE, EP_xIsSelect) ",4,4,8
 leafCorrection==0 ,4,4,8
canSpecializeClass() && getClass() == nullptr,4,4,8
 i > mem3.aPool[i-1].u.hdr.prevSize ,4,4,8
"offsetof(RefData, m_count) == FAST_REFCOUNT_OFFSET, """"",4,4,8
 p->nData<p->nSpace ,4,4,8
 pPg->pgno!=PAGER_MJ_PGNO(pPager) ,4,4,8
 len==sqlite3_value_bytes(argv[0]) ,4,4,8
 fg&(MEM_Int|MEM_Real) ,4,4,8
 !subjRequiresPage(pPg) || pPg->pgno<=pPg->pPager->dbSize ,4,4,8
SQLITE_DEFAULT_PAGE_SIZE<=SQLITE_MAX_DEFAULT_PAGE_SIZE,4,4,8
 db->mallocFailed || pItem->pExpr==pSpan->pExpr ,4,4,8
 mask==-1 || mask==0 ,4,4,8
 pPager->tempFile ,4,4,8
 pMaskSet->n < ArraySize(pMaskSet->ix) ,4,4,8
 nNew==1 ,4,4,8
 pList!=0 || pParse->db->mallocFailed!=0 ,4,4,8
 eOp==SAVEPOINT_ROLLBACK || eOp==SAVEPOINT_RELEASE,4,4,8
"sizeof(T) <= sizeof m_dataBits, ""Constant data was larger than supported""",4,4,8
 fd!=0 ,4,4,8
 pPage->pgno==sqlite3PagerPagenumber(pPage->pDbPage) ,4,4,8
 pParent->isInit ,4,4,8
 p->lock.pBtree==p && p->lock.iTable==1 ,4,4,8
(pg1+nPage)>pPg->pgno,4,4,8
 pWInfo->nLevel==1 || pWInfo->nLevel==pTabList->nSrc ,4,4,8
IS_REFCOUNTED_TYPE(tv->m_type),4,4,8
 TK_NOT==OP_Not ,4,4,8
 p==pBt->pWriter ,4,4,8
 zVal[nVal]=='\'' ,4,4,8
 pTab->azModuleArg && pTab->azModuleArg[0] ,4,4,8
 iLastPg>nFin ,4,4,8
 rc!=SQLITE_IOERR_BLOCKED ,4,4,8
 op!=TK_EQ || c==WO_EQ ,4,4,8
 CURSOR_VALID==pCur->eState ,4,4,8
 azResult!=0 ,4,4,8
 pPg || !MEMDB ,4,4,8
 pOld->hdrOffset==0 ,4,4,8
 mem.pFirst==pHdr ,4,4,8
 p->rc!=SQLITE_IOERR_BLOCKED ,4,4,8
 n==pPage->pgno && e==PTRMAP_OVERFLOW1 ,4,4,8
 (&p[1])==pEnd || p[0].db==p[1].db ,4,4,8
 p->zSql==0 ,4,4,8
" !ExprHasProperty(pE->pLeft, EP_IntValue) ",4,4,8
 eType!=PTRMAP_ROOTPAGE ,4,4,8
 szNew <= MX_CELL_SIZE(pBt) ,4,4,8
 p->flags&PGHDR_DIRTY ,4,4,8
 pE->pLeft!=0 ,4,4,8
subtypeOf(Gen | PtrToGen),4,4,8
!isInitialized(),4,4,8
 PAGER_LOCKINGMODE_NORMAL>=0 && PAGER_LOCKINGMODE_EXCLUSIVE>=0 ,4,4,8
 sqlite3_mutex_notheld(p->pBt->mutex) ,4,4,8
 pMem->u.pRowSet!=0 ,4,4,8
 nCol>1 ,4,4,8
 pU8[nReserve]==0x65 ,4,4,8
 u.bq.pC!=0 ,4,4,8
 iNextLeaf==iFree ,4,4,8
 pExpr->iColumn>=-1 && pExpr->iColumn<pTab->nCol ,4,4,8
 r<nMaxCells ,4,4,8
 j>=0 && j<p->nLabel ,4,4,8
 leafCorrection==0 || leafCorrection==4 ,4,4,8
 u.bi.pC->pseudoTableReg==0 ,4,4,8
 pPage->hdrOffset==(pPage->pgno==1 ? 100 : 0) ,4,4,8
 u.bh.pC!=0 ,4,4,8
 pOffset == 0 ,4,4,8
 !pCur->apPage[0]->intKey || !pCur->pKey ,4,4,8
 (pTrigger && tmask) || (pTrigger==0 && tmask==0) ,4,4,8
 info.nData==(u32)(nData+nZero) ,4,4,8
 u.bd.pC!=0 ,4,4,8
 EIGHT_BYTE_ALIGNMENT(zCsr) ,4,4,8
 nOrderBy>=nExpr || db->mallocFailed ,4,4,8
 pPage->pDirtyPrev || pPage==p->pDirty ,4,4,8
IS_REAL_TYPE(t) || t == KindOfInvalid,4,4,8
 (wctrlFlags & WHERE_ONEPASS_DESIRED)==0 || pWInfo->nLevel==1 ,4,4,8
 zRep==sqlite3_value_text(argv[2]) ,4,4,8
 pTerm->pExpr!=0 ,4,4,8
 rc==SQLITE_OK || pPage==0 ,4,4,8
 db->aDb[i].zName!=0 ,4,4,8
 !isView ,4,4,8
 rc!=SQLITE_OK || zErr==0 ,4,4,8
 p->pOffset==0 || p->pLimit!=0 ,4,4,8
pg1<=pPg->pgno,4,4,8
 pPager->needSync ,4,4,8
 (p->selFlags & SF_Aggregate)==0 ,4,4,8
 idx>0 ,4,4,8
 pTab->iPKey<pTab->nCol ,4,4,8
 db->pSavepoint || db->isTransactionSavepoint==0 ,4,4,8
v2,8,0,8
 j<pTabList->nSrc ,4,4,8
 pMem->n<=nBuf ,4,4,8
 pHdr->pPrev->pNext==pHdr ,4,4,8
 pDest && pSrc ,4,4,8
ent && !ent->isIndirect(),4,4,8
"!m_size && ""IndexedStringMap::create called more than once""",4,4,8
 contentOffset<=usableSize ,4,4,8
 (op==TK_UPDATE)==(pChanges!=0) ,4,4,8
keyType.isKnownDataType() || keyType.equals(Type::Cell),4,4,8
 pFrom->db==0 || sqlite3_mutex_held(pFrom->db->mutex) ,4,4,8
s_singleton == (T*)&s_storage,4,4,8
 pCsr->eState!=CURSOR_REQUIRESEEK ,4,4,8
 pIndex->pSchema==pTable->pSchema ,4,4,8
 pList==0 ,4,4,8
prevAr,4,4,8
 N >= ROUND8(sizeof(*p)) ,4,4,8
numProbes++ < tabMask + 1,4,4,8
 mem3.szMaster>=nBlock ,4,4,8
 eDest==SRT_Discard ,4,4,8
 p->pRightmost!=p ,4,4,8
 pCur->eState==CURSOR_VALID || pCur->eState==CURSOR_INVALID ,4,4,8
IS_STRING_TYPE(cell->m_type),4,4,8
 p->pBt->inTransaction!=TRANS_NONE || p->pBt->nTransaction==0 ,4,4,8
 pTrigger->pSchema==pTab->pSchema || pTrigger->pSchema==db->aDb[1].pSchema ,4,4,8
 pExpr->op!=TK_ISNULL || op==OP_NotNull ,4,4,8
 pFrom->db==0 || pTo->db==0 || pFrom->db==pTo->db ,4,4,8
 db->aDb[1].pSchema ,4,4,8
 (pDest->tabFlags & TF_Autoincrement)==0 ,4,4,8
 pOp->p2<SQLITE_N_BTREE_META ,4,4,8
 pName1 && pName2 ,4,4,8
rname != reg::noreg,4,4,8
 pIn1!=pOut ,4,4,8
 pCur->pVtabCursor ,4,4,8
 pExpr->x.pList==0 ,4,4,8
 sizeof(i64)==8 || sizeof(i64)==4 ,4,4,8
 nSuspect<=nSegment ,4,4,8
 pP1!=0 ,4,4,8
 pCur->eState==CURSOR_VALID || (pCur->eState==CURSOR_INVALID && loc) ,4,4,8
 pExpr->op!=TK_GT || op==OP_Le ,4,4,8
 pReader->aDoclist ,4,4,8
 !sqlite3IsNaN(*pOp->p4.pReal) ,4,4,8
 op!=0 ,4,4,8
 pTree->aData==(char *)&pTree[1] ,4,4,8
pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) || pVal->db==0 || pVal->db->mallocFailed ,4,4,8
 keyClass>=FTS3_HASH_STRING && keyClass<=FTS3_HASH_BINARY ,4,4,8
pSelect->pSrc,4,4,8
" !ExprHasProperty(p->pEList->a[0].pExpr, EP_xIsSelect) ",4,4,8
 pLower || pUpper ,4,4,8
 pMem->n + ((pMem->flags & MEM_Zero)?pMem->u.nZero:0) == (int)sqlite3VdbeSerialTypeLen(serial_type) ,4,4,8
 argc==1 || p==0 || p->n>0x7fffffff || p->n==sqlite3_aggregate_count(context) ,4,4,8
 (pTerm->wtFlags & (TERM_DYNAMIC|TERM_ORINFO|TERM_ANDINFO))==0 ,4,4,8
 p->sharable || 0==*ppIter ,4,4,8
func->isAsync() || func->isGenerator(),4,4,8
&v.m_unit == &m_unit,4,3,7
!child->isFinished(),4,3,7
m_marker.valid(),4,3,7
id >= 0,4,3,7
id < Id(m_mergeInfo->m_firstHoistablePreClass),4,3,7
"false && ""IndexedStringMap::Builder overflowed""",4,3,7
m_acquires == 0,4,3,7
!getResetFlag(),4,3,7
m_type == KindOfRef,4,3,7
threadCount >= 1,4,3,7
!isUnion(),4,3,7
isSIMD(),4,3,7
!isValid() || isPhys(),4,3,7
!(m_val & uintptr_t(1U)),4,3,7
size > 0,5,2,7
!name.empty(),4,3,7
opSz == sz::qword,4,3,7
!m_hasOwner,4,3,7
isGP(),4,3,7
m_node.m_p,4,3,7
"m_acquires == 0 || pthread_equal(m_owner, pthread_self())",4,3,7
"!l.m_address && !l.m_a && ""Label was already set""",4,3,7
off >= 0 && off <= Offset(m_bclen),4,3,7
m_kind == TransKind::ProfPrologue,7,0,7
m_recursive || m_acquires == 1,4,3,7
is(KindOfResource),5,2,7
m_hdr.kind == HeaderKind::Ref,4,3,7
m_p == o.m_p,4,3,7
size_t(probe - tab->entries) < tab->capac,4,3,7
newTable->size == old->size,4,3,7
m_specialized == 0 || desiredClass()->classof(cls) || cls->classof(desiredClass()),4,3,7
func->isGenerator(),4,3,7
ssas[i],4,3,7
tv->m_type == KindOfObject || tv->m_type == KindOfRef,4,3,7
m_stmt.prepared(),4,3,7
m_hasOwner,4,3,7
kind() == Kind::ArrayVirt,4,3,7
"!""High byte registers can't be used with new x64 registers, or"" "" anything requiring a REX prefix""",4,3,7
"!m_hasOwner || pthread_equal(m_owner, pthread_self())",4,3,7
m_dirpath,4,3,7
!(op.flags & IF_BYTEREG),4,3,7
hasFunc(),4,3,7
queue,4,3,7
"!""extra<T> was called with an extra data "" ""type that doesn't match the opcode type""",4,3,7
isNull() || is(KindOfObject),4,3,7
m_queue,4,3,7
getType() == KindOfBoolean,4,3,7
od->isCollection(),4,3,7
"pthread_equal(m_owner, pthread_self())",4,3,7
currentProbe != newKey,4,3,7
cell->m_type == KindOfInt64,4,3,7
m_last - m_p >= sz,4,3,7
!func->isMethod(),4,3,7
!!s,4,3,7
instrOffset < m_bclen,4,3,7
"boost::has_trivial_destructor<data>::value, ""IR extra data type must be trivially destructible""",4,3,7
m_writeOwner != pthread_self(),4,3,7
i < m_workers.size(),4,3,7
id < Id(m_preClasses.size()),4,3,7
e != eLimit,4,3,7
scale != -1,4,3,7
!isValid(),4,3,7
static_cast<context_idx_t>(m_contexts.size()) == m_contexts.size(),4,3,7
key,4,3,7
obj->hasExactlyOneRef(),5,2,7
static_cast<uint32_t>(rt) < 32,7,0,7
tab->capac > tab->size,4,3,7
probe <= (tab->entries + tab->capac),4,3,7
"sizeof(int64_t) == sizeof(long long), ""Must be able to cast an int64* to a long long*""",4,3,7
s > 0 && s <= 8,4,3,7
&v != &null_variant,4,3,7
"int(base) != -1 && ""invalid register""",4,3,7
newTable->capac == old->capac * 2,4,3,7
!(uintptr_t(m_data) & uintptr_t(1U)),4,3,7
Attr(m_attrCopy) == m_preClass->attrs(),4,3,7
reinterpret_cast<const uintptr_t>(mem1) % 4 == 0,4,3,7
 rc==SQLITE_OK || mxLevel==0 ,3,3,6
(pc_ >= buffer_) && (pc_ < (buffer_ + buffer_size_)),3,3,6
 pSorter->nPMA==0 ,3,3,6
 p->pForest==0 ,3,3,6
 !(u.ao.pDest->flags & MEM_Dyn) ,3,3,6
 addr>=0 || p->db->mallocFailed ,3,3,6
 zFilename!=0 ,3,3,6
 (pBt->openFlags & BTREE_SINGLE)==0 || pgnoRoot==2 ,3,3,6
 rc!=SQLITE_OK || sqlite3PagerIswriteable((*ppPage)->pDbPage) ,3,3,6
 u.bs.pC!=0 ,3,3,6
 p->db==0 || p->db==db ,3,3,6
 p->eLock>=SHARED_LOCK ,3,3,6
hasVector(),3,3,6
 pCur->pgnoRoot==0 || pCur->apPage[pCur->iPage]->isInit ,3,3,6
hasCollection() && getCollectionType() == Collection::StableMapType,3,3,6
i >= 0 && i < (int) m_canonIdMap.size(),3,3,6
 pVfs ,3,3,6
 (*pNum)==SMALLEST_INT64 ,3,3,6
 strlen((char*)pFile->lockingContext)<=MAXPATHLEN ,3,3,6
 ArraySize(pPage->apOvfl)==ArraySize(pPage->aiOvfl) ,3,3,6
 SQLITE_OPEN_CREATE == 0x04 ,3,3,6
 dest.nSdst==nColumn ,3,3,6
hhvm || !v.isVarNR(),3,3,6
 IsVirtual(p) ,3,3,6
 iCell<NCELL(pNode) ,3,3,6
 i+size<=mem3.nPool+1 ,3,3,6
 (pFirstTerm->eOperator & (WO_EQ|WO_ISNULL|WO_IN))!=0 ,3,3,6
 p->aMem[i].db==p->db ,3,3,6
 (pLevel->plan.wsFlags & WHERE_ORDERED)!=0 ,3,3,6
 isSorter(u.bk.pC) ,3,3,6
 (rc&0xFF)==(rcp&0xFF) ,3,3,6
 p->cost.plan.u.pIdx==0 || (p->cost.plan.wsFlags&WHERE_ROWID_EQ)==0 ,3,3,6
 !ppDirectory || type==SQLITE_WIN32_DATA_DIRECTORY_TYPE || type==SQLITE_WIN32_TEMP_DIRECTORY_TYPE ,3,3,6
 pParse->azVar==0 ,3,3,6
(m_exprIdx >= 0 && m_exprParent) || (m_exprIdx == -1 && !m_exprParent),3,3,6
 yymsp[-2].minor.yy327!=0 ,3,3,6
 pCsr->isEof==0 ,3,3,6
 pParse->cookieGoto==0 || pParse->cookieGoto==-1 ,3,3,6
scope->getMark() != BlockScope::MarkProcessingDeps,3,3,6
sizeof(instruction) == kInstructionSize,3,3,6
 pRowSet!=0 && (pRowSet->rsFlags & ROWSET_NEXT)==0 ,3,3,6
" sizeof(unique_ptr<int>::type) == sizeof(std::unique_ptr<int>), ""smart::unique_ptr pointer should not be larger than std::unique_ptr"" ",3,3,6
 pOp->p2==SQLITE_CHECKPOINT_PASSIVE || pOp->p2==SQLITE_CHECKPOINT_FULL || pOp->p2==SQLITE_CHECKPOINT_RESTART ,3,3,6
 SQLITE_OPEN_READONLY == 0x01 ,3,3,6
 OPFLAG_BULKCSR==BTREE_BULKLOAD ,3,3,6
 i<pIdx->nSample ,3,3,6
 p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(p) ,3,3,6
 u.bc.pC->pseudoTableReg==0 ,3,3,6
 sqlite3PcacheRefCount(pPager->pPCache)==0 || pPager->tempFile ,3,3,6
 dirSync==0 || dirSync==1 ,3,3,6
"strncmp(revision, BuildInfo_kRevision, revlen) == 0",3,3,6
 pPager->tempFile==0 || eMode!=PAGER_JOURNALMODE_WAL ,3,3,6
 (pMsr->aBuffer[nList] & 0xFE)==0x00 ,3,3,6
 zDatabase!=0 || sqlite3BtreeHoldsAllMutexes(db) ,3,3,6
 isSaveLeft==0 || isExact==0 ,3,3,6
IsString(acc),3,3,6
l1.first,3,3,6
jmp->op() == Jmp_ && jmp->taken() == this,3,3,6
AnalysisResult::s_currentScopeThreadLocal->get() == (scope).get(),3,3,6
 sqlite3BtreeIsInTrans(pTo) ,3,3,6
 pCsr->pKeyInfo && pCsr->pBt==0 ,3,3,6
"ssize_t(PosType::invalid) == ArrayData::invalid_index, ""Bad design: can't have PosType::invalid and"" "" ArrayData::invalid_index mean distinct things.""",3,3,6
getKind() == Kind::GenVector,3,3,6
 SQLITE_LIMIT_TRIGGER_DEPTH==(SQLITE_N_LIMIT-1) ,3,3,6
obj->getVMClass() == c_AsyncGenerator::classof(),3,3,6
 memIsValid(u.aq.pRec) ,3,3,6
" sqlite3SchemaMutexHeld(pParse->db, 0, pTmpSchema) ",3,3,6
 rc!=SQLITE_OK || nDocSize>0 ,3,3,6
 *p==0 ,3,3,6
" !ExprHasProperty(p, EP_IntValue) || p->u.iValue>=0 ",3,3,6
check_refcount_nz(count),3,3,6
 memIsValid(&u.bc.r.aMem[i]) ,3,3,6
 aContent[aList[i]] > aContent[aList[i-1]] ,3,3,6
 u.bc.oc!=OP_SeekGt || u.bc.r.flags==UNPACKED_INCRKEY ,3,3,6
(sp & 0xf) == 0,3,3,6
sizeof(int64) == 8,3,3,6
(type_ != kNoRegister) || (code_ == 0),3,3,6
 nPathname>0 ,3,3,6
 pCsr->aMatchinfo ,3,3,6
 zArg[i]==FTS3_MATCHINFO_HITS ,3,3,6
m_kind != KindOfVectorVariant,3,3,6
 nByte==ROUND8(nByte) ,3,3,6
 zFilename!=0 || (ctrlFlags & UNIXFILE_NOLOCK)!=0 ,3,3,6
 addr>=0 ,3,3,6
 u.bf.pCx->deferredMoveto==0 ,3,3,6
 p->a || p->nSrc==0 ,3,3,6
id >= 0 && id < Id(m_namedInfo.size()),3,3,6
(pc_ >= label->target()) && (pc_ < (buffer_ + buffer_size_)),3,3,6
 pInode->pShmNode==0 ,3,3,6
 u.cr.nArg>1 && u.cr.apArg[0] && (u.cr.apArg[0]->flags&MEM_Null) ,3,3,6
 nToken==ii ,3,3,6
 sWBI.pWC->vmask==0 && pMaskSet->n==0 ,3,3,6
 pagerUseWal(pPager) ,3,3,6
m_tail == NULL,3,3,6
getClsCnsData(class_) == NULL,3,3,6
 (PAGER_JOURNALMODE_WAL & 5)==5 ,3,3,6
 p->journalMode==PAGER_JOURNALMODE_OFF || p->journalMode==PAGER_JOURNALMODE_MEMORY ,3,3,6
 csr.nSegment>0 ,3,3,6
 pNode->n<=pNode->nAlloc ,3,3,6
ret == 1,3,3,6
m_kind != kSpill,3,3,6
"offsetof(ArrayData, _count) == FAST_REFCOUNT_OFFSET, ""Offset of _count in ArrayData must be FAST_REFCOUNT_OFFSET""",3,3,6
" (sqlite3_strnicmp(argv[0], ""fts4"", 4)==0 && isFts4) || (sqlite3_strnicmp(argv[0], ""fts3"", 4)==0 && !isFts4) ",3,3,6
 nDestTruncate==0 || (i64)nDestTruncate*(i64)pgszDest >= iSize || ( nDestTruncate==(int)(PENDING_BYTE_PAGE(p->pDest->pBt)-1) && iSize>=PENDING_BYTE && iSize<=PENDING_BYTE+pgszDest ),3,3,6
 pPgHdr->pCache==pCache ,3,3,6
 !p || (p>aDoclist && p<&aDoclist[nDoclist]) ,3,3,6
 u.cc.iSet==-1 || u.cc.iSet>=0 ,3,3,6
 p->btreeMask==0 ,3,3,6
IsRegister() || IsNone(),3,3,6
e_ == other.e_,3,3,6
 get2byte(&aFrom[iFromHdr+5]) <= (int)pBt->usableSize ,3,3,6
 db->magic==SQLITE_MAGIC_OPEN || db->magic==SQLITE_MAGIC_ZOMBIE ,3,3,6
lockPath!=NULL,3,3,6
 octet>=0 && octet<256 ,3,3,6
 zFilename==0 || zFilename[0]=='/' ,3,3,6
 pBlob->pStmt || db->mallocFailed ,3,3,6
!m_externalDiamond,3,3,6
 pCsr->pSorter->pUnpacked!=0 ,3,3,6
 u.bm.pC->pCursor!=0 ,3,3,6
 u.ay.iDb>=0 && u.ay.iDb<db->nDb ,3,3,6
 (u.bh.pMem->flags & MEM_Int)!=0 ,3,3,6
 pExpr->aMI ,3,3,6
 u.bn.pC->pseudoTableReg==0 || u.bn.pC->nullRow ,3,3,6
 sqlite3BtreeCursorIsValid(u.bh.pC->pCursor) ,3,3,6
 aWalData[3]!=pWal->nCkpt || aWalData[0]<=pWal->hdr.mxFrame ,3,3,6
getTypeParam() == Type::Home,3,3,6
 u.bc.oc!=OP_SeekGe || u.bc.r.flags==0 ,3,3,6
 pWal->ckptLock==1 || pWal->ckptLock==0 ,3,3,6
 FTS3_SEGCURSOR_ALL<0 && FTS3_SEGCURSOR_PENDING<0 ,3,3,6
compressed_size > 0,3,3,6
 SQLITE_FUNC_TYPEOF==OPFLAG_TYPEOFARG ,3,3,6
 op==TK_UNION || op==TK_EXCEPT || op==TK_INTERSECT || op==TK_ALL ,3,3,6
 mem5.currentOut>=(size*mem5.szAtom) ,3,3,6
getTypeParam() == Type::Int,3,3,6
propInitVec != NULL,3,3,6
 iSpace1 <= (int)pBt->pageSize ,3,3,6
sizeof(T) == 4 || sizeof(T) == 8,3,3,6
foreachHasYield.empty(),3,3,6
 iMin<0xffffffff ,3,3,6
 p->aList==&aList[nList&~((2<<iSub)-1)] ,3,3,6
 pMem->flags&MEM_Str ,3,3,6
 SQLITE_CHECKPOINT_FULL<SQLITE_CHECKPOINT_RESTART ,3,3,6
getStack().empty(),3,3,6
type == KindOfArray,3,3,6
 p->nIndex>=1 ,3,3,6
"IMPLIES(data() == mixedData(staticEmptyMixedArray()), !b)",4,2,6
 pCache->szExtra<512 ,3,3,6
 pConstraint->op==RTREE_MATCH ,3,3,6
 pWinMemData->hHeap!=0 ,3,3,6
 db->vtabOnConflict>=1 && db->vtabOnConflict<=5 ,3,3,6
 pMem->enc!=0 ,3,3,6
 pDbFd ,3,3,6
 p->eState==PAGER_OPEN || p->eState==PAGER_READER || p->eState==PAGER_WRITER_LOCKED || p->eState==PAGER_WRITER_CACHEMOD || p->eState==PAGER_WRITER_DBMOD || p->eState==PAGER_WRITER_FINISHED || p->eState==PAGER_ERROR ,3,3,6
 p->db==pBt->db ,3,3,6
 pName->z!=0 ,3,3,6
 pExpr->bEof==0 ,3,3,6
" db==0 || sqlite3SchemaMutexHeld(db, 0, pTab->pSchema) ",3,3,6
 iStartLeaf<=iEndLeaf ,3,3,6
 nNew<=pPhrase->doclist.nList && nNew>0 ,3,3,6
hookType < InstHookTypeSDCount,3,3,6
isBoxed(type),3,3,6
 sqlite3_mutex_held(p->pCache->pGroup->mutex) ,3,3,6
"!std::is_same<Tag, void>::value, ""Must use a unique Tag to use the accessAllThreads feature""",3,3,6
n >= 0 && n < kNumRegs,3,3,6
 u.at.desiredAutoCommit==1 || u.at.iRollback==0 ,3,3,6
0 <= (int32_t)off,3,3,6
op() == OpJmpNZ || op() == OpJmpZ,3,3,6
hasCollection(),3,3,6
 pMem->z || pMem->n==0 ,3,3,6
 !pTable || pTable->nRef>0 ,3,3,6
!(reinterpret_cast<intptr_t>(parent) & ~kParentMask),4,2,6
 pOp->p2==1 || pOp->p5==OE_Fail || pOp->p5==OE_Rollback || pOp->p5==OE_Abort || pOp->p5==OE_Ignore || pOp->p5==OE_Replace ,3,3,6
hasExtraArgs() || hasVarEnv(),3,3,6
 bBulk==0 ,3,3,6
 idx <= HASHTABLE_NSLOT/2 + 1 ,3,3,6
 eType==SQLITE_OPEN_WAL || eType==SQLITE_OPEN_MAIN_JOURNAL ,3,3,6
 pPager->doNotSyncSpill==0 ,3,3,6
 *p ,3,3,6
 aMerge==aList ,3,3,6
t == FSSA,3,3,6
" sqlite3MemdebugHasType(p, MEMTYPE_SCRATCH) ",3,3,6
 pRight->bStart || pLeft->iDocid==pRight->iDocid ,3,3,6
tmp,3,3,6
hookType < (int)m_sdTables.size(),3,3,6
!m_closureGenerator || isClosure(),3,3,6
 p->iBufEnd<p->nBuffer ,3,3,6
 (pBlock[-1].u.hdr.size4x&1)!=0 ,3,3,6
 (m.flags & MEM_Dyn)!=0 || db->mallocFailed ,3,3,6
getKind() == Kind::GenArray,3,3,6
 u.cq.pVtab->pModule->xRename ,3,3,6
!t2.isUnion(),3,3,6
(numArgs & (1u << 31)) == 0,3,3,6
m_kind == Kind::Virtual,3,3,6
 cArg==FTS3_MATCHINFO_HITS ,3,3,6
!!numShapesSeen == !!shape,3,3,6
 (szPage & (szPage-1))==0 && szPage>=512 && szPage<=65536 ,3,3,6
m_magic = kMagic,3,3,6
 OE_Ignore==4 && OE_Replace==5 ,3,3,6
 j<pCsr->nSegment && pSeg->iIdx==i ,3,3,6
 aHardLimit[SQLITE_LIMIT_LENGTH]==SQLITE_MAX_LENGTH ,3,3,6
 u.ap.zAffinity[pOp->p2]==0 ,3,3,6
res >= ((int)UseKindNonStaticRef0) && res <= ((int)UseKindNonStaticRef15),3,3,6
 pReader->iCurrentBlock<=pReader->iLeafEndBlock ,3,3,6
 (PAGER_JOURNALMODE_WAL & 5)!=1 ,3,3,6
 isOpen(pPager->jfd) || pagerUseWal(pPager) ,3,3,6
 p->journalMode!=PAGER_JOURNALMODE_OFF || !isOpen(p->jfd) ,3,3,6
 (iHash==0 || iFrame>HASHTABLE_NPAGE_ONE) && (iHash>=1 || iFrame<=HASHTABLE_NPAGE_ONE) && (iHash<=1 || iFrame>(HASHTABLE_NPAGE_ONE+HASHTABLE_NPAGE)) && (iHash>=2 || iFrame<=HASHTABLE_NPAGE_ONE+HASHTABLE_NPAGE) && (iHash<=2 || iFrame>(HASHTABLE_NPAGE_ONE+2*HASHTABLE_NPAGE)) ,3,3,6
 p->xDel!=SQLITE_DYNAMIC ,3,3,6
 p->zText ,3,3,6
 sWBI.pSrc->pTab ,3,3,6
 (nByte & 7)==0 ,3,3,6
 thisMark!=READMARK_NOT_USED ,3,3,6
 state==pPager->eState ,3,3,6
(iOffset+nAlloc)>mem5.nBlock,3,3,6
scope->getMark() == BlockScope::MarkProcessed,3,3,6
 u.ca.nRoot>0 ,3,3,6
 pcache1.nFreeSlot>=0 ,3,3,6
"offsetof(SharedVariant, m_count) == TypedValueAux::auxOffset, ""Offset of m_count must equal offset of TV.m_aux""",3,3,6
 (int)pWal->szPage==szPage ,3,3,6
 pPager->eState==PAGER_OPEN || pbOpen ,3,3,6
 memIsValid(u.ai.pArg) ,3,3,6
!ar->hasVarEnv(),3,3,6
 pPhrase->aToken[0].pSegcsr ,3,3,6
 pPrior ,3,3,6
!m_cow,3,3,6
 u.aq.i==u.aq.nByte ,3,3,6
regind < bin->nregs,3,3,6
 p->eType==FTSQUERY_PHRASE || p->pPhrase==0 ,3,3,6
" sWBI.notValid & getMask(pMaskSet, pTabList->a[bestJ].iCursor) ",3,3,6
 rc!=SQLITE_OK || pSorter->iReadOff<=pSorter->iWriteOff ,3,3,6
 (PAGER_JOURNALMODE_OFF & 5)!=1 ,3,3,6
 nFull>=pVfs->mxPathname ,3,3,6
 offset==(i64)ii*(4+pPager->pageSize) ,3,3,6
 (nByte&0x00000007)==0 ,3,3,6
 nLeft>0 && nRight>0 ,3,3,6
 pStart==0 ,3,3,6
 pOp->p4type==P4_NOTUSED || pOp->p4type==P4_INT32 ,3,3,6
 aHardLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH]== SQLITE_MAX_LIKE_PATTERN_LENGTH ,3,3,6
" db==0 || sqlite3SchemaMutexHeld(db, 0, pIndex->pSchema) ",3,3,6
 nEntry==idx ,3,3,6
winSysInfo.dwAllocationGranularity > 0,3,3,6
 pPager->journalOff==JOURNAL_HDR_SZ(pPager) || !pPager->journalOff ,3,3,6
 zPrefix ,3,3,6
 pIdx->nSample>0 ,3,3,6
 isOptimal || (sWBI.cost.used&sWBI.notValid)==0 ,3,3,6
 u.bm.pC->pseudoTableReg==0 ,3,3,6
 ret>0 ,3,3,6
 aEntry[0]<key ,3,3,6
 sqlite3BtreeIsInTrans(u.cj.pBt)==0 ,3,3,6
 memIsValid(&u.bf.r.aMem[i]) ,3,3,6
 (flags & SQLITE_OPEN_URI) || zName[strlen(zName)+1]==0 ,3,3,6
output != NULL,3,3,6
 op!=TK_REGISTER || p->op2!=TK_COLLATE ,3,3,6
 pPager->eState!=PAGER_OPEN ,3,3,6
 db!=0 || rc==SQLITE_NOMEM ,3,3,6
 nTries==3 ,3,3,6
"sizeof(FieldType) == 1 || sizeof(FieldType) == 4, ""CondBlock of unimplemented field size""",3,3,6
 pCol->affinity-SQLITE_AFF_TEXT < ArraySize(azType) ,3,3,6
 idx+sz <= (int)pPage->pBt->usableSize ,3,3,6
 pReader->pBlob==0 ,3,3,6
innerType != KindOfRef,3,3,6
 pParse->pVdbe!=0 ,3,3,6
 pLeft->bStart || pLeft->iDocid==pRight->iDocid ,3,3,6
 isOpen(pPager->sjfd) || pPager->nSubRec==0 ,3,3,6
 pPager->changeCountDone==0 || pPager->eLock>=RESERVED_LOCK ,3,3,6
 eFileLock==NO_LOCK ,3,3,6
 aSample[i].eType==SQLITE_FLOAT ,3,3,6
!ret || !enqueued.empty(),3,3,6
 iRes<0 || c>=aEntry[iRes].iCode ,3,3,6
 aHardLimit[SQLITE_LIMIT_COMPOUND_SELECT]==SQLITE_MAX_COMPOUND_SELECT,3,3,6
 pColExpr!=0 ,3,3,6
 aHardLimit[SQLITE_LIMIT_FUNCTION_ARG]==SQLITE_MAX_FUNCTION_ARG ,3,3,6
 iPage>0 ,3,3,6
 sqlite3_mutex_notheld(pcache1.mutex) ,3,3,6
 !pParent || !pNode->pParent || pNode->pParent==pParent ,3,3,6
 u.bi.pKey->flags & MEM_Int ,3,3,6
 j<(int)(sizeof(pPage->apOvfl)/sizeof(pPage->apOvfl[0])) ,3,3,6
 winMutex_isInit==1 ,3,3,6
 p->zContentTbl==0 || bContent==0 ,3,3,6
 u.bm.pC->isSorter==0 ,3,3,6
 p->aList==&aList[iList&~((2<<iSub)-1)] ,3,3,6
 p->nRef==0 && p->owner==0 ,3,3,6
"offsetof(SharedVar, m_data) == offsetof(TypedValue, m_data)",3,3,6
 aHardLimit[SQLITE_LIMIT_EXPR_DEPTH]==SQLITE_MAX_EXPR_DEPTH ,3,3,6
 *pRc==SQLITE_OK ,3,3,6
"""does't work""",3,3,6
fp->resumed() == clone,4,2,6
 pNode->nRef>0 ,3,3,6
 SQLITE_DBSTATUS_CACHE_HIT+1==SQLITE_DBSTATUS_CACHE_MISS ,3,3,6
 zBuffer ,3,3,6
(intptr_t(fp) & 1) == 0,3,3,6
 mem5.currentOut>0 || mem5.currentCount==0 ,3,3,6
 p->pSrc!=0 ,3,3,6
 SQLITE_DBSTATUS_CACHE_HIT+2==SQLITE_DBSTATUS_CACHE_WRITE ,3,3,6
 sqlite3PcacheRefCount(pPager->pPCache)>0 ,3,3,6
 u.al.p2>0 && u.al.p2+mx<=p->nMem+1 ,3,3,6
*pp,3,3,6
 pNode->block.nAlloc>=p->nNodeSize ,3,3,6
 p->journalMode==PAGER_JOURNALMODE_OFF || p->useJournal ,3,3,6
 (u.af.pMem[u.af.i].flags & MEM_Ephem)==0 || (u.af.pMem[u.af.i].flags & (MEM_Str|MEM_Blob))==0 ,3,3,6
 pRoot->bStart ,3,3,6
 rc==SQLITE_OK || rc==SQLITE_FULL || rc==SQLITE_NOMEM || (rc&0xFF)==SQLITE_IOERR ,3,3,6
 iVersion==1 || iVersion==2 ,3,3,6
 p->nSample>0 ,3,3,6
 (u.ak.flags1 & MEM_Cleared)==0 ,3,3,6
 pPager->pWal==0 && pPager->tempFile==0 ,3,3,6
 u.cp.pModule->xNext ,3,3,6
 u.bj.pC->rowidIsValid ,3,3,6
 HASHTABLE_NPAGE==(1<<(ArraySize(aSub)-1)) ,3,3,6
" 0==fts3HashFind(pHash, zToken, nToken) ",3,3,6
 pWal->exclusiveMode!=WAL_HEAPMEMORY_MODE || op==-1 ,3,3,6
 (u.ca.pnErr->flags & (MEM_Str|MEM_Blob))==0 ,3,3,6
 u.bq.pCrsr ,3,3,6
 pTrunk->aData!=0 ,3,3,6
getType() == KindOfString || getType() == KindOfStaticString,3,3,6
 pCsr->pFilter==0 ,3,3,6
m_head == NULL,3,3,6
 (pPager->eLock==SHARED_LOCK) || (pPager->exclusiveMode && pPager->eLock>SHARED_LOCK) ,3,3,6
 pRoot->bEof==0 ,3,3,6
 memIsValid(&u.bv.r.aMem[i]) ,3,3,6
 nDb>0 ,3,3,6
 pFile->pShm==0 ,3,3,6
 sqlite3BtreeIsInTrans(u.au.pBt) ,3,3,6
 u.bz.iDb>=0 && u.bz.iDb<db->nDb ,3,3,6
 OP_ShiftRight==OP_ShiftLeft+1 ,3,3,6
 bufpt>zOut ,3,3,6
 u.bi.pC->iDb>=0 ,3,3,6
 aHardLimit[SQLITE_LIMIT_SQL_LENGTH]==SQLITE_MAX_SQL_LENGTH ,3,3,6
eh != NULL,3,3,6
m_vals && toUint32(pos) < m_capacity,3,3,6
 strlen(argv[0])==4 ,3,3,6
 memIsValid(u.cf.pIn1) ,3,3,6
ctx->rbufev != NULL,3,3,6
 p->pEList->a[0].pExpr->x.pList->nExpr==1 ,3,3,6
 pGroup->nMaxPage >= pCache->nMax ,3,3,6
 pFarg->a[0].pExpr!=0 ,3,3,6
 pPager->mxPgno>=pPager->dbSize ,3,3,6
 u.ai.n==0 || (pOp->p2>0 && pOp->p2+u.ai.n<=p->nMem+1) ,3,3,6
 u.bt.pC!=0 ,3,3,6
 pCsr->nSegment==0 ,3,3,6
 pPager->pWal==0 || rc==SQLITE_OK ,3,3,6
 OE_Rollback==1 && OE_Abort==2 && OE_Fail==3 ,3,3,6
 PAGER_JOURNALMODE_MEMORY==4 ,3,3,6
 pCsr->aDoclist==0 ,3,3,6
i,3,3,6
 r2==r1 ,3,3,6
 sqlite3VdbeCurrentAddr(v)==iJump ,3,3,6
getKind() == Kind::GenMap,3,3,6
 (mCovered&mSeen)==mCovered ,3,3,6
 u.ay.p2>0 ,3,3,6
 PAGER_JOURNALMODE_TRUNCATE==3 ,3,3,6
 pcache1.nFreeSlot<=pcache1.nSlot ,3,3,6
 iWrite2==0 ,3,3,6
"sizeof(TypedValue) == 16, ""emitCopyToAligned assumes sizeof(TypedValue) is 128 bits""",3,3,6
unsigned(pos) <= unsigned(m_lastE),3,3,6
 scratchAllocOut<=1 ,3,3,6
 u.al.pKeyInfo!=0 ,3,3,6
 p->inTransaction!=1 ,3,3,6
 sqlite3_value_type(apVal[0])==SQLITE_INTEGER ,3,3,6
!entry()->empty() && entry()->begin()->is(DefFP),4,2,6
nOverflow<2 || pOld->aiOvfl[0]==pOld->aiOvfl[1]-1,3,3,6
 sizeof(unsigned short)==2 && sizeof(unsigned char)==1 ,3,3,6
PROXY_HOSTIDLEN == sizeof(uuid_t),3,3,6
 p->bHasStat==p->bFts4 ,3,3,6
nOverflow<3 || pOld->aiOvfl[1]==pOld->aiOvfl[2]-1,3,3,6
 pPager->journalMode==PAGER_JOURNALMODE_DELETE || pPager->journalMode==PAGER_JOURNALMODE_MEMORY || pPager->journalMode==PAGER_JOURNALMODE_WAL ,3,3,6
getTypeParam() == Type::TCA,3,3,6
 !pWinMemData->bOwned ,3,3,6
 *pRc || pNode->block.nAlloc==0 ,3,3,6
 iValue>=0 ,3,3,6
 u.al.p2>0 && u.al.p2+u.al.n<=p->nMem+1 ,3,3,6
 ((u8 *)pOld-mem5.zPool)%mem5.szAtom==0 ,3,3,6
 pPgHdr->pExtra==(void *)&pPgHdr[1] ,3,3,6
 isIgnoreErrors==0 || (regOld!=0 && regNew==0) ,3,3,6
 u.bt.pC->deferredMoveto==0 ,3,3,6
 j+1 < ArraySize(apCopy) ,3,3,6
 pChanged ,3,3,6
u.ao.aType,3,3,6
 yymsp[-1].minor.yy327!=0 ,3,3,6
 (pBt->btsFlags & BTS_EXCLUSIVE)==0 || pBt->pWriter==pLock->pBtree ,3,3,6
getCount() <= 1,3,3,6
 u.bj.pC->pCursor!=0 ,3,3,6
isDelete && !isOpenJournal,3,3,6
 pIter->pFile ,3,3,6
 mxSafeFrame==pWal->hdr.mxFrame ,3,3,6
 n>5 && n<=9 ,3,3,6
this_->builtinPropSize() == 0,3,3,6
 memIsValid(u.cn.pQuery) ,3,3,6
 pSorter->iWriteOff==0 ,3,3,6
 rc!=SQLITE_OK || ( pPhrase->pList==0 && pPhrase->pHead==0 && pPhrase->pTail==0 ),3,3,6
 ArraySize(aSyscall)==22 ,3,3,6
 z<=zTerm ,3,3,6
 (idxStr==0 && argc==0) || (idxStr && (int)strlen(idxStr)==argc*2) ,3,3,6
 p->isEof==0 ,3,3,6
 (pMem->n+(desiredEnc==SQLITE_UTF8?1:2))<=len ,3,3,6
isUnboxed(t),3,3,6
uPattern!=0,3,3,6
 p->aNode ,3,3,6
 pIdx->azColl[i]!=0 ,3,3,6
 sqlite3PagerIswriteable(pBt->pPage1->pDbPage) ,3,3,6
is_finalized(),3,3,6
 SLOT_2_0 == ((0x7f<<14) | (0x7f)) ,3,3,6
ctx->prod_handle != NULL,3,3,6
ref->_count > 0,3,3,6
"offsetof(SharedVar, m_type) == offsetof(TypedValue, m_type)",3,3,6
check_refcount_ns(m_count),3,3,6
 y<=pWal->hdr.mxFrame ,3,3,6
 iExclude==-1 ,3,3,6
 u.bm.pC!=0 ,3,3,6
 pSorter->pUnpacked==(UnpackedRecord *)d ,3,3,6
*it > last,3,3,6
 iPage==0 || *ppPage || rc!=SQLITE_OK ,3,3,6
 memIsValid(&aMem[pOp->p2]) ,3,3,6
 PAGER_JOURNALMODE_DELETE==0 ,3,3,6
"m_branchA && ""DiamondReturn was created without being passed to UnlikelyIfBlock""",3,3,6
(size_t)nBuf>=(sizeof(time_t)+sizeof(int)),3,3,6
t1.subtypeOf(t2) || t2.subtypeOf(t1),3,3,6
 get2byteNotZero(&data[hdr+5])==nUsable ,3,3,6
 u.bi.pData->flags & (MEM_Blob|MEM_Str) ,3,3,6
refIsPlausible(ref),4,2,6
 (u.ca.pnErr->flags & MEM_Int)!=0 ,3,3,6
 page0 || pWal->writeLock==0 ,3,3,6
 pItem->isCorrelated==0 && nRef<=0 ,3,3,6
 (u.cn.pQuery->flags&MEM_Int)!=0 && u.cn.pArgc->flags==MEM_Int ,3,3,6
m_pos != ad->iter_end(),4,2,6
 pToken->pSegcsr==0 ,3,3,6
m_top->m_type == KindOfVariant,3,3,6
 nTemp==0 ,3,3,6
 (pPg->flags&PGHDR_NEED_SYNC)==0 ,3,3,6
!isGenerator || !isNotGenerator,3,3,6
 pGroup->mxPinned == pGroup->nMaxPage + 10 - pGroup->nMinPage ,3,3,6
 pGroup->pLruHead!=pPage && pGroup->pLruTail!=pPage ,3,3,6
 n==1 || lockType!=F_RDLCK ,3,3,6
 pDL->pNextDocid==0 ,3,3,6
op >= m_bc && op <= (m_bc + m_bclen),3,3,6
 isPrefix==0 || isScan==0 ,3,3,6
" iOffset==walFrameOffset(iFrame, szPage) ",3,3,6
 memIsValid(u.cq.pName) ,3,3,6
isDelete && !syncDir,3,3,6
ks && vs,3,3,6
current,3,3,6
 n<=9 ,3,3,6
m,3,3,6
 pbegin <= (int)pPage->pBt->usableSize-4 ,3,3,6
 pInode->pPrev->pNext==pInode ,3,3,6
 u.ao.pC->pVtabCursor==0 ,3,3,6
 pVfs!=0 ,3,3,6
!IsValid(),3,3,6
 u.av.iDb>=0 && u.av.iDb<db->nDb ,3,3,6
 iHeight>=0 ,3,3,6
 r2->nField>0 ,3,3,6
 pList->a!=0 || pList->nExpr==0 ,3,3,6
 !pReader->pBlob || (pFrom>=pReader->aNode && pFrom<&pReader->aNode[pReader->nNode]) ,3,3,6
 !p || (p>=aDoclist && p<=&aDoclist[nDoclist]) ,3,3,6
 u.bc.oc!=OP_SeekLe || u.bc.r.flags==UNPACKED_INCRKEY ,3,3,6
 pOp->p3<=u.bh.pFrame->nMem ,3,3,6
 (p->btreeMask & (((yDbMask)1)<<u.ay.iDb))!=0 ,3,3,6
 u.at.desiredAutoCommit==1 ,3,3,6
 (flags & BTREE_SINGLE)==0 || isTempDb ,3,3,6
 (pPager->eLock>=locktype) || (pPager->eLock==NO_LOCK && locktype==SHARED_LOCK) || (pPager->eLock==RESERVED_LOCK && locktype==EXCLUSIVE_LOCK) ,3,3,6
 pgsz>0 ,3,3,6
 p->zText!=0 || p->nChar==0 ,3,3,6
acc && acc->m_type == KindOfBoolean,3,3,6
 memIsValid(u.bi.pKey) ,3,3,6
 (p->btreeMask & (((yDbMask)1)<<pOp->p5))!=0 ,3,3,6
 iCol>=0 && iCol<pTab->nColumn ,3,3,6
 (pCache->szPage & (pCache->szPage-1))==0 && pCache->szPage>=512 ,3,3,6
 (op-SQLITE_DBSTATUS_LOOKASIDE_HIT)>=0 ,3,3,6
 rc!=SQLITE_OK || (nExpect==pSorter->iWriteOff) ,3,3,6
 u.bj.pC->iDb>=0 ,3,3,6
 iType-2 < ArraySize(winMutex_staticMutexes) ,3,3,6
 u.at.desiredAutoCommit==1 || u.at.desiredAutoCommit==0 ,3,3,6
NULL == tv || tvIsPlausible(tv),3,3,6
 v->expired==0 ,3,3,6
 zMaster[sqlite3Strlen30(zMaster)-3]=='9' ,3,3,6
 iScore>=0 ,3,3,6
 u.ao.pReg->flags & MEM_Blob ,3,3,6
 nVal==0 || nVal==1 || nVal==2 ,3,3,6
 aHardLimit[SQLITE_LIMIT_VDBE_OP]==SQLITE_MAX_VDBE_OP ,3,3,6
!loc.isLiteral(),3,3,6
callInfo,3,3,6
 pIter->aAlloc==0 ,3,3,6
(unsigned)i < m_areas.size(),3,3,6
 nArg==1 || nArg==(2 + p->nColumn + 3) ,3,3,6
 nString==0 ,3,3,6
 pTrunk!=0 ,3,3,6
 pCache->n90pct == pCache->nMax*9/10 ,3,3,6
allowable(r) || !r.isValid(),3,3,6
 szExtra < 300 ,3,3,6
 sortOrder==0 || sortOrder==1 ,3,3,6
 ((p->pBt->nPage)&0x8000000)==0 ,3,3,6
 memIsValid(&u.be.r.aMem[i]) ,3,3,6
 p->eLock!=PENDING_LOCK ,3,3,6
" iNewLevel<getAbsoluteLevel(p, iLangid, iIndex,FTS3_SEGDIR_MAXLEVEL) ",3,3,6
kind() == Kind::Direct,3,3,6
 nFToken>0 ,3,3,6
 WAL_ALL_BUT_WRITE==WAL_WRITE_LOCK+1 ,3,3,6
 pTC ,3,3,6
f != NULL,3,3,6
 u.al.p1>0 && u.al.p1+mx<=p->nMem+1 ,3,3,6
 sqlite3_mutex_held(pFile->mutex) || pFile->nRef==0 ,3,3,6
from < to,3,3,6
" sqlite3SchemaMutexHeld(db, i, 0) ",3,3,6
 u.bu.pC!=0 ,3,3,6
 pParse->nzVar==0 ,3,3,6
!hhvm || uintptr_t(this) % sizeof(TypedValue) == 0,3,3,6
check_refcount_ns(count),3,3,6
 u.bv.pC->deferredMoveto==0 ,3,3,6
cond != al,3,3,6
 pParse->pToplevel==0 ,3,3,6
 p!=0 && *p1!=0 && *p2!=0 ,3,3,6
 pNode->nAlloc>=1 ,3,3,6
 p->pInode==pFd->pInode ,3,3,6
 u.ao.p2<u.ao.nField ,3,3,6
 (eType!=SQLITE_OPEN_MAIN_DB) || (flags & SQLITE_OPEN_URI) || zUtf8Name[strlen(zUtf8Name)+1]==0 ,3,3,6
 pWriter ,3,3,6
m_freezeCount >= 0,3,3,6
 sleepObj!=NULL ,3,3,6
 (flags&0xff)==flags ,3,3,6
 op==SAVEPOINT_RELEASE||op==SAVEPOINT_ROLLBACK||op==SAVEPOINT_BEGIN ,3,3,6
 p->bFts4 ,3,3,6
 yyruleno>=0 && yyruleno<sizeof(yyRuleInfo)/sizeof(yyRuleInfo[0]) ,3,3,6
 pWal->readLock<0 ,3,3,6
 pList->pDirty==0 || isCommit ,3,3,6
 aSortOrder!=0 ,3,3,6
 *pzErrMsg==0 ,3,3,6
 rc!=SQLITE_OK || pSorter->aIter[ pSorter->aTree[1] ].pFile ,3,3,6
 eLock==SHARED_LOCK || eLock==RESERVED_LOCK || eLock==EXCLUSIVE_LOCK ,3,3,6
 pOp->p4.z==0 || pOp->p4.z==p->azVar[pOp->p1-1] ,3,3,6
 pBt->nPage!=PENDING_BYTE_PAGE(pBt) ,3,3,6
 n>=1 && n<SQLITE_SHM_NLOCK ,3,3,6
 pPager->eState!=PAGER_OPEN || pPg==0 ,3,3,6
 pCache->bPurgeable || pCache->nMin==0 ,3,3,6
 pCache->bPurgeable==0 || pCache->nMin==10 ,3,3,6
 isOpen(pPager->fd) || pPager->exclusiveMode ,3,3,6
 u.by.pDb->pBt!=0 ,3,3,6
 (sizeof(Mem5Link)&(sizeof(Mem5Link)-1))==0 ,3,3,6
 (u.bf.aMx[u.bf.nField].flags & MEM_Null)==0 ,3,3,6
 pPgHdr->pgno==pgno ,3,3,6
*it > this,3,3,6
 !p->pUnused ,3,3,6
IS_REAL_TYPE(t) || t == kInvalidDataType,3,3,6
b->preds().empty(),3,3,6
 !aPgno[idx] ,3,3,6
preClass() == NULL,3,3,6
" sqlite3MemdebugNoType(pOld, ~MEMTYPE_HEAP) ",3,3,6
 u.bj.pC->isTable ,3,3,6
 pPager->eState!=PAGER_WRITER_FINISHED ,3,3,6
!m_keys && !m_vals,3,3,6
 k>=0 && k<pSrc->nSrc ,3,3,6
 iCol>=0 && iCol<=p->nColumn+2 ,3,3,6
 mask==BTREE_BULKLOAD || mask==0 ,3,3,6
 pPager->eState==PAGER_WRITER_LOCKED || pPager->eState==PAGER_WRITER_CACHEMOD || pPager->eState==PAGER_WRITER_DBMOD ,3,3,6
 pMaskSet->n<=(int)sizeof(Bitmask)*8 ,3,3,6
 rc!=SQLITE_OK || pSorter->pTemp1 ,3,3,6
m_tag == Tag::Local,3,3,6
binind < nbins,3,3,6
 (PAGER_JOURNALMODE_MEMORY & 5)==4 ,3,3,6
 iDelta>0 || (nDoclist==0 && iDelta==iDocid) ,3,3,6
m_typeId,3,3,6
 xleft1<=xright1 && (xleft1<xright1 || xleft2<=xright2) ,3,3,6
 precision>0 ,3,3,6
 pWinMemData->magic==WINMEM_MAGIC ,3,3,6
"MaxSlabSize <= 4294967295U, ""MaxSlabSize may not be larger than UINT32_MAX""",3,3,6
 nTabList==0 || (pLevel->plan.wsFlags & WHERE_ALL_UNIQUE)!=0 ,3,3,6
 p->aMem[i].flags==MEM_Invalid ,3,3,6
 lwr==upr+1 || (pPage->intKey && !pPage->leaf) ,3,3,6
 *pRc || pNode->key.nAlloc==0 ,3,3,6
 iLeft>=nLeft || aContent[aLeft[iLeft]]>dbpage ,3,3,6
m_mergeInfo->m_firstHoistableFunc == 1,3,3,6
 eLock!=NO_LOCK || pagerUseWal(pPager)==0 ,3,3,6
 nUri>=0 ,3,3,6
 pName && pName->z ,3,3,6
 u.bl.pC->isSorter ,3,3,6
check_refcount_ns_nz(m_hdr.count),3,3,6
 pExpr->eType==FTSQUERY_PHRASE ,3,3,6
 (mem3.aPool[i-1].u.hdr.size4x&1)==1 ,3,3,6
 pPhrase->doclist.pList ,3,3,6
 pSorter->iWriteOff>iStart ,3,3,6
 rc!=SQLITE_ROW || (db->flags&SQLITE_CountRows) ,3,3,6
 !pPager->exclusiveMode || pPager->eLock==eLock ,3,3,6
 rc!=SQLITE_OK || pPager->journalOff>=szJ ,3,3,6
 p->pCache->pGroup==pGroup ,3,3,6
 bBulk==0 || bBulk==1 ,3,3,6
 SQLITE_DBSTATUS_CACHE_MISS==SQLITE_DBSTATUS_CACHE_HIT+1 ,3,3,6
 pDistinct!=0 ,3,3,6
 key>=aDia[iRes] ,3,3,6
(int)n <= kNumRegisterArgs,3,3,6
 iBlock+size-1<(u32)mem5.nBlock ,3,3,6
 eState==3 ,3,3,6
 reader.aNode ,3,3,6
 nLookaside==0 || nLookaside==db->lookaside.nOut ,3,3,6
 pParent || pNode->iNode==1 ,3,3,6
tvIsPlausible(key),3,3,6
 SQLITE_CHECKPOINT_PASSIVE+2==SQLITE_CHECKPOINT_RESTART ,3,3,6
 pIter>=&pDL->aAll[pDL->nAll] || *pIter ,3,3,6
 unionTab==dest.iSDParm || dest.eDest!=priorOp ,3,3,6
 pNode->nAlloc>=1+sqlite3Fts3VarintLen(iChild) ,3,3,6
 !fts3SegReaderIsPending(pReader) ,3,3,6
 pWInfo->eDistinct==0 ,3,3,6
 pPager->syncFlags==0 ,3,3,6
" sqlite3SchemaMutexHeld(db, 0, pIndex->pSchema) ",3,3,6
 pToken->z!=0 || pToken->n==0 ,3,3,6
 memIsValid(&aMem[pOp->p1]) ,3,3,6
 pPgHdr->pData==pPage->pBuf ,3,3,6
"k->id() < numIds(m_factory, (Key*)nullptr)",3,3,6
 pPager->doNotSpill==0 ,3,3,6
 SQLITE_OPEN_READWRITE == 0x02 ,3,3,6
waiting >= getNumDepsToWaitFor(),3,3,6
 (u.ao.payloadSize64 & SQLITE_MAX_U32)==(u64)u.ao.payloadSize64 ,3,3,6
strlen(buffer_.start()) == static_cast<size_t>(position_),3,3,6
hasObject(),3,3,6
 (m.flags & MEM_Str)!=0 || db->mallocFailed ,3,3,6
 id-2 >= 0 ,3,3,6
 pEntry->count>=0 ,3,3,6
subtypeOf(Gen | Cls),3,3,6
 nDist>0 ,3,3,6
 rc==SQLITE_OK || *ppStmt==0 ,3,3,6
 p>mem3.aPool && p<&mem3.aPool[mem3.nPool] ,3,3,6
 p->aList && p->nList<=(1<<iSub) ,3,3,6
 ((Fts3Table *)pVtab)->inTransaction ,3,3,6
 u.bg.pC->pseudoTableReg==0 ,3,3,6
 iOpt==6 ,3,3,6
 p->iOff<=p->nNode ,3,3,6
 memIsValid(u.bh.pMem) ,3,3,6
 idx==pCur->aiIdx[pCur->iPage] ,3,3,6
m == BlockScope::MarkProcessingDeps || m == BlockScope::MarkProcessed,3,3,6
 nByte>=8 ,3,3,6
 u.aq.nField>0 && pOp->p2>0 && pOp->p2+u.aq.nField<=p->nMem+1 ,3,3,6
 u.cg.n>=0 ,3,3,6
!(pfd.revents & POLLIN),3,3,6
 iSavepoint>=0 ,3,3,6
 pgszDest==sqlite3BtreeGetPageSize(p->pDest) ,3,3,6
 u.bm.pC->isTable || pOp->opcode!=OP_RowData ,3,3,6
nArg==1 || nArg==2,3,3,6
 pFile->pInode->nLock>0 || pFile->pInode->bProcessLock==0 ,3,3,6
hasIteratorObj(),3,3,6
 (p->btreeMask & (((yDbMask)1)<<pOp->p2))!=0 ,3,3,6
 pSorter->pRecord==0 ,3,3,6
 !u.bm.pC->isTable ,3,3,6
" sqlite3MemdebugNoType(p, ~MEMTYPE_SCRATCH) ",3,3,6
 c>=0 ,3,3,6
 u.ad.n>0 && u.ad.p1>0 && u.ad.p2>0 ,3,3,6
isConst(),3,3,6
 p->nToken==1 ,3,3,6
 pStep!=0 ,3,3,6
isQueryJmpOp(opc),3,3,6
m_heap.size() == 0,3,3,6
 pExpr->eType==FTSQUERY_OR || pExpr->eType==FTSQUERY_AND || pExpr->eType==FTSQUERY_NEAR ,3,3,6
(m_paramCounts >> 1) == params().size(),4,2,6
 desiredEnc==SQLITE_UTF8 ,3,3,6
 pCache->nPage >= pCache->nRecyclable ,3,3,6
mc < NumMemberCodes,3,3,6
 pPager->pWal ,3,3,6
 iCsr>=iStart ,3,3,6
 EIGHT_BYTE_ALIGNMENT(pIndex->aiRowEst) ,3,3,6
 rc!=SQLITE_OK || pPager->eState==PAGER_WRITER_LOCKED ,3,3,6
m_hdr.aux.cow == 0 || (m_hdr.aux.cow == 1 && m_count >= 1),3,3,6
 ap[1]==pBusyHandlerArg ,3,3,6
ret != -1,3,3,6
" sqlite3SchemaMutexHeld(db, idx, 0) ",3,3,6
 pCur->apPage[pCur->iPage]->nCell==0 ,3,3,6
 iDb>=0 && iDb<pParse->db->nDb ,3,3,6
 p->pgno < p->pDirty->pgno ,3,3,6
 aHardLimit[SQLITE_LIMIT_TRIGGER_DEPTH]==SQLITE_MAX_TRIGGER_DEPTH ,3,3,6
 pgno<=pBt->nPage ,3,3,6
m_mergeInfo->m_firstHoistablePreClass == 2,3,3,6
!sorted_,4,2,6
 pWal->ckptLock && pWal->hdr.mxFrame>0 ,3,3,6
"false && ""Expected register to be free""",3,3,6
nArg==2,3,3,6
it->op() == BeginCatch,3,3,6
 zFilename==0 || zFilename[0]=='/' || pVfs->pAppData==(void*)&autolockIoFinder ,3,3,6
 pPhrase->nToken==1 ,3,3,6
 iFrom>=iTo+nReg || iFrom+nReg<=iTo ,3,3,6
(unsigned)row < (unsigned)m_maxId,3,3,6
sg == SgNormal,3,3,6
 pPager->walSyncFlags==0 ,3,3,6
 pMinMax==0 || pMinMax->nExpr==1 ,3,3,6
 desiredEnc==SQLITE_UTF16BE ,3,3,6
 u.bc.pC!=0 ,3,3,6
 sqlite3_mutex_notheld(mem0.mutex) ,3,3,6
 (p->btreeMask & (((yDbMask)1)<<p1))!=0 ,3,3,6
 pFirstTerm->eOperator==WO_IN ,3,3,6
 sqlite3_data_count(pStmt)==1 ,3,3,6
marker.valid(),3,3,6
getTypeParam() == Type::StaticStr,3,3,6
 u.al.i<u.al.pKeyInfo->nField ,3,3,6
 pConstraint->pGeom ,3,3,6
 winShmMutexHeld() ,3,3,6
 memIsValid(&aMem[u.al.p1+u.al.idx]) ,3,3,6
MaxNumDataTypes - 1 <= kDataTypeMask,3,3,6
 (PAGER_JOURNALMODE_MEMORY & 5)!=1 ,3,3,6
 u.bs.pC->isSorter==(pOp->opcode==OP_SorterInsert) ,3,3,6
 pUnpacked->flags & UNPACKED_PREFIX_MATCH ,3,3,6
 (m.flags & MEM_Term)!=0 || db->mallocFailed ,3,3,6
curptr,3,3,6
 pExpr->pPhrase->iDoclistToken==0 ,3,3,6
 key>=aEntry[iRes] ,3,3,6
 pOp->p3<pOp->p2 || pOp->p3>=pOp->p2+u.ai.n ,3,3,6
 (isCommit!=0)==(nTruncate!=0) ,3,3,6
 iDb==0 || pId2->z ,3,3,6
 pExpr->bDeferred || pPhrase->doclist.bFreeList==0 ,3,3,6
 pPager->eState==PAGER_WRITER_LOCKED || pPager->eState==PAGER_WRITER_CACHEMOD || pPager->eState==PAGER_WRITER_DBMOD || pPager->eState==PAGER_ERROR ,3,3,6
 iOut>0 ,3,3,6
 p->nSample - iMin - 1 >= 0 ,3,3,6
 u.cd.pProgram->nMem+u.cd.pProgram->nCsr==u.cd.pFrame->nChildMem ,3,3,6
 pCur->eState==CURSOR_INVALID || pCur->apPage[pCur->iPage]->nCell>0 ,3,3,6
 p->pTab==0 || (p->pTab->tabFlags & TF_Virtual)!=0 ,3,3,6
 (flags & BTREE_UNORDERED)==0 || (flags & BTREE_SINGLE)!=0 ,3,3,6
 idxStr==0 ,3,3,6
 pExpr->op!=TK_AS && pExpr->op!=TK_COLLATE ,3,3,6
AnalysisResult::s_currentScopeThreadLocal->get(),3,3,6
 isOpen(pPager->jfd) || pPager->journalMode==PAGER_JOURNALMODE_OFF || pPager->journalMode==PAGER_JOURNALMODE_WAL ,3,3,6
 pPager->dbSize==pPager->dbOrigSize ,3,3,6
 pPager->eState==PAGER_WRITER_LOCKED || pPager->eState==PAGER_WRITER_FINISHED || (pagerUseWal(pPager) && pPager->eState==PAGER_WRITER_CACHEMOD) ,3,3,6
 p->apCsr[i]==0 ,3,3,6
 nWrite==0 || nWrite<=(DWORD)nRem ,3,3,6
 mem5.currentCount>0 ,3,3,6
 PAGER_JOURNALMODE_PERSIST==1 ,3,3,6
 EIGHT_BYTE_ALIGNMENT(pIndex->azColl) ,3,3,6
!((*AnalysisResult::s_currentScopeThreadLocal).get()),3,3,6
data->validFullPos(*this),3,3,6
!(static_cast<intptr_t>(kind) & ~7UL),3,3,6
 (u32)n==pLevel->plan.nEq ,3,3,6
getTypeParam() == Type::FuncPtr,3,3,6
 p->nList<=(1<<iSub) ,3,3,6
 pPager->eState==PAGER_WRITER_CACHEMOD || pPager->eState==PAGER_WRITER_DBMOD || pPager->eState==PAGER_WRITER_LOCKED ,3,3,6
 iToken!=p->iDoclistToken ,3,3,6
" sqlite3SchemaMutexHeld(db, 0, p->pSchema) ",3,3,6
"what, value",3,3,6
(size_t)res_len <= AFDT_MSGLEN,3,3,6
 pPager->eState>=PAGER_WRITER_CACHEMOD || (pPager->eState==PAGER_OPEN && pPager->eLock==EXCLUSIVE_LOCK) ,3,3,6
" GLOBAL(int, mutexIsInit) ",3,3,6
 zPath[nDb]!='\n' ,3,3,6
 aHardLimit[SQLITE_LIMIT_VARIABLE_NUMBER]==SQLITE_MAX_VARIABLE_NUMBER,3,3,6
 zByte!=0 ,3,3,6
 debugMutexHeld(pX) ,3,3,6
 u.aj.op==OP_ShiftRight || u.aj.op==OP_ShiftLeft ,3,3,6
 pVfs->mxPathname>=MAX_PATH ,3,3,6
 m.z || db->mallocFailed ,3,3,6
 pPager->eState!=PAGER_READER ,3,3,6
 u.ad.p1+u.ad.n<=u.ad.p2 || u.ad.p2+u.ad.n<=u.ad.p1 ,3,3,6
 ((int(*)(void *))(ap[0]))==xBusyHandler ,3,3,6
!getStack().empty() && getStack().back() == m_debugSavedPtr,3,3,6
 iType-2 < ArraySize(staticMutexes) ,3,3,6
getTypeParam() == Type::ClassPtr,3,3,6
 u.bm.pC->isIndex || pOp->opcode==OP_RowData ,3,3,6
hasMap(),3,3,6
!is_finalized() && position_ + n < buffer_.length(),3,3,6
 pWal->apWiData[walFramePage(pWal->hdr.mxFrame)] ,3,3,6
 u.ao.sMem.z==u.ao.sMem.zMalloc ,3,3,6
 rc!=SQLITE_ROW && rc!=SQLITE_DONE ,3,3,6
"offsetof(APCCollection, m_handle) == 0",3,3,6
 pPager->eState>=PAGER_WRITER_CACHEMOD || isMainJrnl ,3,3,6
 pthreadMutexHeld(p) ,3,3,6
 memIsValid(pIn2) ,3,3,6
"KindOfUninit == 0 && kInvalidDataType < 0, """"",4,2,6
m_finishBranchFrontier == m_branchJmp + kJumpSize,3,3,6
buf != NULL,3,3,6
 pVfs->mxPathname==MAX_PATHNAME ,3,3,6
KindOfStaticString == 0x0C,3,3,6
 pOp->opcode==OP_Noop || pOp->opcode==OP_Explain ,3,3,6
 sqlite3_mutex_held(pShmNode->mutex) || pShmNode->nRef==0 ,3,3,6
 pNode->nRef==1 ,3,3,6
 nRead>0 ,3,3,6
 (PAGER_JOURNALMODE_DELETE & 5)!=1 ,3,3,6
 (int)strlen(conchPath) == len+7 ,3,3,6
 pWal==0 || pWal->readLock>=0 ,3,3,6
 u.bo.pC->pCursor || u.bo.pC->pVtabCursor ,3,3,6
 nData==(pRtree->nDim*2 + 3) ,3,3,6
 pagerUseWal(pPager) || pageInJournal(pPg) || pPg->pgno>pPager->dbOrigSize ,3,3,6
!getVMClass()->getNativeDataInfo(),3,3,6
 badHdr==0 || pWal->writeLock==0 ,3,3,6
 p->eState!=PAGER_ERROR && p->eState!=PAGER_OPEN ,3,3,6
"sizeof(MInstrState) - sizeof(uintptr_t) < kReservedRSPScratchSpace, ""MInstrState is too large for the rsp scratch space "" ""in enterTCHelper""",3,3,6
 *pbFirst==0 || iWrite>0 ,3,3,6
 iIndexCur>=0 ,3,3,6
 p->pSchema==0 || p->zDatabase==0 ,3,3,6
 iRead==iRead2 ,3,3,6
hookType < (int)m_int64Tables.size(),3,3,6
 pItem->iOrderByCol>0 && pItem->iOrderByCol<=p->pEList->nExpr ,3,3,6
 SQLITE_FUNC_LENGTH==OPFLAG_LENGTHARG ,3,3,6
 !memDb ,3,3,6
 u.co.pModule->xColumn ,3,3,6
 nSrcPage>=0 ,3,3,6
 !pnCkpt || *pnCkpt==-1 ,3,3,6
 pSorter->aTree==0 ,3,3,6
type == KindOfVariant,3,3,6
 u.bm.pC->nullRow==0 ,3,3,6
data->getCount() <= 1 || data->noCopyOnWrite(),3,3,6
 pLower->eOperator==WO_GT || pLower->eOperator==WO_GE ,3,3,6
 pLvl->iIdxCur==iCovCur ,3,3,6
 aNext!=p->aAlloc ,3,3,6
 pIdx->azColl!=0 ,3,3,6
 SQLITE_CHECKPOINT_FULL>SQLITE_CHECKPOINT_PASSIVE ,3,3,6
 pDest->nSdst==nResultCol ,3,3,6
 pItem->iOrderByCol>0 ,3,3,6
 eMode>=0 && eMode<=ArraySize(azModeName) ,3,3,6
 (int)strlen((char*)pFile->lockingContext)<=MAXPATHLEN ,3,3,6
 (pExpr->flags & (EP_Reduced|EP_TokenOnly))==0 ,3,3,6
 pCur->pgnoRoot==0 || pCur->apPage[pCur->iPage] ,3,3,6
 pOp->opcode==OP_SorterNext ,3,3,6
keyType == StrKey,3,3,6
 p->aOp ,3,3,6
 u.cj.eNew==PAGER_JOURNALMODE_DELETE || u.cj.eNew==PAGER_JOURNALMODE_TRUNCATE || u.cj.eNew==PAGER_JOURNALMODE_PERSIST || u.cj.eNew==PAGER_JOURNALMODE_OFF || u.cj.eNew==PAGER_JOURNALMODE_MEMORY || u.cj.eNew==PAGER_JOURNALMODE_WAL || u.cj.eNew==PAGER_JOURNALMODE_QUERY ,3,3,6
" walFramePgno(pWal, iFrame)==iDbpage ",3,3,6
 eLock==NO_LOCK || eLock==SHARED_LOCK ,3,3,6
 j+1 < nOld ,3,3,6
checkCount(),6,0,6
 sqlite3_mutex_held(mem5.mutex) ,3,3,6
 bAlnum==0 || bAlnum==1 ,3,3,6
 (start + size) <= (int)pPage->pBt->usableSize ,3,3,6
"!mapContains(m, k)",3,3,6
 rc!=SQLITE_OK || isOpen(pPager->fd) ,3,3,6
!is_finalized(),3,3,6
isEphemeralServiceReq(sr) || sr == REQ_RETRANSLATE,3,3,6
c != '\0',3,3,6
i < 32,3,3,6
m_kind == Kind::Imm,3,3,6
 pPager->eState>=PAGER_READER && pPager->eState!=PAGER_ERROR ,3,3,6
 pCache->nMin==0 || pCache->bPurgeable ,3,3,6
(pc_ + sizeof(instruction)) <= (buffer_ + buffer_size_),3,3,6
 u.ca.z==0 ,3,3,6
"offsetof(SmartPtr, m_px) == kExpectedMPxOffset, """"",3,3,6
 (p->btreeMask & (((yDbMask)1)<<u.av.iDb))!=0 ,3,3,6
 pNew->pSrc!=0 || pParse->nErr>0 ,3,3,6
m_top->m_data.pref != NULL,3,3,6
ihandler,3,3,6
m_size < Store::capacity(),3,3,6
acc->m_type == KindOfString || acc->m_type == KindOfStaticString,3,3,6
 c==t ,3,3,6
 x<mem5.nBlock ,3,3,6
 u.bc.nField>0 ,3,3,6
 pMem->enc!=desiredEnc ,3,3,6
 state==PAGER_OPEN || state==PAGER_READER ,3,3,6
 iLevel==FTS3_SEGCURSOR_ALL || iLevel>=0 ,3,3,6
 (pMem->flags & (MEM_Int|MEM_Real|MEM_Null))!=0 ,3,3,6
!current->is(BlockScope::ClassScope) || !scopeToLock->is(BlockScope::FunctionScope),3,3,6
 p->aBuffer ,3,3,6
 db->autoCommit==0 || db->nVTrans==0 ,3,3,6
 u-1==LARGEST_INT64 ,3,3,6
 u.cg.apVal || u.cg.n==0 ,3,3,6
!IsNone(),3,3,6
 sqlite3_mutex_held(mem0.mutex) ,3,3,6
 memIsValid(u.ao.pReg) ,3,3,6
m_keys && toInt<uint32_t>(pos) < m_capacity,3,3,6
 pOp->p5<=ArraySize(p->aCounter) ,3,3,6
 memIsValid(&u.bt.r.aMem[i]) ,3,3,6
m_maxStackCells > 0,3,3,6
hookType < InstHookTypeInt64Count,3,3,6
 zName[strlen(zName)+1]==0 ,3,3,6
 u.bv.pC->isOrdered ,3,3,6
 pPhrase->doclist.bFreeList==0 ,3,3,6
 sizeof(RtreeCoord)==4 ,3,3,6
 sqlite3GlobalConfig.bMemstat || sqlite3GlobalConfig.bCoreMutex==0 || mem.mutex!=0 ,3,3,6
!m_shared->m_preClass,3,3,6
isSwitch(*op),3,3,6
 nArg>=(-1) || createFlag==0 ,3,3,6
 pInode->pNext->pPrev==pInode ,3,3,6
 pc==u.cd.pFrame->pc ,3,3,6
f_ >= other.f_,3,3,6
 mxReadMark<=pWal->hdr.mxFrame ,3,3,6
 pagerUseWal(pPager)==0 || (!isMainJrnl && isSavepnt) ,3,3,6
"(boost::is_base_of<ObjectData,T>::value), ""Non-ObjectData allocated in smart heap""",3,3,6
 p->nIndex>0 ,3,3,6
 pCsr->nDoclist==0 ,3,3,6
 sqlite3BtreeIsInTrans(pTo)==0 ,3,3,6
m_stats,3,3,6
 eFileLock==RESERVED_LOCK || eFileLock==EXCLUSIVE_LOCK ,3,3,6
 pPager->eLock==NO_LOCK || pPager->eLock==UNKNOWN_LOCK ,3,3,6
((uintptr_t(retval) ^ (uintptr_t(retval + 1) - 1)) & ~kCacheLineMask) == 0,3,3,6
 pPager->eState>=PAGER_READER && pPager->eState<PAGER_ERROR ,3,3,6
 (pPg->flags&PGHDR_DIRTY) || pPg->pageHash==pager_pagehash(pPg) ,3,3,6
" p->op!=TK_INTEGER || (p->flags & EP_IntValue)!=0 || sqlite3GetInt32(p->u.zToken, &rc)==0 ",3,3,6
 u.bq.pC->isSorter==(pOp->opcode==OP_SorterSort) ,3,3,6
" sqlite3SchemaMutexHeld(db, 0, pSchema) ",3,3,6
 *pbFirst || *piPrev==0 ,3,3,6
 u.cd.pProgram->nOp>0 ,3,3,6
canSpecializeClass(),3,3,6
 mem5.currentCount>0 || mem5.currentOut==0 ,3,3,6
 !pnLog || *pnLog==-1 ,3,3,6
 u.bc.oc!=OP_SeekLt || u.bc.r.flags==0 ,3,3,6
 pOp->opcode!=OP_Prev || pOp->p4.xAdvance==sqlite3BtreePrevious ,3,3,6
 nTries>1 ,3,3,6
 iIdx>=0 ,3,3,6
ad && m_pos != ad->iter_end(),4,2,6
 scratchAllocOut>=1 && scratchAllocOut<=2 ,3,3,6
 pPager->eState==PAGER_READER || pPager->eState==PAGER_OPEN || pPager->eState==PAGER_ERROR ,3,3,6
r->_count > 0,3,3,6
" sqlite3MemdebugHasType(pOld, MEMTYPE_HEAP) ",3,3,6
 u.bs.pC->deferredMoveto==0 ,3,3,6
"sizeof(SharedVariant) == sizeof(TypedValue), ""Be careful with field layout""",3,3,6
 jrnlOpen==0 || ( sqlite3OsDeviceCharacteristics(pPager->jfd) & SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN ),3,3,6
 sDistinct.isTnct ,3,3,6
 pToken->pDeferred==0 ,3,3,6
 aHardLimit[SQLITE_LIMIT_COLUMN]==SQLITE_MAX_COLUMN ,3,3,6
 u.bu.pC->deferredMoveto==0 ,3,3,6
type < InstHookTypeInt64Count,3,3,6
 pInode->nLock==0 ,3,3,6
 pMem->xDel!=SQLITE_DYNAMIC ,3,3,6
 rc==SQLITE_BUSY || (pWal->readOnly & WAL_SHM_RDONLY)!=0 ,3,3,6
!IS_REFCOUNTED_TYPE(m_type),3,3,6
 xtype==etINVALID ,3,3,6
 pCsr->zTerm==0 ,3,3,6
assertion,3,3,6
 nVal==1 || nVal==2 ,3,3,6
 p->rc==SQLITE_OK ,3,3,6
getTypeParam() == Type::VarEnvPtr,3,3,6
obj->getVMClass() == c_Generator::classof(),3,3,6
sr != REQ_BIND_JMPCC_FIRST && sr != REQ_BIND_JMPCC_SECOND && sr != REQ_BIND_JMP,3,3,6
 nDestTruncate>0 ,3,3,6
 pgno!=0 || rc==SQLITE_CORRUPT ,3,3,6
 v->db->init.busy==0 ,3,3,6
 nMin==-1 || nMin==0 || nMin<SQLITE_WIN32_DBG_BUF_SIZE ,3,3,6
t1 != None && t2 != None,3,3,6
 (pNode->a[0]=='\0')==(aDoclist!=0) ,3,3,6
!m_cls->callsCustomInstanceInit(),3,3,6
it == stack.end() || *it < this,3,3,6
 bDescDoclist==0 || bDescDoclist==1 ,3,3,6
 pIter->aBuffer==0 ,3,3,6
 u.bw.iCnt==1 ,3,3,6
 piLeaf || piLeaf2 ,3,3,6
" !ppDirectory || sqlite3MemdebugHasType(*ppDirectory, MEMTYPE_HEAP) ",3,3,6
"sizeof(FixedVector<int>) == sizeof(CompactSizedPtr<int>), ""Keeping this thing small is most of the point""",3,3,6
getTypeParam() == Type::Bool,3,3,6
spfStart == m_branchJmp,3,3,6
 i>=0 && i<p->db->nDb && i<(int)sizeof(yDbMask)*8 ,3,3,6
 u.bh.pC->isTable ,3,3,6
m_info,3,3,6
"!""Unexpected return value from ucol_strcoll()""",3,3,6
 EIGHT_BYTE_ALIGNMENT(pNew) ,3,3,6
 !piLeaf2 || !piLeaf || rc!=SQLITE_OK || (*piLeaf<=*piLeaf2) ,3,3,6
 memIsValid(u.cr.pX) ,3,3,6
 u.ay.p2<=p->nMem ,3,3,6
 pagerUseWal(pPager)==0 || szJ==0 ,3,3,6
m_kind == Loc,3,3,6
 u.al.p1>0 && u.al.p1+u.al.n<=p->nMem+1 ,3,3,6
getTypeParam() == Type::Dbl,3,3,6
m_cow == 0 || (m_cow == 1 && m_count >= 1),3,3,6
 (u.ch.pMem->flags & ~(MEM_Null|MEM_Agg))==0 ,3,3,6
ctx->wbufev != NULL,3,3,6
 !pLeft->bDeferred || !pRight->bDeferred ,3,3,6
 pToken->pDeferred==0 || pToken->pSegcsr==0 ,3,3,6
 nShift<=nDesired ,3,3,6
 rc==SQLITE_OK || p->pStmt==0 ,3,3,6
 pNode->n>0 ,3,3,6
 (pOp->p5&(OPFLAG_P2ISREG|OPFLAG_BULKCSR))==pOp->p5 ,3,3,6
 u.as.pSavepoint==db->pSavepoint ,3,3,6
 v->aVar[0].flags&MEM_Int ,3,3,6
 u.bj.pC->deferredMoveto==0 ,3,3,6
 pNew!=&standin ,3,3,6
 pLevel->iIdxCur>=0 ,3,3,6
 u.aw.pDb->pBt!=0 ,3,3,6
 p->bIgnoreSavepoint==0 ,3,3,6
 pNew->n<=pNew->nAlloc ,3,3,6
 nCell>=0 && nCell<=(int)MX_CELL(pPage->pBt) && (int)MX_CELL(pPage->pBt)<=10921,3,3,6
getType() == KindOfString,3,3,6
IsValidFPRegister(),3,3,6
" DbHasProperty(db, u.bz.iDb, DB_SchemaLoaded) ",3,3,6
 pCursor->pNode==pChild ,3,3,6
 iRight>=nRight || aContent[aRight[iRight]]>dbpage ,3,3,6
 u.bc.oc==OP_SeekLe || u.bc.oc==OP_SeekGt ,3,3,6
 (pBt->btsFlags & BTS_PENDING)==0 || pBt->pWriter ,3,3,6
(int)buffer.size() == numSetMarks,3,3,6
 (pIn3->flags & MEM_Zero)==0 ,3,3,6
 pDistinct->eTnctType==WHERE_DISTINCT_UNORDERED ,3,3,6
 pUpper->eOperator==WO_LT || pUpper->eOperator==WO_LE ,3,3,6
lc < NumLocationCodes,3,3,6
 u.bn.pC->pCursor!=0 ,3,3,6
 pExpr->op==TK_AGG_FUNCTION ,3,3,6
 p->cnt==0 ,3,3,6
 pIdxInfo->idxStr==0 ,3,3,6
 pgszSrc==sqlite3BtreeGetPageSize(p->pSrc) ,3,3,6
tvIsPlausible(r->tv()),3,3,6
acc && acc->m_type == KindOfDouble,3,3,6
 pRtree->eCoordType==RTREE_COORD_INT32 ,3,3,6
 iLevel>=0 || iLevel==FTS3_SEGCURSOR_ALL ,3,3,6
id < Id(m_preConsts.size()),3,3,6
!pExpr,3,3,6
 u.ao.pC!=0 ,3,3,6
 pWal->ckptLock==0 ,3,3,6
 p->pDestDb ,3,3,6
 iPos>=0 ,3,3,6
" offsetof(BaseVector, m_size) == FAST_COLLECTION_SIZE_OFFSET, """"",3,3,6
 iA1*iB0==0 || iA0*iB1==0 ,3,3,6
 u.br.pC->pCursor ,3,3,6
 *pbFound==0 ,3,3,6
px != NULL,3,3,6
!m_branchSynced,3,3,6
 db->mallocFailed==0 || pTab==0 ,3,3,6
 inodeList==pInode ,3,3,6
 iOvflSpace <= (int)pBt->pageSize ,3,3,6
 rc!=SQLITE_OK || !pCsr->pNode || pCsr->iCell<NCELL(pCsr->pNode) ,3,3,6
 iCol==0 ,3,3,6
 PAGER_STAT_HIT==0 && PAGER_STAT_MISS==1 && PAGER_STAT_WRITE==2 ,3,3,6
 n>3 && n<=9 ,3,3,6
 pPager->errCode || pPager->eState!=PAGER_ERROR ,3,3,6
 resetSchemaOnFault==0 || resetSchemaOnFault==u.bw.iDb+1 ,3,3,6
 rc!=SQLITE_SCHEMA ,3,3,6
 (mem5.aCtrl[iBlock] & CTRL_FREE)==0 ,3,3,6
 (pList->flags&PGHDR_NEED_SYNC)==0 ,3,3,6
 pPager->journalMode==PAGER_JOURNALMODE_WAL ,3,3,6
 u.cn.pCur->pVtabCursor ,3,3,6
m_pce == NULL,3,3,6
 u.cd.pProgram->nCsr==u.cd.pFrame->nChildCsr ,3,3,6
 pPager->doNotSpill==1 ,3,3,6
 pagerUseWal(pPager)==0 ,3,3,6
 zTerm && nTerm>0 ,3,3,6
length == static_cast<size_t>(static_cast<int>(length)),3,3,6
 pNew->pInode==NULL ,3,3,6
 win_mem_data.magic==WINMEM_MAGIC ,3,3,6
 p->syncFlags & (SQLITE_SYNC_NORMAL|SQLITE_SYNC_FULL) ,3,3,6
 pInfo->aReadMark[0]==0 ,3,3,6
 (PAGER_JOURNALMODE_OFF & 5)==0 ,3,3,6
 pPage->nCell<=MX_CELL(pPage->pBt) && MX_CELL(pPage->pBt)<=10921 ,3,3,6
 pPager->dbOrigSize<=pPager->dbHintSize ,3,3,6
 memIsValid(&aMem[u.al.p2+u.al.idx]) ,3,3,6
pfd.revents & POLLIN,3,3,6
hasStableMap(),3,3,6
 pagerUseWal(p)==0 ,3,3,6
 u.ai.apVal || u.ai.n==0 ,3,3,6
 left<=right ,3,3,6
 mem0.nScratchFree <= (u32)sqlite3GlobalConfig.nScratch ,3,3,6
 pGroup->nMinPage >= pCache->nMin ,3,3,6
 pBt->nPage>0 ,3,3,6
 SQLITE_DBSTATUS_CACHE_WRITE==SQLITE_DBSTATUS_CACHE_HIT+2 ,3,3,6
 1==(int)pParse->nQueryLoop ,3,3,6
 u.ay.pX!=0 ,3,3,6
 u.bu.pC->isTable==0 ,3,3,6
(*it)->getNumDepsToWaitFor() == 0,3,3,6
refIsPlausible(fr),4,2,6
 top+nByte <= (int)pPage->pBt->usableSize ,3,3,6
"KindOfStaticString & KindOfStringBit, """"",3,3,6
 pPager->eLock>=eLock ,3,3,6
KindOfString == 0x14,3,3,6
 pSrc->pIndex==0 || p->cost.plan.u.pIdx==0 || p->cost.plan.u.pIdx==pSrc->pIndex ,3,3,6
 idx<pIdx->nSample ,3,3,6
 pCsr->nRowAvg>0 ,3,3,6
strlen(resp) < (size_t)*response_length,3,3,6
 pPgOld ,3,3,6
bool(m_attrs & AttrVariadicParam) != bool(m_paramCounts & 1),4,2,6
j<=nBuf,3,3,6
 (h>='0' && h<='9') || (h>='a' && h<='f') || (h>='A' && h<='F') ,3,3,6
 pOp->opcode!=OP_Next || pOp->p4.xAdvance==sqlite3BtreeNext ,3,3,6
 nArg>=(-2) ,3,3,6
 pOther->szExtra<512 ,3,3,6
 p->eLock>=EXCLUSIVE_LOCK ,3,3,6
 pInfo->nBackfill==pWal->hdr.mxFrame ,3,3,6
 (HASHTABLE_NSLOT & (HASHTABLE_NSLOT-1))==0 ,3,3,6
 p->iPrevDocid==*pRowid ,3,3,6
k && m_keys && m_vals && toInt<uint32_t>(pos) < m_capacity,3,3,6
 u.br.pC->deferredMoveto==0 ,3,3,6
 pPager->nSavepoint==nSavepoint ,3,3,6
 sWBI.pSrc->pIndex==0 || (sWBI.cost.plan.wsFlags & WHERE_NOT_FULLSCAN)==0 || sWBI.cost.plan.u.pIdx==sWBI.pSrc->pIndex ,3,3,6
rm.code() != kSPRegInternalCode,4,2,6
 u.ao.p1<p->nCursor ,3,3,6
 sqlite3BtreeCursorIsValid(u.bm.pCrsr) ,3,3,6
 pParent->nOverflow==0 || pParent->aiOvfl[0]==iParentIdx ,3,3,6
 pWal->exclusiveMode==0 ,3,3,6
mode == Uns::Mode::ColKey,3,3,6
 !(u.ao.pDest->flags & (MEM_Blob|MEM_Str)) || u.ao.pDest->z==u.ao.sMem.z ,3,3,6
IsFPRegister() || IsNone(),3,3,6
 pPage->nOverflow<=ArraySize(pPage->apOvfl) ,3,3,6
 sqlite3_mutex_held(p->pGroup->mutex) ,3,3,6
 pCsr->nDoc>0 ,3,3,6
 p->pEList!=0 ,3,3,6
 pSubWInfo || pParse->nErr || pParse->db->mallocFailed ,3,3,6
 ((Fts3Table *)pVtab)->mxSavepoint < iSavepoint ,3,3,6
 sqlite3BtreeGetReserveNoMutex(p->pSrc)>=0 ,3,3,6
 eOld==PAGER_JOURNALMODE_MEMORY || eOld==PAGER_JOURNALMODE_OFF ,3,3,6
 WAL_CKPT_LOCK==WAL_ALL_BUT_WRITE ,3,3,6
isBoxed(t),3,3,6
 u.bz.iDb==1 || sqlite3BtreeHoldsMutex(db->aDb[u.bz.iDb].pBt) ,3,3,6
" pExpr->u.zToken[0]=='?' || strcmp(pExpr->u.zToken, pParse->azVar[pExpr->iColumn-1])==0 ",3,3,6
" walFramePgno(pWal, iFrame)!=1 ",3,3,6
 u.bv.pC!=0 ,3,3,6
 zFile[0]!=0 ,3,3,6
sizeof(int64_t) == 8,3,3,6
 p->pgno>0 ,3,3,6
hasCollection() && getCollectionType() == Collection::VectorType,3,3,6
 u.bs.pC->isTable==0 ,3,3,6
 (pOther->szPage & (pOther->szPage-1))==0 && pOther->szPage>=512 ,3,3,6
 rc==SQLITE_OK || iHash>0 ,3,3,6
c1 && c2,3,3,6
!IS_REFCOUNTED_TYPE(m_top->m_type),3,3,6
" sqlite3SchemaMutexHeld(db, 0, pTable->pSchema) ",3,3,6
 idxNum==FTS4AUX_EQ_CONSTRAINT || idxNum==0 || idxNum==FTS4AUX_LE_CONSTRAINT || idxNum==FTS4AUX_GE_CONSTRAINT || idxNum==(FTS4AUX_LE_CONSTRAINT|FTS4AUX_GE_CONSTRAINT) ,3,3,6
type < InstHookTypeSDCount,3,3,6
 u.ao.avail>=0 ,3,3,6
 (PAGER_JOURNALMODE_DELETE & 5)==0 ,3,3,6
!res || isRef(n),3,3,6
 *pnOut<=n1+n2+FTS3_VARINT_MAX-1 ,3,3,6
 nList<=HASHTABLE_NPAGE && nList>0 ,3,3,6
 pE->aMI==0 ,3,3,6
 p->tempFile==0 || p->eLock==EXCLUSIVE_LOCK ,3,3,6
hasCollection() && getCollectionType() == Collection::SetType,3,3,6
 m.z==m.zMalloc ,3,3,6
 pbOpen!=0 || (!pPager->tempFile && !pPager->pWal) ,3,3,6
"offsetof(SharedVar, m_count) == offsetof(TypedValue, _count)",3,3,6
nKey==elem->nKey,3,3,6
 (p->btreeMask & (((yDbMask)1)<<u.bw.iDb))!=0 ,3,3,6
 pCsr->nTerm==0 ,3,3,6
 p->pParent && p->pParent->pLeft==p ,3,3,6
 iLimit>0 ,3,3,6
 eMode==PAGER_JOURNALMODE_DELETE || eMode==PAGER_JOURNALMODE_TRUNCATE || eMode==PAGER_JOURNALMODE_PERSIST || eMode==PAGER_JOURNALMODE_OFF || eMode==PAGER_JOURNALMODE_WAL || eMode==PAGER_JOURNALMODE_MEMORY ,3,3,6
 fd>=0 ,3,3,6
 pItem->pExpr->pLeft==pE ,3,3,6
 !db || sqlite3_mutex_held(db->mutex) ,3,3,6
u.cm.pVtab && u.cm.pModule,3,3,6
 id-2 < (int)(sizeof(aStatic)/sizeof(aStatic[0])) ,3,3,6
i1 && i2,3,3,6
m_maxJobQueuingMs > 0,4,2,6
(int)m_arg == a,3,3,6
 pCache->bPurgeable || (pCache->nMax==0 && pCache->nMin==0) ,3,3,6
 *p2!=POS_END && *p2!=POS_COLUMN ,3,3,6
 ArraySize(aSyscall)==74 ,3,3,6
" strcmp(pDb->zName,""vacuum_db"")==0 ",3,3,6
 u.ao.payloadSize==0 || u.ao.zRec!=0 ,3,3,6
 pOBItem->sortOrder==0 || pOBItem->sortOrder==1 ,3,3,6
getTypeParam() == Type::Arr,3,3,6
 pOp->opcode==OP_OpenWrite || pOp->p5==0 ,3,3,6
isXMM() || n == -1,3,3,6
 pWinMemData->bOwned ,3,3,6
 handleNFSUnlock==0 ,3,3,6
 p->op==SQLITE_INDEX_CONSTRAINT_MATCH ,3,3,6
static_cast<size_t>(n) <= strlen(s),3,3,6
 u.cp.pCur->pVtabCursor ,3,3,6
 u.be.pC->isTable==0 ,3,3,6
 p->pEList->a[0].pExpr!=0 ,3,3,6
 rc!=SQLITE_BUSY ,3,3,6
 (rc&0xff)!=SQLITE_BUSY ,3,3,6
IsValidRegister(),3,3,6
sr == REQ_BIND_JMPCC_FIRST || sr == REQ_BIND_JMPCC_SECOND || sr == REQ_BIND_JMP,3,3,6
 nColumn>0 ,3,3,6
fr.empty(),3,3,6
 u.cq.pName->flags & MEM_Str ,3,3,6
 n==nColumn ,3,3,6
 rc==SQLITE_OK || pPager->eState==PAGER_READER ,3,3,6
 aiCol[i]!=pTab->iPKey ,3,3,6
((flags & EMIT_TRAILING_DECIMAL_POINT) != 0) || !((flags & EMIT_TRAILING_ZERO_AFTER_POINT) != 0),3,3,6
(pc_ + size) <= (buffer_ + buffer_size_),3,3,6
m_keys && m_vals && toInt<uint32_t>(pos) < m_capacity,3,3,6
 pbOpen==0 || *pbOpen==0 ,3,3,6
 memIsValid(u.bi.pData) ,3,3,6
 eStat==SQLITE_DBSTATUS_CACHE_HIT || eStat==SQLITE_DBSTATUS_CACHE_MISS || eStat==SQLITE_DBSTATUS_CACHE_WRITE ,3,3,6
 pPager->fullSync==0 ,3,3,6
 rc!=SQLITE_OK || pPhrase->bIncr==0 ,3,3,6
 pItem->pExpr->op==TK_COLLATE ,3,3,6
 pPager->ckptSyncFlags==0 ,3,3,6
 p->pOrderBy || (p->cost.plan.wsFlags&WHERE_ORDERED)==0 ,3,3,6
 preserve==0 || pMem->flags&(MEM_Blob|MEM_Str) ,3,3,6
 *pRc!=SQLITE_OK || pRight->bStart ,3,3,6
branchA != mainA,3,3,6
!ar->hasExtraArgs(),3,3,6
l.first,3,3,6
 pItem->addrFillSub==0 ,3,3,6
 pIter ,3,3,6
 zC!=0 ,3,3,6
 pInode!=0 ,3,3,6
 SLOT_4_2_0 == ((0xfU<<28) | (0x7f<<14) | (0x7f)) ,3,3,6
 u.br.pC->isSorter==(pOp->opcode==OP_SorterNext) ,3,3,6
 p->rc!=SQLITE_OK ,3,3,6
 z!=0 || N==0 ,3,3,6
 pPhrase->doclist.pList[nNew]=='\0' ,3,3,6
 db==0 || db->pnBytesFreed==0 ,3,3,6
 sizeof(t)+sizeof(pid)<=(size_t)nBuf ,3,3,6
 pCsr->bDesc==0 || pCsr->bDesc==1 ,3,3,6
 pPager->eState>=PAGER_READER && !MEMDB ,3,3,6
 pWal->nWiData>walFramePage(pWal->hdr.mxFrame) ,3,3,6
 u.bh.v>0 ,3,3,6
m_size != 0 || m_used == 0,3,3,6
 p->tempFile==0 || pPager->changeCountDone ,3,3,6
" db==0 || sqlite3SchemaMutexHeld(db, 0, p->pSchema) ",3,3,6
 pPager->eState==PAGER_READER || rc!=SQLITE_OK ,3,3,6
 pSub->pSrc!=0 ,3,3,6
opc >= OpGt && opc <= OpNSame,3,3,6
0 <= index && index < length_,3,3,6
 nDoclist>0 || iDelta==iDocid ,3,3,6
"offsetof(SharedVariant, m_type) == offsetof(TypedValue, m_type), ""Offset of m_type must be equal in SharedVar and TypedValue""",3,3,6
tvIsPlausible(to),3,3,6
 WIN_SHM_BASE==WALINDEX_LOCK_OFFSET ,3,3,6
!(I->P),3,3,6
hasCollection() && getCollectionType() == Collection::PairType,3,3,6
 nFarg==1 ,3,3,6
to <= length_,3,3,6
 roundUp==0 || roundUp==1 ,3,3,6
 pOp->p1<p->nOnceFlag ,3,3,6
IS_REFCOUNTED_TYPE(type),3,3,6
 PAGER_JOURNALMODE_OFF==2 ,3,3,6
 pCur->wrFlag && pBt->inTransaction==TRANS_WRITE && (pBt->btsFlags & BTS_READ_ONLY)==0 ,3,3,6
length == 0 || (length > 0 && data != NULL),3,3,6
 iOut<pSorter->nTree && iOut>0 ,3,3,6
" sqlite3SchemaMutexHeld(db, u.ay.iDb, 0) ",3,3,6
 u.as.p1==SAVEPOINT_BEGIN||u.as.p1==SAVEPOINT_RELEASE||u.as.p1==SAVEPOINT_ROLLBACK ,3,3,6
 i<p->nSample ,3,3,6
 pDel==0 || pDel==pMod ,3,3,6
literals_.empty() || (pc_ < (literals_.back()->pc_ + kMaxLoadLiteralRange)),3,3,6
 p->noSync ,3,3,6
 nIter>0 ,3,3,6
*op == OpSSwitch,3,3,6
 PAGER_JOURNALMODE_WAL==5 ,3,3,6
 pPager->exclusiveMode || 0==sqlite3WalHeapMemory(pPager->pWal) ,3,3,6
 UNIX_SHM_BASE==WALINDEX_LOCK_OFFSET ,3,3,6
i <= mask && probe == h0 + ((i + i * i) / 2),3,3,6
 pOld==pIndex || pOld==0 ,3,3,6
 *p1!=POS_END && *p1!=POS_COLUMN ,3,3,6
 p->nPgsz>0 || rc!=SQLITE_OK ,3,3,6
 (pCsr->pBt->btsFlags & BTS_READ_ONLY)==0 && pCsr->pBt->inTransaction==TRANS_WRITE ,3,3,6
 &db->pVtabCtx ,3,3,6
 wrFlag==0 ,3,3,6
 pPager->doNotSyncSpill==1 ,3,3,6
 iCol<0 || iCol<p->nColumn ,3,3,6
 u.al.n>0 ,3,3,6
 rc==SQLITE_OK || pList==0 ,3,3,6
0 <= from,3,3,6
 pTop->pVdbe ,3,3,6
 u.ap.zAffinity!=0 ,3,3,6
supports(SpecKind::Array),3,3,6
!RuntimeOption::RepoAuthoritative,3,3,6
pc_ < (buffer_ + buffer_size_),3,3,6
 pParse->nQueryLoop >= (double)1 ,3,3,6
"offsetof(SharedVariant, m_data) == offsetof(TypedValue, m_data), ""Offset of m_data must be equal in SharedVar and TypedValue""",3,3,6
 regRow!=pDest->iSdst+i ,3,3,6
 iBuddy>=0 ,3,3,6
 db->aDb[u.av.iDb].pBt!=0 ,3,3,6
hasCollection() && getCollectionType() == Collection::MapType,3,3,6
 u.bc.pC->isOrdered ,3,3,6
 pPager->errCode!=SQLITE_OK ,3,3,6
f_ != 0,3,3,6
 pnBlob ,3,3,6
l2.first,3,3,6
m == MarkProcessed,3,3,6
IsValidOrNone() && other.IsValidOrNone(),3,3,6
" iNewLevel>=getAbsoluteLevel(p, iLangid, iIndex, 0) ",3,3,6
 zWalName && zWalName[0] ,3,3,6
iStart<=iEnd,3,3,6
 iCurrent<=iMinPos ,3,3,6
 memIsValid(&u.af.pMem[u.af.i]) ,3,3,6
tvIsPlausible(&key),3,3,6
 (op-SQLITE_DBSTATUS_LOOKASIDE_HIT)<3 ,3,3,6
 iBlock>=0 && iBlock<mem5.nBlock ,3,3,6
 memIsValid(u.cg.pRec) ,3,3,6
 u.bn.pModule->xRowid ,3,3,6
(type_ != kNoRegister) || (size_ == 0),3,3,6
 rc!=SQLITE_OK || p->nToken<1 || p->aToken[0].pSegcsr==0 || p->bIncr ,3,3,6
 pWal->readLock>=0 || (op<=0 && pWal->exclusiveMode==0) ,3,3,6
 nBytes>0 ,3,3,6
 iPrev>=0 ,3,3,6
checkNoScratch(),3,3,6
 aHardLimit[SQLITE_LIMIT_ATTACHED]==SQLITE_MAX_ATTACHED ,3,3,6
 pPager->eState==PAGER_READER || !pbOpen ,3,3,6
 pIdx->nSample==0 ,3,3,6
posLimit() + 1 <= cap(),3,2,5
is_uint7(imm7),3,2,5
sz == 2,3,2,5
is_uint6(scale),3,2,5
((imm7 >> size) << size) == imm7,3,2,5
func,3,2,5
m_top[ind].m_type != KindOfRef,3,2,5
is_int14(imm14),3,2,5
code_ < (sizeof(RegList) * 8),3,2,5
"KindOfString & KindOfStringBit, """"",3,2,5
shift == LSL || shift == LSR || shift == ASR || shift == ROR,3,2,5
getKind() == Kind::Condition,3,2,5
"!(KindOfUninit & KindOfStringBit), """"",3,2,5
b->is(BlockScope::ClassScope),3,2,5
"boost::has_trivial_destructor<T>::value, ""TinyVector only supports elements with trivial destructors""",3,2,5
col->hasExactlyOneRef(),3,2,5
sizeof(pad) == kInstructionSize,3,2,5
" std::is_same<Key,Block>::value || std::is_same<Key,IRInstruction>::value || std::is_same<Key,SSATmp>::value, ""StateVector can only be used with Block, IRInstruction, or SSATmp"" ",3,2,5
"offsetof(c_WaitHandle, m_kind_state) < aux, """"",3,2,5
!m_start || (m_end - m_start) < (1ll << 32),3,2,5
(uintptr_t)&m_top[n] <= (uintptr_t)m_base,3,2,5
!b && !m_edges,3,2,5
m_iterMixed <= m_stopMixed,3,2,5
m_frame.prev,3,2,5
b->is(BlockScope::FunctionScope),3,2,5
((type == CPURegister::kRegister) && (last_reg < kNumberOfRegisters)) || ((type == CPURegister::kFPRegister) && (last_reg < kNumberOfFPRegisters)),3,2,5
ctx_idx <= AsioSession::Get()->getCurrentContextIdx(),3,2,5
"!(KindOfNull & KindOfStringBit), """"",3,2,5
!candidate.Is(forbidden),3,2,5
is_uint2(shift),3,2,5
masm_->SizeOfCodeGeneratedSince(&start_) == size_,3,2,5
arr == staticEmptyArray() || arr->isPacked(),3,2,5
(uintptr_t)&m_top[-kNumIterCells] >= (uintptr_t)m_elms,3,2,5
m_size + 1 <= m_capacity,3,2,5
"!(KindOfObject & KindOfStringBit), """"",3,2,5
t < m_universe_size,4,1,5
kNumActRecCells * sizeof(Cell) == sizeof(ActRec),3,2,5
"offsetof(c_WaitHandle, m_contextIdx) == type, """"",3,2,5
m_numDepsToWaitFor > 0,3,2,5
pair->isFullyConstructed(),3,2,5
(dump_.flags_ & ~Flags_mask) == 0,3,2,5
!a->hasMultipleRefs(),3,2,5
rt2.code() != kSPRegInternalCode,3,2,5
kNumIterCells * sizeof(Cell) == sizeof(Iter),3,2,5
static_cast<const c_Pair*>(obj)->isFullyConstructed(),3,2,5
!ret.m_hasConstVal,3,2,5
m_size + 1 <= cap(),3,2,5
rn.code() != kSPRegInternalCode,3,2,5
IsWordAligned(this + offset),3,2,5
!rs.IsZero(),3,2,5
"!AreAliased(stack_pointer, Tmp0(), Tmp1())",3,2,5
!IsLinked() || IsBound(),3,2,5
e->hasStrKey(),3,2,5
ctx_idx <= m_contexts.size(),3,2,5
(numArgs & kFlagsMask) == 0,3,2,5
m_kind == Kind::Destructor,3,2,5
m_package && !m_parseOnDemand,3,2,5
i < m_gpArgs.size(),3,2,5
sizeof(pointer) == sizeof(uintptr_t),3,2,5
is_uint6(imms),3,2,5
"!(KindOfArray & KindOfStringBit), """"",3,2,5
target->canMutateBuffer(),3,2,5
getKind() == Kind::AsyncGenerator,3,2,5
vec->canMutateBuffer(),3,2,5
sizeof(dump_.d_[0]) == kXRegSizeInBytes,3,2,5
"!(KindOfBoolean & KindOfStringBit), """"",3,2,5
result->m_type == KindOfNull,4,1,5
sizeof(dump_.d_[0]) == kDRegSizeInBytes,3,2,5
is_uint6(immr),3,2,5
sz <= m_capacity,3,2,5
(reg_size == kXRegSize) || (bitn == 0),3,2,5
getKind() == Kind::ExternalThreadEvent,3,2,5
"std::is_convertible<T*,BaseVector*>::value || std::is_convertible<T*,HashCollection*>::value || std::is_convertible<T*,c_Pair*>::value, """"",3,2,5
seg == DS,3,2,5
checkOperandTypes(inst),3,2,5
string != nullptr,3,2,5
"sizeof(TypedValueAux) <= 16, ""don't add big things to AuxUnion""",3,2,5
is_uint6(amount),3,2,5
cellIsPlausible(*fr),3,2,5
(uint8_t)kind < 0x10 && state < 0x10,3,2,5
m_value.outerType == KindOfString || m_value.innerType == KindOfString || m_value.outerType == KindOfClass || m_value.innerType == KindOfClass || m_value.outerType == KindOfObject || m_value.innerType == KindOfObject || m_value.outerType == KindOfArray || m_value.innerType == KindOfArray || m_value.outerType == KindOfBoolean || m_value.outerType == KindOfInt64 || m_value.klass == NULL,3,2,5
child,3,2,5
sizeof(pointer) == sizeof(intptr_t),3,2,5
size() % 8 == 0,3,2,5
!m_start || m_start < m_end,3,2,5
is_int26(imm26),3,2,5
size_t(pos) <= posLimit(),3,2,5
bool(m_start) == bool(m_end),3,2,5
m_funcId != InvalidFuncId,3,2,5
(size_in_bits % 8) == 0,3,2,5
IsShiftedRegister(),3,2,5
ra.code() != kSPRegInternalCode,3,2,5
isFinished(),3,2,5
!m_ptr,3,2,5
sz <= cap(),3,2,5
a->isStatic(),3,2,5
"!(KindOfInt64 & KindOfStringBit), """"",3,2,5
IsImmAddSub(imm),3,2,5
(SizeLS_offset + SizeLS_width) == (kInstructionSize * 8),3,2,5
left_shift <= 4,3,2,5
!m_obj || m_obj->checkCount(),5,0,5
isNormalHandle(handle),5,0,5
"!(KindOfClass & KindOfStringBit), """"",3,2,5
limit == (ssize_t)posLimit(),3,2,5
(pointer_raw + align_step) % alignment == 0,3,2,5
rd.code() != kSPRegInternalCode,3,2,5
last_reg >= first_reg,3,2,5
cell->m_data.pobj->getAttribute(ObjectData::IsWaitHandle),3,2,5
!xd.IsZero(),3,2,5
!xm.IsZero(),3,2,5
reinterpret_cast<uintptr_t>(__builtin_frame_address(0)) % 16 == 0,3,2,5
"false && ""Invalid KindOf for constant TypedValue""",3,2,5
IsExtendedRegister(),3,2,5
cellIsPlausible(*tv),4,1,5
is_uint16(imm),3,2,5
fp->hasExtraArgs(),3,2,5
is_int21(imm21),3,2,5
"InternalSize >= 1, ""TinyVector assumes that the internal size is at least 1""",3,2,5
(uintptr_t)&m_top[-kNumActRecCells] >= (uintptr_t)m_elms,3,2,5
"!(KindOfDouble & KindOfStringBit), """"",3,2,5
m_immCopy.isNull(),3,2,5
repoId < RepoIdCount,3,2,5
sd->checkSane(),3,2,5
limit == 0,3,2,5
"boost::has_trivial_copy<T>::value && boost::has_trivial_assign<T>::value, ""TinyVector only supports elements with trivial copy "" ""constructors and trivial assignment operators""",3,2,5
m_data->hasExactlyOneRef(),5,0,5
is_int7(scaled_imm7),3,2,5
cell->m_type == KindOfObject,3,2,5
i < m_simdArgs.size(),3,2,5
m_kind == Kind::Addr,3,2,5
"!AreAliased(xzr, sp, tmp0, tmp1)",3,2,5
handle->checkInvariants(),5,0,5
is_uint1(shift_amount),3,2,5
IsImmediate(),3,2,5
shift < reg_size,3,2,5
this != &rhs,3,2,5
"((uintptr_t(address) + sizeof(T) - 1) & ~63ul) == ( uintptr_t(address) & ~63ul) && ""Atomically accessed addresses may not span cache lines""",3,2,5
hasAd(),3,2,5
m_iterPacked <= m_stopPacked,3,2,5
Label::kEndOfChain == 0,3,2,5
"offsetof(c_WaitHandle, m_parentChain) == data, """"",3,2,5
getKind() == Kind::Reschedule,3,2,5
m_pce == nullptr,3,2,5
is_uint15(imm15),3,2,5
sz == 0,3,2,5
((reg_size == kXRegSize) && is_uint6(imms)) || ((reg_size == kWRegSize) && is_uint5(imms)),3,2,5
s_cls,3,2,5
"!(KindOfRef & KindOfStringBit), """"",3,2,5
accum->n_len+accum->n_scale >= shift+count,3,2,5
is_uint12(imm12),3,2,5
sizeof(dump_.s_[0]) == kSRegSizeInBytes,3,2,5
s->isStatic(),3,2,5
"AreSameSizeAndType(reg1, reg2, reg3, reg4)",3,2,5
!isFullyConstructed(),3,2,5
getKind() == Kind::AsyncFunction,3,2,5
ei && !validPos(*ei) && m_size <= posLimit() && posLimit() < cap(),3,2,5
rt.code() != kSPRegInternalCode,3,2,5
sizeof(dump_.s_[0]) == kWRegSizeInBytes,3,2,5
buffer_used == 0,3,2,5
IsWordAligned(pc_),3,2,5
is_int9(imm9),3,2,5
"!AreAliased(StackPointer(), tmp0, tmp1)",3,2,5
getKind() == Kind::Sleep,3,2,5
(reg_size == kXRegSize) || is_uint6(imms + 3),3,2,5
label->IsBound(),3,2,5
"IMPLIES(!m_immCopy.isNull(), arrayData()->hasMultipleRefs())",3,2,5
limit <= cap(),3,2,5
newEnd >= m_end,3,2,5
is_uint5(imm),3,2,5
is_uint6(bit_pos),3,2,5
sizeof(dump_.w_[0]) == kWRegSizeInBytes,3,2,5
obj->getVMClass() == c_Pair::classof(),3,2,5
numLocals == fp->m_func->numLocals(),3,2,5
value > 1,3,2,5
sizeof(dump_.x_[0]) == kXRegSizeInBytes,3,2,5
getKind() == Kind::AwaitAll,3,2,5
"offsetof(c_WaitHandle, m_ctxVecIndex) == aux, """"",3,2,5
is_uint16(imm16),3,2,5
index != -1,2,2,4
rbp_i_cmp > 0,2,2,4
Null,2,2,4
IS_REFCOUNTED_TYPE(tv->m_type) && tv->m_type != KindOfVariant,2,2,4
newCapacity > 0 && newCapacity > currentSize,2,2,4
"offsetof(String, m_px) == kExpectedMPxOffset, """"",2,2,4
isValid(obj),2,2,4
key->is(KindOfString),2,2,4
IS_REFCOUNTED_TYPE((tv)->m_type),2,2,4
m_value.knownClass == nullptr || m_value.outerType == KindOfObject,2,2,4
"kNumSmartSizes <= sizeof(kSmartSize2Index), ""Extend SMART_SIZES table""",2,2,4
"(offsetof(String, m_px) == kExpectedMPxOffset)",2,2,4
m_type == KindOfRef ? m_data.pvar->m_data.parr : m_data.parr,2,2,4
"t == Gen || isMoreRefined(t, Gen)",2,2,4
offset % kBitSize == 0,2,2,4
"(offsetof(ArrNR, m_px) == kExpectedMPxOffset)",2,2,4
 pPager->state>=PAGER_SHARED ,2,2,4
"IMPLIES(m_cap == 0, !b)",2,2,4
!m_vec,2,2,4
handle->kind() == APCKind::SharedArray,2,2,4
ne.first->data()[0] != '\\',2,2,4
!m_trace->back()->next(),2,2,4
offset < vector.size(),2,2,4
m_handle.getUncounted() && m_handle.is(KindOfArray),2,2,4
!r.isValid() || r.isVirt() || r.isSIMD(),2,2,4
category() == isSmall && this->size() == rhs.size(),2,2,4
isContainer(c),3,1,4
*this <= PtrToGen,2,2,4
m_ptr >= 1,2,2,4
"keyType != IntKey, ""Integer property keys are not supported""",2,2,4
"offsetof(ObjectData, _count) == FAST_REFCOUNT_OFFSET, ""Offset of ObjectData._count must be FAST_REFCOUNT_OFFSET""",2,2,4
sizeof(*this) == sizeof(Char*) + 2 * sizeof(size_t),2,2,4
this->size() == n,2,2,4
this != &other,2,2,4
!last->next(),2,2,4
"!""getExtra<T> was called with an extra data "" ""type that doesn't match the opcode type""",2,2,4
(size < packedCodeToCap(packedCapCode)) == (size < cap),2,2,4
isSF() || n == -1,2,2,4
offset < alloc_size,2,2,4
r->m_count > 0,2,2,4
"TypedValue* _rv, TypedValue* assertion",2,2,4
!data->hasMultipleRefs() || data->noCopyOnWrite(),2,2,4
tvIsPlausible(*r->tv()),2,2,4
!(KindOfUninit & KindOfUncountedInitBit),2,2,4
m_type == KindOfVariant ? m_data.pvar->m_data.parr : m_data.parr,2,2,4
arr,2,2,4
"offsetof(StringData,m_small) % 8 == 4, """"",2,2,4
 sqlite3BtreeCursorIsValid(u.am.pCrsr) ,2,2,4
!(KindOfDouble & KindOfStringBit),2,2,4
&src != this,2,2,4
page_size > 3*CACHE_LINE_SIZE + (int)sizeof(int),2,2,4
detail::pointerFlagGet(heap_),2,2,4
!retval || (reg >= 0 && reg < 64),2,2,4
"(KindOfString >> kShiftDataTypeToDestrIndex == 1) && (KindOfArray >> kShiftDataTypeToDestrIndex == 2) && (KindOfObject >> kShiftDataTypeToDestrIndex == 3) && (KindOfResource >> kShiftDataTypeToDestrIndex == 4) && (KindOfRef >> kShiftDataTypeToDestrIndex == 5), ""lookup of destructors depends on KindOf* values""",2,2,4
expired == false,2,2,4
i < kNumSizes,2,2,4
!v.isContagious(),2,2,4
!decRefCount(),2,2,4
!(KindOfArray & KindOfUncountedInitBit),2,2,4
getType() == LiteralString,2,2,4
genFunc->isGenerator(),2,2,4
!isEphemeralServiceReq(sr),2,2,4
sz < (std::size_t(1) << kLockBit),2,2,4
CHUNK_ADDR2BASE(ptr) != ptr,2,2,4
a->m_type == KindOfArray,2,2,4
"offsetof(SharedVar, m_data) == offsetof(TypedValue, m_data), ""Offset of m_data must be equal in SharedVar and TypedValue""",2,2,4
 pMem->z ,2,2,4
this->isExtern(),2,2,4
m_type == KindOfVariant ? m_data.pvar->m_data.pobj : m_data.pobj,2,2,4
" boost::is_arithmetic<T>::value || boost::is_pointer<T>::value, ""Atomic operations only supported for built in integer, floating point "" ""and pointer types.""",2,2,4
bin_mags->sparemag == NULL,2,2,4
supports(SpecKind::Class) && !clsSpec(),2,2,4
value != 0,2,2,4
id < m_unit.numIds(nullKey),2,2,4
category() == isSmall && small_[maxSmallSize] <= maxSmallSize,2,2,4
val != InvalidReg,2,2,4
vmfp() == fp && vmsp() == sp && vmpc() == pc,2,2,4
getState() == Running,2,2,4
"sizeof(MInstrState) - sizeof(uintptr_t) < kReservedRSPTotalSpace, ""MInstrState is too large for the rsp scratch space "" ""in enterTCHelper""",2,2,4
buf[size] == 0,2,2,4
Type::isPtr(t->getType()),2,2,4
"std::is_same<SizeType,void>::value, ""OneBitMutex only works on x86-64""",2,2,4
!(KindOfRef & KindOfUncountedInitBit),2,2,4
bytes_read != -1 && bytes_read != 0,2,2,4
"!(kNotConstantValueTypeMask & (KindOfNull|KindOfBoolean|KindOfInt64|KindOfDouble| KindOfStaticString|KindOfString)), ""DataType & kNotConstantValueTypeMask must be zero for "" ""null, bool, int, double and string types""",2,2,4
checkSane(),3,1,4
!isInContext() || getCurrentContext()->isRunning(),2,2,4
"static_assert(!std::is_same<Tag, void>::value, ""Must use a unique Tag to use the accessAllThreads feature"")",2,2,4
!m_px || m_px->getCount() == 0,2,2,4
parentName,2,2,4
count <= sizeof(UnderlyingType) * 8,2,2,4
!(size < packedCodeToCap(packedCapCode)),2,2,4
!m_obj || m_obj->hasMultipleRefs(),4,0,4
 p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld(p) ,2,2,4
a != NULL,2,2,4
factoryId(k) < m_info.size(),2,2,4
isValid(cpos),2,2,4
v.isContagious(),2,2,4
delta <= smallSize(),2,2,4
m_boolVal <= 1,2,2,4
"memcmp(data(), rhs.data(), size() * sizeof(Char)) == 0",2,2,4
oldcnt > 0,2,2,4
begin() <= i2 && i2 <= end(),2,2,4
"sizeof...(Types) < std::numeric_limits<uint16_t>::max(), ""too many types""",2,2,4
"alignof(MaxAlign) > 0 && FOLLY_CACHE_LINE_SIZE % alignof(MaxAlign) == 0 && sizeof(T) <= alignof(MaxAlign), ""T can cross cache line boundaries""",2,2,4
"int, HPHP::Variant const&",2,2,4
(sizeof(DataType) == 4),2,2,4
 u.am.pDest->flags&MEM_Null ,2,2,4
uintptr_t(this) - Util::s_stackLimit >= Util::s_stackSize,2,2,4
"offsetof(Variant,m_type) == offsetof(TypedValue,m_type), ""Offset of m_type must be equal in Variant and TypedValue""",2,2,4
index <= maxArgReg(),2,2,4
!on_join || on_join->instanceof(c_Closure::classof()),2,2,4
reg != Transl::InvalidReg,2,2,4
"IMPLIES(!b, a->hasMultipleRefs())",2,2,4
m_data.pres->getCount(),2,2,4
"sizeof(int64_t) == sizeof(PosType), ""can't""",2,2,4
ad->kind() == ArrayData::kPackedKind,2,2,4
sz <= policyMaxSize(),2,2,4
m_type == LiteralString,2,2,4
"offsetof(Variant, _count) == 8 && offsetof(Variant, m_type) == 12 && sizeof(_count) == sizeof(uint32_t) && sizeof(m_type) == sizeof(uint32_t), ""Bad offset or size for _count or m_type""",2,2,4
&rhs != this,2,2,4
key <= Type::Str,2,2,4
gen->noDestruct(),2,2,4
p->op==RTREE_LE || p->op==RTREE_LT || p->op==RTREE_GE || p->op==RTREE_GT || p->op==RTREE_EQ ,2,2,4
&map != this,2,2,4
className->isA(Type::Str),2,2,4
"keyType != KeyType::Int, ""Integer property keys are not supported""",2,2,4
keyType <= Type::Cell,2,2,4
"KindOfStaticString & KindOfUncountedInitBit, """"",2,2,4
!detail::pointerFlagGet(newh),2,2,4
isCmpOp(opc),2,2,4
category() == isMedium,2,2,4
"is_malloc_size_class<value>::value, ""Bug in malloc_size_class.h""",2,2,4
m_bytes == (int)(m_count * sizeof(T)),2,2,4
"offsetof(MediumLarge, capacity_) == 2 * sizeof(ml_.data_)",2,2,4
callee,2,2,4
"kNotConstantValueTypeMask & KindOfArray && kNotConstantValueTypeMask & KindOfObject && kNotConstantValueTypeMask & KindOfRef, ""DataType & kNotConstantValueTypeMask must be non-zero for "" ""Array, Object and Ref types""",2,2,4
head != this,2,2,4
bytes > 0,3,1,4
v.data() == nullptr,2,2,4
s <= maxSmallSize,2,2,4
a.base() != ahot.base() && a.base() != astubs.base() && ahot.base() != astubs.base(),2,2,4
m_handle.is(KindOfStaticString) || (m_handle.getUncounted() && m_handle.is(KindOfString)),2,2,4
"sizeof(T) <= 0xffff && sizeof(T) < kMaxSmallSize, """"",2,2,4
rawdata()[size()] == 0,2,2,4
IS_STRING_TYPE(key->m_type),2,2,4
!m_failedSetTrace,2,2,4
amount <= headroom(),2,2,4
 i==0 || pArray->aBtree[i-1]->pBt<p->pBt ,2,2,4
func->contains(offset),2,2,4
m_kind == kSpill,2,2,4
category == DataTypeSpecialized,2,2,4
pos <= size(),2,2,4
"TypedValue* _rv, int what, TypedValue* value",2,2,4
isMixed(m_kind) || m_kind == kPackedKind || m_kind == kStructKind,2,2,4
exp->isKindOf(KindOfVariableExpression),2,2,4
amount <= tailroom(),2,2,4
m_data.pstr->getCount(),2,2,4
hash != -1,2,2,4
lock_ == nullptr,2,2,4
sizeof(T) <= kMaxSmartSize,2,2,4
eventBase->isInEventBaseThread(),2,2,4
(tv)->m_type > KindOfStaticString,2,2,4
 pPager->state <= PAGER_SHARED ,2,2,4
"std::is_standard_layout<T>::value, ""must be standard layout""",2,2,4
"offsetof(APCObject, m_handle) == 0",2,2,4
rbp_p_t != &(a_tree)->rbt_nil,2,2,4
!m_data || (uintptr_t(this) - Util::s_stackLimit >= Util::s_stackSize),2,2,4
isSIMD() || n == -1,2,2,4
isGenerator(),2,2,4
keyType == KeyType::Str,2,2,4
"BitCount<UseKindNonStaticRef>::value == 16, ""UseKindNonStaticRef should have 16 bits set""",2,2,4
"offsetof(Variant,m_data) == offsetof(TypedValue,m_data), ""Offset of m_data must be equal in Variant and TypedValue""",2,2,4
node != NULL,2,2,4
ct == obj2->getCollectionType(),2,2,4
(prev & kWaiterMask) != 0,2,2,4
subtypeOf(StaticArr) && m_hasConstVal,2,2,4
subtypeOf(StackElem),2,2,4
b <= e,2,2,4
dis->refCount_.load(std::memory_order_acquire) == 1,2,2,4
res == ObjectData::getVMClassOffset(),2,2,4
pos < m_data.vec->size,2,2,4
KindOfString & KindOfStringBit,2,2,4
capacity() >= used(),3,1,4
subtypeOf(Dbl) && m_hasConstVal,2,2,4
 pExpr->isLoaded ,2,2,4
m_type == KindOfVariant,2,2,4
m_class.get(),2,2,4
"offsetof(Object, m_px) == offsetof(Value, m_data), ""Offset of m_px in Object must be offset of m_data in Value""",2,2,4
newCapacity < std::numeric_limits<InternalSizeType>::max(),2,2,4
"deltaFits(diff, sz::byte)",2,2,4
"!""called getExtra on an opcode without extra data""",2,2,4
packedCodeToCap(packedCapToCode(cap)) == cap,2,2,4
 db->magic==SQLITE_MAGIC_BUSY ,2,2,4
(fr)->m_type == KindOfVariant,2,2,4
!isAbstract(),2,2,4
crtBuf_->next() == buffer_,2,2,4
!(KindOfBoolean & KindOfStringBit),2,2,4
"IMPLIES(isCallable(), m_type.m_dt == KindOfObject)",2,2,4
getState() == Created || getState() == Started,2,2,4
"offsetof(Variant,_count) == offsetof(TypedValue,_count), ""Offset of _count must be equal in Variant and TypedValue""",2,2,4
 pIn->nMem==1 ,2,2,4
varIsPlausible(&fr),2,2,4
ad->isMixed() || ad->isDict(),2,2,4
"IsSameType<T, Types...>::value, ""Not all types in pack are the same""",2,2,4
subtypeOf(TCA) && m_hasConstVal,2,2,4
"offsetof(ObjectData, m_count) == FAST_REFCOUNT_OFFSET, """"",2,2,4
"!(KindOfIndirect & KindOfUncountedInitBit), """"",2,2,4
m_type == KindOfInt32 || m_type == KindOfInt64,2,2,4
*this <= Cell,2,2,4
m_top->m_data.ptv != NULL,2,2,4
p->second.isString(),2,2,4
category() == isSmall,2,2,4
m_iid != kTransient,2,2,4
"offsetof(c_Pair, m_size) == FAST_COLLECTION_SIZE_OFFSET, """"",2,2,4
it != m_constant.items().end(),2,2,4
"offsetof(APCTypedValue, m_handle) == sizeof(SharedData)",2,2,4
IS_STRING_TYPE(getType()),2,2,4
ptr,3,1,4
capacity > size,2,2,4
spc != Stack,2,2,4
&inst,2,2,4
!m_curTrace->back()->next(),2,2,4
limit == iter_limit(),2,2,4
"offsetof(APCArray, m_handle) == 0",2,2,4
 !pBt->readOnly ,2,2,4
acc->m_type == KindOfInt32 || acc->m_type == KindOfInt64,2,2,4
small_[smallSize()] == TERMINATOR || smallSize() == maxSmallSize || small_[smallSize()] == '\0',2,2,4
!(KindOfIndirect & KindOfStringBit),2,2,4
getVar(iter->second.var),2,2,4
!(KindOfClass & KindOfUncountedInitBit),2,2,4
m_immCopy.isNull() || (m_data == ((BaseVector*)m_immCopy.get())->m_data && arrayData()->hasMultipleRefs()),2,2,4
"le(s + n, oldData + oldSize)",2,2,4
U_SUCCESS(error),2,2,4
"sizeof(String) == sizeof(StringBase),""Fix this.""",2,2,4
"sizeof(ActRec*) <= sizeof(uint64_t), ""ActRec* must be <= 64 bits""",2,2,4
(uint32_t)off >> 31 == 0,4,0,4
&meta_ == &other.meta_,2,2,4
static_cast<uint32_t>(rs) < 32,4,0,4
subtypeOf(Cctx) && m_hasConstVal,2,2,4
(uint64_t(n) * sizeof(T)) < (uint64_t(1) << 32),2,2,4
KindOfInt64 & KindOfUncountedInitBit,2,2,4
(uintptr_t(sp) & 0xf) == 0,2,2,4
m_type == KindOfResource && m_data.pobj,2,2,4
b && e && b <= e,2,2,4
cellIsPlausible(to),3,1,4
!(KindOfClass & KindOfStringBit),2,2,4
isMixed(m_kind) || m_kind == kPackedKind,2,2,4
subtypeOf(Cls) && m_hasConstVal,2,2,4
capacity() >= newSz,2,2,4
Type::isStaticallyKnown(key->getType()),2,2,4
size() + n <= capacity(),2,2,4
"sizeof(Type) <= sizeof(uint64_t), ""JIT::Type should fit in a register""",2,2,4
capacity >= size,2,2,4
!(KindOfInt64 & KindOfStringBit),2,2,4
"!std::is_reference<Value>::value, ""Optional may not be used with reference types""",2,2,4
first <= last,2,2,4
i1 <= i2,2,2,4
startPos < endPos,2,2,4
m_data.pobj->getCount(),2,2,4
sizeof(*this) == sizeof(int),2,2,4
fp->func()->isGenerator(),2,2,4
 ((Fts3Table *)pVtab)->nPendingData==0 ,2,2,4
size < packedCodeToCap(packedCapCode),2,2,4
isHphpArray(),2,2,4
subtypeOf(RDSHandle) && m_hasConstVal,2,2,4
"offsetof(APCTypedValue, m_handle) == 0",2,2,4
relOffset >= static_cast<int32_t>(env.irb->evalStack().size()),2,2,4
KindOfDouble & KindOfUncountedInitBit,2,2,4
subtypeOf(Func) && m_hasConstVal,2,2,4
(cacheLineSize() & (cacheLineSize()-1)) == 0,2,2,4
"(offsetof(StrNR, m_px) == kExpectedMPxOffset)",2,2,4
cb.contains(start),2,2,4
effectiveCapacity >= ml_.capacity(),2,2,4
 u.az.oc==OP_SeekGe || u.az.oc==OP_SeekGt ,2,2,4
"offsetof(APCString, m_handle) == 0",2,2,4
lgSize <= 32,2,2,4
i <= mask,4,0,4
"offsetof(ResourceData, m_count) == FAST_REFCOUNT_OFFSET, """"",2,2,4
idx >= 0 && idx < length(),2,2,4
b.code.isValidAddress(addr),2,2,4
i < m_locs.size(),2,2,4
ml_.data_[ml_.size_] == TERMINATOR || ml_.data_[ml_.size_] == '\0',2,2,4
dummyFixups.empty(),2,2,4
nullptr == tv || tvIsPlausible(*tv),2,2,4
small_[smallSize()] == '\0',2,2,4
size() == desiredSize,2,2,4
begin() <= i1 && i1 <= end(),2,2,4
inst->getBlock() == this,2,2,4
 pBt->pageSize>=512 && pBt->pageSize<=32768 ,2,2,4
"offsetof(ArrNR, m_px) == kExpectedMPxOffset, """"",2,2,4
isValid(first) && isValid(last),2,2,4
subtypeOf(Bool) && m_hasConstVal,2,2,4
m_type == KindOfVariant ? m_data.pvar->m_data.pstr : m_data.pstr,2,2,4
refIsPlausible(&ref),2,2,4
p >= begin() && p <= end(),2,2,4
(numT * sizeof(T)) % 8 == 0,2,2,4
capCode <= 0xFFFFFFul && capCode <= cap,2,2,4
ret <= kMaxSmartSize,2,2,4
result->refCount_.load(std::memory_order_acquire) == 1,2,2,4
m_data.parr->getCount(),2,2,4
canSpecializeClass() || subtypeOf(Type::Cls),2,2,4
hasCollection() && getCollectionType() == Collection::FrozenSetType,2,2,4
 pPager->state > PAGER_UNLOCK ,2,2,4
(void*)dynamic_cast<ObjectData*>(data) == (void*)data,2,2,4
s_class,3,1,4
KindOfStaticString & KindOfStringBit,2,2,4
dest,2,2,4
m_immCopy.isNull() || (m_data == ((HashCollection*)m_immCopy.get())->m_data && arrayData()->hasMultipleRefs()),2,2,4
gen->hasExactlyOneRef(),2,2,4
"std::is_same<Expected, Value>::value, ""assert_type() check failed""",2,2,4
"!(sizeof(MediumLarge) % sizeof(Char)), ""Corrupt memory layout for fbstring.""",2,2,4
KindOfStaticString & KindOfUncountedInitBit,2,2,4
m_funcId != Func::InvalidId,2,2,4
flag >= 1ul << 48,2,2,4
 p->id==SQLITE_MUTEX_RECURSIVE || os2MutexNotheld(p) ,2,2,4
!m_state.fpiStack.empty(),2,2,4
"imm == 0 || deltaFits(delta, sz::byte)",2,2,4
malloc_initialized,2,2,4
ne.first->data()[ne.first->size()] == 0,2,2,4
 0!=pFile->locktype ,2,2,4
size() >= idx,2,2,4
"e, assert_fail_impl(e), ::folly::format(__VA_ARGS__).str()",2,2,4
sp.start() != nullptr,2,2,4
!(KindOfRef & KindOfStringBit),2,2,4
size() == srcSize,2,2,4
"size > 0 && ""size must be nonzero""",2,2,4
arr->m_kind == kMixedKind || arr->m_kind == kPackedKind,2,2,4
"mpl::size<Integrals>::value == 0 || mpl::size<Integrals>::value == 1, ""Multiple size types specified in small_vector<>""",2,2,4
getClsCnsData(class_) == nullptr,2,2,4
size() == rhs.size(),2,2,4
arena->magic == ARENA_MAGIC,2,2,4
"sizeof(void*) == 8, ""Unexpected pointer size""",2,2,4
(tv)->m_type == KindOfVariant,2,2,4
InitCell,2,2,4
 sz<=pBt->pageSize/4 ,2,2,4
*this <= StkElem,2,2,4
m_kind == Kind::Indirect,2,2,4
klass != nullptr,2,2,4
"offsetof(MediumLarge, data_) == 0",2,2,4
"MAX_HEIGHT >= 2 && MAX_HEIGHT < 64, ""MAX_HEIGHT can only be in the range of [2, 64)""",2,2,4
"offsetof(Array, m_px) == offsetof(Value, m_data), ""Offset of m_px in Array must be offset of m_data in Value""",2,2,4
"sizeof(IntType) == 2 || sizeof(IntType) == 4 || sizeof(IntType) == 8, ""PicoSpinLock can't work on integers smaller than 2 bytes""",2,2,4
"sizeof(DataType) == 4 || sizeof(DataType) == 1, ""Your DataType has an unsupported size.""",2,2,4
"offsetof(BaseMap, m_size) == FAST_COLLECTION_SIZE_OFFSET, """"",2,2,4
extraInfo <= kExtraInfoMax,2,2,4
is(KindOfInt32) || is(KindOfInt64),2,2,4
!(KindOfObject & KindOfStringBit),2,2,4
m_hLoad <= m_cap,2,2,4
!getVMClass()->needsInitThrowable(),2,2,4
hasExactlyOneRef(),3,1,4
m_type == KindOfRef ? m_data.pvar->m_data.pstr : m_data.pstr,2,2,4
ty <= Type::Gen,2,2,4
category() == isSmall && size() == 0,2,2,4
KindOfNull & KindOfUncountedInitBit,2,2,4
"offsetof(SharedVar, m_count) == offsetof(TypedValue, _count), ""Offset of m_count must be equal SharedVar and TypedValue""",2,2,4
extra >= 0,2,2,4
handle,2,2,4
!(t->isConst() && t->isA(Type::Int)),2,2,4
"std::is_integral<typename BaseIter::value_type>::value, ""BitIterator may only be used with integral types""",2,2,4
d >= e || d + (e - b) <= b,2,2,4
m_label >= 1,2,2,4
!maybe(Uninit) || *this == Cell,2,2,4
AssertDetailImpl*,2,2,4
chunk != NULL,2,2,4
HPHP::Variant const&,2,2,4
r1 != reg::noreg && r2 != reg::noreg,2,2,4
check_refcount_ns_nz(m_count),2,2,4
ml_.data_[ml_.size_] == '\0',2,2,4
"!containerMode || sizeof...(Args) == 1, ""Exactly one argument required in container mode""",2,2,4
"sizeof(PaddedSpinLock) == FOLLY_CACHE_LINE_SIZE, ""Invalid size of PaddedSpinLock""",2,2,4
"sizeof(DataType) == 1, ""required for m_cow/z packing""",2,2,4
" sizeof(m_flags_val) == sizeof(m_flags), ""m_flags_val must cover all the flags""",2,2,4
tvIsPlausible(*to),2,2,4
subtypeOf(StaticStr) && m_hasConstVal,2,2,4
lgSize >= 2,2,2,4
"reachable(b_, e_, typename std::iterator_traits<Iter>::iterator_category())",2,2,4
!newVal->type().maybe(Type::BoxedCell),2,2,4
m_count == 1,2,2,4
p.second >= size,2,2,4
m_px && m_px->getCount() == 0,2,2,4
currentRead != writeIndex_.load(std::memory_order_acquire),2,2,4
isEncodableCap(cap),2,2,4
"offsetof(Variant,_count) == FAST_REFCOUNT_OFFSET",2,2,4
!m_needInitFree,2,2,4
isAligned(mem),2,2,4
bytes <= kMaxSmartSize + kDebugExtraSize,2,2,4
current.m_count >= 0 && current.m_bytes >= 0,2,2,4
cap <= kMaxPackedCap && packedCapCode <= cap,2,2,4
"deltaFits(table, sz::dword), ""Destructor function table is expected to be in the data "" ""segment, with addresses less than 2^31"" ",2,2,4
isRealType(t) || t == kInvalidDataType,3,1,4
(size & PAGE_MASK) == 0,2,2,4
isHandlerRegistered(),2,2,4
capacity() >= sz + 1,2,2,4
!getVMClass()->callsCustomInstanceInit(),2,2,4
varIsPlausible(&var),2,2,4
m_top->m_type == KindOfHome,2,2,4
"offsetof(String, m_px) == offsetof(Value, m_data), ""Offset of m_px in String must be offset of m_data in Value""",2,2,4
getKind() == Kind::AwaitAllWaitHandleNode,2,2,4
ad->kind() == ArrayKind::kVector,2,2,4
rbp_n_t != &(a_tree)->rbt_nil,2,2,4
"sizeof(ObjectImpl) <= sizeof(Data::objectBuffer), ""In your implementation, std::unordered_map<> apparently takes different"" "" amount of space depending on its template parameters. This is "" ""weird. Make objectBuffer bigger if you want to compile dynamic.""",2,2,4
getTypeParam() == Type::NamedEntityPtr,2,2,4
m_main,2,2,4
(tv)->m_type > LiteralString,2,2,4
"sizeof(A) == 0, ""If you want to use a custom allocator, then you must upgrade to gcc 4.7""",2,2,4
"sizeof(std::atomic<KeyT>) == sizeof(KeyT), ""std::atomic is implemented in an unexpected way for AHM""",2,2,4
i < len,2,2,4
!validPos(*ei) && m_size <= m_used && m_used < m_cap,2,2,4
currentSize <= currentCapacity && currentCapacity < newCapacity,2,2,4
"offsetof(Variant,_count) == FAST_REFCOUNT_OFFSET, ""Offset of _count in Variant must be FAST_REFCOUNT_OFFSET""",2,2,4
refIsPlausible(&fr),2,2,4
front()->getOpcode() == DefLabel,2,2,4
"IMPLIES(a != staticEmptyMixedArray() && b, m_immCopy.isNull())",2,2,4
!s.empty() && s.start() != nullptr,2,2,4
"sizeof(T) <= sizeof ret, ""Constant data was larger than supported""",2,2,4
"IMPLIES(m_data == nullptr, !b)",2,2,4
 u.bd.pC->rowidIsValid==0 ,2,2,4
"(offsetof(Array, m_px) == kExpectedMPxOffset)",2,2,4
!(KindOfNull & KindOfStringBit),2,2,4
isContextFixed(),2,2,4
cls != nullptr,4,0,4
dynamic_cast<HphpArray*>(ad),2,2,4
" (boost::is_base_of<ObjectData,T>::value) || (boost::is_base_of<ResourceData,T>::value), ""Cannot allocate types other than ObjectData and ResourceData""",2,2,4
m_type == KindOfRef ? m_data.pvar->m_data.pobj : m_data.pobj,2,2,4
m_analysisDepth >= 0,2,2,4
"offsetof(BaseSet, m_size) == FAST_COLLECTION_SIZE_OFFSET, """"",2,2,4
i < m_dstOff,2,2,4
"deltaFits(diff, sz::dword)",2,2,4
"(offsetof(SmartPtr, m_px) == kExpectedMPxOffset)",2,2,4
"std::is_unsigned<SizeType>::value, ""Size type should be an unsigned integral type""",2,2,4
k->m_type == KindOfRef,2,2,4
condition,2,2,4
!rhs.isUnion(),2,2,4
m_kind == kMixedKind,2,2,4
isObj() && m_class == nullptr,2,2,4
hasCollection() && getCollectionType() == Collection::FrozenVectorType,2,2,4
b != NULL,2,2,4
o_attribute == flags && m_kind == HeaderKind::Object && !m_count,2,2,4
pos >= 0 && pos < size(),2,2,4
 pRight->eType==FTSQUERY_PHRASE ,2,2,4
*this <= (Gen | PtrToGen),2,2,4
queue_ == nullptr,2,2,4
(const void*)&*d != &*b,2,2,4
 pLeft->eType==FTSQUERY_PHRASE ,2,2,4
"BitPhase<UseKindNonStaticRef>::value <= 2, ""UseKindNonStaticRef set bits should be consecutive""",2,2,4
!(KindOfArray & KindOfStringBit),2,2,4
"opc == getOpcode() && ""getExtra type error""",2,2,4
ad->kind() == ArrayKind::kHphpArray,2,2,4
"sizeof(Data) == sizeof(uint32_t), ""UnwindRegInfo::Data was too big""",2,2,4
arrayKindValid(info),2,2,4
(size & chunksize_mask) == 0,2,2,4
t->isA(Type::Obj) || Type::isPtr(t->getType()),2,2,4
data[size] == '\0',2,2,4
!(KindOfIndirect & KindOfUncountedInitBit),2,2,4
hasArrayKind(),2,2,4
n1 >= 0,2,2,4
"!(KindOfIndirect & KindOfStringBit), """"",2,2,4
var,2,2,4
tail != this,2,2,4
ad->kind() == kPackedKind,2,2,4
"offsetof(ActRec, m_savedRbp) == 0, ""m_savedRbp should be at offset 0 of ActRec""",2,2,4
"offsetof(SharedVar, m_type) == offsetof(TypedValue, m_type), ""Offset of m_type must be equal in SharedVar and TypedValue""",2,2,4
obj->checkCount(),3,1,4
"kVectorKind < kMixedKind, """"",2,2,4
delta <= size(),2,2,4
obj->getCount() > 0,2,2,4
"offsetof(Array, m_px) == kExpectedMPxOffset, """"",2,2,4
size < n,2,2,4
IS_REAL_TYPE(t),2,2,4
"(std::is_convertible<KeyT,int32_t>::value || std::is_convertible<KeyT,int64_t>::value), ""You are trying to use AtomicHashArray with disallowed key "" ""types. You must use atomically compare-and-swappable integer "" ""keys, or a different container class.""",2,2,4
trailsize < alloc_size,2,2,4
sizeof(T) <= MemoryManager::kMaxSmartSize,2,2,4
len >= 0 && len < capacity() && !isImmutable(),2,2,4
!IS_REFCOUNTED_TYPE(m_handle.m_type),2,2,4
dynamic_cast<const HphpArray*>(ad),2,2,4
!IS_REFCOUNTED_TYPE(type) || type == KindOfString || type == KindOfArray || type == KindOfObject,2,2,4
!(KindOfObject & KindOfUncountedInitBit),2,2,4
id < m_numTrans,2,2,4
check_refcount_nz(m_count),2,2,4
!isVarNR(),2,2,4
m_next.load(),3,1,4
size() == oldSize + n + 1,2,2,4
"HasMutex::value == 0 || HasMutex::value == 1, ""Multiple copies of small_vector_policy::OneBitMutex "" ""supplied; this is probably a mistake""",2,2,4
0 <= out && out < 64,4,0,4
pobj,2,2,4
inst.src(i)->isConst(),2,2,4
value > 0,2,2,4
this->m_opaque,2,2,4
n->jmp->op() == Jmp_ && n->jmp->getTaken() == this,2,2,4
"offsetof(ArrayData, m_count) == FAST_REFCOUNT_OFFSET, """"",2,2,4
"READER > WRITER + UPGRADED, ""wrong bits!""",2,2,4
id != Func::InvalidId,2,2,4
subtypeOf(Int) && m_hasConstVal,2,2,4
value == 1,2,2,4
oldsize > newsize,2,2,4
!isVector(),2,2,4
"sizeof(UnwindRegInfo) <= sizeof(uint64_t) * 2, ""Unexpected size for UnwindRegInfo""",2,2,4
getState() == State::Created || getState() == State::Started,2,2,4
k->m_type == keyDataType(kt) || (IS_STRING_TYPE(k->m_type) && IS_STRING_TYPE(keyDataType(kt))),2,2,4
m_universe_size == o.m_universe_size,4,0,4
m_handle.m_flags == 0,2,2,4
index <= m_count,2,2,4
"sizeof(int64_t) == sizeof(PosType), """"",2,2,4
 u.az.oc==OP_SeekLt || u.az.oc==OP_SeekLe ,2,2,4
size() == newSz,2,2,4
 u.bf.pC->isTable ,2,2,4
(sizeof(size_t) & (sizeof(size_t) - 1)) == 0,2,2,4
!(flags & AccessFlags::CheckExist),2,2,4
begin != end,2,2,4
(a_node) == rbp_r_c,2,2,4
sizeof(Char*) == sizeof(size_t),2,2,4
static_cast<T*>(p)->heapSize() == sizeof(T),2,2,4
"sizeof(PackedSyncPtr<void>) == 8, ""PackedSyncPtr should be only 8 bytes---something is "" ""messed up""",2,2,4
"offsetof(ObjNR, m_px) == kExpectedMPxOffset, """"",2,2,4
pos < (ssize_t) m_data.vec->size,2,2,4
m_label == -1,2,2,4
"!std::is_signed<Tgt>::value, ""Unsigned type expected""",2,2,4
check_refcount_nz(m_hdr.count),2,2,4
ei && !validPos(*ei) && m_size <= m_used && m_used < m_cap,2,2,4
 pOpen->nLock>=0 ,2,2,4
"KindOfString == 0x14, """"",2,2,4
KindOfBoolean & KindOfUncountedInitBit,2,2,4
errno == EAGAIN,2,2,4
b == e,2,2,4
"offsetof(MediumLarge, size_) == sizeof(ml_.data_)",2,2,4
*this <= BoxedCell,2,2,4
"memcmp(this->data(), data, size * sizeof(Char)) == 0",2,2,4
"sizeof(DataType) == 1, ""Your DataType has an unsupported size.""",2,2,4
getSPropData(class_) == NULL,2,2,4
(m_bits & 1) == 0,2,2,4
canSpecializeClass() && m_class == nullptr,2,2,4
isObj() && m_class != nullptr,2,2,4
isObj(),2,2,4
!delayed,2,2,4
category() == isLarge && size() == rhs.size(),2,2,4
this->size() == size,2,2,4
this != &null_variant,2,2,4
r != reg::noreg,2,2,4
!(KindOfUninit & KindOfStringBit),2,2,4
(next_ == this) == (prev_ == this),2,2,4
"(offsetof(ObjNR, m_px) == kExpectedMPxOffset)",2,2,4
m_used <= m_cap,2,2,4
(fr)->m_type == KindOfRef,2,2,4
isBoxed() || equals(Bottom),2,2,4
(buffer_size >= 2) && ((buffer_size & (buffer_size - 1)) == 0),2,2,4
 pArray->aBtree[i]!=pBtree ,2,2,4
func->isNonAsyncGenerator(),2,2,4
++m_addCount <= m_expectedCount,4,0,4
cap <= kMaxPackedCap && capCode <= cap,2,2,4
"imm == 0 || deltaFits(delta, sz::dword)",2,2,4
probe == static_cast<uint32_t>(h0) + (i + i * i) / 2,4,0,4
"sizeof(Type) <= 2 * sizeof(uint64_t), ""JIT::Type should fit in (2 * sizeof(uint64_t))""",2,2,4
!(KindOfString & KindOfUncountedInitBit),2,2,4
"kBitWidth == 32 || kBitWidth == 64, ""bit width has to be either 32 or 64 """,2,2,4
isClosureBody(),2,2,4
reg != InvalidReg,2,2,4
"std::is_integral<IntType>::value, ""PicoSpinLock needs an integral type""",2,2,4
buffer == finish,2,2,4
ad->isMixed(),2,2,4
bytes <= kMaxSmallSize,3,1,4
"HasNoHeap::value == 0 || HasNoHeap::value == 1, ""Multiple copies of small_vector_policy::NoHeap "" ""supplied; this is probably a mistake""",2,2,4
m_type == KindOfResource && m_data.pres,3,1,4
getKind() == Kind::AsyncFunction || getKind() == Kind::AsyncGenerator,2,1,3
!cls->getNativeDataInfo(),2,1,3
isPassthrough(),2,1,3
m_immCopy.isNull() || (data() == ((HashCollection*)m_immCopy.get())->data() && arrayData()->hasMultipleRefs()),2,1,3
varEnv != nullptr,2,1,3
cc >= 0 && cc <= 0xF,2,1,3
isMonomorphic(),2,1,3
func->isResumable(),2,1,3
"offsetof(BaseMap, m_size) == collections::FAST_SIZE_OFFSET, """"",2,1,3
"std::is_convertible<T*,ResourceData*>::value, """"",2,1,3
"std::is_pod<T>::value, ""Constant data wasn't a pod""",2,1,3
!m_px,2,1,3
"false && ""FixedStringMap::Builder overflowed""",2,1,3
hasConstVal(),2,1,3
result.m_type != KindOfRef,2,1,3
"!""extra<T> was called with an extra data type that "" ""doesn't exactly match the opcode type""",2,1,3
DataType(int8_t(t)) == t,2,1,3
contains(pc),2,1,3
m_deallocated,2,1,3
it != begin(),2,1,3
"IMPLIES(exit == nullptr, !curFunc(env)->isPseudoMain())",2,1,3
"offsetof(BaseGenerator, m_resumable) == 0, ""Resumable must be the first member of the Generator""",2,1,3
m_fullName != nullptr,2,1,3
tl_regState == VMRegState::DIRTY,2,1,3
cellIsPlausible(tv),2,1,3
"!(KindOfRef & KindOfUncountedInitBit), """"",2,1,3
"KindOfInt64 & KindOfUncountedInitBit, """"",2,1,3
isArray(),3,0,3
spOffset >= 0,2,1,3
 m_state.load() == Finished || m_state.load() == Canceled || m_state.load() == Abandoned ,2,1,3
nmemb_written == nmemb,2,1,3
!exists(key),2,1,3
priority < m_jobQueues.size(),2,1,3
(flags() & ~IsFCallAwait) == Flags::None,2,1,3
pcOffset >= 0,2,1,3
"is(IncRef, CheckType, AssertType, AssertNonNull, ColAddElemC, ColAddNewElemC, Mov)",2,1,3
ndi->scan,2,1,3
env.state.stack.empty(),2,1,3
sanityCheck(),2,1,3
obj->noDestruct(),2,1,3
"!detail::UnboundedArray<T>::value, ""Trying to scan unbounded array""",3,0,3
dynamic_cast<ObjectData*>(tv->m_data.pobj),2,1,3
"IMPLIES(!arrayData()->cowCheck(), m_immCopy.isNull())",2,1,3
" std::is_pointer<Fun>::value && std::is_function<typename std::remove_pointer<Fun>::type>::value, ""You can only register pointers to functions."" ",3,0,3
hasVarEnv(),2,1,3
isMergeOnly(),2,1,3
"KindOfNull & KindOfUncountedInitBit, """"",2,1,3
!curFunc(env)->isPseudoMain(),2,1,3
isReturnHelper(jit::mcg->ustubs().callToExit),2,1,3
!target || inst->hasEdges(),2,1,3
n >= 0 && n < kMaxRegs,2,1,3
m_hasTypeParam,2,1,3
!m_hdr.aux.cow && !m_hdr.aux.z,2,1,3
n <= Max,3,0,3
numT != 0,2,1,3
m_allocated,2,1,3
c.m_type == KindOfObject && c.m_data.pobj->isCollection(),2,1,3
loc.numAllocated() == 1,3,0,3
cellIsPlausible(*base),2,1,3
type == type.dropConstVal(),2,1,3
msg->isStatic(),2,1,3
errOk || err == 0,2,1,3
"!(KindOfResource & KindOfStringBit), """"",2,1,3
id == m_nextFreeIterator,2,1,3
v.subtypeOf(TInitCell),2,1,3
" offsetof(BaseVector, m_size) == collections::FAST_SIZE_OFFSET, """"",2,1,3
tvIsPlausible(*this) && tvIsPlausible(v),2,1,3
prev >= 0 && prev < m_size,2,1,3
cellIsPlausible(*result),2,1,3
!smashesAllLocals || !nChangedLocals,2,1,3
"KindOfBoolean & KindOfUncountedInitBit, """"",2,1,3
m_hdr.aux != 0,2,1,3
!m_hdr.aux.cow,3,0,3
fromFuncId(m_funcId) == this,2,1,3
!(cls->getODAttrs() & ~static_cast<uint16_t>(flags)),2,1,3
optimizing(),2,1,3
"!(KindOfString & KindOfUncountedInitBit), """"",2,1,3
"Vreg::G0 == 0, """"",2,1,3
"!(KindOfClass & KindOfUncountedInitBit), """"",2,1,3
jmp->op() == Jmp && jmp->taken() == this,2,1,3
v.m_type == KindOfRef,2,1,3
!exists(ki),2,1,3
m_state.load() == Finished,2,1,3
th_id == NULL,2,1,3
!decRefOld,2,1,3
isStringType(key->m_type),2,1,3
m_conn,2,1,3
(uint32_t{flags} & kNumArgsMask) == 0,2,1,3
"offsetof(ActRec, m_sfp) == 0, ""m_sfp should be at offset 0 of ActRec""",2,1,3
hasThis() || hasClass(),2,1,3
size % sizeof(T) == 0,3,0,3
tvIsPlausible(v),3,0,3
tv->m_type == KindOfResource,2,1,3
r->hasExactlyOneRef(),2,1,3
"offsetof(BaseSet, m_size) == collections::FAST_SIZE_OFFSET, """"",2,1,3
"is(IncRef, CheckType, AssertType, AssertNonNull, MapAddElemC, ColAddNewElemC, CastCtxThis, Mov)",2,1,3
!arrayData()->cowCheck(),3,0,3
!m_cachedClass.bound(),2,1,3
tmp != ad,2,1,3
"IMPLIES(N, mode == Mode::Normal)",3,0,3
!cls->instanceDtor(),2,1,3
k == m_size,2,1,3
(uintptr_t(address) & (sizeof(T) - 1)) == 0,2,1,3
v.subtypeOf(TRef),2,1,3
"!(KindOfObject & KindOfUncountedInitBit), """"",2,1,3
i < numSrcs(),3,0,3
!resumed(),2,1,3
index < kNumSmallSizes,3,0,3
"!(KindOfUninit & KindOfUncountedInitBit), """"",2,1,3
"sizeof(AliasIdSet) == sizeof(uint64_t), """"",2,1,3
!m_stack.empty(),2,1,3
!validPos(*ei) && !isFull(),2,1,3
m_count.load() > 0,2,1,3
!magicDispatch(),2,1,3
magic == MAGIC_CONSTANT,2,1,3
mallctl != nullptr,2,1,3
hasClass(),2,1,3
hasConstVal(TypeName),2,1,3
n <= 0x7fffffffU,2,1,3
hasThis(),2,1,3
m_stack,2,1,3
cellIsPlausible(value),2,1,3
m_hdr.aux.cow == 0 || (m_hdr.aux.cow == 1 && m_hdr.count >= 1),3,0,3
(void*)this != (void*)&src,2,1,3
"KindOfDouble & KindOfUncountedInitBit, """"",2,1,3
f != nullptr,2,1,3
keyType <= TCell,2,1,3
!type.isSpecialized(),2,1,3
a.isMonomorphic(),2,1,3
ad->hasExactlyOneRef(),2,1,3
"offsetof(StrNR, m_px) == kExpectedMPxOffset, """"",2,1,3
n != kInvalidId,2,1,3
m_iter != m_map.end(),2,1,3
isValidHandle(handle),3,0,3
idx < vec.size(),2,1,3
k < m_universe_size,2,1,3
guard,2,1,3
tvRef.m_data.pstr->isStatic(),2,1,3
"!(KindOfArray & KindOfUncountedInitBit), """"",2,1,3
" sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8, ""T must be a 1, 2, 4, or 8 byte object for atomic access""",2,1,3
l <= h,2,1,3
obj->isCollection(),2,1,3
v.subtypeOf(TCls),2,1,3
sorted_,2,1,3
!cls->needInitialization() || cls->initialized(),3,0,3
"G0 < V0 && X0 < V0 && S0 < V0 && V0 < kInvalidReg, """"",2,1,3
!cls->instanceCtor(),2,1,3
h->heapSize() == size,2,1,3
!is_null(p),2,1,3
m_varEnv != reinterpret_cast<VarEnv*>(kTrashedVarEnvSlot),2,1,3
i < numPop(),3,0,3
"int(index) != -1 && ""invalid register""",2,1,3
fixup.spOffset >= 0,2,1,3
isCatch(),2,1,3
m_size == 0,3,0,3
m_iter == m_map.end() || key <= m_iter->first,2,1,3
priority >= 0,2,1,3
 testAddr>0 || pParse->db->mallocFailed ,1,1,2
arena != NULL,1,1,2
 (p->btreeMask & (1<<pOp->p2))!=0 ,1,1,2
"offsetof(StringData, _count) == FAST_REFCOUNT_OFFSET",1,1,2
 p->aMem[n].db==db ,1,1,2
 sqlite3GlobalConfig.bMemstat || mem.mutex!=0 ,1,1,2
 pOrderBy || (pCost->plan.wsFlags&WHERE_ORDERBY)==0 ,1,1,2
m_data.parr != px,1,1,2
assertValidHelper(obj),1,1,2
"kBitSize == sizeof(TypedValue*), """"",1,1,2
"sizeof(uint32_t) == 4, ""bad platform""",1,1,2
"(std::is_base_of<ObjectData,T>::value || std::is_base_of<ResourceData,T>::value), ""isa() only works for Resource and Object classes""",1,1,2
 p->iLimit==0 ,1,1,2
 u.ag.apVal || u.ag.n==0 ,1,1,2
"std::is_integral<Value>::value && std::is_unsigned<Value>::value, ""Value should be unsigned integral""",1,1,2
getType() == Type::VarEnvPtr,1,1,2
 u.at.iDb>=0 && u.at.iDb<db->nDb ,1,1,2
stackaddr != NULL,1,1,2
m_cls == nullptr,2,0,2
offset >= static_cast<int32_t>(env.irb->evalStack().numCells()),1,1,2
tv->_count == 0,1,1,2
(flags_ & (kFlagExt | kFlagMaybeShared)) == (kFlagExt | kFlagMaybeShared),1,1,2
 pArray->nMutex>=0 ,1,1,2
 (u.be.pMem->flags & MEM_Int)!=0 ,1,1,2
getType() == KindOfInt64 || getType() == KindOfInt32,1,1,2
 (i64)nDestTruncate*(i64)nDestPagesize >= iSize || ( nDestTruncate==(int)(PENDING_BYTE_PAGE(p->pDest->pBt)-1) && iSize>=PENDING_BYTE && iSize<=PENDING_BYTE+nDestPagesize ),1,1,2
 u.ao.nField>0 && pOp->p2>0 && pOp->p2+u.ao.nField<=p->nMem+1 ,1,1,2
m_immCopy.isNull() || (m_data == ((BaseMap*)m_immCopy.get())->m_data && arrayData()->hasMultipleRefs()),1,1,2
 get2byte(&data[hdr+5])==nUsable ,1,1,2
obj->getVMClass() == c_AsyncGenerator::classof() || obj->getVMClass() == c_Generator::classof(),1,1,2
 eType!=SQLITE_OPEN_MAIN_DB ,1,1,2
pos2 >= 0 && pos2 < dest.size(),1,1,2
pos != PosType::invalid,1,1,2
"!Source::infinite, ""Cannot count infinite source""",1,1,2
chunk->arena->magic == ARENA_MAGIC,1,1,2
"sizeof(ServiceReqInfo) == 0x30, ""rsp adjustments in handleSRHelper""",1,1,2
incr >= 0,1,1,2
newlyCreated,1,1,2
"kMaxSmartSize > kSmartSizeAlign * 2, ""Too few size classes""",1,1,2
m_kind == HeaderKind::Object || m_kind == HeaderKind::ResumableObj,1,1,2
m_hdr.aux == flags && !getCount(),1,1,2
 pc==u.by.pFrame->pc ,1,1,2
p.hasStr(),1,1,2
 u.cb.n>=0 ,1,1,2
m_big.cap == cap,1,1,2
mag->nrounds < max_rounds,1,1,2
b == (m_kind == kIntMapKind || m_kind == kVPackedKind),1,1,2
 (rc==SQLITE_OK && pNode) || (pNode==0 && rc!=SQLITE_OK) ,1,1,2
"(std::is_convertible<KeyT,int32_t>::value || std::is_convertible<KeyT,int64_t>::value || std::is_convertible<KeyT,const void*>::value), ""You are trying to use AtomicHashArray with disallowed key "" ""types. You must use atomically compare-and-swappable integer "" ""keys, or a different container class.""",1,1,2
 u.ab.p1>=0 && u.ab.p1+u.ab.n<=p->nVar ,1,1,2
isObjectKind(kind),2,0,2
 pParent->nOverflow==0 || pParent->aOvfl[0].idx==iParentIdx ,1,1,2
 (p->btreeMask & (1<<u.aw.iDb))!=0 ,1,1,2
 u.ar.desiredAutoCommit==1 ,1,1,2
oldsize == (chunk->map[pageind].bits & ~PAGE_MASK),1,1,2
*this <= Dbl && m_hasConstVal,1,1,2
howTo.empty(),1,1,2
"std::is_unsigned<typeof(m_pos)>::value, ""m_pos should be unsigned""",1,1,2
(nbytes & 7) == 0,1,1,2
(reinterpret_cast<uintptr_t>(ptr) & kSmartSizeAlignMask) == 0,1,1,2
cls->numDeclProperties() == 0,2,0,2
m_type == Type::Bool,1,1,2
check_refcount_nz(this->m_count),1,1,2
nOverflow<3 || pOld->aOvfl[1].idx==pOld->aOvfl[2].idx-1,1,1,2
"boost::has_trivial_destructor<T>::value, ""GrowableVector can only hold trivially destructible types""",1,1,2
" offsetof(APCTypedValue, m_handle) == 0, ""m_handle must appear first in PACKED_TV"" ",1,1,2
"(FAST_REFCOUNT_OFFSET >= sizeof(void*)), ""FAST_REFCOUNT_OFFSET has to be larger than "" ""sizeof(void*) to work correctly with GarbageList""",1,1,2
"sizeof(Type) <= 2 * sizeof(uint64_t), ""jit::Type should fit in (2 * sizeof(uint64_t))""",1,1,2
" kMaxSmartSize <= std::numeric_limits<uint32_t>::max(), ""Size-specified smart malloc functions assume this"" ",1,1,2
 nOut==0 || pOut!=0 ,1,1,2
other->m_data.pstr,1,1,2
mainCode.base() != hotCode.base() && mainCode.base() != stubsCode.base() && hotCode.base() != stubsCode.base(),1,1,2
hasCollection() && getCollectionType() == CollectionType::Pair,1,1,2
"sizeof(X_format) == sizeof(uint32_t), ""X_format_t size != 4""",1,1,2
m_nLastSlot != 0,1,1,2
*heap + heap_size == bottom + shared_mem_size + page_size,1,1,2
"sizeof(Z22_format) == sizeof(uint32_t), ""Z22_format_t size != 4""",1,1,2
hasCollection() && getCollectionType() == CollectionType::ImmSet,1,1,2
bin->runcur->nfree > 0,1,1,2
 pDest->nMem==nResultCol ,1,1,2
!dst,1,1,2
 yymsp[-2].minor.yy473!=0 ,1,1,2
"sizeof(MD_format) == sizeof(uint32_t), ""MD_format_t size != 4""",1,1,2
"memset(obj, 0x5a, m_itemSize)",1,1,2
"rbp_right_get(a_type, a_field, rbp_i_g) == rbp_i_p",1,1,2
bin_mags->curmag->binind == i,1,1,2
"sizeof(XS_format) == sizeof(uint32_t), ""XS_format_t size != 4""",1,1,2
(KindOfString & ~1) == KindOfStaticString,1,1,2
 (u.cc.pMem->flags & ~(MEM_Null|MEM_Agg))==0 ,1,1,2
uintptr_t(sp) % 16 == 0,1,1,2
"kVmspOff == 16 && kVmfpOff == 32, ""Eager vm-reg save in translator-asm-helpers.S""",1,1,2
SUBPAGE * (((sizeof(ssize_invs)) / sizeof(unsigned)) + 3) >= PAGE_SIZE,1,1,2
m_type == Type::StaticStr,1,1,2
 (u.bv.pnErr->flags & (MEM_Str|MEM_Blob))==0 ,1,1,2
 pSrc->pIndex==0 || pCost->plan.u.pIdx==0 || pCost->plan.u.pIdx==pSrc->pIndex ,1,1,2
 sqlite3BtreeIsInTrans(u.as.pBt) ,1,1,2
size <= arena_maxclass,1,1,2
off >= 0,1,1,2
 (u.am.payloadSize64 & SQLITE_MAX_U32)==(u64)u.am.payloadSize64 ,1,1,2
"IMPLIES(isNumber(), m_type.dt != KindOfObject)",1,1,2
reg.isXMM() && m_kind != kSpill,1,1,2
pos + sizeof(T) <= m_bcmax,1,1,2
isClosureBody() || isGeneratorFromClosure(),1,1,2
n_fds <= ANCIL_MAX_N_FDS,2,0,2
 u.aw.p2<=p->nMem ,1,1,2
getType() == Type::Bool,1,1,2
"false && ""Not a valid conditional branch instruction""",1,1,2
"KindOfStaticString == 0x0C, """"",1,1,2
 i>=0 && i<p->db->nDb && i<sizeof(u32)*8 ,1,1,2
sizeof(mag_rack_t) + (sizeof(bin_mags_t *) * (nbins - 1)) <= bin_maxclass,1,1,2
!m_vec || m_vec->hasExactlyOneRef(),2,0,2
 u.az.oc==OP_SeekLe || u.az.oc==OP_SeekGt ,1,1,2
size < HASHTBL_SIZE,1,1,2
"(uint32_t)StaticValue & (1uL << UncountedBitPos), ""Check StaticValue and UncountedBitPos""",1,1,2
m_numNonVariadicParams == (hasVariadicCaptureParam() ? (m_numParams - 1) : (m_numParams)),1,1,2
"kSIMDOffset >= X64::kNumGPRegs, """"",1,1,2
 u.bn.pC->isTable==0 ,1,1,2
 pPager->state!=PAGER_UNLOCK ,1,1,2
"(checkForInt && !converted) || !checkForInt, ""Can't both check for integer string and have been converted""",1,1,2
 openList==pOpen ,1,1,2
Collection::isValidType(static_cast<Collection::Type>(m_kind)) || !isCollection(),1,1,2
((jmp[3] >> 2) & 0x3F) == 16,1,1,2
 u.bg.pC->deferredMoveto==0 ,1,1,2
m_writeLease.amOwner(),1,1,2
r->heapSize(),1,1,2
 pItem->iCol>0 && pItem->iCol<=p->pEList->nExpr ,1,1,2
id == m_unnamedLocals[m_nextFreeUnnamedLocal],1,1,2
obj->getVMClass() == c_Continuation::classof(),1,1,2
m_stats.peakIntervalSlabBytes >= 0,1,1,2
 compatible[RTREE_EQ & 7]==0 ,1,1,2
m_handle.m_shouldCache == false,1,1,2
" pPager->fd->pMethods==0 || sqlite3OsFileControl(pPager->fd,SQLITE_FCNTL_DB_UNCHANGED,0)>=SQLITE_OK ",1,1,2
alias.kind != KindOfObject,1,1,2
i != methodIndexMap.end(),1,1,2
isRefcountedType(tv->m_type),2,0,2
Cell,1,1,2
"subtypeOf(t1, Gen) || t1 == t2",1,1,2
"endless, ""Must supply 'end'""",1,1,2
"offsetof(Header, headerHash) + sizeof(Header::headerHash) == sizeof(Header), ""invalid header layout""",1,1,2
t1.subtypeOf(Gen) == t2.subtypeOf(Gen),1,1,2
 sqlite3SafetyCheckSickOrOk(db) ,1,1,2
"sizeof(StringData) == sizeof(char*) + 8 + sizeof(strhash_t) + StringData::MaxSmallSize + 1, ""StringData size changed---update assertion if you mean it""",1,1,2
node->size > size,1,1,2
ad->kind() == kApcKind,2,0,2
cst != nullptr,1,1,2
 sqlite3SafetyCheckOk(db) ,1,1,2
!m_data || m_data->hasExactlyOneRef(),2,0,2
getState() == STATE_SCHEDULED,1,1,2
(mapelm->bits & CHUNK_MAP_ALLOCATED) != 0,1,1,2
 u.bd.pC->pseudoTableReg==0 ,1,1,2
"offsetof(APCVariant, m_count) == TypedValueAux::auxOffset, ""Offset of m_count must equal offset of TV.m_aux""",1,1,2
exp->isKindOf(KindOfScalarValueExpression),1,1,2
 (u.bc.aMx[u.bc.nField].flags & MEM_Null)==0 ,1,1,2
"sizeof(Slab) == 16, """"",1,1,2
bytes <= kSmallIndex2Size[index],2,0,2
"ArrayData::kNvtwKind == uint8_t(HeaderKind::Nvtw), """"",1,1,2
check_refcount(m_data.pres->getCount()),1,1,2
BitCount<UseKindNonStaticRef>::value == 16,1,1,2
 u.an.zAffinity[pOp->p2]==0 ,1,1,2
kind() == HeaderKind::NativeData,2,0,2
 u.bv.nRoot>0 ,1,1,2
 pPager->dbOrigSize==0 ,1,1,2
 pParse->db->mallocFailed==0 ,1,1,2
 u.aj.i<u.aj.pKeyInfo->nField ,1,1,2
m_origFunc,1,1,2
orderings && orderings->is(Expression::KindOfExpressionList),1,1,2
handle->getType() == KindOfString,1,1,2
m_tail == nullptr,1,1,2
!highBitSet,2,0,2
IS_REFCOUNTED_TYPE(m_type) ? varNrFlag() == NR_FLAG : true,1,1,2
ad->m_kind == kPackedKind,1,1,2
"offsetof(ArrayData, _count) == FAST_REFCOUNT_OFFSET",1,1,2
t == FuncType::SSA,1,1,2
((uintptr_t(retval) ^ (uintptr_t(retval + 1) - 1)) & ~(kX64CacheLineSize - 1)) == 0,1,1,2
getType() == KindOfByte || getType() == KindOfInt16 || getType() == KindOfInt32 || getType() == KindOfInt64,1,1,2
Sub,1,1,2
!isContagious() && this != &v && !v.isContagious(),1,1,2
!on_fail || on_fail->instanceof(c_Closure::s_cls),1,1,2
(*it)->getMark() == BlockScope::MarkProcessedInQueue,1,1,2
size <= kMaxSmartSize,1,1,2
"pop(env), TGen",2,0,2
subtypeOf(StkElem),1,1,2
(tv)->m_type == KindOfArray,1,1,2
"kLgMaxSmartSize > kLgSmartSizeQuantum + 1, ""Too few size classes""",1,1,2
(DType == tv->m_type) || (IS_STRING_TYPE(DType) && IS_STRING_TYPE(tv->m_type)),1,1,2
loc.isLiteral(),1,1,2
origFp,1,1,2
"std::is_convertible<T*,ObjectData*>::value, """"",1,1,2
sizeof(arena_run_t) + (sizeof(unsigned) * (good_mask_nelms - 1)) <= good_reg0_offset,1,1,2
 argc==2 ,1,1,2
"(std::is_base_of<ObjectData,T>::value || std::is_base_of<ResourceData,T>::value), ""toSmartPtrCRef() only works for Resource or Object classes""",1,1,2
" canEmit(nBytes), ([this,nBytes] { return folly::format( ""Attempted to emit {} byte(s) into a {} byte DataBlock with {} bytes "" ""available. This almost certainly means the TC is full. If this is "" ""the case, increasing Eval.JitASize, Eval.JitAStubsSize and "" ""Eval.JitGlobalDataSize in the configuration file when running this "" ""script or application should fix this problem."", nBytes, m_size, m_size - (m_frontier - m_base)).str(); })",1,1,2
 pArray->nMutex<ArraySize(pArray->aBtree)-1 ,1,1,2
 pNew->pLock==NULL ,1,1,2
m_firstHoistableFunc == 1,1,1,2
handle->checkInvariants() && !handle->isAtomicCounted(),2,0,2
as.contains(start),1,1,2
uintptr_t(rawdata()) % 4 == 0,1,1,2
(uint32_t)count - 1 < (uint32_t)RefCountMaxRealistic,1,1,2
"success == 0 && ""sysinfo() failed""",2,0,2
m_handle.type() == KindOfPersistentArray || (m_handle.isUncounted() && m_handle.type() == KindOfArray),1,1,2
ret <= kMaxSmartSize + kDebugExtraSize,1,1,2
 u.ag.n==0 || (pOp->p2>0 && pOp->p2+u.ag.n<=p->nMem+1) ,1,1,2
"offsetof(APCArray, m_handle) == 0, """"",2,0,2
sv,1,1,2
 pLeft->pColl ,1,1,2
i==1 || (pDb->pBt && sqlite3BtreeHoldsMutex(pDb->pBt)),1,1,2
isMapCollection(getCollectionType()),1,1,2
reinterpret_cast<uintptr_t>(sp) % 16 == 0,1,1,2
v.m_type != KindOfVariant,1,1,2
(narenas & 1) == 0,1,1,2
m_cowAndZ == 0,1,1,2
(run->regs_mask[elm] & (1U << bit)) == 0,1,1,2
"offsetof(Array, m_px) == offsetof(TypedValue, m_data), ""Offset of m_px in Array must be offset of m_data in TV""",1,1,2
n->jmp->getOpcode() == Jmp_ && n->jmp->getTaken() == this,1,1,2
CHUNK_ADDR2BASE(chunk) == chunk,1,1,2
 pPager->state>=PAGER_SHARED || pPager->dbSizeValid==0 ,1,1,2
 u.bb.pC!=0 ,1,1,2
!r.isValid() || r.isVirt() || r.isGP(),1,1,2
count == RefCountStaticValue || (uint32_t)count - 1 < (uint32_t)RefCountMaxRealistic,1,1,2
getType() == Type::Int,1,1,2
 u.bq.pC->deferredMoveto==0 ,1,1,2
 pPager->journalMode!=PAGER_JOURNALMODE_OFF ,1,1,2
" sizeof(APCTypedValue) == sizeof(TypedValue), ""Be careful with field layout""",1,1,2
 dbMem==db || dbMem==0 ,1,1,2
m_vmFunc,1,1,2
"kNumSetOpOps == 11, ""SetOpOp enum must fit in 4 bits""",1,1,2
"offsetof(String, m_px) == offsetof(Value, m_data)",1,1,2
"KindOfUninit == 0, ""Several things assume this tag is 0, expecially target cache""",1,1,2
"STRHASH_MSB < 0, ""using strhash_t = int32_t""",2,0,2
 u.am.pReg->flags & MEM_Blob ,1,1,2
m_fiberCount >= 0,1,1,2
"sizeof(Data) == sizeof(int64_t), ""Data type in tv() not proper size""",1,1,2
parser,1,1,2
 u.bp.pC->deferredMoveto==0 ,1,1,2
!on_success || on_success->instanceof(c_Closure::s_cls),1,1,2
 pUnpacked->flags & UNPACKED_IGNORE_ROWID ,1,1,2
"!(KindOfNamedLocal & KindOfUncountedInitBit), """"",1,1,2
b == (m_kind == kStrMapKind || m_kind == kIntMapKind || m_kind == kVPackedKind),1,1,2
check_refcount_ns(newCount),1,1,2
m_type == Type::FuncRef,1,1,2
m_kind == Kind::Indirect || m_kind == Kind::Destructor,1,1,2
"kReservedRSPScratchSpace == NumPreAllocatedSpillLocs * 8, ""kReservedRSPScratchSpace changes require updates in "" ""LinearScan""",1,1,2
m_hdr.aux == flags && !m_count,1,1,2
heap_init_size >= 0,1,1,2
 u.aw.p2>0 ,1,1,2
 !isOpen(pPager->jfd) || pPager->journalOff>0 || rc!=SQLITE_OK ,1,1,2
 sqlite3BtreeHoldsMutex(db->aDb[u.bu.iDb].pBt) ,1,1,2
"offsetof(Object, m_px) == offsetof(Value, m_data)",1,1,2
m_kind == APCKind::SerializedObject || m_kind == APCKind::SharedObject || m_kind == APCKind::SharedCollection,2,0,2
 u.bh.pC->pCursor!=0 ,1,1,2
exists(),1,1,2
m_value.innerType != KindOfHome,1,1,2
tdata,2,0,2
nProps == cls->m_declPropInit.size(),1,1,2
sz == sizeof(ImmutablePackedArray),1,1,2
 compatible[RTREE_GE & 7]==2 ,1,1,2
!m_hdr.aux && m_hdr.kind == HeaderKind::Object && !m_count,1,1,2
this->m_count,1,1,2
*this <= Cls && m_hasConstVal,1,1,2
*this <= StaticArr && m_hasConstVal,1,1,2
OptBool,1,1,2
m_handle.is(KindOfDouble),1,1,2
 u.br.iCnt==1 ,1,1,2
r.isVirt() || r.isGP() || !r.isValid(),1,1,2
(tv)->m_type == KindOfObject || (tv)->m_type == KindOfRef,1,1,2
 p->aMutex.nMutex==0 ,1,1,2
id < m_ctx.func->locals.size(),1,1,2
getChild() == child,1,1,2
 p || (pTokenizer && rc!=SQLITE_OK) ,1,1,2
opt_qspace_max_2pow != QSPACE_MAX_2POW_DEFAULT || opt_cspace_max_2pow != CSPACE_MAX_2POW_DEFAULT,1,1,2
b == (m_kind == kPackedKind || m_kind == kVPackedKind),1,1,2
(isGenerator && !isAsync && !hasReturn) || !isGenerator,1,1,2
v != this,1,1,2
m_kind == Kind::IndirectReg || m_kind == Kind::Destructor,1,1,2
 pLock->pNext->pPrev==pLock ,1,1,2
 pCost->plan.u.pIdx==0 || (pCost->plan.wsFlags&WHERE_ROWID_EQ)==0 ,1,1,2
 p->owner==GetCurrentThreadId() ,1,1,2
"sizeof(MDS_format) == sizeof(uint32_t), ""MDS_format_t size != 4""",1,1,2
(chunk->map[run_ind+run_pages-1].bits & ~PAGE_MASK) == nrun_size,1,1,2
m_namedEntity,1,1,2
iid < m_info.size(),1,1,2
 eMode==PAGER_JOURNALMODE_QUERY || eMode==PAGER_JOURNALMODE_DELETE || eMode==PAGER_JOURNALMODE_TRUNCATE || eMode==PAGER_JOURNALMODE_PERSIST || eMode==PAGER_JOURNALMODE_OFF || eMode==PAGER_JOURNALMODE_MEMORY ,1,1,2
!fp->hasThis(),1,1,2
isValidCollection(static_cast<CollectionType>(m_kind)),1,1,2
hasCollection() && getCollectionType() == Collection::TupleType,1,1,2
"addr >= m_base && addr < m_base + kNullptrOffset, ""{} outside [{}, {})"", addr, m_base, m_base + kNullptrOffset",2,0,2
"offsetof(SharedVar, m_count) == TypedValueAux::auxOffset, ""Offset of m_count must equal offset of TV.m_aux""",1,1,2
 (u.cg.pQuery->flags&MEM_Int)!=0 && u.cg.pArgc->flags==MEM_Int ,1,1,2
 zToken!=0 ,1,1,2
"std::is_trivially_destructible<T>::value, ""GrowableVector can only hold trivially "" ""destructible types""",1,1,2
flag >= 1ull << 48,2,0,2
check_refcount(oldCount),1,1,2
!isGenerator || !hasNonEmptyReturn,1,1,2
 pParse->nVarExprAlloc==0 ,1,1,2
ready != k_waitingForExternalThreadEvents,1,1,2
 rc!=SQLITE_OK || iPageSize16==(u16)iPageSize ,1,1,2
stacksize >= PTHREAD_STACK_MIN,1,1,2
"sizeof(TranslatorX64::MInstrState) - sizeof(uintptr_t) < kReservedRSPScratchSpace, ""MInstrState is too large for the rsp scratch space "" ""in enterTCHelper""",1,1,2
(intptr_t(func) & 1) == 0,1,1,2
v->isStatic(),1,1,2
state.stackIdx == state.info.valCount(),1,1,2
cellIsPlausible(cns),2,0,2
 u.aw.pX!=0 ,1,1,2
 pOld==0 || pOld==p ,1,1,2
"sizeof(T) == sizeof(UnderlyingType), ""Size mismatch""",1,1,2
r != InvalidReg,1,1,2
OptDbl,1,1,2
unsigned(kind_) <= NumHeaderKinds,1,1,2
 PAGER_JOURNALMODE_QUERY<0 ,1,1,2
"subtypeOf(t1, Gen) == subtypeOf(t2, Gen)",1,1,2
 lockList==pLock ,1,1,2
ret == NULL || (addr == NULL && ret != addr) || (addr != NULL && ret == addr),1,1,2
!object || object->getCount() > 0,1,1,2
newp == m_data,2,0,2
relOffset >= static_cast<int32_t>(env.irb->evalStack().numCells()),1,1,2
data.pobj,1,1,2
*this <= TGen,2,0,2
Str,1,1,2
 argc==2 || argc==3 ,1,1,2
actRec()->func()->contains(m_offset),1,1,2
 u.bt.pDb->pBt!=0 ,1,1,2
 u.ba.pC!=0 ,1,1,2
 (u.bv.pnErr->flags & MEM_Int)!=0 ,1,1,2
count <= StaticValue || (uint32_t)count <= (uint32_t)RefCountMaxRealistic,1,1,2
"offsetof(APCTypedValue, m_handle) == sizeof(APCHandle), """"",2,0,2
hasInvName(),1,1,2
"false && ""unexpected header in worklist""",1,1,2
"(n % 4 == 0) && ""This arch supports only 4 bytes alignment""",1,1,2
state.stackIdx == state.info.valCount() + 1 ,1,1,2
SStr,1,1,2
"sizeof(DS_format) == sizeof(uint32_t), ""DS_format_t size != 4""",1,1,2
isDelete && !isOpenDirectory,1,1,2
chunk->arena == arena,1,1,2
genFunc,1,1,2
op[2 + sizeof(Offset)] == OpPopC,1,1,2
"offsetof(RefData, m_kind) == HeaderKindOffset, """"",1,1,2
!cls->instanceCtor() && !cls->callsCustomInstanceInit() && !(cls->attrs() & (AttrAbstract | AttrInterface | AttrTrait | AttrEnum)),1,1,2
m_iter <= m_stop,1,1,2
"(uint32_t)UncountedValue & (1uL << UncountedBitPos), ""Check UncountedValue and UncountedBitPos""",1,1,2
(DType == tv->m_type) || (isStringType(DType) && isStringType(tv->m_type)),1,1,2
!closed(),1,1,2
id >= 0 && id < Id(s_litstrTable->m_namedInfo.size()),1,1,2
check_refcount(newCount),1,1,2
newMode != Mode::Small,1,1,2
OptInt,1,1,2
"sizeof(int) == 4, ""bad platform""",1,1,2
m_needInitFree = true,1,1,2
" offsetof(APCString, m_handle) == 0, ""m_handle must appear first in APCString"" ",2,0,2
check_refcount_ns(oldCount),1,1,2
m_value.outerType == KindOfVariant || m_value.innerType == KindOfInvalid,1,1,2
nullptr == tv || tvIsPlausible(tv),1,1,2
 !pPager->dbModified ,1,1,2
 pWC->vmask==0 && pMaskSet->n==0 ,1,1,2
 SQL_SELECT_LEVEL+1==SQL_SELECT_ALL_LEVEL,1,1,2
 u.bh.pC->isTable || pOp->opcode==OP_RowKey ,1,1,2
 u.bg.pC->pCursor!=0 ,1,1,2
other,1,1,2
c > Threshold,1,1,2
" MemoryManager::kMaxSmartSize <= std::numeric_limits<uint32_t>::max(), ""Size-specified smart malloc functions assume this"" ",1,1,2
m_top[ind].m_type == KindOfVariant,1,1,2
isPreFunc(),1,1,2
mode == UnserializeMode::ColKey,1,1,2
"false && ""Unexpected DataType""",1,1,2
"IMPLIES(isArrayKey(), m_type.dt != KindOfObject)",1,1,2
Obj,1,1,2
" offsetof(APCTypedValue, m_handle) == sizeof(SharedData), ""m_handle must come after SharedData"" ",1,1,2
 pList->nAlloc==0 ,1,1,2
 u.aw.iDb>=0 && u.aw.iDb<db->nDb ,1,1,2
m_data.pstr != px,1,1,2
 u.cj.pName->flags & MEM_Str ,1,1,2
newp == m_vec,2,0,2
getType() == Type::TCA,1,1,2
&other.m_unit == &m_unit,1,1,2
res == 0 || !m_exclusive,1,1,2
reinterpret_cast<uintptr_t>(p) % 16 == 0,1,1,2
ty <= TGen,1,1,2
!m_flags.strengthReduced,1,1,2
"!converted || keyType == KeyType::Int, ""Should have only been converted if KeyType is now an int""",1,1,2
pColl || pParse->nErr,1,1,2
 pParse->apVarExpr==0 ,1,1,2
 pLock->pPrev->pNext==pLock ,1,1,2
 !pPager->setMaster ,1,1,2
m_kindOf != KindOfExpression,2,0,2
(ret << BLOCK_COST_2POW) != 0 || ncpus == 1,1,1,2
m_firstHoistablePreClass == 2,1,1,2
not(Uninit),1,1,2
 idx+sz <= pPage->pBt->usableSize ,1,1,2
m_type == Type::FuncPtr,1,1,2
key->is(KindOfString) || key->is(KindOfStaticString),1,1,2
m_vars.find(key.get()) == m_vars.end(),1,1,2
 u.aq.p1==SAVEPOINT_BEGIN||u.aq.p1==SAVEPOINT_RELEASE||u.aq.p1==SAVEPOINT_ROLLBACK ,1,1,2
arena->ndirty > opt_dirty_max,1,1,2
"false && ""addr was not part of any known code block""",1,1,2
!on_await || on_await->instanceof(c_Closure::classof()),1,1,2
!v.isVarNR(),1,1,2
str.m_px->isStatic(),1,1,2
"offsetof(APCVariant, m_data) == offsetof(TypedValue, m_data), ""Offset of m_data must be equal in APCVariant and TypedValue""",1,1,2
!state.base.type.strictSubtypeOf(TArr),1,1,2
topT(i).subtypeOf(TRef),1,1,2
"sizeof(A_format) == sizeof(uint32_t), ""A_format_t size != 4""",1,1,2
 mergetype==MERGE_OR || mergetype==MERGE_POS_OR || mergetype==MERGE_AND || mergetype==MERGE_NOT || mergetype==MERGE_PHRASE || mergetype==MERGE_POS_PHRASE || mergetype==MERGE_NEAR || mergetype==MERGE_POS_NEAR ,1,1,2
"ArrayData::kVPackedKind == uint8_t(HeaderKind::VPacked), """"",1,1,2
it >= begin() && it < end(),1,1,2
 (pMem->flags & MEM_Null)==0 ,1,1,2
"offsetof(Variant, m_data) == 0 && offsetof(Variant, _count) == 8 && offsetof(Variant, m_type) == 12 && sizeof(m_data) == sizeof(uint64_t) && sizeof(_count) == sizeof(uint32_t) && sizeof(m_type) == sizeof(uint32_t) && sizeof(Variant) == 2 * sizeof(uint64_t)",1,1,2
&v.m_unit == &m_unit && v.m_meta == m_meta,1,1,2
"std::tuple_size< typename std::remove_reference<Tuple>::type >::value == 2, ""Can only merge tuples of size 2""",1,1,2
getTypeParam() == Type::VarEnv,1,1,2
m_profData == nullptr || !RuntimeOption::EvalJitConcurrently,1,1,2
 pTabItem->pTab ,1,1,2
detail::g_current_gen_link.bound(),2,0,2
 PAGER_RESERVED==RESERVED_LOCK ,1,1,2
isValidOpcode(op),1,1,2
"sizeof(APCVariant) == sizeof(TypedValue), ""Be careful with field layout""",1,1,2
IS_STRING_TYPE(out->m_type),1,1,2
 p->aMem==0 || p->aMem[i].flags==MEM_Null ,1,1,2
 pPager->journalMode==PAGER_JOURNALMODE_DELETE || pPager->journalMode==PAGER_JOURNALMODE_MEMORY ,1,1,2
 unionTab==dest.iParm || dest.eDest!=priorOp ,1,1,2
"(std::is_base_of<ObjectData,T>::value || std::is_base_of<ResourceData,T>::value), ""toSmartPtr() only works for Resource or Object classes""",1,1,2
 (p->btreeMask & (1<<p1))!=0 ,1,1,2
reinterpret_cast<uintptr_t>(elm->m_tv) % 16 == 0,1,1,2
!isDescendantOf(child),1,1,2
topT(i).subtypeOf(TCls),1,1,2
m_kind == VALUE || m_kind == HOME || m_kind == ITER,1,1,2
"RefCountTombstoneValue < 0, ""RefCountTombstoneValue should be negative to aid assertions""",1,1,2
"!infinite, ""Cannot call foreach on infinite GenImpl""",1,1,2
 u.bp.pC->isTable==0 ,1,1,2
 pWriter || rc!=SQLITE_OK ,1,1,2
 (pMem->flags & (MEM_Int|MEM_Real|MEM_Null))==0 ,1,1,2
CACHE_LINE_SIZE >= sizeof(pthread_mutex_t),1,1,2
Bool,1,1,2
cellIsPlausible(rhs),1,1,2
*this <= TCA && m_hasConstVal,1,1,2
m_kind == HeaderKind::String,1,1,2
 offset==ii*(4+pPager->pageSize) ,1,1,2
 u.bu.iDb>=0 && u.bu.iDb<db->nDb ,1,1,2
offset != (unsigned)-1,1,1,2
thiz->m_nLastSlot != 0,1,1,2
factory != NULL,1,1,2
!methodIndex.isFail(),1,1,2
 eMode==PAGER_JOURNALMODE_DELETE || eMode==PAGER_JOURNALMODE_TRUNCATE || eMode==PAGER_JOURNALMODE_PERSIST || eMode==PAGER_JOURNALMODE_OFF || eMode==PAGER_JOURNALMODE_MEMORY ,1,1,2
ndirty == arena->ndirty,1,1,2
size > oldsize,1,1,2
acc && IS_STRING_TYPE(acc->m_type),1,1,2
 u.be.pC->isTable ,1,1,2
uint16_t(handle) == handle,1,1,2
"sizeof(SC_format) == sizeof(uint32_t), ""SC_format_t size != 4""",1,1,2
kind() == HeaderKind::ResumableFrame,2,0,2
m_writeOwner == pthread_self(),1,1,2
InitUnc,1,1,2
"kBitSize * 2 == sizeof(TypedValue), """"",1,1,2
m_kind == Kind::IndirectVreg,1,1,2
" ExprHasAnyProperty(p, EP_Reduced|EP_TokenOnly) || (p->flags2 & EP2_MallocedToken)==0 ",1,1,2
" !std::is_reference<Container>::value, ""Can't copy into a reference""",1,1,2
 pLock->cnt>0 ,1,1,2
!r.isValid() || r.isVirt() || r.isSF(),1,1,2
!IS_REFCOUNTED_TYPE(ret.asCell()->m_type),1,1,2
isIter() && m_iterKind == ArrayIter::IterKind::Undefined,1,1,2
m_type == Type::Dbl,1,1,2
!m_hdr.aux && m_hdr.kind == HeaderKind::Object && hasExactlyOneRef(),1,1,2
CACHE_LINE_SIZE >= sizeof(int),1,1,2
!m_trace->back()->getNext(),1,1,2
 u.ci.pModule->xNext ,1,1,2
tag() == Tag::Packed,2,0,2
RuntimeOption::DisableSmartAllocator || contains(p),1,1,2
t != Type::None,1,1,2
run->nfree > 0,1,1,2
hasCollection() && getCollectionType() == Collection::FixedVectorType,1,1,2
Arr,1,1,2
!on_start || on_start->instanceof(c_Closure::s_cls),1,1,2
(*it)->getMark() == 2,1,1,2
"offsetof(APCVariant, m_type) == offsetof(TypedValue, m_type), ""Offset of m_type must be equal in APCVariant and TypedValue""",1,1,2
"(loc->type().isBoxed() || loc->type().notBoxed()) && ""Currently we don't handle traces where locals are maybeBoxed""",1,1,2
dest && jmpDeltaFits(dest),2,0,2
 pPager->state>=PAGER_EXCLUSIVE ,1,1,2
"sizeof(uint64_t) == 8, ""bad platform""",1,1,2
data.right() != nullptr,2,0,2
!m_state.stack.empty(),1,1,2
"sizeof(XX2_format) == sizeof(uint32_t), ""XX2_format_t size != 4""",1,1,2
"kSIMDOffset >= ARM::kNumGPRegs, """"",1,1,2
"sizeof(EVS_format) == sizeof(uint32_t), ""EVS_format_t size != 4""",1,1,2
&other.m_factory == &m_factory,1,1,2
m_node->getCache() && Native::data<DOMNode>(m_node->getCache()) == this,2,0,2
 pTerm->sortOrder==0 || pTerm->sortOrder==1 ,1,1,2
"kMinCap / 2 > 0, """"",1,1,2
keyType.isKnownDataType() || keyType == Type::InitCell || keyType == Type::Cell,1,1,2
cap >= kMinCap,1,1,2
 debugMutexHeld(p) ,1,1,2
 pPage->nOverflow<=ArraySize(pPage->aOvfl) ,1,1,2
"sizeof(MInstrState) % 8 == 0, """"",1,1,2
sturn - current_sturn < std::numeric_limits<uint32_t>::max() / 2,1,1,2
data.pstr,1,1,2
"sizeof(String) == sizeof(SmartPtr<StringData>), """"",1,1,2
m_start || (m_end - m_start) < 1ull << 32,1,1,2
link.bound(),1,1,2
 pList->a!=0 || (pList->nExpr==0 && pList->nAlloc==0) ,1,1,2
"!Source::infinite, ""Cannot call 'all' on infinite source""",1,1,2
"offsetof(c_Set, m_size) == FAST_COLLECTION_SIZE_OFFSET, """"",1,1,2
i < m_regSIMDArgs.size(),1,1,2
!isShared() && isStatic(),1,1,2
 pNext<&pReader->aNode[pReader->nNode] ,1,1,2
hasCollection() && getCollectionType() == CollectionType::ImmVector,1,1,2
obj->headerKind() == HeaderKind::ResumableObj,2,0,2
m_type == Type::ClassPtr,1,1,2
 u.ch.pModule->xColumn ,1,1,2
"!m_address && !m_a && ""Label was already set""",1,1,2
"HphpArray::MinLgTableSize >= 2, ""lower limit for 0.75 load factor""",1,1,2
"sizeof(g_array_funcs_unmodified) % sizeof(g_array_funcs_unmodified.release) == 0, ""The calculation below will be incorrect if it's not"" "" a strict multiple""",1,1,2
!on_success || on_success->instanceof(c_Closure::classof()),1,1,2
topT(i).subtypeOf(TInitCell),1,1,2
ret != 0,1,1,2
isCollection(),1,1,2
m_nLocals == 0,1,1,2
"sizeof(DQ_format) == sizeof(uint32_t), ""DQ_format_t size != 4""",1,1,2
 u.ba.pC->isTable ,1,1,2
lg_range <= 32,1,1,2
"!detail::IsVoid<T>::value, ""Trying to scan void pointer(s). "" ""Please provide a more specific type.""",2,0,2
m_vals.size() == 0,1,1,2
*this <= Bool && m_hasConstVal,1,1,2
getType() == Type::FuncPtr,1,1,2
 u.am.pC->pVtabCursor==0 ,1,1,2
static_cast<uint8_t>(OpLowInvalid) == 0,1,1,2
opc != JmpZero && opc != JmpNZero,1,1,2
chunksize >= PAGE_SIZE,1,1,2
isReturnHelper(jit::mcg->tx().uniqueStubs.callToExit),1,1,2
hasName(),1,1,2
m_type != KindOfVariant,1,1,2
size_t(area) == m_areas.size(),1,1,2
 pCur->apPage[pCur->iPage]->nCell>0 || pCur->eState==CURSOR_INVALID ,1,1,2
rv == 0 || (errno == EWOULDBLOCK || errno == EINTR),1,1,2
thiz->m_count,1,1,2
 p->apCsr==0 || p->apCsr[i]==0 ,1,1,2
"!""who is generating this code?""",1,1,2
o_attribute == flags && !m_count,1,1,2
handle->kind() == APCKind::SharedArray || handle->kind() == APCKind::SharedPackedArray,2,0,2
0 <= index && index <= m_params.size(),1,1,2
 u.bf.pC->iDb>=0 ,1,1,2
 (iPos&(SNIPPET_BUFFER_CHUNK-1))==0 ,1,1,2
 iIdx<sizeof(zIdxStr)-1 ,1,1,2
 (((u8*)p - (u8*)0) & 7)==0 ,1,1,2
m_threadId,1,1,2
"uint32_t(PosType::invalid) == uint32_t(-1), """"",1,1,2
 u.ac.n>0 && u.ac.p1>0 && u.ac.p2>0 ,1,1,2
LinearScan::regNameAsInt(regNo) < NumRegs && LinearScan::regNameAsInt(regNo) >= 0,1,1,2
 (start + size)<=pPage->pBt->usableSize ,1,1,2
vmfp() == fp,1,1,2
(canSpecializeClass() && m_class != nullptr) || (canSpecializeArrayKind() && m_arrayKindValid),1,1,2
m_size != 0,1,1,2
uintptr_t(data()) % 4 == 0,1,1,2
 yymsp[-1].minor.yy473!=0 ,1,1,2
&v.m_unit == &m_unit && v.m_area == m_area,1,1,2
"ArrayData::kStrMapKind == uint8_t(HeaderKind::StrMap), """"",1,1,2
count == 0 || count == 1,1,1,2
 nSegment>0 ,1,1,2
newEnd <= m_end,1,1,2
"IMPLIES(is_jccandjmp, is_aligned(cb.frontier(), AImpl::s_table[idx + 1]))",1,1,2
m_state.load() == Finished || m_state.load() == Canceled,1,1,2
isArrayType(cbase->m_type),2,0,2
 rc==SQLITE_OK || nPage==-1 ,1,1,2
"kFPushCtorShift <= 8 * sizeof(int32_t) - 1, ""Out of bits in ActRec""",1,1,2
"!""LowInvalid""",1,1,2
 j<(int)(sizeof(pPage->aOvfl)/sizeof(pPage->aOvfl[0])) ,1,1,2
LZ4_MAX_INPUT_SIZE >= DEP_SIZE_B,1,1,2
 u.bh.pC->deferredMoveto==0 ,1,1,2
"sizeof(XFL_format) == sizeof(uint32_t), ""XFL_format_t size != 4""",1,1,2
other.isPacked(),1,1,2
isIndirect(),1,1,2
tag <= 0xffffu,2,0,2
 pTable->nRef==0 ,1,1,2
"sizeof(B_format) == sizeof(uint32_t), ""B_format_t size != 4""",1,1,2
ir != reg::rsp,1,1,2
!canSpecializeClass() || (m_class == nullptr && other.m_class == nullptr),1,1,2
OptObj,1,1,2
"MaxNumDataTypes - 1 <= kDataTypeMask, """"",1,1,2
(isObj() || isIter()) && m_class != nullptr,1,1,2
ad->checkInvariants(),1,1,2
frontierOff <= m_size,1,1,2
((jmp[3] >> 2) & 0x3F) == 19,1,1,2
 compatible[RTREE_LT & 7]==1 ,1,1,2
uintptr_t(s->data()) % 4 == 0,1,1,2
_count > Countable::ATOMIC_FLAG,1,1,2
HashSize(scale) == scale * 4,2,0,2
valid(filename),1,1,2
Exact,1,1,2
!running(),1,1,2
!ar->resumed(),1,1,2
m_type == Type::TCA,1,1,2
m_class,1,1,2
Res,1,1,2
min_run_size >= PAGE_SIZE,1,1,2
size <= kMaxSmartSize + kDebugExtraSize,1,1,2
"MixedArray::MinLgTableSize >= 2, ""lower limit for 0.75 load factor""",1,1,2
fr->m_type != KindOfVariant,1,1,2
 u.ar.desiredAutoCommit==1 || u.ar.iRollback==0 ,1,1,2
 u.bx.iSet==-1 || u.bx.iSet>=0 ,1,1,2
bool(m_attrs & AttrVariadicParam) == (numParams() && params()[numParams() - 1].isVariadic()),1,1,2
(mag_rack_t *)arg == mag_rack,1,1,2
m_yieldCount >= 0,1,1,2
 p->pParent->pRight==p ,1,1,2
tvIsPlausible(cell),1,1,2
m_val < NumPreAllocatedSpillLocs,1,1,2
i < NumCallerSavedRegs,1,1,2
m_handle.type() == KindOfInt64,1,1,2
m_data == NULL,1,1,2
 pPager->state>=PAGER_SHARED && !MEMDB ,1,1,2
!on_start || on_start->instanceof(c_Closure::classof()),1,1,2
m_top[ind].m_type == KindOfHome,1,1,2
fr->m_type != KindOfUninit,1,1,2
"boost::has_trivial_destructor<RegSet>::value, ""RegSet must have a trivial destructor""",1,1,2
ad->m_used == other.m_used,1,1,2
b == (m_kind == kStrMapKind || m_kind == kIntMapKind),1,1,2
 p->flags & UNPACKED_NEED_DESTROY ,1,1,2
m_stateLocal >= 0,1,1,2
 u.am.payloadSize==0 || u.am.zRec!=0 ,1,1,2
 u.aj.p2>0 && u.aj.p2+mx<=p->nMem+1 ,1,1,2
 p->pGroupBy==0 || (p->selFlags & SF_Aggregate)!=0 ,1,1,2
m_head == nullptr,1,1,2
get_nothrow<ObjectImpl>(),1,1,2
 get2byte(&aFrom[iFromHdr+5])<=pBt->usableSize ,1,1,2
!validPos(*ei) && m_used < m_cap,1,1,2
 isAgg || pGroupBy ,1,1,2
"state == encode(turn << kTurnShift, decodeMaxWaitersDelta(state))",1,1,2
m_state.stack.empty(),1,1,2
size > bin_maxclass,1,1,2
"sizeof(VC_format) == sizeof(uint32_t), ""VC_format_t size != 4""",1,1,2
m_flags.wasPEI,1,1,2
"RefCountTombstoneValue < 0, ""RefCountTombstoneValue is expected to be less than "" ""zero for assertion purposes""",1,1,2
handle->checkInvariants() && handle->kind() == APCKind::SharedObject,2,0,2
 pIdx!=0 ,1,1,2
"kMaxRegs - kSIMDOffset >= X64::kNumSIMDRegs, """"",1,1,2
 pExpr->eType==FTSQUERY_PHRASE || pExpr->eType==FTSQUERY_NEAR || isReqPos==0 ,1,1,2
px == NULL || (void*)px == (void*)m_data.pobj,1,1,2
 iDb==0 ,1,1,2
 (pPager->state>=locktype) || (pPager->state==PAGER_UNLOCK && locktype==PAGER_SHARED) || (pPager->state==PAGER_RESERVED && locktype==PAGER_EXCLUSIVE) ,1,1,2
!m_handle.isRefCountedHandle(),1,1,2
check_refcount_ns_nz(count),1,1,2
isValidCollection(static_cast<CollectionType>(m_kind)) || !isCollection(),1,1,2
"HPHP::jit::deltaFits(diff, HPHP::sz::word) && ""Offset too big""",1,1,2
!ar->inGenerator(),1,1,2
block->empty(),1,1,2
rbp_fr_node != &(a_tree)->rbt_nil,1,1,2
 pPager->journalMode!=PAGER_JOURNALMODE_OFF || pPager->dbOrigSize==0 ,1,1,2
m_value.outerType == KindOfString || m_value.innerType == KindOfString || m_value.outerType == KindOfClass || m_value.innerType == KindOfClass || m_value.outerType == KindOfObject || m_value.innerType == KindOfObject || m_value.outerType == KindOfArray || m_value.innerType == KindOfArray || m_value.outerType == KindOfBoolean || m_value.outerType == KindOfInt64 || m_value.klass == nullptr,1,1,2
" offsetof(c_Vector, m_size) == FAST_COLLECTION_SIZE_OFFSET, """"",1,1,2
 pPager->state==PAGER_RESERVED || pPager->state>=PAGER_EXCLUSIVE ,1,1,2
 u.ao.i==u.ao.nByte ,1,1,2
"(uint32_t)RefCountStaticValue == (1uL << RefCountStaticBitPos), ""Check RefCountStaticValue and RefCountStaticBitPos""",1,1,2
int(slot) != int(InvalidReg),1,1,2
"rbp_right_get(a_type, a_field, rbp_r_xp) == (a_node)",1,1,2
extShared(),2,0,2
"IMPLIES(isCallable(), m_type.dt == KindOfObject)",1,1,2
n <= available_,1,1,2
 sqlite3BtreeCursorIsValid(u.bh.pCrsr) ,1,1,2
"0 && ""blocks should not contain JmpNS instructions""",1,1,2
mode() == newMode,1,1,2
it.m_type != KindOfRef,2,0,2
sz == sizeof(APCPackedArray),1,1,2
 pOrderBy==0 ,1,1,2
"sizeof(XX4_format) == sizeof(uint32_t), ""XX4_format_t size != 4""",1,1,2
"sizeof(List<T>) == sizeof(Slice<T>), """"",1,1,2
m_handle.type() == KindOfStaticString || (m_handle.isUncounted() && m_handle.type() == KindOfString),1,1,2
rn1 != noreg && rn2 != noreg,2,0,2
count == RefCountStaticValue || (uint32_t)count <= (uint32_t)RefCountMaxRealistic,1,1,2
size < GLOBAL_SIZE_B - sizeof(value),1,1,2
unsigned(area) < m_areas.size(),1,1,2
contains(id),2,0,2
(uint32_t)f->unit()->offsetOf(pc) >> 31 == 0,2,0,2
"Random::max() >= std::numeric_limits<int32_t>::max() - 1, ""Random number generator must support big values""",1,1,2
u.cf.pVtab && u.cf.pModule,1,1,2
type < Type::Cell,1,1,2
m_handle.isUncounted() && m_handle.type() == KindOfArray,1,1,2
"ArrayKind::kVector < ArrayKind::kHphpArray, """"",1,1,2
LZ4_MAX_INPUT_SIZE >= dep_size_b,1,1,2
"sizeof(Variant) == sizeof(TypedValue), ""Reimplement this""",1,1,2
m_type == Type::Home,1,1,2
hasReg(i),1,1,2
" sizeof(unique_ptr<int>) == sizeof(std::unique_ptr<int>), ""smart::unique_ptr pointer should not be larger than std::unique_ptr"" ",1,1,2
 !pRtree->aHash[ii] ,1,1,2
 pLock->locktype==0 ,1,1,2
isUninitializedInTargetCache(),1,1,2
sizeof(ActRec*) <= sizeof(uint64_t),1,1,2
oldLoc->type().isBoxed() || oldLoc->type().notBoxed(),1,1,2
sp.empty() || sp.start() != nullptr,1,1,2
 idx<=pPage->nCell ,1,1,2
index < detail::g_metadata_table_size,2,0,2
"!""HighInvalid""",1,1,2
(alignment & PAGE_MASK) == 0,1,1,2
var->_count > 0,1,1,2
sizeof(const_size2bin) == bin_maxclass + 1,1,1,2
 p->pEntry==0 ,1,1,2
str,1,1,2
 pFile->locktype==0 ,1,1,2
t == KindOfString || t == KindOfArray || t == KindOfObject || t == KindOfResource || t == KindOfRef,1,1,2
 u.bk.pC!=0 ,1,1,2
m_handle.is(KindOfInt64),1,1,2
!HashCollection::isTombstone(&e),2,0,2
"!(KindOfStaticString & KindOfArrayBit), """"",1,1,2
data.parr,1,1,2
tv->_count > 0,1,1,2
 pPager->state==PAGER_SYNCED || MEMDB || !pPager->dbModified ,1,1,2
m_base && frontier,1,1,2
size2bin[0] == 0xffU,1,1,2
fp->inGenerator(),1,1,2
mayHaveArrData(),2,0,2
 sqlite3BtreeHoldsMutex(db->aDb[iDb].pBt) ,1,1,2
" offsetof(APCTypedValue, m_handle) + offsetof(APCHandle, m_count) == TypedValueAux::auxOffset, ""Offset of m_count must equal offset of TV.m_aux""",1,1,2
 (pTerm->wtFlags & TERM_CODED)==0 ,1,1,2
isIter(),1,1,2
category == DataTypeSpecialized || innerCat == DataTypeSpecialized,1,1,2
((Iter*)m_top)->m_itype == Iter::TypeUndefined,1,1,2
 pPage->pExtra==(void *)&pPage[1] ,1,1,2
"offsetof(Variant,m_data) == offsetof(TypedValue,m_data)",1,1,2
hashtbl[slot].hash == get_hash(key),2,0,2
"kNumIncDecOps == 4, ""IncDecOp enum must fit in 2 bits""",1,1,2
CACHE_LINE_SIZE >= sizeof(uint64_t),2,0,2
m_kind == Kind::IndirectReg || m_kind == Kind::IndirectVreg,1,1,2
"ArrayData::kIntMapKind == uint8_t(HeaderKind::IntMap), """"",1,1,2
(m_value.knownClass == nullptr || m_value.outerType == KindOfObject || (m_value.outerType == KindOfRef && m_value.innerType == KindOfObject)) || (!m_value.arrayKindValid || m_value.outerType == KindOfArray || (m_value.outerType == KindOfRef && m_value.innerType == KindOfArray)),1,1,2
OptSStr,1,1,2
 iNewLevel>=0 ,1,1,2
 u.am.pC!=0 ,1,1,2
mixedData(a) == elms,1,1,2
"tl_miter_table.ents.size() == 7, """"",1,1,2
pos1 >= 0 && pos1 < dest.size(),1,1,2
 rc==SQLITE_EMPTY || rc==SQLITE_OK ,1,1,2
pos < (ssize_t)m_vec->m_size,1,1,2
topT().subtypeOf(TRef),1,1,2
 !MEMDB && !pPager->tempFile ,1,1,2
 isOpen(pPager->jfd) || pPager->journalMode==PAGER_JOURNALMODE_OFF ,1,1,2
(m_value.outerType == KindOfRef) == (m_value.innerType != KindOfNone),1,1,2
id >= 0 && id < Id(s_litstrTable->m_litstrs.size()),1,1,2
 pOp->p3<=u.be.pFrame->nMem ,1,1,2
*this <= Func && m_hasConstVal,1,1,2
len >= 32,2,0,2
 scratchAllocOut==1 ,1,1,2
OptExact,1,1,2
mustBeInFrame(state.base) || state.base.loc == BaseLoc::LocalArrChain,1,1,2
 u.aj.p2>0 && u.aj.p2+u.aj.n<=p->nMem+1 ,1,1,2
 nVal==0 || nVal==1 ,1,1,2
min_run_size <= arena_maxclass,1,1,2
static_cast<size_t>(pos) < m_size,2,0,2
m_arr->isPacked(),1,1,2
toOp(*op) == OpSSwitch,1,1,2
m_handle.is(KindOfStaticString),1,1,2
!newVal->type().maybeBoxed(),1,1,2
op >= m_bc && op < (m_bc + m_bclen),1,1,2
OptSArr,1,1,2
reg != InvalidReg && reg.isGP(),1,1,2
 pLock->cnt!=0 ,1,1,2
it != m_propertyMap.end(),1,1,2
"sizeof(decltype(m_bits)) * 8 >= PhysReg::kMaxRegs, """"",1,1,2
*op == Op::SSwitch,1,1,2
!isRefCounted(),1,1,2
 compatible[RTREE_LE & 7]==1 ,1,1,2
m_expressions->getCount() > 0,1,1,2
OptArr,1,1,2
(intptr_t(func) & 0x3) == 0,1,1,2
"boost::has_trivial_destructor<T>::value, ""GrowableVector can only hold trivially "" ""destructible types""",1,1,2
"sizeof(VX_format) == sizeof(uint32_t), ""VX_format_t size != 4""",1,1,2
 u.am.avail>=0 ,1,1,2
sz == sizeof(APCString),1,1,2
m_handle.is(KindOfBoolean),1,1,2
 pPage->pgno==pgno ,1,1,2
 u.ar.desiredAutoCommit==1 || u.ar.desiredAutoCommit==0 ,1,1,2
run_ind >= arena_chunk_header_npages,1,1,2
varNrFlag() == NR_FLAG,1,1,2
key->m_type != KindOfVariant,1,1,2
QUANTUM_CEILING(size) <= arena_maxclass,1,1,2
key->getType().isStaticallyKnown(),1,1,2
min_run_size <= RUN_MAX_SMALL,1,1,2
naryDst() && i < m_numDsts,1,1,2
handle->type() == KindOfString,1,1,2
 u.az.pC->pseudoTableReg==0 ,1,1,2
"TypedValueAux::auxSize == sizeof(int32_t), ""emitStoreInvalid assumes m_aux is dword sized.""",1,1,2
isString(),2,0,2
h < kNumTargetCacheBytes,1,1,2
page_size > 5*CACHE_LINE_SIZE + (int)sizeof(int),1,1,2
 pMaskSet->n<=sizeof(Bitmask)*8 ,1,1,2
jmp->op() == Jmp_ && jmp->getTaken() == this,1,1,2
id < Id(m_funcs.size()),1,1,2
!on_failed_callback || on_failed_callback->instanceof(c_Closure::s_cls),1,1,2
isLow(px),1,1,2
data->isUncounted(),2,0,2
 u.bf.pKey->flags & MEM_Int ,1,1,2
&goner != this,1,1,2
isMethod(),2,0,2
 pExpr->op!=TK_VARIABLE ,1,1,2
 lwr==upr+1 ,1,1,2
 scratchAllocOut==0 ,1,1,2
g_context->m_stack.isValidAddress((uintptr_t)vmsp()),1,1,2
 u.cb.apVal || u.cb.n==0 ,1,1,2
"offsetof(Variant,m_type) == offsetof(TypedValue,m_type)",1,1,2
count <= StaticValue || (uint32_t)count - 1 < (uint32_t)RefCountMaxRealistic,1,1,2
"arena_run_tree_search(&bin->runs, run_mapelm) == NULL",1,1,2
 pCur->wrFlag && pBt->inTransaction==TRANS_WRITE && !pBt->readOnly ,1,1,2
"e, assert_throw_fail_impl(e), l",1,1,2
"is(IncRef, CheckType, AssertType, AssertNonNull, ColAddElemC, ColAddNewElemC, CastCtxThis, Mov)",1,1,2
 !(u.am.pDest->flags & MEM_Dyn) ,1,1,2
 u.aj.n>0 ,1,1,2
isUninitializedInRDS(),1,1,2
 zNum[0]>='0' && zNum[0]<='9' ,1,1,2
h_->size() > 0,1,1,2
!env.state.fpiStack.empty(),2,0,2
"sizeof(MInstrState) - sizeof(uintptr_t) < X64::kReservedRSPTotalSpace, ""MInstrState is too large for the rsp scratch space "" ""in enterTCHelper""",1,1,2
run->regs_minelm < bin->regs_mask_nelms,1,1,2
m_obj.isNull(),1,1,2
type == KindOfArray || type == KindOfPersistentArray,1,1,2
!on_yield || on_yield->instanceof(c_Closure::s_cls),1,1,2
u.am.aType,1,1,2
m_kind == TransKind::Profile,2,0,2
other->m_data.parr,1,1,2
"0 && ""blocks should not contain Jmp instructions""",1,1,2
info->m_mm->DEBUG_checkStats(),1,1,2
!m_failedSetBlock,1,1,2
narenas != 0,1,1,2
(*it)->preds().empty(),1,1,2
 pPager->state==PAGER_UNLOCK ,1,1,2
cont->getObjectSize() == objectSize,1,1,2
m_reentrant || m_acquires == 1,1,1,2
 pPage->nCell<=MX_CELL(pPage->pBt) && MX_CELL(pPage->pBt)<=5460 ,1,1,2
((capCode - 0xFF00ul) << 8) == cap,1,1,2
 pPager->readOnly ,1,1,2
" detail::understandable_sig<Fun>::value, ""Arguments on builtin function were not understood types"" ",2,0,2
!pCur->isIncrblobHandle,1,1,2
 (pDup->flags & (EP_Reduced|EP_TokenOnly))==0 ,1,1,2
reqBytes <= kMaxSmartSize,1,1,2
"sizeof(Header) <= 64, ""RDS::Header should fit in one cache line""",1,1,2
"HPHP::jit::deltaFits(diff, HPHP::sz::word) && ""Patching offset is too big""",1,1,2
k && m_keys && m_vals && toUint32(pos) < m_capacity,1,1,2
((bctr_addr[3] >> 2) & 0x3F) == 19,1,1,2
m_handle.type() == KindOfBoolean,1,1,2
!self->isContagious() && !other->isContagious(),1,1,2
m_buf != nullptr,2,0,2
m_handle.type() == KindOfDouble,1,1,2
check_refcount(m_data.pobj->getCount()),1,1,2
it != s_x2aRegMap.end(),1,1,2
"kMaxRegs - kSIMDOffset >= ARM::kNumSIMDRegs, """"",1,1,2
 u.bh.pC->pseudoTableReg==0 ,1,1,2
ready != k_consumerWaiting,1,1,2
key->isA(Type::Str),1,1,2
" offsetof(APCTypedValue, m_data) == offsetof(TypedValue, m_data), ""Offset of m_data must be equal in APCHandle and TypedValue""",1,1,2
CompileTimeKeyType == KindOfUnknown || key->m_type == CompileTimeKeyType,1,1,2
r.isVirt() || r.isSIMD() || !r.isValid(),1,1,2
getContextIdx() == child->getContextIdx(),1,1,2
 u.aj.p1>0 && u.aj.p1+u.aj.n<=p->nMem+1 ,1,1,2
m_child->instanceof(c_WaitableWaitHandle::classof()),1,1,2
isArray() && hasArrayKind(),1,1,2
 pItem->isPopulated==0 ,1,1,2
 !pCsr->pBt->readOnly && pCsr->pBt->inTransaction==TRANS_WRITE ,1,1,2
base != reg::r12 && base != reg::rsp,1,1,2
 i>=0 && i<=SQLITE_INDEX_SAMPLES ,1,1,2
(numArgs & (1u << 29)) == 0,1,1,2
len == sizeof(malloc_utrace_t),1,1,2
 pItem->iCol>0 ,1,1,2
 u.az.oc!=OP_SeekLt || u.az.r.flags==0 ,1,1,2
 u.az.oc!=OP_SeekGt || u.az.r.flags==UNPACKED_INCRKEY ,1,1,2
 pcache1.pLruHead!=pPage && pcache1.pLruTail!=pPage ,1,1,2
m_kind == kind,1,1,2
"memset(ptr, kSmartFreeFill, bytes)",1,1,2
p >= 0 && p < SARR_TABLE_SIZE,1,1,2
*heap == (char*)(SAVE_START + save_size),1,1,2
p != NULL,1,1,2
OptStr,1,1,2
Ref,1,1,2
debug_.allocatedMagic == DebugHeader::kAllocatedMagic,1,1,2
key <= TStr,1,1,2
objdata,1,1,2
 u.bl.pC!=0 ,1,1,2
 locktype==NO_LOCK ,1,1,2
Uninit,1,1,2
getTypeParam() == Type::Cls,1,1,2
"sizeof(M_format) == sizeof(uint32_t), ""M_format_t size != 4""",1,1,2
cap < std::numeric_limits<int32_t>::max(),1,1,2
 locktype==SHARED_LOCK ,1,1,2
 iOvflSpace<=pBt->pageSize ,1,1,2
rbp_r_p != &(a_tree)->rbt_nil,1,1,2
 p->locked ,1,1,2
 (p->selFlags & SF_HasTypeInfo)==0 ,1,1,2
isEphemeralServiceReq(sr),1,1,2
static_cast<size_t>(pos) < m.m_num,2,0,2
 pLock->locktype==pFile->locktype ,1,1,2
"!Source::infinite, ""Cannot sum infinite source""",1,1,2
 u.aq.pSavepoint==db->pSavepoint ,1,1,2
((bool) (m_attrs & AttrVariadicParam)) == (numParams() && params()[numParams() - 1].isVariadic()),1,1,2
i != methodIndexMap.methodIndexReverseMap.end(),1,1,2
mag_rack != (void *)-1,1,1,2
getType() == Type::ClassPtr,1,1,2
it != m_funcProfTrans.end(),1,1,2
(chunk->map[run_ind + i].bits & CHUNK_MAP_DIRTY) == 0,1,1,2
isAtomicCounted(),2,0,2
 p->nLeavesStmt<p->nLeavesTotal ,1,1,2
aType,1,1,2
"sizeof(XX1_format) == sizeof(uint32_t), ""XX1_format_t size != 4""",1,1,2
h->kind() == HeaderKind::NativeData,1,1,2
m_data.pobj != px,1,1,2
m_homeLoc == Location(),1,1,2
 pIdx->aSortOrder!=0 || iColumn==-1 ,1,1,2
"kMaxRegs >= X64::kNumRegs, """"",1,1,2
len <= cap,1,1,2
(offset & PAGE_MASK) == 0,1,1,2
CACHELINE * (((sizeof(csize_invs)) / sizeof(unsigned)) + 3) >= (1U << CSPACE_MAX_2POW_DEFAULT),1,1,2
type <= Type::StaticStr,1,1,2
v.get() && !v.get()->isRefCounted(),2,0,2
 PAGER_EXCLUSIVE==EXCLUSIVE_LOCK ,1,1,2
id < Id(m_firstHoistablePreClass),1,1,2
isthreaded,1,1,2
 u.bh.pC->nullRow==0 ,1,1,2
"kMaxSmartSize < kSlabSize, ""fix kNumSmartSizes or kLgSlabSize""",1,1,2
alignment >= chunksize,1,1,2
 iAlias>0 && iAlias<=pParse->nAlias ,1,1,2
m_actRec.func()->contains(m_offset),1,1,2
"offsetof(SharedVar, m_count) == offsetof(TypedValue, m_aux), ""Offset of m_count must equal offset of TV.m_aux""",1,1,2
 nCell>=0 && nCell<=MX_CELL(pPage->pBt) && MX_CELL(pPage->pBt)<=5460 ,1,1,2
other->m_data.pobj,1,1,2
*this <= TypeName && m_hasConstVal,1,1,2
"!m_flags.tookBranch && ""you can't use impl with branching opcodes before last position""",1,1,2
BitPhase<UseKindNonStaticRef>::value <= 2,1,1,2
"!(KindOfNamedLocal & KindOfStringBit), """"",1,1,2
DType == tv->m_type,2,0,2
 pLock->cnt==0 ,1,1,2
 u.bb.pC->isTable==0 ,1,1,2
InitNull,1,1,2
 pBt->readOnly==0 ,1,1,2
r.n != 0xff,2,0,2
 pCol->affinity-SQLITE_AFF_TEXT < sizeof(azType)/sizeof(azType[0]) ,1,1,2
m_start || m_start < m_end,1,1,2
AsioSession::Get()->getContext(ctx_idx),1,1,2
 u.am.sMem.z==u.am.sMem.zMalloc ,1,1,2
slotval.s.next.num < dep_size,2,0,2
"offsetof(c_Map, m_size) == FAST_COLLECTION_SIZE_OFFSET, """"",1,1,2
"KindOfUninit == 0, ""Several things assume this tag is 0, especially target cache""",1,1,2
void *obj,1,1,2
tvIsPlausible(fr->tv()),1,1,2
getTypeParam() == Type::NamedEntity,1,1,2
 pParse->nVarExpr==0 ,1,1,2
 u.bf.pC->pseudoTableReg==0 ,1,1,2
uintptr_t(s->rawdata()) % 4 == 0,1,1,2
isMixed(m_kind) || m_kind == kPackedKind || m_kind == kVecKind || m_kind == kStructKind,2,0,2
 u.bf.pData->flags & (MEM_Blob|MEM_Str) ,1,1,2
this->m_context,2,0,2
 iLevel>=0 ,1,1,2
!obj || obj->getRoot() == obj,1,1,2
innerCell->_count > 0,1,1,2
h->kindIsValid(),2,0,2
 (p->btreeMask & (1<<u.at.iDb))!=0 ,1,1,2
"sizeof(((TypedValue*)0)->m_aux) == sizeof(int32_t), ""emitStoreInvalid assumes m_aux is dword sized.""",1,1,2
sizeof(Elm) == 16,1,1,2
!isDistinct,1,1,2
hasRef(),2,0,2
getCount() > 1,1,1,2
"kFalseSharingRange == 64, ""FOLLY_ON_NEXT_CACHE_LINE must track kFalseSharingRange""",1,1,2
 (p->btreeMask & (1<<u.br.iDb))!=0 ,1,1,2
bin_mags->sparemag->binind == i,1,1,2
idx < NumNodes,2,0,2
page_size > 2*CACHE_LINE_SIZE + (int)sizeof(int),1,1,2
this == s_head,1,1,2
m_data == static_cast<void*>(this + 1),1,1,2
arr.subtypeOf(TArr),1,1,2
m_nextFreeUnnamedLocal == (int)m_unnamedLocals.size(),1,1,2
canSpecializeArrayKind() && hasArrayKind(),1,1,2
 iIdxCur>=0 ,1,1,2
 !pOpen->pUnused || threadsOverrideEachOthersLocks==0 ,1,1,2
off < Offset(m_bclen),1,1,2
packedCapCode <= 0xFFFFFFul,1,1,2
capCode <= 0xFFFFFFul,1,1,2
 u.am.p2<u.am.nField ,1,1,2
page_size > CACHE_LINE_SIZE + sizeof(int),1,1,2
id != InvalidFuncId,1,1,2
m_keys && m_vals && toUint32(pos) < m_capacity,1,1,2
"kPackedKind < kMixedKind, """"",1,1,2
i >= arena_chunk_header_npages,1,1,2
 u.bn.pC->deferredMoveto==0 ,1,1,2
 iSpace1<=pBt->pageSize ,1,1,2
 pBt->isExclusive==0 || pBt->pWriter==pLock->pBtree ,1,1,2
run_ind < chunk_npages,1,1,2
" ~ExprHasAnyProperty(pExpr, EP_TokenOnly|EP_Reduced) ",1,1,2
 sqlite3PagerIswriteable(pTrunk->pDbPage) ,1,1,2
 pNew!=0 || rc!=SQLITE_OK ,1,1,2
0 <= (int32_t)o,1,1,2
!isRefcountedType(m_handle.m_type),1,1,2
 PAGER_SHARED==SHARED_LOCK ,1,1,2
m_hdr.aux == flags && hasExactlyOneRef(),2,0,2
"(m_p = nullptr, true)",1,1,2
bin->runcur->magic == ARENA_RUN_MAGIC,1,1,2
"k->getId() < numIds(m_factory, (Key*)nullptr)",1,1,2
id < env.ctx.func->locals.size(),1,1,2
ad->m_tableMask == mask,1,1,2
Collection::isMapType(getCollectionType()),1,1,2
mem,1,1,2
m_kind == Kind::Imm || m_kind == Kind::IpRel,1,1,2
lg_range > 0,1,1,2
isShared(),1,1,2
typeReg != r32(argNumToRegName[0]),1,1,2
 pPager->nRec==0 ,1,1,2
sspace_min < PAGE_SIZE,1,1,2
 pToken->n<=nToken ,1,1,2
"offsetof(RefData, m_tv) > offsetof(RefData, _count) + sizeof(int32_t), """"",1,1,2
 iCol>=0 && iCol<=p->nColumn+1 ,1,1,2
getType() == Type::Arr,1,1,2
vmsp() == sp,1,1,2
" db==0 || sqlite3BtreeHoldsMutex(db->aDb[sqlite3SchemaToIndex(db, p->pSchema)].pBt) ",1,1,2
isStringType(m_type) && m_data.pstr,2,0,2
m_kind == HeaderKind::Object || m_kind == HeaderKind::ResumableObj || m_kind == HeaderKind::AwaitAllWH,1,1,2
 u.ac.p1+u.ac.n<=u.ac.p2 || u.ac.p2+u.ac.n<=u.ac.p1 ,1,1,2
v.first < m_universe_size,2,0,2
 (idxStr==0 && argc==0) || strlen(idxStr)==argc*2 ,1,1,2
need_pages > 0,1,1,2
m_str,2,0,2
!on_fail || on_fail->instanceof(c_Closure::classof()),1,1,2
size < oldsize,1,1,2
"memset(obj, 0x6a, m_itemSize)",1,1,2
file,1,1,2
"offsetof(TypedValue, m_data) == 0, """"",1,1,2
jeAllocated >= 0 && jeAllocated <= std::numeric_limits<int64_t>::max(),1,1,2
 u.cg.pCur->pVtabCursor ,1,1,2
 u.az.oc!=OP_SeekLe || u.az.r.flags==UNPACKED_INCRKEY ,1,1,2
"offsetof(ObjectData, _count) == FAST_REFCOUNT_OFFSET",1,1,2
cellIsPlausible(&to),1,1,2
p && p->eType==FTSQUERY_PHRASE ,1,1,2
 u.au.pDb->pBt!=0 ,1,1,2
Dbl,1,1,2
ad->kind() == kStructKind,2,0,2
"std::is_same<const Value&, ConstRefType>::value, ""Only matching types may be interleaved""",1,1,2
"success != NULL && ""Failed to parse build time""",1,1,2
m_hasConstVal,1,1,2
 u.bi.pModule->xRowid ,1,1,2
"offsetof(Object, m_px) == offsetof(TypedValue, m_data), ""Offset of m_px in Object must be offset of m_data in TV""",1,1,2
m_hash >= 0,1,1,2
hasCollection() && getCollectionType() == Collection::ImmSetType,1,1,2
m_numIterators >= m_nextFreeIterator,1,1,2
!loc.spilled(),1,1,2
!m_hdr.aux && m_hdr.kind == HeaderKind::Object && !getCount(),1,1,2
 !yyendofinput ,1,1,2
"alignof(MPMCQueue<T,Atom>) >= kFalseSharingRange",1,1,2
static_cast<unsigned>(i) < m_areas.size(),2,0,2
m_type == Type::ClassRef,1,1,2
 top+nByte <= pPage->pBt->usableSize ,1,1,2
!(m_p & 0x1),1,1,2
transitionRequiresGrowth(),1,1,2
 pPager->nSavepoint==0 || isOpen(pPager->sjfd) || pPager->journalMode==PAGER_JOURNALMODE_MEMORY ,1,1,2
t1.subtypeOf(Gen) || t1 == t2,1,1,2
t->isA(Type::Obj) || t->getType().isPtr(),1,1,2
acc->m_type == KindOfByte || acc->m_type == KindOfInt16 || acc->m_type == KindOfInt32 || acc->m_type == KindOfInt64,1,1,2
!isGenerator || (!isAsync && !hasNonEmptyReturn),1,1,2
func->isAsyncFunction(),2,0,2
isGotoing(),1,1,2
 FTSQUERY_NOT==MERGE_NOT && FTSQUERY_AND==MERGE_AND ,1,1,2
m_value.knownClass == nullptr || m_kind == ITER || m_value.outerType == KindOfObject || (m_value.outerType == KindOfRef && m_value.innerType == KindOfObject),1,1,2
(fr)->m_type != KindOfRef,1,1,2
check_refcount(m_data.pstr->getCount()),1,1,2
isRunning(),2,0,2
need_pages <= total_pages,1,1,2
fr->m_type == KindOfVariant,1,1,2
ad->isMixed() || ad->isDict() || ad->isKeyset(),2,0,2
 pFirst->aiRowEst!=0 ,1,1,2
vmpc() == pc,1,1,2
PTRMAP_PTR_SIZE % PTRMAP_LEVEL_BITS == 0,1,1,2
" offsetof(APCTypedValue, m_handle) + offsetof(APCHandle, m_type) == offsetof(TypedValue, m_type), ""Offset of m_type must be equal in APCHandle and TypedValue""",1,1,2
"IMPLIES(isParent(), m_type.dt == KindOfObject)",1,1,2
offset >= 0 && offset < size() && !isStatic(),1,1,2
 iType-2 < sizeof(staticMutexes)/sizeof(staticMutexes[0]) ,1,1,2
OptRes,1,1,2
m_value.outerType != KindOfHome,1,1,2
 eType!=FTSQUERY_PHRASE || !p->pPhrase->isNot ,1,1,2
jeDeallocated >= 0 && jeDeallocated <= std::numeric_limits<int64_t>::max(),1,1,2
Int,1,1,2
getCollectionType() == Collection::SetType || getCollectionType() == Collection::ImmSetType,1,1,2
this != &r,1,1,2
node->addr == ptr,1,1,2
(offset & chunksize_mask) == 0,1,1,2
 *p1!=0 && *p2!=0 ,1,1,2
(good_mask_nelms << (SIZEOF_INT_2POW + 3)) >= good_nregs,1,1,2
!(flags & SQLITE_OPEN_EXCLUSIVE) || (flags & SQLITE_OPEN_CREATE),1,1,2
 u.by.pProgram->nCsr==u.by.pFrame->nChildCsr ,1,1,2
 zNum[i]>='0' && zNum[i]<='9' ,1,1,2
reg.isSIMD() && m_kind != kSpill,1,1,2
 regRow!=pDest->iMem+i ,1,1,2
"sizeof(m_arrayKind) == 1, ""Type expects ArrayKind to be one byte""",1,1,2
getCount() == 1,1,1,2
 pRight->pColl ,1,1,2
(mapbits & CHUNK_MAP_ALLOCATED) != 0,1,1,2
 pPager->state>=PAGER_SHARED || pPager->dbModified==0 ,1,1,2
 iNode!=0 ,1,1,2
inst->getCount() > 0,1,1,2
!exit->m_main,1,1,2
"sizeof(D_format) == sizeof(uint32_t), ""D_format_t size != 4""",1,1,2
v.m_type != KindOfUninit,2,0,2
"sizeof(Z23_format) == sizeof(uint32_t), ""Z23_format_t size != 4""",1,1,2
loc.space == Location::Litint,1,1,2
"sizeof(*this) == sizeof(Base), """"",1,1,2
(tv)->_count == 0,1,1,2
(uint32_t{flags} & ~kFlagsMask) == 0,1,1,2
mode == Uns::ColKeyMode,1,1,2
 pPager->doNotSync==0 ,1,1,2
"sizeof(m_bits) * 8 >= PhysReg::kMaxRegs, """"",1,1,2
 p->isSorted==0 ,1,1,2
ev_idx < vec.size(),1,1,2
XDEBUG_GLOBAL(Server) != nullptr,1,1,2
"sizeof(RefData::_count) == TypedValueAux::auxSize, """"",1,1,2
m_kindOf != KindOfStatement,2,0,2
"sizeof(I_format) == sizeof(uint32_t), ""I_format_t size != 4""",1,1,2
 pPager->exclusiveMode || pPager->state==PAGER_SHARED ,1,1,2
inst->getIId() < m_info.size(),1,1,2
m_count >= 0,1,1,2
 pOpen->pNext->pPrev==pOpen ,1,1,2
numProbes++ < m_mask + 1,2,0,2
 (pgno>0 && pgno<=iLastPg) || rc!=SQLITE_OK ,1,1,2
index >= 0 && index < (int)src.size(),1,1,2
" !std::is_reference<StorageType>::value, ""StorageType must be decayed""",1,1,2
MM().empty(),1,1,2
 u.az.nField>0 ,1,1,2
m_type == Type::VarEnvRef,1,1,2
*detail::g_current_gen_link != kInvalidGenNumber,2,0,2
ad->m_count == 0,1,1,2
isArrayKind(m_hdr.kind),1,1,2
!(reinterpret_cast<uintptr_t>(r) & TagBit),1,1,2
 u.ck.nArg>1 && u.ck.apArg[0] && (u.ck.apArg[0]->flags&MEM_Null) ,1,1,2
m_immCopy.isNull() || (data() == ((BaseVector*)m_immCopy.get())->data() && arrayData()->hasMultipleRefs()),1,1,2
RuntimeOption::DisableSmallAllocator || contains(p),1,1,2
m_arr == staticEmptyArray() || m_arr->isPacked(),2,0,2
m_z == 0 || m_z == 1,1,1,2
!on_yield || on_yield->instanceof(c_Closure::classof()),1,1,2
m_type == Type::Arr,1,1,2
hasCollection() && getCollectionType() == Collection::FixedSetType,1,1,2
 (pPager->state==PAGER_SHARED) || (pPager->exclusiveMode && pPager->state>PAGER_SHARED) ,1,1,2
!on_join || on_join->instanceof(c_Closure::s_cls),1,1,2
 db->aDb[u.at.iDb].pBt!=0 ,1,1,2
!m_pipeVars.empty() && m_pipeVars.top() == pipeVar,1,1,2
newMode != Mode::Flat,1,1,2
"!Source::infinite, ""Cannot foldl infinite source""",1,1,2
base->m_type == KindOfArray,1,1,2
nOverflow<2 || pOld->aOvfl[0].idx==pOld->aOvfl[1].idx-1,1,1,2
 pPager->tempFile==0 || pPager->state>=PAGER_EXCLUSIVE ,1,1,2
m_type == Memory,1,1,2
 pbegin<=pPage->pBt->usableSize-4 ,1,1,2
metric != nullptr,1,1,2
 mergetype==MERGE_POS_NEAR || mergetype==MERGE_NEAR ,1,1,2
!m_arrayKindValid && !other.m_arrayKindValid,1,1,2
m_type == Type::VarEnvPtr,1,1,2
 u.by.pProgram->nMem+u.by.pProgram->nCsr==u.by.pFrame->nChildMem ,1,1,2
getCollectionType() == CollectionType::Set || getCollectionType() == CollectionType::ImmSet,1,1,2
kind <= Ptr::Ptr,1,1,2
CHUNK_ADDR2BASE(ret) == ret,1,1,2
" offsetof(c_StableMap, m_size) == FAST_COLLECTION_SIZE_OFFSET, """"",1,1,2
 iEst<=SQLITE_INDEX_SAMPLES ,1,1,2
"sizeof(XX3_format) == sizeof(uint32_t), ""XX3_format_t size != 4""",1,1,2
"ArrayData::kSharedKind == uint8_t(HeaderKind::Shared), """"",1,1,2
diff == regind * size,1,1,2
" 0==fts3HashFind(&p->pendingTerms, zToken, nToken) ",1,1,2
*this <= Cctx && m_hasConstVal,1,1,2
"sizeof(XO_format) == sizeof(uint32_t), ""XO_format_t size != 4""",1,1,2
"offsetof(String, m_px) == offsetof(TypedValue, m_data), ""Offset of m_px in String must be offset of m_data in TV""",1,1,2
v.is(KindOfNull),1,1,2
"(kNotConstantValueTypeMask & KindOfArray) != 0 && (kNotConstantValueTypeMask & KindOfObject) != 0 && (kNotConstantValueTypeMask & KindOfResource) != 0 && (kNotConstantValueTypeMask & KindOfRef) != 0, ""DataType & kNotConstantValueTypeMask must be non-zero for "" ""Array, Object and Ref types""",1,1,2
 rc!=SQLITE_OK || pPager->journalOff==szJ ,1,1,2
m_keys && toUint32(pos) < m_capacity,1,1,2
transDB.find(tca) != transDB.end(),1,1,2
!isRefcountedType(tDest.m_type),1,1,2
 pIdx->aSample ,1,1,2
 u.bg.pC->iDb>=0 ,1,1,2
&mem,1,1,2
ad->kind() == ArrayData::kMixedKind || ad->kind() == ArrayData::kPackedKind || ad->kind() == ArrayData::kEmptyKind,1,1,2
argNum >= m_vals.size(),1,1,2
mem + HEAP_SIZE == bottom + SHARED_MEM_SIZE + page_size,1,1,2
SArr,1,1,2
m_top->m_type == KindOfClass,2,0,2
 regTabname+1==regIdxname && regTabname+2==regSampleno && regTabname+3==regCol ,1,1,2
CACHE_LINE_SIZE >= sizeof(char*),1,1,2
"sizeof(EVX_format) == sizeof(uint32_t), ""EVX_format_t size != 4""",1,1,2
scratch != argNumToRegName[0],1,1,2
m_value.innerType != KindOfVariant,1,1,2
"offsetof(APCObject, m_handle) == 0, """"",2,0,2
"(kVmMInstrStateOff % 16) == 0, ""MInstrState should be 16-byte aligned in RDS::Header""",1,1,2
k->isLiteral(),1,1,2
"sizeof(VA_format) == sizeof(uint32_t), ""VA_format_t size != 4""",1,1,2
cell->m_type != KindOfRef,1,1,2
 pPager->noSync==0 && !MEMDB ,1,1,2
 pPager->tempFile==0 || pPager->changeCountDone ,1,1,2
mInd < mvec.mcodes.size(),1,1,2
 !MEMDB && pPager->noSync==0 ,1,1,2
 i>=0 && i<sqlite3GlobalConfig.nScratch ,1,1,2
this->len < this->cap,1,1,2
"offsetof(RefData, _count) == TypedValueAux::auxOffset, """"",1,1,2
idx < m_state.stack.size(),1,1,2
m_z < 2,1,1,2
m_reg == InvalidReg && c2.m_reg == InvalidReg,1,1,2
 mem0.nScratchFree<(u32)sqlite3GlobalConfig.nScratch ,1,1,2
px == NULL || (void*)px == (void*)m_px,1,1,2
body != nullptr && body->is(Expression::KindOfExpressionList),1,1,2
 pOp->p4.z==0 || pOp->p3==1 || pOp->p3==0 ,1,1,2
id / transCountersPerChunk < m_transCounters.size(),1,1,2
static_cast<uint64_t>(OpLowInvalid) == 0,1,1,2
*this <= RDSHandle && m_hasConstVal,1,1,2
r->getRealCount() > 0,1,1,2
 pNew->pOpen==NULL ,1,1,2
 u.bf.pC!=0 ,1,1,2
"!Gen::infinite, ""Cannot pull all values from an infinite sequence.""",1,1,2
 pCur->apPage[pCur->iPage]->isInit ,1,1,2
 u.bh.pC->isIndex || pOp->opcode==OP_RowData ,1,1,2
 pOpen->pPrev->pNext==pOpen ,1,1,2
 u.bf.pC->pCursor!=0 ,1,1,2
 bufpt>buf ,1,1,2
regNo < NumRegs && regNo >= 0,1,1,2
 u.az.oc!=OP_SeekGe || u.az.r.flags==0 ,1,1,2
t->getType().isPtr(),1,1,2
"sizeof(XFX_format) == sizeof(uint32_t), ""XFX_format_t size != 4""",1,1,2
 rc!=SQLITE_ROW ,1,1,2
current == TGen || current == TCell,1,1,2
isa<T>(p),1,1,2
numT < std::numeric_limits<int64_t>::max() && (numT * sizeof(T)) % 8 == 0,2,0,2
hasCollection() && getCollectionType() == Collection::ImmVectorType,1,1,2
sizeof(Elm) == 24,1,1,2
" strcmp(db->aDb[db->nDb-1].zName,""vacuum_db"")==0 ",1,1,2
getType() == Type::Dbl,1,1,2
 pPager->state>=SHARED_LOCK ,1,1,2
pce,1,1,2
"sizeof(int64) == sizeof(long long), ""Must be able to cast an int64* to a long long*""",1,1,2
!m_flags.canConstProp,1,1,2
!isRefcountedType(tv.m_type),2,0,2
"canEmitCheck, [] { return ""Data block emission failed. This almost certainly means the TC is "" ""full. If this is the case, increasing Eval.JitASize, "" ""Eval.JitAStubsSize and Eval.JitGlobalDataSize in the configuration "" ""file when running this script or application should fix this "" ""problem.""; } ",1,1,2
 u.by.pProgram->nOp>0 ,1,1,2
m_inst->getType() == m_type,1,1,2
" offsetof(APCTypedValue, m_handle) == sizeof(SharedData), ""m_handle must come after SharedData in !PACKED_TV"" ",1,1,2
idx < m_list.size(),1,1,2
!on_failed_callback || on_failed_callback->instanceof(c_Closure::classof()),1,1,2
 !(u.am.pDest->flags & (MEM_Blob|MEM_Str)) || u.am.pDest->z==u.am.sMem.z ,1,1,2
n != uint32_t(-1),1,1,2
 compatible[RTREE_GT & 7]==2 ,1,1,2
 u.bv.z==0 ,1,1,2
"IMPLIES(isSelf(), m_type.dt == KindOfObject)",1,1,2
" notReady & getMask(pMaskSet, pTabList->a[bestJ].iCursor) ",1,1,2
data->isStatic(),2,0,2
n <= remainingGrowth_,1,1,2
ad->m_cap == cap,1,1,2
((uintptr_t)ret & (alignment - 1)) == 0,1,1,2
"true && ""If this struct is completely empty we get unused "" ""variable warnings in code that uses it.""",2,0,2
key->getType().isKnownDataType(),1,1,2
rv >= 0,1,1,2
!isGenerator || (!isAsync && !hasReturn),1,1,2
 p->pRight!=0 ,1,1,2
 (nTabList-iFrom)>1 || isOptimal ,1,1,2
!ar->inGenerator() || !ar->func()->isAsync(),1,1,2
"HPHP::jit::deltaFits(address, HPHP::sz::word) && ""Address too big""",1,1,2
"k->id() < numIds(m_unit, (Key*)nullptr)",1,1,2
origFunc,1,1,2
((result - 1) & result) == 0,1,1,2
 eType==SQLITE_OPEN_MAIN_DB || eType==SQLITE_OPEN_TEMP_DB || eType==SQLITE_OPEN_MAIN_JOURNAL || eType==SQLITE_OPEN_TEMP_JOURNAL || eType==SQLITE_OPEN_SUBJOURNAL || eType==SQLITE_OPEN_MASTER_JOURNAL || eType==SQLITE_OPEN_TRANSIENT_DB ,1,1,2
"kMaxSmartSize <= kMaxFreeSize, """"",1,1,2
Unc,1,1,2
 !db->pVTab ,1,1,2
 u.ci.pCur->pVtabCursor ,1,1,2
 u.am.p1<p->nCursor ,1,1,2
 u.an.zAffinity!=0 ,1,1,2
 u.bg.pC->rowidIsValid ,1,1,2
minsize != 0,1,1,2
ntbins <= QUANTUM_2POW,1,1,2
handle->kind() == APCKind::SharedString || handle->kind() == APCKind::SerializedArray || handle->kind() == APCKind::SerializedObject,2,0,2
"offsetof(ArrayData, m_kind) == HeaderKindOffset, """"",1,1,2
*heap + heap_size == bottom + shared_mem_size,1,1,2
b == (m_kind == kMixedKind || m_kind == kStrMapKind || m_kind == kIntMapKind),1,1,2
!(reinterpret_cast<uintptr_t>(l) & TagBit),1,1,2
"!Source::infinite, ""Calling contains on an infinite source might cause "" ""an infinite loop.""",1,1,2
first->getOpcode() == DefLabel,1,1,2
page_size > CACHE_LINE_SIZE + (int)sizeof(int),1,1,2
m_stats.maxBytes > 0,1,1,2
 pColl!=0 ,1,1,2
isa_or_null<T>(p),1,1,2
unsigned(m_kind) < unsigned(ArrayKind::kNumKinds),1,1,2
"G0 == 0, """"",1,1,2
m_label >= 0,1,1,2
"offsetof(Array, m_px) == offsetof(Value, m_data)",1,1,2
 !pPg->pageHash || pPager->errCode || (pPg->flags&PGHDR_DIRTY) || pPg->pageHash==pager_pagehash(pPg) ,1,1,2
(fr)->m_type != KindOfVariant,1,1,2
m_count == 0,1,1,2
(uint32_t)count <= (uint32_t)RefCountMaxRealistic,1,1,2
"strncmp(path.c_str(), ""file://"", sizeof(""file://"") - 1) == 0",1,1,2
hashIsEmpty(pRtree),1,1,2
maybe(PtrToGen),1,1,2
ad->m_size == other.m_size,1,1,2
 u.aj.pKeyInfo!=0 ,1,1,2
OptSub,1,1,2
"sizeof(T) <= 0xffff && sizeof(T) < kMaxSmartSize, """"",1,1,2
"rbp_right_get(a_type, a_field, rbp_i_p) == rbp_i_c",1,1,2
 sqlite3BtreeCursorIsValid(u.be.pC->pCursor) ,1,1,2
 u.ab.p2>=1 && u.ab.p2+u.ab.n-1<=p->nMem ,1,1,2
 !p || (p->locked==0 && p->sharable) || p->pBt->db==p->db ,1,1,2
reinterpret_cast<uintptr_t>(ptr) % 16 == 0,1,1,2
state.base.loc != BaseLoc::LocalArrChain,1,1,2
(reinterpret_cast<uintptr_t>(ptr) & kSmallSizeAlignMask) == 0,2,0,2
x64reg.isSIMD(),2,0,2
 u.cj.pVtab->pModule->xRename ,1,1,2
odata->collectionType() == CollectionType::Pair,2,0,2
 pList->nExpr<=pList->nAlloc ,1,1,2
(numArgs & (1u << 30)) == 0,1,1,2
0 <= (int32_t)f->unit()->offsetOf(i),1,1,2
"m_address && ""Cannot evaluate branch size without defined target""",1,1,2
QUANTUM_2POW >= TINY_MIN_2POW,1,1,2
"!std::is_reference<Value>::value && !std::is_const<Value>::value, ""Value mustn't be const or ref.""",1,1,2
result != -1,1,1,2
tv.m_type == KindOfArray,1,1,2
*this <= Int && m_hasConstVal,1,1,2
sizeof(instruction) == sizeof(uint32_t),2,0,2
 p->wantToLock==1 ,1,1,2
folly::isPowTwo(newCapac),1,1,2
index < kNumSmartSizes,1,1,2
 ppBtree != 0,1,1,2
"offsetof(TypedValue, m_type) == 8, """"",1,1,2
m_refCount,1,1,2
isBuiltin() || m_maxStackCells > 0,1,1,2
index <= 7,1,1,2
count == StaticValue || !MemoryManager::sweeping(),1,1,2
!target || hasEdges(inst->op()),1,1,2
"factoryId(k) < count(m_factory, (Key*)nullptr)",1,1,2
m_stats.peakIntervalAlloc >= 0,1,1,2
typeReg != argNumToRegName[0],1,1,2
m_retLocal >= 0,1,1,2
"!Source::infinite, ""Cannot sample infinite source!""",1,1,2
!className || className->isStatic(),1,1,2
(chunk->map[run_ind].bits & ~PAGE_MASK) == prun_size,1,1,2
"KindOfStaticString == 0x0c, """"",1,1,2
*this <= StaticStr && m_hasConstVal,1,1,2
m_top->m_data.pref != nullptr,1,1,2
!localsDecRefd(),1,1,2
m_top[ind].m_type != KindOfVariant,1,1,2
segr == reg::fsPrefix || segr == reg::gsPrefix,1,1,2
 (p->btreeMask & (1<<pOp->p5))!=0 ,1,1,2
m_mask.size() == 0,1,1,2
getType() == Type::StaticStr,1,1,2
!(m_numArgsAndFlags & (1 << 29)),1,1,2
name->data()[name->size()] == 0,1,1,2
"sizeof(aux) == 2, """"",1,1,2
"!Source::infinite, ""Cannot sort infinite source!""",1,1,2
getType() == KindOfInt32 || getType() == KindOfInt64,1,1,2
notBoxed(),1,1,2
m_handle.is(KindOfStaticString) || (m_handle.isUncounted() && m_handle.is(KindOfString)),1,1,2
m_value.knownClass == nullptr || m_value.outerType == KindOfObject || (m_value.outerType == KindOfRef && m_value.innerType == KindOfObject),1,1,2
rbp_f_node != &(a_tree)->rbt_nil,1,1,2
 pTab->dbMem==0 ,1,1,2
 pBt->isPending==0 || pBt->pWriter ,1,1,2
 !u.bh.pC->isTable ,1,1,2
isObjectKind(obj->headerKind()),2,0,2
 pOp->p3<pOp->p2 || pOp->p3>=pOp->p2+u.ag.n ,1,1,2
(numArgs & ~kNumArgsMask) == 0,1,1,2
ret != this && ret->hasExactlyOneRef(),1,1,2
"offsetof(Variant,_count) == offsetof(TypedValue,_count)",1,1,2
m_type == Type::Int,1,1,2
p->type == XML_HTML_DOCUMENT_NODE || p->type == XML_DOCUMENT_NODE || p->type == XML_DOCUMENT_TYPE_NODE,1,1,2
index == smartSize2IndexCompute(size),1,1,2
 nCol==1 ,1,1,2
"offsetof(Variant, _count) == 8 && offsetof(Variant, m_type) == 12 && sizeof(_count) == sizeof(uint32_t) && sizeof(m_type) == sizeof(uint32_t)",1,1,2
getCollectionType() == CollectionType::Vector || getCollectionType() == CollectionType::ImmVector,1,1,2
getTypeParam() == Type::Func,1,1,2
m_origFuncName->isStatic(),1,1,2
"rbp_right_get(a_type, a_field, rbp_r_p) == rbp_r_c",1,1,2
 u.bo.pC->deferredMoveto==0 ,1,1,2
ndi,1,1,2
HphpArray::Empty == -1,1,1,2
t != Type::Bottom,1,1,2
newCount != 0,1,1,2
!m_cow && !m_z,1,1,2
*this == Bottom || !isPtr(),1,1,2
(tvptr)->m_type == KindOfRef,1,1,2
 u.aj.p1>0 && u.aj.p1+mx<=p->nMem+1 ,1,1,2
"e, assert_throw_fail_impl(e)",1,1,2
m_funcs.size() == 2,1,1,2
 isOptimal || (sCost.used&notReady)==0 ,1,1,2
 *p1!=0x00 && *p2!=0x00 && *p1!=0x01 && *p2!=0x01 ,1,1,2
preClass() == nullptr,1,1,2
"offsetof(ActRec, m_savedRbp) == 0",1,1,2
mag->nrounds == 0,1,1,2
"offsetof(RefData, _count) == FAST_REFCOUNT_OFFSET, """"",1,1,2
 p->db==p->pBt->db ,1,1,2
m_funcId != InvalidId,1,1,2
 u.az.pC!=0 ,1,1,2
cb_.available() > 0,2,0,2
!m_object || m_object->getRoot() == m_object,1,1,2
obj->getVMClass() == c_Continuation::s_cls,1,1,2
!pCur->aOverflow,1,1,2
getType() == Type::Home,1,1,2
getContextIdx() <= child->getContextIdx(),1,1,2
 u.bc.pCx->deferredMoveto==0 ,1,1,2
 pcache1.isInit ,1,1,2
op[1 + sizeof(Offset)] == OpRetC,1,1,2
*heap == (char*)(SHARED_MEM_INIT + heap_size),1,1,2
(reinterpret_cast<uintptr_t>(p) & kSmartSizeAlignMask) == 0,1,1,2
QUANTUM * (((sizeof(qsize_invs)) / sizeof(unsigned)) + 3) >= (1U << QSPACE_MAX_2POW_DEFAULT),1,1,2
dynamic_cast<c_Continuation*>(obj),1,1,2
m_handle.m_flags == 0 || m_handle.getUncounted(),1,1,2
ad->m_pos == other.m_pos,1,1,2
 pOp->opcode==OP_ShiftRight ,1,1,2
compressed_size == actual_compressed_size,1,1,2
"kMaxRegs >= ARM::kNumRegs, """"",1,1,2
isArrayType(m_type) && m_data.parr,2,0,2
"SORTFUNC_ASORT > 0, """"",2,0,2
tvIsPlausible(&fr),1,1,2
m_actRec.func()->contains(offset),1,1,2
check_refcount(m_data.parr->getCount()),1,1,2
getCollectionType() == Collection::VectorType || getCollectionType() == Collection::ImmVectorType,1,1,2
m_top->m_type == KindOfClass || tvIsPlausible(m_top),1,1,2
!m_safeToRead,1,1,2
!isFlat(),1,1,2
 pPager->doNotSync==1 ,1,1,2
 ii<(NCELL(pNode)-1) ,1,1,2
 pParse->apVarExpr!=0 ,1,1,2
 dest.nMem==nColumn ,1,1,2
 pExpr->eType==FTSQUERY_NEAR || pExpr->eType==FTSQUERY_OR || pExpr->eType==FTSQUERY_AND || pExpr->eType==FTSQUERY_NOT ,1,1,2
m_handle.isUncounted() && m_handle.is(KindOfArray),1,1,2
m_data.pstr->checkCount(),1,0,1
v2.first,1,0,1
c_NumberFormatter,1,0,1
p && !p->_private,1,0,1
!(reinterpret_cast<Opaque>(r) & TagBit),1,0,1
"sizeof(XX4_format) == sizeof(uint32_t), ""XX4_form_t size != 4""",1,0,1
"SSATmp* tmp, Type type",1,0,1
tl_regState == VMRegState::CLEAN,1,0,1
m_activeUnnamedLocals > 0,1,0,1
feof(fp),1,0,1
"SORTFUNC_KRSORT == SORTFUNC_KSORT + 1, """"",1,0,1
m_set.test(t),1,0,1
m_numIterators == 0,1,0,1
size < global_size_b - sizeof(value),1,0,1
!finished(),1,0,1
"kMaxSmallSize <= kMaxFreeSize, """"",1,0,1
c_IntlBreakIterator,1,0,1
"sizeof(XS_format) == sizeof(uint32_t), ""XS_form_t size != 4""",1,0,1
len < StringData::MaxSize,1,0,1
"checkBlockEnd(unit, labels[i])",1,0,1
"kMaxDataType <= kDataTypeMask, """"",1,0,1
m_sprop == nullptr,1,0,1
"sizeof(VA_format) == sizeof(uint32_t), ""VA_form_t size != 4""",1,0,1
name != nullptr,1,0,1
"ArrayData::kEmptyKind == uint8_t(HeaderKind::Empty), """"",1,0,1
vmStack().isAllocated() || MM().empty(),1,0,1
"allowable(this, r) || !r.isValid()",1,0,1
!(flags & MOpFlags::Define) && !(flags & MOpFlags::Unset),1,0,1
n <= Threshold,1,0,1
"keyType == KeyType::Any, ""bad KeyType""",1,0,1
nep.first,1,0,1
!is_ephemeral(sr),1,0,1
!hasUserDefinedCmp(s),1,0,1
"sizeof(toCopy) == 8, ""Unexpected size for toCopy""",1,0,1
"hdr == slab_end && ""hdr > slab_end indicates corruption""",1,0,1
"!(KindOfPersistentString & KindOfArrayBit), """"",1,0,1
singleton() == (T*)&s_storage,1,0,1
sortBy < NUM_EVENT_TYPES,1,0,1
inst->checkCount(),1,0,1
fp->m_varEnv == nullptr,1,0,1
"static_cast<int>(HealthLevel::Bold) == 0, """"",1,0,1
"sizeof(inthash_t) == sizeof(strhash_t), """"",1,0,1
"0 && ""This code needs to be conditional on "" ""deltaFits(p, sz::dword) before using it""",1,0,1
ret != nullptr && ret->getWand() != nullptr,1,0,1
"top(env, i), TCls",1,0,1
obj->getAttribute(ObjectData::IsWaitHandle),1,0,1
"!(KindOfClass & KindOfArrayBit), """"",1,0,1
m_liveNodes,1,0,1
"sizeof(VC_format) == sizeof(uint32_t), ""VC_form_t size != 4""",1,0,1
m_refCount.load(),1,0,1
alias.type != AnnotType::Object,1,0,1
m_fatal_error_msg == nullptr,1,0,1
m_kind == Kind::Stub,1,0,1
nep.first->data()[0] != '\\',1,0,1
obj->instanceof(classof()),1,0,1
m_type == KindOfRef ? m_data.pref->var()->m_data.pres : m_data.pres,1,0,1
!tv.m_data.pstr->isRefCounted(),1,0,1
offset < m_len,1,0,1
ei == m_used,1,0,1
" sizeof(decltype(m_flags_val)) == sizeof(decltype(m_flags)), ""m_flags_val must cover all the flags""",1,0,1
*this <= TBoxedCell,1,0,1
tv != nullptr,1,0,1
status == 0,1,0,1
static_cast<uint32_t>(s) < 32,1,0,1
hashtbl[slot1].hash == get_hash(key1),1,0,1
p->type == XML_HTML_DOCUMENT_NODE || p->type == XML_DOCUMENT_NODE,1,0,1
len > 0 && len % 16 == 0,1,0,1
m_funcID != InvalidFuncId,1,0,1
"v == TGen, ""volatile local was not TGen""",1,0,1
"ArrayData::kApcKind == uint8_t(HeaderKind::Apc), """"",1,0,1
"sizeof(FuncId) == sizeof(uint32_t), """"",1,0,1
"env.flags.jmpFlag == StepFlags::JmpFlags::Either && ""you can't use impl with branching opcodes before last position""",1,0,1
size < std::numeric_limits<uint32_t>::max(),1,0,1
"sizeof(RuntimeOption) == 1, ""no instance variables""",1,0,1
property->isStatic(),1,0,1
"sizeof(PDO_ERR_NONE) <= sizeof(PDOErrorType), ""PDO_ERR_NONE should actually fit into PDOErrorType""",1,0,1
"KindOfPersistentString & KindOfStringBit, """"",1,0,1
"KindOfArray & KindOfArrayBit, """"",1,0,1
"offsetof(HeaderWord<Flags>, aux) == offsetof(Flags, type),""""",1,0,1
"kMaxBuiltinArgs == 32,""Regenerate native-func-caller.h for updated kMaxBuiltinArgs""",1,0,1
m_unit,1,0,1
"std::is_pointer<T>::value, ""ZendRequestLocalVector only stores pointers""",1,0,1
"sizeof(B_format) == sizeof(uint32_t), ""B_form_t size != 4""",1,0,1
op1 == OpCreateCont,1,0,1
" std::is_arithmetic<T>::value || std::is_pointer<T>::value, ""Atomic operations only supported for built in integer, floating point "" ""and pointer types.""",1,0,1
naryDst() || m_numDsts <= 1,1,0,1
"offsetof(RefData, m_hdr) == HeaderOffset, """"",1,0,1
"false, ""Bad KindOf: {}"", (size_t)tv.m_type",1,0,1
fp->hasThis(),1,0,1
sd != nullptr,1,0,1
"top(env, i), TGen",1,0,1
"0 && ""Impossible constant evaluation occurred""",1,0,1
"ArrayData::kDictKind == uint8_t(HeaderKind::Dict), """"",1,0,1
" !std::is_convertible<L,R>::value && !std::is_convertible<R,L>::value, ""Either<L,R> should not be used with compatible pointer types"" ",1,0,1
finished(),1,0,1
!equal || getClass(key1)->name()->equal(getClass(key2)->name()),1,0,1
t < m_set.size(),1,0,1
cellIsPlausible(*r->tv()),1,0,1
kind() == Kind::Direct || kind() == Kind::Smashable,1,0,1
e && !isPhpException(e),1,0,1
" std::is_trivially_destructible<Key>::value && std::is_trivially_destructible<Val>::value, ""TreadHashMap only supports trivially destructible keys and values"" ",1,0,1
!data || data->hasMultipleRefs(),1,0,1
sz::byte,1,0,1
CACHE_LINE_SIZE >= sizeof(size_t),1,0,1
!newVal->type().maybe(TBoxedCell),1,0,1
checkInvariants() && m_handle.kind() == APCKind::Int,1,0,1
m_used <= capacity(),1,0,1
type.clsSpec(),1,0,1
"Empty == -1, ""The following fills with all 1's.""",1,0,1
strong_iterators_exist(),1,0,1
"sizeof(BuiltinFile) == sizeof(PlainFile), ""BuiltinFile inherits PlainFile::heapSize()""",1,0,1
"sizeof(HeaderKind) == 1, """"",1,0,1
reinterpret_cast<const uintptr_t>(mem2) % W == 0,1,0,1
"sizeof(EVX_format) == sizeof(uint32_t), ""EVX_form_t size != 4""",1,0,1
i < DebuggerClient::AutoCompleteCount,1,0,1
RuntimeOption::RepoAuthoritative,1,0,1
m_p >= m_last,1,0,1
"sizeof(MDS_format) == sizeof(uint32_t), ""MDS_form_t size != 4""",1,0,1
event.type < NUM_EVENT_TYPES,1,0,1
"IMPLIES(N, l.isNormal())",1,0,1
folly::isPowTwo(a.align),1,0,1
isValidCollection(static_cast<CollectionType>(m_hdr.kind)),1,0,1
"ArrayData::kGlobalsKind == uint8_t(HeaderKind::Globals), """"",1,0,1
" std::is_same<TagBitPolicy,void>::value || std::is_same<TagBitPolicy,either_policy::high_bit>::value, ""Unknown policy in Either"" ",1,0,1
this->main() != this->frozen() || this->main() == this->cold(),1,0,1
"sizeof(MIterTable) == 2*64, """"",1,0,1
c > Threshold / 2,1,0,1
isStr(elm),1,0,1
!cls->instanceCtor() && !(cls->attrs() & (AttrAbstract | AttrInterface | AttrTrait | AttrEnum)),1,0,1
rds::isNormalHandle(handle),1,0,1
irName != rn(reg::rsp),1,0,1
regs.fp == fp,1,0,1
dt == KindOfRef || (dt >= KindOfUninit && dt <= KindOfResource),1,0,1
" std::is_integral<K>::value && std::is_unsigned<K>::value, ""sparse_id_set is intended for use with unsigned integer types"" ",1,0,1
err != 0 || outLen == sizeof(T),1,0,1
result->m_type != KindOfUninit,1,0,1
adjusted_mantissa <= M && adjusted_exp <= MaxExp,1,0,1
data.left()->kind() == kind,1,0,1
fpcr().DN() == 0,1,0,1
checkInvariants() && m_handle.kind() == APCKind::Double,1,0,1
mysql,1,0,1
sz::word,1,0,1
!name.isNull(),1,0,1
page_size > 6*CACHE_LINE_SIZE + (int)sizeof(int),1,0,1
m_value.outerType == KindOfString || m_value.innerType == KindOfString || m_value.outerType == KindOfClass || m_value.innerType == KindOfClass || m_value.outerType == KindOfObject || m_value.innerType == KindOfObject || m_value.outerType == KindOfBoolean || m_value.outerType == KindOfInt64 || m_value.klass == NULL,1,0,1
(uintptr_t)&m_top[-n] <= (uintptr_t)m_base,1,0,1
m_arrTypes[i] != nullptr,1,0,1
!m_node->doc,1,0,1
empty(),1,0,1
!maybe(TUninit) || *this == TCell,1,0,1
ret->isProxyArray(),1,0,1
cls_Closure,1,0,1
m_kind == APCKind::UncountedArray,1,0,1
"kNumSmallSizes <= sizeof(kSmallSize2Index), ""Extend SMALL_SIZES table""",1,0,1
!ad->isRefCounted(),1,0,1
numWords != 0,1,0,1
tvIsPlausible(frIn),1,0,1
name->size() != 0,1,0,1
shared_mem,1,0,1
fp->func()->isAsyncFunction(),1,0,1
"std::is_trivially_destructible<RegSet>::value, ""RegSet must have a trivial destructor""",1,0,1
m_doc.get() == libxml_register_node((xmlNodePtr)m_node->doc).get(),1,0,1
"ArrayData::kMixedKind == uint8_t(HeaderKind::Mixed), """"",1,0,1
m_population == 0 && m_data != 0,1,0,1
env.vmain,1,0,1
"sizeof(String) == sizeof(req::ptr<StringData>), """"",1,0,1
c_ResourceBundle,1,0,1
"SORTFUNC_RSORT == SORTFUNC_SORT + 1, """"",1,0,1
isArrayType(base->m_type),1,0,1
alias.type == AnnotType::Object,1,0,1
transId < succs.size(),1,0,1
"!(KindOfRef & KindOfArrayBit), """"",1,0,1
getc(fp) == BuildInfo_kRevision[i],1,0,1
getState() == STATE_READY,1,0,1
tvIsPlausible(*self) && tvIsPlausible(*other),1,0,1
(((uintptr_t) actRec()) & (sizeof(Cell) - 1)) == 0,1,0,1
"std::is_unsigned<decltype(m_pos)>::value, ""m_pos should be unsigned""",1,0,1
refIsPlausible(*m_top),1,0,1
hashtbl[slot2].addr == NULL,1,0,1
m_arrTypes.size() < std::numeric_limits<uint32_t>::max(),1,0,1
name.isInteger() || name.isString(),1,0,1
"sizeof(XFL_format) == sizeof(uint32_t), ""XFL_form_t size != 4""",1,0,1
isStringType(getType()),1,0,1
"sizeof(X_format) == sizeof(uint32_t), ""X_form_t size != 4""",1,0,1
" std::is_trivially_destructible<T>::value, ""GrowableVector can only hold trivially destructible types"" ",1,0,1
id < m_arrTypes.size(),1,0,1
m_pos == p || !isStatic(),1,0,1
name,1,0,1
className->isA(TStr),1,0,1
ret != this && ret->isStatic(),1,0,1
"!""can't forceAsProxyArray an empty array""",1,0,1
"topT(env, i).subtypeOf(TCls)",1,0,1
c_EncodingMatch,1,0,1
(uint32_t)o >> 31 == 0,1,0,1
data.left(),1,0,1
m_node,1,0,1
fde_len != 0 || idx == m_buf->size(),1,0,1
"!(KindOfNull & KindOfArrayBit), """"",1,0,1
"e, """"",1,0,1
cellIsPlausible(*rhs),1,0,1
m_table,1,0,1
isNull() || isArray(),1,0,1
str->isStatic(),1,0,1
m_const == nullptr,1,0,1
result->m_type == KindOfObject,1,0,1
cellIsPlausible(*lhs),1,0,1
"ArrayData::kPackedKind == uint8_t(HeaderKind::Packed), """"",1,0,1
"ptrSubsetOf(kind, Ptr::Ptr)",1,0,1
"sizeof(XX3_format) == sizeof(uint32_t), ""XX3_form_t size != 4""",1,0,1
mm >= tm && mm_end <= tm_end,1,0,1
lenIn64 != 0,1,0,1
"std::is_same<A, B>::value, ""Optab type mismatch""",1,0,1
"SORTFUNC_KSORT == 0, """"",1,0,1
m_immCopy.isNull() || (data() == ((BaseVector*)m_immCopy.get())->data() && arrayData()->cowCheck()),1,0,1
kind() == TransKind::Profile,1,0,1
index == computeSmallSize2Index(size),1,0,1
*heap + heap_size == shared_mem + shared_mem_size,1,0,1
"sizeof(Offset) == sizeof(uint32_t), """"",1,0,1
val_.m_type != KindOfRef && val_.m_type != KindOfUninit,1,0,1
size < hashtbl_size,1,0,1
"sizeof(T) == 2, ""header layout requres 2-byte aux""",1,0,1
rname != noreg,1,0,1
!type.hasConstVal(),1,0,1
"SORTFUNC_UKSORT < 0, """"",1,0,1
"sizeof(TransLoc) == 16, ""Don't add fields to TransLoc""",1,0,1
n,1,0,1
i < numDsts(),1,0,1
"size <= 0xffff && size < kMaxSmallSize, """"",1,0,1
pNode == &s_node,1,0,1
m_hdr.aux == 0 && hasExactlyOneRef(),1,0,1
"top(env, i, tc), TCell",1,0,1
container,1,0,1
e && isPhpException(e),1,0,1
!isTaggedStringData(s2),1,0,1
!s->isRefCounted(),1,0,1
(reinterpret_cast<uintptr_t>(p) & kSmallSizeAlignMask) == 0,1,0,1
a.nbytes <= a.align,1,0,1
m_break == nullptr,1,0,1
!resumed,1,0,1
"tag == LTag::Stack || tag == LTag::Local || false, ""invalid LTag for LocationState""",1,0,1
!(reinterpret_cast<Opaque>(l) & TagBit),1,0,1
m_iterStruct <= m_stopStruct,1,0,1
m_actRec.func()->contains(resumeOffset),1,0,1
getVMClass()->numDeclProperties() > s,1,0,1
" std::is_same<Key,Block>::value || std::is_same<Key,IRInstruction>::value || std::is_same<Key,SSATmp>::value, ""StateMultiMap can only be used with Block, IRInstruction, or SSATmp"" ",1,0,1
m_stats.peakIntervalCap >= 0,1,0,1
" !type.subtypeOfAny(TCls, TCountedStr, TPersistentArr), ""Unsupported type in emitTypeTest(): {}"", type ",1,0,1
"sizeof(T*) == sizeof(uint64_t), """"",1,0,1
m_req == nullptr,1,0,1
"sizeof(c_Closure) == sizeof(void*) + sizeof(ObjectData), ""c_Closure size mismatch""",1,0,1
t->hasExactlyOneRef(),1,0,1
"std::numeric_limits<type_scan::Index>::max() <= std::numeric_limits<uint16_t>::max(), ""type_scan::Index must be no greater than 16-bits "" ""to fit into HeaderWord""",1,0,1
context_size >= 0,1,0,1
revlen == strlen(BuildInfo_kRevision),1,0,1
isStringType(cell->m_type),1,0,1
m_top->m_type == KindOfClass || tvIsPlausible(*m_top),1,0,1
func->contains(resumeOffset),1,0,1
"sizeof(type_scan::Index) <= 4, ""type_scan::Index cannot be greater than 32-bits""",1,0,1
"KindOfPersistentArray & KindOfUncountedInitBit, """"",1,0,1
id < m_ssaTmps.size(),1,0,1
new_context != nullptr,1,0,1
regs.stack.top() == sp,1,0,1
*this <= TStkElem,1,0,1
"(sizeof(TypedValue) & (sizeof(TypedValue)-1)) == 0, ""TypedValue's size is expected to be a power of 2""",1,0,1
m_hdr.aux.z < 2,1,0,1
data->validMArrayIter(*this),1,0,1
"top(env, i, tc), TGen",1,0,1
fwd < m_next,1,0,1
f.addr <= addr,1,0,1
"sizeof...(vals), ""use Array::Create() instead""",1,0,1
static_cast<uint32_t>(bc) < 32,1,0,1
op2 == OpPopC,1,0,1
"!(KindOfPersistentArray & KindOfStringBit), """"",1,0,1
"sizeof(A_format) == sizeof(uint32_t), ""A_form_t size != 4""",1,0,1
"false && ""Not a valid conditional branch parameter""",1,0,1
!x64reg.isSIMD(),1,0,1
c_IntlTimeZone,1,0,1
isArrayType(tv.m_type),1,0,1
str.m_str->isStatic(),1,0,1
getVMClass()->builtinODTailSize() == sizeof(void*),1,0,1
"kNumSIMDRegs == 8,""Regenerate native-func-caller.h for updated kNumSIMDRegs""",1,0,1
sz::qword,1,0,1
m_state.vcold,1,0,1
ret <= kMaxSmallSize,1,0,1
flags & MOpFlags::Define && !(flags & MOpFlags::Unset),1,0,1
!v1 == !v2,1,0,1
!getResetFlag() && data->validMArrayIter(*this),1,0,1
bool(m_attrs & AttrVariadicParam) == (numParams() && params()[numParams() - 1].variadic),1,0,1
m_dataForName.count(origName),1,0,1
!arr->isRefCounted(),1,0,1
location,1,0,1
" std::is_pointer<L>::value && std::is_pointer<R>::value, ""Either<L,R> should only be used with pointer types"" ",1,0,1
func != nullptr,1,0,1
"!(KindOfString & KindOfArrayBit), """"",1,0,1
c_IntlIterator,1,0,1
RuntimeOption::DisableSmallAllocator || m_bypassSlabAlloc || contains(p),1,0,1
"sizeof(node) == 64, ""Node should be cache-line sized""",1,0,1
handle->kind() == APCKind::SharedCollection,1,0,1
(this == m_prev) == (this == m_next),1,0,1
"pop(env), TCls",1,0,1
prop != nullptr,1,0,1
data_size == sizeof(void*),1,0,1
it != entry()->end() && it->is(DefSP),1,0,1
nbytes,1,0,1
uintptr_t(s->data()) % 8 == 0,1,0,1
"Resumable::arOff() == 0, ""ActRec must be in the beginning of Resumable""",1,0,1
"tl_miter_table.ents_size == 7, """"",1,0,1
!data->cowCheck() || data->noCopyOnWrite(),1,0,1
checkCount() || count == 0 ,1,0,1
" sizeof(unique_ptr<int>) == sizeof(std::unique_ptr<int>), ""req::unique_ptr pointer should not be larger than std::unique_ptr"" ",1,0,1
m_arrTypes[i]->id() == i,1,0,1
m_size < m_capacity,1,0,1
"keyType != KeyType::Any, ""KeyType::Any is not supported in arraySetMImpl""",1,0,1
"0, ""a non-std::exception was thrown in eval_cell""",1,0,1
waitHandle->getVMClass() == c_AsyncFunctionWaitHandle::classof(),1,0,1
"sizeof(XO_format) == sizeof(uint32_t), ""XO_form_t size != 4""",1,0,1
isSingletonKind() || m_unref_root_count++ == 0,1,0,1
req != nullptr,1,0,1
name.get()->isStatic(),1,0,1
!m_cache && m_node->_private == this,1,0,1
tag() == Tag::PackedN,1,0,1
!isRefcountedType(m_top->m_type),1,0,1
"sizeof(ReqInfo) == 0x30, ""rsp adjustments in handleSRHelper""",1,0,1
m_handle.kind() == APCKind::StaticString || m_handle.kind() == APCKind::UncountedString,1,0,1
tv.m_type != KindOfRef,1,0,1
"!(kNotConstantValueTypeMask & (KindOfNull|KindOfBoolean|KindOfInt64|KindOfDouble| KindOfPersistentString|KindOfString)), ""DataType & kNotConstantValueTypeMask must be zero for "" ""null, bool, int, double and string types""",1,0,1
"MixedArray::SmallSize == 3, """"",1,0,1
"sizeof(Impl) == sizeof(CompactSizedPtr<T>), ""Keeping this thing small is most of the point""",1,0,1
dt == KindOfUninit || dt == KindOfBoolean || dt == KindOfInt64 || dt == KindOfDouble || dt == KindOfString || dt == KindOfArray || dt == KindOfObject || dt == KindOfResource,1,0,1
count != 0,1,0,1
"offsetof(ptr, m_px) == kExpectedMPxOffset, """"",1,0,1
(DType == tv->m_type) || (isStringType(DType) && isStringType(tv->m_type)) || (isArrayType(DType) && isArrayType(tv->m_type)),1,0,1
numStaticProperties() > index,1,0,1
transId < preds.size(),1,0,1
m_hash == 0,1,0,1
observer != nullptr,1,0,1
"ret == TGen, ""volatile local was not TGen""",1,0,1
reinterpret_cast<intptr_t>(s) < 0,1,0,1
CACHE_LINE_SIZE >= sizeof(uintptr_t),1,0,1
codeBlock.canEmit(sizeof(instruction)),1,0,1
m_actRec.func()->contains(m_resumeOffset),1,0,1
"MixedArray::SmallHashSize >= 4, ""lower limit for 0.75 load factor""",1,0,1
is_ephemeral(sr) || sr == REQ_RETRANSLATE,1,0,1
"!(KindOfDouble & KindOfArrayBit), """"",1,0,1
metatype == AnnotMetaType::Precise,1,0,1
m_handle.kind() == APCKind::StaticArray || m_handle.kind() == APCKind::UncountedArray,1,0,1
static_cast<uint16_t>(imm << 12) == 0,1,0,1
"sizeof(D_format) == sizeof(uint32_t), ""D_form_t size != 4""",1,0,1
it != keyToStr.end(),1,0,1
line != -1,1,0,1
!tmp || tmp->isA(type),1,0,1
"sizeof(EVS_format) == sizeof(uint32_t), ""EVS_form_t size != 4""",1,0,1
size % 16 == 0,1,0,1
zval_ptr != &EG(uninitialized_zval),1,0,1
m_func == nullptr,1,0,1
" offsetof(IndirectFixup, magic) == offsetof(FixupEntry, firstElem), ""Differentiates between Fixup and IndirectFixup by looking at magic."" ",1,0,1
dt != KindOfRef && dt != KindOfClass,1,0,1
"ArrayData::kVecKind == uint8_t(HeaderKind::VecArray), """"",1,0,1
isSF() || n == 0xff,1,0,1
"!(KindOfBoolean & KindOfArrayBit), """"",1,0,1
!vmpc(),1,0,1
" sizeof...(kvpairs) % 2 == 0, ""make_map_array needs key value pairs""",1,0,1
"(kNotConstantValueTypeMask & KindOfPersistentArray) != 0 && (kNotConstantValueTypeMask & KindOfArray) != 0 && (kNotConstantValueTypeMask & KindOfObject) != 0 && (kNotConstantValueTypeMask & KindOfResource) != 0 && (kNotConstantValueTypeMask & KindOfRef) != 0, ""DataType & kNotConstantValueTypeMask must be non-zero for "" ""Array, Object and Ref types""",1,0,1
type.isKnownDataType(),1,0,1
is_low(px),1,0,1
id < transCounters.size(),1,0,1
m_value.outerType == KindOfString || m_value.innerType == KindOfString || m_value.outerType == KindOfClass || m_value.innerType == KindOfClass || m_value.outerType == KindOfObject || m_value.innerType == KindOfObject || m_value.klass == NULL,1,0,1
isSwitch(op),1,0,1
op == Op::SSwitch,1,0,1
!env.state.stack.empty(),1,0,1
isRefCounted(),1,0,1
*this <= TPtrToGen,1,0,1
nep.first->data()[nep.first->size()] == 0,1,0,1
funcAddr.get() == nullptr || funcAddr.get() == func,1,0,1
"!(KindOfResource & KindOfUncountedInitBit), """"",1,0,1
v1.first,1,0,1
"offsetof(APCCollection, m_handle) == 0, """"",1,0,1
env.vcold,1,0,1
m_kind == Kind::TypeImm,1,0,1
c_IntlDatePatternGenerator,1,0,1
"initVal >= counter, ""transCounter({}) = {}, initVal = {}\n"", id, counter, initVal",1,0,1
"sizeof(MD_format) == sizeof(uint32_t), ""MD_form_t size != 4""",1,0,1
literals_.empty() || (cb_.frontier() < (literals_.back()->pc_ + kMaxLoadLiteralRange)),1,0,1
" std::is_integral<T>::value && std::is_unsigned<T>::value, ""dataflow_worklist requires an unsigned integer type"" ",1,0,1
"sizeof(XX2_format) == sizeof(uint32_t), ""XX2_form_t size != 4""",1,0,1
"SORTFUNC_SORT > 0, """"",1,0,1
h->kind() == HeaderKind::Resource || isObjectKind(h->kind()),1,0,1
(key & 0x7FFFFFFF) == key64,1,0,1
fp->func()->isAsyncGenerator(),1,0,1
"(kNotConstantValueTypeMask & KindOfArray) != 0 && (kNotConstantValueTypeMask & KindOfObject) != 0 && (kNotConstantValueTypeMask & KindOfRef) != 0, ""DataType & kNotConstantValueTypeMask must be non-zero for "" ""Array, Object and Ref types""",1,0,1
c_IntlCalendar,1,0,1
"false && ""corrupt header in worklist""",1,0,1
isSIMD() || n == 0xff,1,0,1
mayUseVV || !(func->attrs() & AttrMayUseVV),1,0,1
sz::dword,1,0,1
"sizeof(Z23_format) == sizeof(uint32_t), ""Z23_form_t size != 4""",1,0,1
size <= kMaxSmallSize,1,0,1
offset >= 0 && offset < size(),1,0,1
"false && ""forEachHeader skips these kinds""",1,0,1
"pop(env), TBoxedInitCell",1,0,1
type == KindOfString || type == KindOfArray || type == KindOfObject || type == KindOfResource || type == KindOfRef,1,0,1
m_frontier >= m_base,1,0,1
cb_.frontier() >= addr,1,0,1
m_method,1,0,1
"is_aligned(cb.frontier(), AImpl::s_table[idx])",1,0,1
header(h),1,0,1
"Op_count <= 0x1fe, ""Op encoding scheme doesn't support Ops >= 0x1fe""",1,0,1
"sizeof(DQ_format) == sizeof(uint32_t), ""DQ_form_t size != 4""",1,0,1
m_pos == 0,1,0,1
"sizeof(XFX_format) == sizeof(uint32_t), ""XFX_form_t size != 4""",1,0,1
CACHE_LINE_SIZE >= sizeof(pid_t),1,0,1
"sizeof...(vals), ""use Array::CreateVec() instead""",1,0,1
m_data.parr->checkCount(),1,0,1
"!(KindOfInt64 & KindOfArrayBit), """"",1,0,1
nmemb_read == size,1,0,1
"ArrayData::kProxyKind == uint8_t(HeaderKind::Proxy), """"",1,0,1
"sizeof(T) <= sizeof(ret), ""Constant data was larger than supported""",1,0,1
m_size == -1,1,0,1
old_context != nullptr,1,0,1
low <= high && type < NUM_EVENT_TYPES,1,0,1
m_value.outerType == KindOfString || m_value.innerType == KindOfString || m_value.outerType == KindOfClass || m_value.innerType == KindOfClass || m_value.outerType == KindOfObject || m_value.innerType == KindOfObject || m_value.outerType == KindOfBoolean || m_value.klass == NULL,1,0,1
byte < 0xff,1,0,1
"false && ""unexpected guard on specialized Resource""",1,0,1
my_pid == *master_pid,1,0,1
cursor <= reinterpret_cast<TypedValue*>(ar),1,0,1
hasClassName(),1,0,1
"pop(env, tc), TCell",1,0,1
empty_file,1,0,1
"(kVmMInstrStateOff % 16) == 0, ""MInstrState should be 16-byte aligned in rds::Header""",1,0,1
sprop != nullptr,1,0,1
"std::is_unsigned<Handle>::value, ""Handle is supposed to be unsigned""",1,0,1
hasVar(name),1,0,1
m_bound,1,0,1
"SORTFUNC_ARSORT == SORTFUNC_ASORT + 1, """"",1,0,1
"SORTFUNC_USORT < 0, """"",1,0,1
uintptr_t(data()) % 8 == 0,1,0,1
cb_.canEmit(sizeof(instruction)),1,0,1
size > 0 && size <= kMaxFreeSize,1,0,1
"false, ""address {} was not part of any known code block"", addr",1,0,1
propType == NotStatic || property->isStatic(),1,0,1
c_IntlDateFormatter,1,0,1
"KindOfUninit == 0, ""Several things assume this tag is 0, especially RDS""",1,0,1
checkInvariants(ad),1,0,1
checkInvariants() && m_handle.kind() == APCKind::Bool,1,0,1
"sizeof(MixedArray) + MixedArray::SmallSize * sizeof(MixedArray::Elm) == 104, """"",1,0,1
"kNumSmallSizes <= (1 << 6), ""only 6 bits available in HeaderWord""",1,0,1
handle && size > 0,1,0,1
"sizeof(TransFlags) <= sizeof(uint64_t), ""Too many TransFlags!""",1,0,1
isNull() || isString(),1,0,1
getRealCount() != 0,1,0,1
"KindOfPersistentString & KindOfUncountedInitBit, """"",1,0,1
type < TArr && type.arrSpec() && type.arrSpec().kind(),1,0,1
cb_.canEmit(size),1,0,1
"sizeof(I_format) == sizeof(uint32_t), ""I_form_t size != 4""",1,0,1
rs.code() != kSPRegInternalCode,1,0,1
"MixedArray::Empty == -1, """"",1,0,1
"sizeof(Z22_format) == sizeof(uint32_t), ""Z22_form_t size != 4""",1,0,1
name.isString() || name.isInteger(),1,0,1
isNullType(type),1,0,1
folly::isPowTwo(tab->capac),1,0,1
destId < nTranslations,1,0,1
srcId < nTranslations,1,0,1
savedKind == m_kind,1,0,1
m_hdr.kind == static_cast<HeaderKind>(kind),1,0,1
m_tag == LTag::Local,1,0,1
!define,1,0,1
m_base <= addr && addr <= (m_base + m_size),1,0,1
cursor <= base,1,0,1
" XSD_STRING > kMaxDataType, ""Overlap between SOAP types and DataTypes"" ",1,0,1
p->doc == (xmlDocPtr)p,1,0,1
m <= M && e <= MaxExp,1,0,1
"sizeof(VX_format) == sizeof(uint32_t), ""VX_form_t size != 4""",1,0,1
ret == propVec(),1,0,1
cellIsPlausible(*m_top),1,0,1
!shared()->m_preClass,1,0,1
isRefData(),1,0,1
__file,1,0,1
m_frontier <= m_base + m_size,1,0,1
c_IntlCodePointBreakIterator,1,0,1
m_size == 0 || m_used != 0,1,0,1
"offsetof(ArrayData, m_hdr) == HeaderOffset, """"",1,0,1
id < m_unit->numIds(nullKey),1,0,1
m_fatal_error_msg != nullptr,1,0,1
0 == fp->m_func->numLocals(),1,0,1
fpcr().RMode() == FPTieEven,1,0,1
id < m_arrays.size(),1,0,1
idx < env.state.stack.size(),1,0,1
hasIntKey(),1,0,1
"shm_dir, minimum_avail",1,0,1
isRefcountedType(m_type) ? varNrFlag() == NR_FLAG : true,1,0,1
"kVmspOff == 16, ""Eager vm-reg save in translator-asm-helpers.S""",1,0,1
"is_malloc_size_class<value>::value, ""Bug in malloc-size-class.h""",1,0,1
regs.pc == pc,1,0,1
cls.find(cnsName) == cls.end(),1,0,1
static_cast<uint16_t>(imm << 14) == 0,1,0,1
id < translations.size(),1,0,1
i >= B - 1,1,0,1
key1 && key2,1,0,1
isMixed(m_kind),1,0,1
"SORTFUNC_UASORT < 0, """"",1,0,1
"sizeof(XL_form) == sizeof(uint32_t), ""XL_form size != 4""",1,0,1
cns != nullptr,1,0,1
fwd < back,1,0,1
"KindOfPersistentArray & KindOfArrayBit, """"",1,0,1
uintptr_t(this) - s_stackLimit >= s_stackSize,1,0,1
"kMaxSmallSize < kSlabSize, ""fix kNumSmallSizes or kLgSlabSize""",1,0,1
pos == Empty,1,0,1
"Type::Bits::kBottom == 0, ""Assuming TBottom is 0""",1,0,1
type.arrSpec().type() == nullptr,1,0,1
(!destroy || tvIsPlausible(*this)) && tvIsPlausible(v),1,0,1
!v.empty(),1,0,1
"!(KindOfObject & KindOfArrayBit), """"",1,0,1
zRefcount() == val,1,0,1
m_tag == LTag::Stack,1,0,1
regN != noreg,1,0,1
c_Transliterator,1,0,1
storage != nullptr,1,0,1
"topT(env, i).subtypeOf(TInitCell)",1,0,1
m_state.vmain,1,0,1
"ArrayData::kStructKind == uint8_t(HeaderKind::Struct), """"",1,0,1
key < 0x80000000 && val < 0x80000000,1,0,1
"!(KindOfUninit & KindOfArrayBit), """"",1,0,1
" std::is_integral<T>::value && std::is_unsigned<T>::value, ""sparse_id_set is intended for use with unsigned integer types"" ",1,0,1
*this <= TCell,1,0,1
isGP() || n == 0xff,1,0,1
nArgs >= 0,1,0,1
*this <= (TGen | TPtrToGen),1,0,1
"sizeof(M_format) == sizeof(uint32_t), ""M_form_t size != 4""",1,0,1
key < m_universe_size,1,0,1
id < m_transRecs.size(),1,0,1
"!""deserialized invalid RepoAuthType::Array tag""",1,0,1
"sizeof(RingBufferEntry) == 32, ""RingBufferEntry expected to be 32 bytes""",1,0,1
"offsetof(MixedArray, m_nextKI) + 8 == sizeof(MixedArray), ""Revisit this if MixedArray layout changes""",1,0,1
imm.fits(sz::dword),1,0,1
m_prop == nullptr,1,0,1
m_op == Op::JmpZ || m_op == Op::JmpNZ,1,0,1
zIsRef() == isRef,1,0,1
isSingletonKind() || m_unref_root_count == 1,1,0,1
!tvDecRefWillCallHelper(tv),1,0,1
!(static_cast<intptr_t>(kind) & kParentMask),1,0,1
m_frontier < m_base + m_size,1,0,1
fp->resumed(),1,0,1
" kMaxSmallSize <= std::numeric_limits<uint32_t>::max(), ""Size-specified small block alloc functions assume this"" ",1,0,1
m_data.pres->checkCount(),1,0,1
"!size() && ""IndexedStringMap::create called more than once""",1,0,1
iterValid(),1,0,1
"(nbytes % 4 == 0) && ""This arch supports only 4 bytes alignment""",1,0,1
cls->classof(c_Pair::classof()),1,0,1
dummy_meta.empty(),1,0,1
"topT(env, i).subtypeOf(TRef)",1,0,1
reinterpret_cast<const uintptr_t>(mem1) % W == 0,1,0,1
"kVmfpOff == 32, ""Eager vm-reg save in translator-asm-helpers.S""",1,0,1
!object || object->checkCount(),1,0,1
rawVal < 0xff,1,0,1
"current == TGen, ""volatile local was not TGen""",1,0,1
"!(KindOfResource & KindOfArrayBit), """"",1,0,1
"profCount <= profCountCap, ""Trying to create IR block with suspicious profCount {}\n"", profCount",1,0,1
len >=16 && len % 16 == 0,1,0,1
"offsetof(c_Pair, m_size) == collections::FAST_SIZE_OFFSET, """"",1,0,1
!m_table,1,0,1
v1.second,1,0,1
"kMaxSmallSize > kSmallSizeAlign * 2, ""Too few size classes""",1,0,1
"IMPLIES(at == AnnotType::Object, annotClsName != nullptr)",1,0,1
!(cls->attrs() & AttrInterface),1,0,1
" sizeof(T) >= sizeof(uint64_t), ""TlsPodBag expects at least 8 bytes per entry"" ",1,0,1
"sizeof(XX1_format) == sizeof(uint32_t), ""XX1_form_t size != 4""",1,0,1
!singleton() || singleton() == (T*)&s_storage,1,0,1
m_kind == Kind::Imm || m_kind == Kind::DataPtr,1,0,1
obj->instanceof(T::classof()),1,0,1
id / kCountersPerChunk < m_chunks.size(),1,0,1
handle && size > 0 && oldHandle && oldSize > 0,1,0,1
!(type < TBoxedInitCell),1,0,1
v2.second,1,0,1
"sizeof(SC_format) == sizeof(uint32_t), ""SC_form_t size != 4""",1,0,1
"top(env, i), TBoxedCell",1,0,1
m_sPropCacheInit.bound(),1,0,1
"t == TGen, ""volatile local was not TGen""",1,0,1
T::instanceof(obj),1,0,1
v && !v->isRefCounted(),1,0,1
m_data.pobj->checkCount(),1,0,1
"sizeof(Elm) == 24, """"",1,0,1
unsigned(hdr_.kind) <= NumHeaderKinds,1,0,1
"sizeof(DS_format) == sizeof(uint32_t), ""DS_form_t size != 4""",1,0,1
"!detail::IsVoid<T>::value, ""Trying to enqueue void pointer(s). "" ""Please provide a more specific type.""",1,0,1
size <= dep_size,1,0,1
func->hasVariadicCaptureParam(),1,0,1
type.clsSpec().exact() || type.clsSpec().cls()->attrs() & AttrNoOverride,1,0,1
global_storage[0] == 0,1,0,1
"static_cast<uint64_t>(OpLowInvalid) == 0, ""stats.h assumes OpLowInvalid == 0""",1,0,1
fpcr().FZ() == 0,1,0,1
