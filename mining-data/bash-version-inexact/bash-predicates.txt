ASSERT(current->domain==IDLE_DOMAIN_ID);
ASSERT(!__task_on_runqueue(p));
ASSERT(p->state==TASK_DYING);
ASSERT(!p->has_cpu);
ASSERT(__task_on_runqueue(prev));
ASSERT(page_type_count(page)!=0);
ASSERT(page_nr<max_page);
ASSERT((page->flags&PG_domain_mask)==current->domain);
ASSERT((((page->flags&PG_type_mask)==PGT_writeable_page)&&(page_type_count(page)!=0))||(((page->flags&PG_type_mask)==PGT_none)&&(page_type_count(page)==0)));
ASSERT((!writeable)||(page_type_count(page)!=0));
ASSERT((!writeable)||((page_type_count(page)!=0)&&((page->flags&PG_type_mask)==PGT_writeable_page)));
ASSERT(DOMAIN_OKAY(page->flags));
ASSERT(skb->skb_type==SKB_ZERO_COPY);
ASSERT((skb->data-skb->head)==(18+ETH_HLEN));
ASSERT((ranfor>0));
ASSERT(!list_empty(&schedule_data[smp_processor_id()].runqueue));
ASSERT(next!=NULL);
ASSERT(r_time!=0);
ASSERT(r_time>0);
ASSERT(!list_empty(&schedule_data[this_cpu].runqueue));
ASSERT(next_prime->evt>next->evt);
ASSERT(r_time>ctx_allow);
ASSERT(r_time>=ctx_allow);
ASSERT(next_prime->evt>=next->evt);
ASSERT(timer!=NULL);
ASSERT(!active_ac_timer(timer));
ASSERT(timer->timer_list.next);
ASSERT(t->cpu==cpu);
ASSERT(skb->len<=PAGE_SIZE);
ASSERT((page->flags&PG_type_mask)==PGT_gdt_page);
ASSERT((page->type_count!=0)&&(page->tot_count!=0));
ASSERT((page->flags&PG_type_mask)==PGT_ldt_page);
ASSERT(free_pfns!=0);
ASSERT(ent->next->prev==ent);
ASSERT(ent->prev->next==ent);
ASSERT(!__on_blkdev_list(p));
ASSERT(entry->next->prev==entry);
ASSERT(entry->prev->next==entry);
ASSERT(__on_net_schedule_list(vif));
ASSERT(rx->status==RING_STATUS_OK);
ASSERT(tx->status==RING_STATUS_OK);
ASSERT((page->flags&PG_domain_mask)==p->domain);
ASSERT((page_type_count(page)&~REFCNT_PIN_BIT)!=0);
ASSERT(rp!=NULL);
ASSERT(rid<rp->max_event_channel);
ASSERT(rchn[rid].flags==(ECF_INUSE|ECF_CONNECTED|lid));
ASSERT(rchn[rid].target_dom==lp->domain);
ASSERT((page_type_count(page)!=0)&&(page_tot_count(page)!=0));
ASSERT(p->state!=TASK_DYING);
ASSERT(prev->state!=TASK_UNINTERRUPTIBLE);
ASSERT(l1_pgentry_val(l1e)&_PAGE_PRESENT);
ASSERT(l2_pgentry_val(l2e)&_PAGE_PRESENT);
ASSERT((!writeable)||((page_type_count(page)!=0)&&((page->flags&PG_type_mask)==PGT_writeable_page)&&((page->flags&PG_need_flush)==PG_need_flush)));
ASSERT(((_p)->type_and_flags&PGT_type_mask)==(_t));
ASSERT(((_p)->type_and_flags&PGT_count_mask)!=0);
ASSERT(((_p)->count_and_flags&PGC_count_mask)!=0);
ASSERT((_p)->u.domain==(_d));
ASSERT(nr_psegs<=MAX_BLK_SEGS*2);
ASSERT(!list_empty(&schedule_data[cpu].runqueue));
ASSERT((_p&PAGE_MASK)!=0);
ASSERT((_l&PAGE_MASK)!=0);
ASSERT((_p&~PAGE_MASK)==0);
ASSERT((_l&~PAGE_MASK)==0);
ASSERT(memguard_is_guarded(ch));
ASSERT(memguard_is_guarded(ct));
ASSERT(((void*)ch->pprev<(void*)&_end)||memguard_is_guarded(ch->pprev));
ASSERT(((void*)ch->next<(void*)&_end)||memguard_is_guarded(ch->next));
ASSERT(inf!=NULL);
ASSERT(p!=NULL);
ASSERT(p->sched_priv!=NULL);
ASSERT(prev->sched_priv!=NULL);
ASSERT(prev_inf!=NULL);
ASSERT(next_prime_inf->evt>=next_inf->evt);
ASSERT(current->domain!=IDLE_DOMAIN_ID);
ASSERT(prev!=NULL);
ASSERT(next->processor==current->processor);
ASSERT(spfn_info);
ASSERT(live<9999);
ASSERT(gpfn);
ASSERT(s);
ASSERT(B->next==0);
ASSERT(sdom->domain!=IDLE_DOMAIN_ID);
ASSERT(cur_sdom!=NULL);
ASSERT((a->pfn&0xf0000000)==0);
ASSERT(a->pfn<0x00100000);
ASSERT(a->pfn);
ASSERT((a->pfn&0xf0000000)==0);
ASSERT(a->pfn<0x00100000);
ASSERT(a->spfn_and_flags&PSH_pfn_mask);
ASSERT(!allocated_in_map(first_page+i));
ASSERT(allocated_in_map(first_page+i));
ASSERT(m->shadow_dirty_bitmap);
ASSERT(local_irq_is_enabled());
ASSERT(nr_psegs<=BLKIF_MAX_SEGMENTS_PER_REQUEST*2);
ASSERT(__on_net_schedule_list(netif));
ASSERT(nr_psegs<=(BLKIF_MAX_SEGMENTS_PER_REQUEST+1));
ASSERT(!in_irq());
ASSERT((p!=NULL)||!in_irq());
ASSERT((p==NULL)||!in_irq());
ASSERT(spin_is_locked(&p->mm.shadow_lock));
ASSERT(spin_is_locked(&current->mm.shadow_lock));
ASSERT(spin_is_locked(&m->shadow_lock));
ASSERT(B->next==0);
ASSERT(local_irq_is_enabled());
ASSERT(__task_on_runqueue(d));
ASSERT(!d->has_cpu);
ASSERT(spin_is_locked(&d->mm.shadow_lock));
ASSERT(d!=current);
ASSERT(spin_is_locked(lock));
ASSERT(skb->dev==dev);
ASSERT((sizeof(structpfn_info)<<20)>(FRAMETABLE_VIRT_END-FRAMETABLE_VIRT_START));
ASSERT(inf->time_slept+CPU_SVT(p->processor)>inf->avt+io_warp);
ASSERT(prev_inf->time_slept>=mcus*prev_inf->mcu_advance);
ASSERT(prev_inf->time_slept>=prev_inf->vtb);
ASSERT(prev_inf->time_slept>=LAST_VTB(cpu));
ASSERT(LAST_VTB(cpu)>=0);
ASSERT(prev_inf->time_slept>=mcus*prev_inf->mcu_advance);
ASSERT(inf->time_slept+CPU_SVT(cpu)>inf->avt+io_warp);
ASSERT(!list_empty(RUNQUEUE(cpu)));
ASSERT(((_p)->u.inuse.type_info&PGT_type_mask)==(_t));
ASSERT(((_p)->u.inuse.type_info&PGT_count_mask)!=0);
ASSERT(((_p)->u.inuse.count_info&PGC_count_mask)!=0);
ASSERT((_p)->u.inuse.domain==(_d));
ASSERT((sizeof(structpfn_info)<<20)>
ASSERT((sizeof(structpfn_info)<<20)<=(FRAMETABLE_VIRT_END-FRAMETABLE_VIRT_START));
ASSERT(__task_on_runqueue(RUNLIST(prev)));
ASSERT(nr_iovecs==1);
ASSERT(insn_len>=PATCH_LEN);
ASSERT(!(atomic_read(&d->refcnt)&DOMAIN_DESTRUCTED));
ASSERT(test_bit(_PGC_always_set,&page->count_info));
ASSERT((_pfn)->u.inuse.count_info==PGC_always_set);
ASSERT((_pfn)->count_info==PGC_always_set);
ASSERT(((_p)->count_info&PGC_count_mask)!=0);
ASSERT(e->tot_pages<=e->max_pages);
ASSERT(d->grant_table!=NULL);
ASSERT(crit_count[cpu]>=0);
ASSERT(crit_count[cpu]==0);
ASSERT(1);
ASSERT(crit_checking_disabled[cpu]>=0);
ASSERT(flags==(GTF_accept_transfer|GTF_transfer_committed));
ASSERT((x&PGT_count_mask)!=0);
ASSERT(x&PGT_validated);
ASSERT(((page->u.inuse.type_info&PGT_va_mask)>>
PGT_va_shift)<(PAGE_OFFSET>>L2_PAGETABLE_SHIFT));
ASSERT((pg[i].u.inuse.type_info&PGT_count_mask)==0);
ASSERT((x&PGT_validated)||test_bit(DF_DYING,&page->u.inuse.domain->flags));
ASSERT(d!=NULL);
ASSERT(d->sched_priv!=NULL);
ASSERT(!local_irq_is_enabled());
ASSERT((_pfn)->count_info==0);
ASSERT(m->shadow_extras_count==0);
ASSERT(m->shadow_dirty_bitmap!=NULL);
ASSERT(gpte&_PAGE_RW);
ASSERT(a->pfn<0x00100000UL);
ASSERT(x->pfn||((x==head)&&(x->next==NULL)));
ASSERT(m->shadow_mode);
ASSERT(gpfn!=0);
ASSERT(s&PSH_shadowed);
ASSERT(head->next==NULL);
ASSERT(current->id==IDLE_DOMAIN_ID);
ASSERT(sdom->id!=IDLE_DOMAIN_ID);
ASSERT(current->id!=IDLE_DOMAIN_ID);
ASSERT(((tlbflush_clock+1)&TLBCLOCK_EPOCH_MASK)==0);
ASSERT(tlbflush_clock==0);
ASSERT(pending!=0);
ASSERT(prev->ed_sched_priv!=NULL);
ASSERT(prev_einf!=NULL);
ASSERT(ed!=current);
ASSERT(d->exec_domain[vcpu]==NULL);
ASSERT(key_table[key].u.handler==NULL);
ASSERT(key_table[key].u.irq_handler==NULL);
ASSERT(current->domain->id==IDLE_DOMAIN_ID);
ASSERT(current->domain->id!=IDLE_DOMAIN_ID);
ASSERT(next_prime_einf->evt>=next_einf->evt);
ASSERT(active_cons!=active_prod);
ASSERT(ridblock_owner[i]==d);
ASSERT(mpfn_info);
ASSERT(value);
ASSERT(mpl2e[PERDOMAIN_VIRT_START>>L2_PAGETABLE_SHIFT]);
ASSERT(d->sched_priv!=NULL);
ASSERT(zone<NR_ZONES);
ASSERT(order<=MAX_ORDER);
ASSERT(purb->actual_length<=purb->transfer_buffer_length);
ASSERT(purb->actual_length<=pending_req->nr_pages*PAGE_SIZE);
ASSERT(sched==pending_req->sched);
ASSERT(sched[i].buffer_offset==purb->iso_frame_desc[i].offset);
ASSERT((req->length>>PAGE_SHIFT)<=MMAP_PAGES_PER_REQUEST);
ASSERT(buffer_mach);
ASSERT(virt_to_machine(MMAP_VADDR(pending_idx,i));==buffer_mach+i<<PAGE_SHIFT);
ASSERT(i<=MMAP_PAGES_PER_REQUEST);
ASSERT(i*PAGE_SIZE>=req->length);
ASSERT(sched[i].buffer_offset==purb->iso_frame_desc[i].offset);==buffer_mach+i<<PAGE_SHIFT);
ASSERT(m->monitor_table);
ASSERT(ed->thread.arch_vmx.vmcs);
ASSERT((inf->latency<ULONG_MAX)&&(inf->slice_orig<ULONG_MAX));
ASSERT((WEIGHT_PERIOD<ULONG_MAX)&&(DOM_INFO(p)->slice_orig<ULONG_MAX));
ASSERT(page_get_owner(_p)==(_d));
ASSERT(pagetable_val(m->monitor_table));
ASSERT(pagetable_val(ed->arch.monitor_table));
ASSERT(ed->arch.arch_vmx.vmcs);
ASSERT(d->arch.shadow_extras_count==0);
ASSERT(spin_is_locked(&d->arch.shadow_lock));
ASSERT(d->arch.shadow_dirty_bitmap!=NULL);
ASSERT(d->arch.shadow_mode);
ASSERT(a->smfn_and_flags&PSH_pfn_mask);
ASSERT(shadow_mode(d));
ASSERT((x&PGT_validated)||test_bit(DF_DYING,&page_get_owner(page)->d_flags));
ASSERT(pending_list[idx].count==0);
ASSERT(!local_irq_is_enabled());
ASSERT(!local_irq_is_enabled());
ASSERT(sercon_buffer);
ASSERT(!ed->arch.monitor_table);
ASSERT(!pagetable_val(ed->arch.monitor_table));
ASSERT(shadow_mode_enabled(d));
ASSERT(debugtrace_buf!=NULL);
ASSERT((inf->period<ULONG_MAX)&&(inf->slice_orig<ULONG_MAX));
ASSERT((inf->period<ULONG_MAX)&&(inf->slice_orig<ULONG_MAX));
ASSERT(shadow_mode_enabled(ed->domain));
ASSERT(mmfn_info);
ASSERT(!a->next);
ASSERT((a->pfn&~PSH_hl2)<0x00100000UL);
ASSERT(s&(PSH_shadowed|PSH_hl2));
ASSERT(flush_count++==0);
ASSERT(d->grant_table->active!=NULL);
ASSERT(d->grant_table->shared!=NULL);
ASSERT(d->grant_table->maptrack!=NULL);
ASSERT(shadow_mode_translate(rd));
ASSERT(debugtrace_buf[debugtrace_bytes-1]==0);
ASSERT(shadow_enabled);
ASSERT(!page_out_of_sync(page));
ASSERT(!shadow_mode_enabled(d));
ASSERT(!shadow_mode_external(d));
ASSERT(!shadow_mode_enabled(ed->domain));
ASSERT(frame_table[gmfn].count_info&PGC_page_table);
ASSERT((gmfn&~PGT_mfn_mask)==0);
ASSERT(!IS_INVALID_M2P_ENTRY(gpfn));
ASSERT(shadow_mode_external(ed->domain));
ASSERT(l2_pgentry_val(hl2e)&_PAGE_PRESENT);
ASSERT(mfn);
ASSERT(d->arch.out_of_sync_extras_count==0);
ASSERT(PGT_base_page_table==PGT_l2_page_table);
ASSERT(pagetable_val(current->arch.guest_table)==(gmfn<<PAGE_SHIFT));
ASSERT(gl2e&_PAGE_PRESENT);
ASSERT(!(old_sl2e&_PAGE_PRESENT));
ASSERT(__shadow_status(d,gpfn,PGT_snapshot));
ASSERT(pfn_is_ram(mfn));
ASSERT(sl2e&_PAGE_PRESENT);
ASSERT(!(entry->writable_pl1e&(sizeof(l1_pgentry_t)-1)));
ASSERT(gmfn);
ASSERT(max_mode);
ASSERT(shadow_mode_translate(d));
ASSERT(ptbase_mfn);
ASSERT((void*)MAPCACHE_VIRT_START<=va);
ASSERT(va<(void*)MAPCACHE_VIRT_END);
ASSERT(d->arch.out_of_sync==NULL);
ASSERT(pfn_is_ram(smfn));
ASSERT(!(frame_table[smfn].u.inuse.type_info&PGT_pinned));
ASSERT(a->smfn);
ASSERT(gpfn==(gpfn&PGT_mfn_mask));
ASSERT(stype&&!(stype&~PGT_type_mask));
ASSERT(x->gpfn_and_flags||((x==head)&&(x->next==NULL)));
ASSERT(gpfn&&!(gpfn&~PGT_mfn_mask));
ASSERT(pfn_is_ram(gmfn));
ASSERT(smfn&&!(smfn&~PGT_mfn_mask));
ASSERT(gpde&_PAGE_PRESENT);
ASSERT(shadow_mode_translate(current->domain));
ASSERT(___shadow_status(d,gpfn,stype)==0);
ASSERT((page->u.inuse.type_info&PGT_type_mask)==PGT_writable_page);
ASSERT(entry->writable_pl1e==-1);
ASSERT(pfn!=INVALID_M2P_ENTRY);
ASSERT(pfn<(1u<<20));
ASSERT(new_modes);
ASSERT(!(d->arch.shadow_mode&~mode));
ASSERT(!d->arch.shadow_ht);
ASSERT(!d->arch.shadow_dirty_bitmap);
ASSERT(!pagetable_val(d->arch.phys_table));
ASSERT(d==page_get_owner(&frame_table[mfn]));
ASSERT((l1_pgentry_val(p2m[gpfn])>>PAGE_SHIFT)==mfn);
ASSERT(shadow_mode_translate(d)&&!shadow_mode_external(d));
ASSERT(root_pgentry_val(idle_pg_table[1])==0);
ASSERT(pagetable_val(d->arch.phys_table));
ASSERT(current->domain==IDLE_DOMAIN_ID);
ASSERT(phystab);
ASSERT(d==page_get_owner(&frame_table[pagetable_val(d->arch.phys_table)>>PAGE_SHIFT]));
ASSERT(shadow_mode_translate(d)||gpfn);
ASSERT(!(gpfn&~PGT_mfn_mask));
ASSERT(score);
ASSERT(VALID_MFN(readonly_gmfn));
ASSERT(VALID_MFN(gmfn));
ASSERT(page_get_owner(&frame_table[ed->arch.monitor_shadow_ref])==NULL);
ASSERT(shadow_mode_translate(ed->domain));
ASSERT(d->arch.iobmp_mask);
ASSERT((psh_type==PGT_snapshot)||!mfn_out_of_sync(gmfn));
ASSERT(pagetable_val(ed->arch.monitor_table)==0);
ASSERT(mmfn_info!=NULL);
ASSERT((inf->period<ULONG_MAX);
&&(inf->slice_orig<ULONG_MAX));
ASSERT((inf->period<ULONG_MAX);
&&(inf->slice_orig<ULONG_MAX));
&&(inf->slice_orig<ULONG_MAX));
ASSERT((WEIGHT_PERIOD<ULONG_MAX);
&&(DOM_INFO(p)->slice_orig<ULONG_MAX));
ASSERT(ref!=-ENOSPC);
ASSERT(VALID_M2P(gpfn));
ASSERT(l1_pgentry_val(nl1e)&_PAGE_PRESENT);
ASSERT((frame_table[smfn].u.inuse.type_info&PGT_pinned));
ASSERT(pfn_valid(mfn));
ASSERT(pfn_valid(smfn));
ASSERT(root_get_value(idle_pg_table[1])==0);
ASSERT(l1e_get_pfn(p2m[gpfn])==mfn);
ASSERT(l2e_get_flags(gl2e)&_PAGE_PRESENT);
ASSERT(!(l2e_get_flags(old_sl2e)&_PAGE_PRESENT));
ASSERT(l2e_get_flags(sl2e)&_PAGE_PRESENT);
ASSERT(l1e_get_flags(l1e)&_PAGE_PRESENT);
ASSERT(l1e_get_flags(gpte)&_PAGE_RW);
ASSERT(l2e_get_flags(gpde)&_PAGE_PRESENT);
ASSERT(l1e_get_pfn(p2m[gpfn])==mfn);
&&(inf->slice_orig<ULONG_MAX));
&&(inf->slice_orig<ULONG_MAX));
&&(inf->slice_orig<ULONG_MAX));
&&(DOM_INFO(p)->slice_orig<ULONG_MAX));
ASSERT(((pg[i].u.inuse.type_info&PGT_count_mask)==0)||
ASSERT(d->exec_domain[i]->ed_sched_priv!=NULL);
ASSERT(curinf->deadl_abs>now);
ASSERT(ret.time>now);
ASSERT(!page_get_owner(&frame_table[ed->arch.monitor_shadow_ref]));
ASSERT(ed->domain->id==IDLE_DOMAIN_ID);
ASSERT(extraq_on(d,i));
ASSERT(extraq_on(d,i));
ASSERT(!extraq_on(d,i));
ASSERT(__task_on_queue(d));
ASSERT(!__task_on_queue(d));
ASSERT(!__task_on_queue(d));
ASSERT(__task_on_queue(d));
ASSERT(EQ(sedf_runnable(d),__task_on_queue(d)));
ASSERT(IMPLY(extraq_on(d,EXTRA_UTIL_Q)||extraq_on(d,EXTRA_PEN_Q),
sedf_runnable(d)));
ASSERT(ret.time>0);
ASSERT(sedf_runnable(ret.task));
ASSERT(!sedf_runnable(d));
ASSERT(!extraq_on(d,EXTRA_UTIL_Q));
ASSERT(!extraq_on(d,EXTRA_PEN_Q));
ASSERT(IMPLY(inf->status&EXTRA_AWARE,extraq_on(d,EXTRA_UTIL_Q)));
ASSERT(snapshot_mfn);
ASSERT(!shadow_mode_refcounts(d));
ASSERT(d==page_get_owner(&frame_table[pagetable_get_pfn(d->arch.phys_table)]));
ASSERT(type==PGT_writable_page);
ASSERT(type&&(type<PGT_l4_page_table));
ASSERT(VM_ASSIST(d,VMASST_TYPE_writable_pagetables));
ASSERT(shadow_mode_write_all(d));
ASSERT(current->domain==(_d));
ASSERT(IMPLY(extraq_on(d,EXTRA_UTIL_Q)||extraq_on(d,EXTRA_PEN_Q),
sedf_runnable(d)));
&&(inf->slice_orig<ULONG_MAX));
&&(inf->slice_orig<ULONG_MAX));
&&(inf->slice_orig<ULONG_MAX));
&&(EDOM_INFO(p)->slice_orig<ULONG_MAX));
ASSERT(d->exec_domain[i]->sched_priv!=NULL);
ASSERT(cache!=NULL);
ASSERT(VALID_M2P(l2pfn));
ASSERT(shadow_lock_is_acquired(d));
ASSERT(!shadow_lock_is_acquired(_d));
ASSERT(shadow_lock_is_acquired(_d));
ASSERT(ed->domain->domain_id==IDLE_DOMAIN_ID);
ASSERT(VM_ASSIST(d,VMASST_TYPE_writable_pagetables)||shadow_mode_write_all(d));
ASSERT(d->arch.pmt);
ASSERT(page);
ASSERT(vm_buffer);
ASSERT(tmp_base!=__vsa_base);
ASSERT(vpd);ASSERT(hcb->ht==THASH_VHPT);ASSERT(hcb->ht==THASH_VTLB);ASSERT(hcb->hash_sz%sizeof(thash_data_t)==0);
ASSERT(mpt_order<=MAX_ORDER);
ASSERT(pending_list[idx].count==0);ASSERT(hcb->ht==THASH_VHPT);ASSERT(hcb->ht==THASH_VTLB);ASSERT(hcb->hash_sz%sizeof(thash_data_t)==0);ASSERT(hcb->ht==THASH_VHPT);ASSERT(hcb->ht==THASH_VTLB);ASSERT(hcb->hash_sz%sizeof(thash_data_t)==0);ASSERT(hcb->ht==THASH_VHPT);ASSERT(hcb->ht==THASH_VTLB);ASSERT(hcb->hash_sz%sizeof(thash_data_t)==0);
ASSERT(is_idle_task(ed->domain));
ASSERT(d->exec_domain[i]->sched_priv!=NULL);
ASSERT(IMPLY(extraq_on(d,EXTRA_UTIL_Q)||extraq_on(d,EXTRA_PEN_Q),sedf_runnable(d)));
ASSERT(IMPLY(extraq_on(d,EXTRA_UTIL_Q)||extraq_on(d,EXTRA_PEN_Q),sedf_runnable(d)));
&&(inf->slice_orig<ULONG_MAX));&&(inf->slice_orig<ULONG_MAX));
&&(inf->slice_orig<ULONG_MAX));&&(inf->slice_orig<ULONG_MAX));
&&(inf->slice_orig<ULONG_MAX));&&(inf->slice_orig<ULONG_MAX));
&&(EDOM_INFO(p)->slice_orig<ULONG_MAX));&&(EDOM_INFO(p)->slice_orig<ULONG_MAX));
ASSERT(!test_bit(ARCH_VMX_IO_WAIT,&d->arch.arch_vmx.flags));
ASSERT(offset<size);
ASSERT(pagetable_get_phys(d->arch.phys_table));
ASSERT(pagetable_get_phys(ed->arch.monitor_table)==0);
ASSERT(pagetable_get_phys(ed->arch.monitor_table));
ASSERT(!pagetable_get_phys(d->arch.phys_table));
ASSERT(pagetable_get_paddr(d->arch.phys_table));
ASSERT(pagetable_get_paddr(ed->arch.monitor_table)==0);
ASSERT(pagetable_get_paddr(ed->arch.monitor_table));
ASSERT(!pagetable_get_paddr(d->arch.phys_table));
ASSERT((pa&~(PADDR_MASK&PAGE_MASK))==0);
ASSERT(is_idle_task(v->domain));
ASSERT(!page_get_owner(&frame_table[v->arch.monitor_shadow_ref]));
ASSERT(pagetable_get_paddr(v->arch.monitor_table)==0);
ASSERT(pagetable_get_paddr(v->arch.monitor_table));
ASSERT(v!=NULL);
ASSERT(d->vcpu[i]->sched_priv!=NULL);
ASSERT(d->vcpu[vcpu]==NULL);
ASSERT(shadow_mode_enabled(v->domain));
ASSERT(shadow_mode_translate(v->domain));
ASSERT(tabpfn!=0);
ASSERT(st_scale_f||st_scale_i);
ASSERT(msg->shmem_ref!=-ENOSPC);
ASSERT(entry_get_flags(gle)&_PAGE_PRESENT);
ASSERT(l2e_get_flags(gl2e)&_PAGE_RW);
ASSERT(!pagetable_get_paddr(v->arch.monitor_table));
ASSERT(dividend<divisor);
ASSERT(spin_is_locked(&platform_timer_lock));
ASSERT((u32)tsc_elapsed64==tsc_elapsed64);
ASSERT(tsc_elapsed32!=0);
ASSERT(cpu_online(cpu));
ASSERT(d->processor>=0);
ASSERT(d->processor<NR_CPUS);
ASSERT(schedule_data[d->processor].curr);
ASSERT((l1e_get_flags(_nl1e)&L1_DISALLOW_MASK)==0);
ASSERT(spin_is_locked(&d->big_lock));
ASSERT(shmem_ref!=-ENOSPC);==buffer_mach+i<<PAGE_SHIFT);
ASSERT(virt_to_mfn(MMAP_VADDR(pending_idx,i));==((buffer_mach>>PAGE_SHIFT)+i));
ASSERT(info->grant_id!=-ENOSPC);
ASSERT(d!=dom0);==buffer_mach+i<<PAGE_SHIFT);==((buffer_mach>>PAGE_SHIFT)+i));
ASSERT(ref!=-ENOSPC);==buffer_mach+i<<PAGE_SHIFT);==((buffer_mach>>PAGE_SHIFT)+i));
ASSERT(info->ring_ref!=-ENOSPC);
ASSERT(guest_l2e_get_flags(gl2e)&_PAGE_PRESENT);
ASSERT(guest_l1e_get_flags(gpte)&_PAGE_RW);
ASSERT(ridblock_owner[i]==d);ASSERT(hcb->ht==THASH_VHPT);ASSERT(hcb->ht==THASH_VTLB);ASSERT(hcb->hash_sz%sizeof(thash_data_t)==0);ASSERT(hcb->ht==THASH_VHPT);ASSERT(hcb->ht==THASH_VTLB);ASSERT(hcb->hash_sz%sizeof(thash_data_t)==0);
ASSERT(!test_bit(ARCH_VMX_CONTIG_MEM,&v->arch.arch_vmx.flags));
ASSERT(flags&GPFN_IO_MASK);
ASSERT(skb->dev==dev);
ASSERT(sched[i].buffer_offset==purb->iso_frame_desc[i].offset);==((buffer_mach>>PAGE_SHIFT)+i));
ASSERT(pagetable_val(v->arch.monitor_table));
ASSERT(d->vcpu[vcpuid]==NULL);
ASSERT(end_xt>now);
ASSERT(!test_bit(ARCH_VMX_IO_WAIT,&v->arch.arch_vmx.flags));
ASSERT(offset<=size);
ASSERT(page==NULL);
ASSERT(vlapic!=NULL);
ASSERT(s&&target);
ASSERT(s&&s->lapic_info[number]);
ASSERT(shadow_mode_write_l1(d)||shadow_mode_write_all(d)||shadow_mode_wr_pt_pte(d));
ASSERT(shadow_mode_write_all(d)||shadow_mode_wr_pt_pte(d));
ASSERT(d->arch.ops->guest_paging_levels>=PAGING_L3);
ASSERT(!page_get_owner(pfn_to_page(v->arch.monitor_shadow_ref)));
ASSERT(pfn_to_page(gmfn)->count_info&PGC_page_table);
ASSERT(d==page_get_owner(pfn_to_page(pagetable_get_pfn(d->arch.phys_table))));
ASSERT(!(pfn_to_page(smfn)->u.inuse.type_info&PGT_pinned));
ASSERT((pfn_to_page(smfn)->u.inuse.type_info&PGT_pinned));
ASSERT(act->pin&(GNTPIN_devw_mask|GNTPIN_devr_mask));
ASSERT(act->pin&(GNTPIN_hstw_mask|GNTPIN_hstr_mask));
ASSERT(is_idle_domain(v->domain));&&(EDOM_INFO(p)->slice_orig<ULONG_MAX));&&(EDOM_INFO(p)->slice_orig<ULONG_MAX));
ASSERT(schedule_data[cpu].context_switch_in_progress);
ASSERT(!cpu_isset(cpu,next->vcpu_dirty_cpumask));
ASSERT(cpus_empty(next->vcpu_dirty_cpumask));&&(EDOM_INFO(p)->slice_orig<ULONG_MAX));&&(EDOM_INFO(p)->slice_orig<ULONG_MAX));
ASSERT(p!=n);
ASSERT(cpus_empty(n->vcpu_dirty_cpumask));
ASSERT(cpus_weight(dirty_mask)<=1);
ASSERT(is_idle_vcpu(v));
ASSERT(!in_irq()&&local_irq_is_enabled());
ASSERT(hashent->refcnt!=0);
ASSERT(l1e_get_pfn(cache->l1tab[idx])==pfn);
ASSERT(idx<MAPCACHE_ENTRIES);
ASSERT(hashent->pfn==pfn);
ASSERT(l1e_get_pfn(cache->l1tab[hashent->idx])==hashent->pfn);
ASSERT(va<FIXADDR_START);
ASSERT(l1e_get_pfn(cache->l1tab[hashent->idx])==hashent->pfn);&&(EDOM_INFO(p)->slice_orig<ULONG_MAX));&&(EDOM_INFO(p)->slice_orig<ULONG_MAX));
ASSERT(!(atomic_read(&d->refcnt)&DOMAIN_DESTROYED));
ASSERT(!test_bit(_VCPUF_running,&next->vcpu_flags));
ASSERT(0);
ASSERT(opcode);
ASSERT(opcode[0]<=15);
ASSERT(inst_len<=MAX_INST_LEN);
ASSERT(vmcb);
ASSERT(buffer[0]==0x0f&&(buffer[1]&0xFD)==0x21);
ASSERT(reg==decode_dest_reg(buffer[2]));
ASSERT(inst_len);
ASSERT(v);
ASSERT(regs);
ASSERT(order>=0);
ASSERT(hsa);
ASSERT(iopm);
ASSERT(msrpm);
ASSERT(regs->eax<=0xFFFF);
ASSERT(!test_bit(ARCH_HVM_IO_WAIT,&v->arch.hvm_vcpu.ioflags));
ASSERT(VALID_M2P(gmfn));
ASSERT(!page_get_owner(mfn_to_page(v->arch.monitor_shadow_ref)));
ASSERT(mfn_valid(mfn));
ASSERT(mfn_to_page(gmfn)->count_info&PGC_page_table);
ASSERT(d==page_get_owner(pfn_to_page(pagetable_get_pfn(
ASSERT(d==page_get_owner(mfn_to_page(pagetable_get_pfn(d->arch.phys_table))));
ASSERT(mfn_valid(smfn));
ASSERT(!(mfn_to_page(smfn)->u.inuse.type_info&PGT_pinned));
ASSERT((mfn_to_page(smfn)->u.inuse.type_info&PGT_pinned));
ASSERT(s<=e);ASSERT(pagetable_get_pfn(d->vcpu[0]->arch.monitor_table));ASSERT(pagetable_get_pfn(v->arch.monitor_table));ASSERT(v->arch.shadow_vtable);ASSERT(v->arch.shadow_vtable);ASSERT(pagetable_get_pfn(d->vcpu[0]->arch.monitor_table));ASSERT(pagetable_get_pfn(v->arch.monitor_table));
ASSERT(s2mfn);
ASSERT(m3mfn_info);
ASSERT(m2mfn_info);
ASSERT(percpu_info[cpu].foreign==NULL);
ASSERT(HVM_DOMAIN(v));ASSERT(pagetable_get_pfn(d->vcpu[0]->arch.monitor_table));
ASSERT(l2e_get_flags(l2e)&_PAGE_PRESENT);ASSERT(v->arch.shadow_vtable);
ASSERT(d==page_get_owner(mfn_to_page(pagetable_get_pfn(d->arch.phys_table))));ASSERT(v->arch.shadow_vtable);
ASSERT(vmcb->eventinj.v==0);
ASSERT(vmcb->eventinj.fields.v==0);
ASSERT(shadow_mode_external(d));ASSERT(pagetable_get_pfn(v->arch.monitor_table));
ASSERT(pagetable_get_pfn(d->vcpu[0]->arch.monitor_table));
ASSERT(tabmfn!=0);ASSERT(pagetable_get_pfn(d->vcpu[0]->arch.monitor_table));
ASSERT(pagetable_get_pfn(d->vcpu[0]->arch.monitor_table));ASSERT(pagetable_get_pfn(v->arch.monitor_table));
ASSERT(v->runstate.state!=new_state);
ASSERT(spin_is_locked(&schedule_data[v->processor].schedule_lock));
ASSERT(runstate->state=RUNSTATE_running);
ASSERT(prev->runstate.state==RUNSTATE_running);
ASSERT(next->runstate.state!=RUNSTATE_running);
ASSERT(runstate->state==RUNSTATE_running);
ASSERT(inst_len>0);
ASSERT(buffer[index+0]==0x0f&&(buffer[index+1]&0xFD)==0x21);
ASSERT(reg==decode_dest_reg(prefix,buffer[index+2]));
ASSERT(writable_pagetable_in_sync(d));
ASSERT((l1e_get_flags(pte)&(_PAGE_RW|_PAGE_PRESENT))==_PAGE_PRESENT);
ASSERT((page->u.inuse.type_info&PGT_type_mask)==PGT_l1_page_table);
ASSERT((page->u.inuse.type_info&PGT_count_mask)!=0);
ASSERT(page_get_owner(page)==d);
ASSERT(read_cr3()==__pa(idle_pg_table));
ASSERT(reg==decode_dest_reg(prefix,buffer[index+2]));ASSERT(pagetable_get_pfn(v->arch.monitor_table));
ASSERT(pagetable_get_pfn(d->vcpu[0]->arch.monitor_table));ASSERT(pagetable_get_pfn(d->vcpu[0]->arch.monitor_table));
ASSERT(hvm_guest(v));
ASSERT((diff!=0)||VM86_MODE(r)||((r->cs&3)>=GUEST_KERNEL_RPL)||(r->cs==0)||HVM_DOMAIN(current));
ASSERT((diff!=0)||vm86_mode(r)||((r->cs&3)>=GUEST_KERNEL_RPL)||(r->cs==0)||hvm_guest(current));
ASSERT((diff==0)||(!VM86_MODE(r)&&(r->cs==__HYPERVISOR_CS)));
ASSERT((diff==0)||(!vm86_mode(r)&&(r->cs==__HYPERVISOR_CS)));
ASSERT(page->count_info==0);
ASSERT(l2_backptr!=PGT_va_unknown);
ASSERT(l3_backptr!=PGT_va_unknown);
ASSERT((type&PGT_va_mask)!=(x&PGT_va_mask));
ASSERT(curinf->deadl_abs>=now);
ASSERT(l2_backptr!=PGT_va_mutable);
ASSERT(l3_backptr!=PGT_va_mutable);
ASSERT((type&PGT_va_mask)!=PGT_va_mutable);
ASSERT((x&PGT_validated)||test_bit(_DOMF_dying,&page_get_owner(page)->domain_flags));ASSERT(hcb->ht==THASH_TLB);
ASSERT((diff!=0)||VM86_MODE(r)||!RING_0(r)||HVM_DOMAIN(current));
ASSERT((diff==0)||(!VM86_MODE(r)&&RING_0(r)));
ASSERT((diff!=0)||vm86_mode(r)||((r->cs&3)>=GUEST_KERNEL_RPL)||(r->cs==0)||hvm_guest(current));ASSERT(hcb->ht==THASH_TLB);
ASSERT((x&PGT_validated)||test_bit(_DOMF_dying,&page_get_owner(page)->domain_flags));
ASSERT(atomic_read(&v->pausecnt)!=0);
ASSERT(v->arch.hvm_vmx.launch_cpu==smp_processor_id());
ASSERT(cpus_subset(cpumask,cpu_online_map));
ASSERT(!cpus_empty(cpumask));
ASSERT(p->dir==IOREQ_WRITE);
ASSERT((virq>=0)&&(virq<NR_VIRQS));
ASSERT(!virq_is_global(virq));
ASSERT(virq_is_global(virq));
ASSERT(port!=0);
ASSERT(!__task_on_queue(v));
ASSERT(__task_on_queue(v));
ASSERT(d->vcpu[i]->sched_priv!=NULL);&&(inf->slice_orig<ULONG_MAX));&&(inf->slice_orig<ULONG_MAX));&&(inf->slice_orig<ULONG_MAX));
ASSERT(action->ack_type==ACKTYPE_MULTI);
ASSERT(action->ack_type!=ACKTYPE_NONE);
ASSERT(action->ack_type==ACKTYPE_LAPIC_EOI);
ASSERT((sp==0)||(pending_lapic_eoi[cpu][sp-1].vector<vector));
ASSERT(sp<(NR_VECTORS-1));
ASSERT(sp>0);
ASSERT(!pending_lapic_eoi[cpu][sp].ready_to_end);
ASSERT(!pending_lapic_eoi[cpu][sp-1].ready_to_end);
ASSERT(desc->status&IRQ_GUEST);
ASSERT(action->ack_type==ACKTYPE_EOI);
ASSERT(desc->status&IRQ_DISABLED);
ASSERT((sp==0)||(pending_eoi[cpu][sp-1].vector<vector));
ASSERT(!pending_eoi[cpu][sp].ready);
ASSERT(!d->arch.physmap_built);
ASSERT(d->max_pages==d->tot_pages);
ASSERT(list_ent!=&d->page_list);
ASSERT(list_ent==&d->page_list);
ASSERT((x&PGT_validated)||
ASSERT(!test_bit(irq,d->pirq_mask)||(action->ack_type!=ACKTYPE_NONE));
ASSERT(cpus_empty(action->cpu_eoi_map));
ASSERT(current==idle_vcpu[smp_processor_id()]);
ASSERT(dir==IOREQ_READ||dir==IOREQ_WRITE);
ASSERT(cur);
ASSERT(cmd->direction==SCHED_INFO_PUT);
ASSERT(smfn);
ASSERT(action->ack_type==ACKTYPE_UNMASK);
ASSERT(smfn!=0);
ASSERT(page_to_mfn(gpage)!=0);
ASSERT(page_get_owner(&pg[i])==NULL);
ASSERT((pg[i].count_info&~(PGC_allocated|1))==0);
ASSERT(((irq_guest_action_t*)desc->action)->ack_type==ACKTYPE_UNMASK);
ASSERT(current->domain->domain_id==IDLE_DOMAIN_ID);
ASSERT(((l1va=d->arch.ptwr[PTWR_PT_ACTIVE].l1va)==0)||(l1_linear_offset(l1va)!=l1_linear_offset(addr)));
ASSERT(((l1va=d->arch.ptwr[PTWR_PT_INACTIVE].l1va)==0)||(l1_linear_offset(l1va)!=l1_linear_offset(addr)));
ASSERT(v!=current);
ASSERT(d!=current->domain);
ASSERT(tab[offset]&_PAGE_PRESENT);
ASSERT(!allocated_in_map(virt_to_pfn(head)));
ASSERT(head->next->pprev==&head->next);
ASSERT(free_head[x]->pprev==&free_head[x]);
ASSERT(sizeof(header)<512);
ASSERT(blkif->pending_list[idx].count==0);
ASSERT(image_len<rma_sz);
ASSERT((dst-rma)+(ulong)firmware_image_size<eomem);
ASSERT(*ofh_tree==0xdeadbeef00000000);
ASSERT((dst-rma)+oftree_len<eomem);
ASSERT((dst-rma)+image_len<eomem);
ASSERT(papr_hcalls!=NULL);
ASSERT(hypercall_table!=NULL);
ASSERT((htab_addr&((1UL<<log_htab_size)-1))==0);
ASSERT(log_htab_size<=SDR1_HTABSIZE_MAX);
ASSERT(log_htab_size>=HTAB_MIN_LOG_SIZE);
ASSERT(htab_raddr!=0);
ASSERT((htab_raddr&(htab_bytes-1))==0);
ASSERT(d->arch.htab.shadow!=NULL);
ASSERT(xl<sizeof(xen));
ASSERT(r>0);
ASSERT((pte->bits.v==0));
ASSERT(parea!=NULL);
ASSERT(stack!=0);
ASSERT(m1mfn_info);
ASSERT(result==-1||result>16);
ASSERT(len==4&&offset>0&&offset<=APIC_TDCR);
ASSERT(d==current->domain);
ASSERT(*mfn==INVALID_MFN);
ASSERT(port_is_valid(ld,lport));
ASSERT(lchn->consumer_is_xen);
ASSERT(per_cpu(schedule_data,d->processor).curr);
ASSERT(spin_is_locked(&per_cpu(schedule_data,v->processor).schedule_lock));
ASSERT(v->processor==smp_processor_id());
ASSERT(info->foreign==NULL);
ASSERT((sp==0)||(peoi[sp-1].vector<vector));
ASSERT(!peoi[sp].ready);
ASSERT(result==-1||result>=16);
ASSERT(alignment!=3);
ASSERT(alignment==0);
ASSERT(v==current);
ASSERT(!shadow2_mode_refcounts(d));
ASSERT(valid_mfn(gmfn));
ASSERT(shadow2_remove_write_access(v,gmfn,0,0)==0);
ASSERT(!test_bit(type>>PGC_SH2_type_shift,&page->shadow2_flags));
ASSERT(test_bit(_PGC_page_table,&page->count_info));
ASSERT(test_bit(type>>PGC_SH2_type_shift,&page->shadow2_flags));
ASSERT((page->shadow2_flags&(SH2F_L3_PAE|SH2F_L2_PAE|SH2F_L1_PAE))==0);
ASSERT((page->shadow2_flags&(SH2F_L4_64|SH2F_L3_64|SH2F_L2_64|SH2F_L1_64))==0);
ASSERT(shadow2_lock_is_acquired(v->domain));
ASSERT(shadow2_lock_is_acquired(d));
ASSERT(order<=SHADOW2_MAX_ORDER);
ASSERT(shadow_type!=PGC_SH2_none);
ASSERT(shadow_type!=PGC_SH2_p2m_table);
ASSERT(index<MACHPHYS_MBYTES>>1);
ASSERT(shadow2_mode_external(v->domain));
ASSERT(l3e_get_flags(ml3e[3])&_PAGE_PRESENT);
ASSERT(p2m_entry);
ASSERT(pagetable_get_pfn(d->arch.phys_table)==0);
ASSERT(shadow2_mode_translate(d));
ASSERT(page_get_owner(pg)==d);
ASSERT(d->arch.shadow2_p2m_pages==0);
ASSERT(!list_empty(&d->arch.shadow2_freelists[SHADOW2_MAX_ORDER]));
ASSERT(!d->arch.shadow2_hash_table);
ASSERT(d->arch.shadow2_hash_table);
ASSERT(t);
ASSERT(x->t||((x==head)&&(x->next==NULL)));
ASSERT(x);/*Wecan'thavehittheend,sinceourtargetis
ASSERT(d->arch.shadow2_hash_walking==0);
ASSERT(x->t<=15);
ASSERT(callbacks[x->t]!=NULL);
ASSERT(t==PGC_SH2_fl1_32_shadow||t==PGC_SH2_fl1_pae_shadow||t==PGC_SH2_fl1_64_shadow||t==PGC_SH2_monitor_table||(page_get_owner(mfn_to_page(_mfn(pg->u.inuse.type_info)));==v->domain));
ASSERT((pg->count_info&PGC_SH2_type_mask)>0);
ASSERT((pg->count_info&PGC_SH2_type_mask)<PGC_SH2_max_shadow);
ASSERT((pg->count_info&PGC_SH2_type_mask)!=PGC_SH2_l2_32_shadow);
ASSERT((pg->count_info&PGC_SH2_type_mask)!=PGC_SH2_l3_pae_shadow);
ASSERT((pg->count_info&PGC_SH2_type_mask)!=PGC_SH2_l4_64_shadow);
ASSERT(valid_mfn(pmfn));
ASSERT(vaddr);
ASSERT(l1e_get_pfn(*(l1_pgentry_t*)vaddr)==mfn_x(smfn));
ASSERT(shadow2_mode_external(d));
ASSERT(pagetable_get_pfn(d->arch.phys_table)!=0);
ASSERT(l4e_get_flags(l4e[0])&_PAGE_PRESENT);
ASSERT(test_bit(_DOMF_dying,&d->domain_flags));
ASSERT(d->arch.shadow2_total_pages==0);
ASSERT(d->arch.shadow_dirty_bitmap==NULL);
ASSERT(mfn_x(sh2_gfn_to_mfn(d,gfn))==mfn);
ASSERT(sc->op==DOM0_SHADOW_CONTROL_OP_PEEK);
ASSERT(shadow2_mode_log_dirty(d));
ASSERT(valid_mfn(_mfn(mfn)));
ASSERT(res==1);
ASSERT(!guest_op||shadow2_lock_is_acquired(v->domain));
ASSERT(valid_mfn(gmfn);&&(sh2_mfn_is_a_page_table(gmfn);||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask);==0)));
ASSERT(ep&&!(((unsignedlong)ep)&((sizeof*ep)-1)));
ASSERT(level<=GUEST_PAGING_LEVELS);
ASSERT(ft==ft_demand_read||ft==ft_demand_write);
ASSERT((pg->u.inuse.type_info&PGT_count_mask)==0);
ASSERT(shflags&(1u<<bit));
ASSERT(res==0||res==SHADOW2_SET_CHANGED);
ASSERT(sflags!=-1);
ASSERT(!((unsignedlong)d&(sizeof(shadow_l1e_t)-1)));
ASSERT(map!=NULL);
ASSERT(sl4e!=NULL);
ASSERT(sl3e!=NULL);
ASSERT(sl2e!=NULL);
ASSERT(!(pair[0].l2&(1<<PAGE_SHIFT)));
ASSERT(sl1e!=NULL);
ASSERT(valid_mfn(shadow_l4e_get_mfn(*sl4e)));
ASSERT(valid_mfn(shadow_l3e_get_mfn(*sl3e)));
ASSERT(valid_mfn(shadow_l2e_get_mfn(*sl2e)));
ASSERT((mfn_to_page(_sl1mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_l1_shadow||(mfn_to_page(_sl1mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_fl1_shadow);
ASSERT((mfn_to_page(_sl2mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_l2_32_shadow);
ASSERT((mfn_to_page(_sl2mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_l2_pae_shadow||(mfn_to_page(_sl2mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_l2h_pae_shadow);
ASSERT((mfn_to_page(_sl2mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_l2_64_shadow);
ASSERT((mfn_to_page(_sl3mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_l3_pae_shadow);
ASSERT((mfn_to_page(_sl3mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_l3_64_shadow);
ASSERT((mfn_to_page(_sl4mfn)->count_info&PGC_SH2_type_mask)==PGC_SH2_l4_64_shadow);
ASSERT(sizeof(l4_pgentry_t)==sizeof(shadow_l4e_t));
ASSERT(sizeof(l2_pgentry_t)==sizeof(shadow_l2e_t));
ASSERT(!shadow2_mode_external(v->domain));
ASSERT(guest_l3e_get_flags(gl3e[3])&_PAGE_PRESENT);
ASSERT(pagetable_get_pfn(v->arch.monitor_table)==0);
ASSERT(valid_mfn(*sl3mfn));
ASSERT((r&SHADOW2_SET_FLUSH)==0);
ASSERT(valid_mfn(*sl2mfn));
ASSERT(r&SHADOW2_SET_L3PAE_RECOPY);
ASSERT(valid_mfn(*sl1mfn));
ASSERT(t==PGC_SH2_l4_shadow);
ASSERT(t==PGC_SH2_l3_shadow);
ASSERT((unsignedlong)sl3e%(4*sizeof(shadow_l3e_t))==0);
ASSERT((mfn_to_page(smfn)->count_info&PGC_SH2_type_mask);==PGC_SH2_l3_pae_shadow);
ASSERT(t==PGC_SH2_l2_shadow||t==PGC_SH2_l2h_pae_shadow);
ASSERT(t==PGC_SH2_l1_shadow||t==PGC_SH2_fl1_shadow);
ASSERT((mfn_to_page(mmfn)->count_info&PGC_SH2_type_mask);==PGC_SH2_monitor_table);
ASSERT(l3e_get_flags(l3e[3])&_PAGE_PRESENT);
ASSERT(size+(((unsignedlong)new_gp)&~PAGE_MASK)<=PAGE_SIZE);
ASSERT(valid_mfn(smfn));
ASSERT(ptr_sl1e);
ASSERT(!mmio||!(shadow_l1e_get_flags(sl1e)&_PAGE_PRESENT));
ASSERT(l4e_get_flags(ml4e[0])&_PAGE_PRESENT);
ASSERT(shadow_l3e_get_flags(shadow_l3e[3])&_PAGE_PRESENT);
ASSERT(test_bit(v->vcpu_id,&info->vcpus));
ASSERT(v->arch.shadow2);
ASSERT(pagetable_get_pfn(v->arch.guest_table)==mfn_x(gmfn));
ASSERT(v->arch.guest_table.pfn==d->arch.phys_table.pfn);
ASSERT(v->arch.cr3==0);
ASSERT(sh2_mfn_is_a_page_table(gmfn));
ASSERT(!test_bit(v->vcpu_id,&info->vcpus));
ASSERT(v->arch.hvm_vcpu.hw_cr3==virt_to_maddr(v->arch.hvm_vcpu.hvm_lowmem_l3tab));
ASSERT(sh2_mfn_is_a_page_table(mfn));
ASSERT(bytes<=sizeof(unsignedlong));
ASSERT((__va>=IOREMAP_VIRT_START)&&(__va<=(IOREMAP_VIRT_END-1)));
ASSERT(v->arch.shadow2_action_log);
ASSERT(page_get_owner(page)==NULL);
ASSERT(current==v);
ASSERT(current==(v));
ASSERT(bk->refcount>0);
ASSERT((_d)->arch.shadow2_locker==-1);
ASSERT((_d)->arch.shadow2_locker==current->processor);
ASSERT(v->arch.shadow2!=NULL);
ASSERT(shadow2_mode_enabled(v->domain));
ASSERT(l4e_get_flags(l4e[0])&_PAGE_PRESENT);&&(sh2_mfn_is_a_page_table(gmfn);||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask);==0)));
ASSERT((unsignedlong)sl3e%(4*sizeof(shadow_l3e_t))==0);==PGC_SH2_l3_pae_shadow);
ASSERT(t==PGC_SH2_l2_shadow||t==PGC_SH2_l2h_pae_shadow);==PGC_SH2_monitor_table);
ASSERT(!list_empty(&d->arch.shadow2.freelists[SHADOW2_MAX_ORDER]));
ASSERT(d->arch.shadow2.dirty_bitmap==NULL);
ASSERT(d->arch.shadow2.dirty_bitmap!=NULL);
ASSERT(v->arch.shadow2.mode);
ASSERT(v->arch.shadow2.mode!=NULL);
ASSERT(l1e_get_pfn(cache->l1tab[idx])==mfn);
ASSERT(hashent->mfn==mfn);
ASSERT(l1e_get_pfn(cache->l1tab[hashent->idx])==hashent->mfn);
ASSERT((__va>=IOREMAP_VIRT_START)&&(__va<IOREMAP_VIRT_END));
ASSERT(__va>=IOREMAP_VIRT_START);
ASSERT(op->cmd==XEN_DOMCTL_SCHEDOP_getinfo);
ASSERT(op->cmd==XEN_DOMCTL_SCHEDOP_putinfo);
ASSERT(shadow_remove_write_access(v,gmfn,0,0)==0);
ASSERT(!test_bit(type>>PGC_SH_type_shift,&page->shadow_flags));
ASSERT(test_bit(type>>PGC_SH_type_shift,&page->shadow_flags));
ASSERT((page->shadow_flags&(SHF_L3_PAE|SHF_L2_PAE|SHF_L1_PAE))==0);
ASSERT((page->shadow_flags&(SHF_L4_64|SHF_L3_64|SHF_L2_64|SHF_L1_64))==0);
ASSERT(shadow_lock_is_acquired(v->domain));
ASSERT(order<=SHADOW_MAX_ORDER);
ASSERT(shadow_type!=PGC_SH_none);
ASSERT(shadow_type!=PGC_SH_p2m_table);
ASSERT(shadow_mode_external(v->domain));
ASSERT(d->arch.shadow.p2m_pages==0);
ASSERT(!list_empty(&d->arch.shadow.freelists[SHADOW_MAX_ORDER]));
ASSERT(!d->arch.shadow.hash_table);
ASSERT(d->arch.shadow.hash_table);
ASSERT(d->arch.shadow.hash_walking==0);
ASSERT(t==PGC_SH_fl1_32_shadow||t==PGC_SH_fl1_pae_shadow||t==PGC_SH_fl1_64_shadow||t==PGC_SH_monitor_table||(page_get_owner(mfn_to_page(_mfn(pg->u.inuse.type_info)));==v->domain));
ASSERT((pg->count_info&PGC_SH_type_mask)>0);
ASSERT((pg->count_info&PGC_SH_type_mask)<PGC_SH_max_shadow);
ASSERT((pg->count_info&PGC_SH_type_mask)!=PGC_SH_l2_32_shadow);
ASSERT((pg->count_info&PGC_SH_type_mask)!=PGC_SH_l3_pae_shadow);
ASSERT((pg->count_info&PGC_SH_type_mask)!=PGC_SH_l4_64_shadow);
ASSERT(d->arch.shadow.total_pages==0);
ASSERT(mfn_x(sh_gfn_to_mfn(d,gfn))==mfn);
ASSERT(shadow_mode_log_dirty(d));
ASSERT(!guest_op||shadow_lock_is_acquired(v->domain));&&(sh_mfn_is_a_page_table(gmfn);||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask);==0)));
ASSERT(res==0||res==SHADOW_SET_CHANGED);
ASSERT((mfn_to_page(_sl1mfn)->count_info&PGC_SH_type_mask)==PGC_SH_l1_shadow||(mfn_to_page(_sl1mfn)->count_info&PGC_SH_type_mask)==PGC_SH_fl1_shadow);
ASSERT((mfn_to_page(_sl2mfn)->count_info&PGC_SH_type_mask)==PGC_SH_l2_32_shadow);
ASSERT((mfn_to_page(_sl2mfn)->count_info&PGC_SH_type_mask)==PGC_SH_l2_pae_shadow||(mfn_to_page(_sl2mfn)->count_info&PGC_SH_type_mask)==PGC_SH_l2h_pae_shadow);
ASSERT((mfn_to_page(_sl2mfn)->count_info&PGC_SH_type_mask)==PGC_SH_l2_64_shadow);
ASSERT((mfn_to_page(_sl3mfn)->count_info&PGC_SH_type_mask)==PGC_SH_l3_pae_shadow);
ASSERT((mfn_to_page(_sl3mfn)->count_info&PGC_SH_type_mask)==PGC_SH_l3_64_shadow);
ASSERT((mfn_to_page(_sl4mfn)->count_info&PGC_SH_type_mask)==PGC_SH_l4_64_shadow);
ASSERT(!shadow_mode_external(v->domain));
ASSERT((r&SHADOW_SET_FLUSH)==0);
ASSERT(r&SHADOW_SET_L3PAE_RECOPY);
ASSERT(t==PGC_SH_l4_shadow);
ASSERT(t==PGC_SH_l3_shadow);
ASSERT((mfn_to_page(smfn)->count_info&PGC_SH_type_mask);==PGC_SH_l3_pae_shadow);
ASSERT(t==PGC_SH_l2_shadow||t==PGC_SH_l2h_pae_shadow);
ASSERT(t==PGC_SH_l1_shadow||t==PGC_SH_fl1_shadow);
ASSERT((mfn_to_page(mmfn)->count_info&PGC_SH_type_mask);==PGC_SH_monitor_table);
ASSERT(v->arch.shadow.mode);
ASSERT(sh_mfn_is_a_page_table(gmfn));
ASSERT(sh_mfn_is_a_page_table(mfn));
ASSERT(v->arch.shadow.action_log);
ASSERT((_d)->arch.shadow.locker==-1);
ASSERT((_d)->arch.shadow.locker==current->processor);
ASSERT(v->arch.shadow.mode!=NULL);
ASSERT(l4e_get_flags(l4e[0])&_PAGE_PRESENT);&&(sh_mfn_is_a_page_table(gmfn);||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask);==0)));
ASSERT((unsignedlong)sl3e%(4*sizeof(shadow_l3e_t))==0);==PGC_SH_l3_pae_shadow);
ASSERT(t==PGC_SH_l2_shadow||t==PGC_SH_l2h_pae_shadow);==PGC_SH_monitor_table);
ASSERT(d->tot_pages>0);
ASSERT(rma_settings!=NULL);
ASSERT(d->tot_pages>=rma_nrpages);
ASSERT(d->tot_pages==dom0_nrpages);
ASSERT(!(type&~PGT_type_mask));
ASSERT(!(type&~(PGT_type_mask|PGT_pae_xen_l2)));
ASSERT(!(x&PGT_pae_xen_l2));
ASSERT((result==-1)||(result>=16));
ASSERT(spin_is_locked(&s->pics_state->lock));
ASSERT(spin_is_locked(&s->lock));
ASSERT((res==0)||(res==SHADOW_SET_CHANGED));
ASSERT(count);
ASSERT(!(all&&fast));
ASSERT((page->shadow_flags&(SHF_L2H_PAE|SHF_L2_PAE|SHF_L1_PAE))==0);
ASSERT((pg->count_info&PGC_SH_type_mask)!=PGC_SH_l2_pae_shadow);
ASSERT((pg->count_info&PGC_SH_type_mask)!=PGC_SH_l2h_pae_shadow);
ASSERT(GUEST_PAGING_LEVELS>3||level!=3);
ASSERT(pagetable_is_null(v->arch.shadow_table[slot]));
ASSERT(pagetable_is_null(v->arch.shadow_table[i]));
ASSERT(virt_to_maddr(&v->arch.shadow.l3table)<=0xffffffe0ULL);
ASSERT(node>=0);
ASSERT(node<num_nodes);
ASSERT(avail[zone][node]>=request);
ASSERT(node<num_online_nodes());
ASSERT(phys_to_nid(page_to_maddr(pg))==node);
ASSERT(ep&&!(((unsignedlong)ep)&((sizeof*ep)-1)));&&(sh_mfn_is_a_page_table(gmfn);||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask);==0)));
ASSERT(level==1||!(ft&FETCH_TYPE_DEMAND));
ASSERT((ft==ft_prefetch));
ASSERT(!sh_l1e_is_magic(sl1e));
ASSERT(guest_l2e_get_flags(*gw->l2e)&_PAGE_PSE);
ASSERT(regs->error_code&PFEC_page_present);
ASSERT(sh_l1e_is_mmio(sl1e));
ASSERT(is_hvm_domain(d));
ASSERT(!cpus_empty(cpus));
ASSERT(!cpu_isset(nxt,cpus));
ASSERT(spin_is_locked(&vpic->lock));
ASSERT((len==4)&&(offset>0)&&(offset<=APIC_TDCR));
ASSERT(list_ent!=&d->page_list);
ASSERT(gfn<(RO_MPT_VIRT_END-RO_MPT_VIRT_START)/sizeof(l1_pgentry_t));
ASSERT(this_cpu(mc_state).flags==0);
ASSERT(spin_is_locked(vpic_lock(s->pics_state)));
ASSERT(spin_is_locked(vpic_lock(vpic)));
ASSERT(isa_irq<=15);
ASSERT((link<=3)&&(isa_irq<=15));
ASSERT(spin_is_locked(&vioapic_domain(vioapic)->arch.hvm_domain.irq.lock));
ASSERT(irq<VIOAPIC_NUM_PINS);
ASSERT(spin_is_locked(&d->arch.hvm_domain.irq.lock));
ASSERT((devfn!=PCI_ISA_DEVFN)||((vendor_id==0x8086)&&(device_id==0x7000)));
ASSERT((vendor_id==0x8086)&&(device_id==0x7113));
ASSERT((vendor_id==0x8086)&&(device_id==0x7010));
ASSERT(!test_bit(type,&page->shadow_flags));
ASSERT(test_bit(type,&page->shadow_flags));
ASSERT(shadow_type<16);
ASSERT(shadow_type!=SH_type_none);
ASSERT(shadow_type!=SH_type_p2m_table);
ASSERT(t==PGC_SH_fl1_32_shadow||t==PGC_SH_fl1_pae_shadow||t==PGC_SH_fl1_64_shadow||t==PGC_SH_monitor_table||(page_get_owner(mfn_to_page(_mfn(pg->u.inuse.type_info)));
ASSERT(t==SH_type_fl1_32_shadow||t==SH_type_fl1_pae_shadow||t==SH_type_fl1_64_shadow||t==SH_type_monitor_table||==v->domain));
ASSERT(sp->type>0);
ASSERT(sp->type<SH_type_max_shadow);
ASSERT(sp->type!=SH_type_l2_32_shadow);
ASSERT(sp->type!=SH_type_l2_pae_shadow);
ASSERT(sp->type!=SH_type_l2h_pae_shadow);
ASSERT(sp->type!=SH_type_l4_64_shadow);
ASSERT(mfn_to_shadow_page(_sl1mfn)->type==SH_type_l1_shadow||mfn_to_shadow_page(_sl1mfn)->type==SH_type_fl1_shadow);
ASSERT(mfn_to_shadow_page(_sl2mfn)->type==SH_type_l2_32_shadow);
ASSERT(mfn_to_shadow_page(_sl2mfn)->type==SH_type_l2_pae_shadow||mfn_to_shadow_page(_sl2mfn)->type==SH_type_l2h_pae_shadow);
ASSERT(mfn_to_shadow_page(_sl2mfn)->type==SH_type_l2_64_shadow);
ASSERT(mfn_to_shadow_page(_sl3mfn)->type==SH_type_l3_64_shadow);
ASSERT(mfn_to_shadow_page(_sl4mfn)->type==SH_type_l4_64_shadow);
ASSERT(t==SH_type_l4_shadow);
ASSERT(t==SH_type_l3_shadow);
ASSERT(t==SH_type_l2_shadow||t==SH_type_l2h_pae_shadow);
ASSERT(t==SH_type_l1_shadow||t==SH_type_fl1_shadow);==PGC_SH_monitor_table);
ASSERT(mfn_to_shadow_page(mmfn)->type==SH_type_monitor_table);
ASSERT(sp->mbz==0);
ASSERT(prev);
ASSERT(x->type<=15);
ASSERT(callbacks[x->type]!=NULL);
ASSERT(ok);
ASSERT(!(r&SHADOW_SET_ERROR));
ASSERT(sh_type_is_pinnable(v,sp->type));
ASSERT(((vaddr&~PAGE_MASK)+bytes)<=PAGE_SIZE);
ASSERT(vpic_is_locked(vpic));
ASSERT(irq<=15);
ASSERT(mfn_valid(gmfn));
ASSERT(mfn_valid(pmfn));
ASSERT(mfn_valid(_mfn(mfn)));
ASSERT(mfn_valid(gmfn);&&(sh_mfn_is_a_page_table(gmfn);||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask);==0)));
ASSERT(mfn_valid(*sl3mfn));
ASSERT(mfn_valid(*sl2mfn));
ASSERT(mfn_valid(*sl1mfn));
ASSERT(*addr==(u32)*addr);
ASSERT(ea==(u32)ea);
ASSERT((ACPI_PHYSICAL_ADDRESS+acpi_sz)<=0xF0000);
ASSERT(is_hvm_vcpu(v));
ASSERT(t==SH_type_fl1_32_shadow||t==SH_type_fl1_pae_shadow||t==SH_type_fl1_64_shadow||t==SH_type_monitor_table||==v->domain));&&(sh_mfn_is_a_page_table(gmfn);||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask);==0)));
ASSERT(t==SH_type_l2_shadow||t==SH_type_l2h_pae_shadow);==PGC_SH_monitor_table);
ASSERT(!cpus_empty(cpus)&&cpu_isset(cpu,cpus));
ASSERT(cpu_isset(nxt,cpu_core_map[cpu]));
ASSERT(!cpu_isset(nxt,cpu_core_map[cpu]));
ASSERT(current->processor==cpu);
ASSERT(svc->sdom!=NULL);
ASSERT((v==current)||!vcpu_runnable(v));
ASSERT(shadow_locked_by_me(v->domain));
ASSERT(shadow_locked_by_me(d));
ASSERT(!guest_op||shadow_locked_by_me(v->domain));
ASSERT(sh_remove_write_access(v,gmfn,0,0)==0);
ASSERT(tn<HPET_TIMER_NUM);
ASSERT((diff!=0)||vm86_mode(r)||((r->cs&3)>=GUEST_KERNEL_RPL)||
ASSERT((diff!=0)||vm86_mode(r)||((r->cs&3)>=GUEST_KERNEL_RPL(current->domain))||(r->cs==0)||is_hvm_vcpu(current));
ASSERT(spin_is_locked(&vioapic_domain(vioapic)->arch.hvm_domain.irq_lock));
ASSERT(spin_is_locked(&d->arch.hvm_domain.irq_lock));
ASSERT(typecode<=HVM_SAVE_CODE_MAX);
ASSERT(hvm_sr_handlers[typecode].save==NULL);
ASSERT(hvm_sr_handlers[typecode].load==NULL);
ASSERT(h->cur<=h->size);
ASSERT((_d)->arch.p2m.locker==-1);
ASSERT((_d)->arch.p2m.locker==current->processor);
ASSERT(d->arch.p2m.alloc_page);
ASSERT(paging_mode_translate(d));
ASSERT(mfn_x(gfn_to_mfn(d,gfn))==mfn);
ASSERT(!list_empty(&d->arch.paging.shadow.freelists[SHADOW_MAX_ORDER]));
ASSERT(!d->arch.paging.shadow.hash_table);
ASSERT(d->arch.paging.shadow.hash_table);
ASSERT(d->arch.paging.shadow.hash_walking==0);
ASSERT(d->arch.paging.shadow.total_pages==0);
ASSERT(d->arch.paging.shadow.dirty_bitmap==NULL);
ASSERT(d->arch.paging.shadow.dirty_bitmap!=NULL);
ASSERT(v->arch.paging.mode);
ASSERT(virt_to_maddr(&v->arch.paging.shadow.l3table)<=0xffffffe0ULL);
ASSERT((_d)->arch.paging.shadow.locker==-1);
ASSERT((_d)->arch.paging.shadow.locker==current->processor);
ASSERT(!paging_mode_external(v->domain));
ASSERT(v->arch.paging.shadow.guest_vtable==NULL);
ASSERT(req_nr_frames<=max_nr_grant_frames);
ASSERT(sizeof(grant_entry_t)==8);
ASSERT(sizeof(QCowHeader)+sizeof(QCowHeader_ext)<512);
ASSERT(sector>=seg_start&&sector+nr_secs<=seg_end);
ASSERT(info->busy.req==req);
ASSERT(blkif->pending_list[idx].secs_pending==0);
ASSERT((len==4)&&(offset>=0)&&(offset<=APIC_TDCR));
ASSERT(shadow_type<SH_type_unused);
ASSERT(IS_COMPAT(v->domain));
ASSERT(mfn_to_shadow_page(_sl2mfn)->type==SH_type_l2_64_shadow||mfn_to_shadow_page(_sl2mfn)->type==SH_type_l2h_64_shadow);
ASSERT(t==SH_type_l2_shadow||t==SH_type_l2h_shadow);
ASSERT(t==SH_type_l2_shadow);
ASSERT(!sh_mfn_is_a_page_table(gmfn));
ASSERT(regs->eflags&X86_EFLAGS_IF);
ASSERT((id==BUGFRAME_bug)||(id==BUGFRAME_assert));
ASSERT(id==BUGFRAME_assert);
ASSERT(zone_lo<=zone_hi);
ASSERT(zone_hi<NR_ZONES);
ASSERT(avail[node][zone]>=request);
ASSERT(hap_locked_by_me(d));
ASSERT(!list_empty(&d->arch.paging.hap.freelists));
ASSERT(d->arch.paging.hap.total_pages==0);
ASSERT(hap_locked_by_me(v->domain));
ASSERT((_d)->arch.paging.hap.locker==-1);
ASSERT((_d)->arch.paging.hap.locker==current->processor);
ASSERT(!active_timer(&v->periodic_timer));
ASSERT(op==XENMEM_maximum_gpfn);
ASSERT((size<=sizeof(mask))&&(size>0));
ASSERT((x&PGT_validated)||page_get_owner(page)->is_dying);
ASSERT(d->is_dying);
ASSERT(d->is_shutdown);
ASSERT(!next->is_running);
ASSERT(d->arch.paging.hap.p2m_pages>=0);
ASSERT(d->is_shutting_down);
ASSERT((result&mask)<(src&mask));
ASSERT(instr==INSTR_CMP||instr==INSTR_SUB);
ASSERT(d->arch.paging.hap.p2m_pages==0);
ASSERT(paging_mode_external(v->domain));
ASSERT(l3e_get_flags(ml3e[3])&_PAGE_PRESENT);
ASSERT(op_size==BYTE||op_size==WORD||op_size==LONG);
ASSERT((v==current)||spin_is_locked(&d->arch.hvm_domain.ioreq.lock));
ASSERT(d->arch.hvm_domain.ioreq.va!=NULL);
ASSERT(pv_32on64_vcpu(v));
ASSERT(is_pv_32on64_vcpu(v));
ASSERT(va>=XEN_VIRT_START);
ASSERT(va<DIRECTMAP_VIRT_END);
ASSERT((va<XEN_VIRT_END)||(va>=DIRECTMAP_VIRT_START));
ASSERT((s&~PAGE_MASK)==0);
ASSERT((e&~PAGE_MASK)==0);
ASSERT(res_ptr<res_end);
ASSERT(0!=mask);
ASSERT(pages_needed);
ASSERT(0==(size&~iovp_mask));
ASSERT(m!=0);
ASSERT(bits_not_wanted);
ASSERT((*res_ptr&m)==m);
ASSERT(byte_cnt>0);
ASSERT(0==(byte_cnt&~iovp_mask));
ASSERT(off<ioc->pdir_size);
ASSERT(t<=31);
ASSERT(ioc->pdir_base[off]>>63);
ASSERT(to_pci_dev(dev)->dma_mask);
ASSERT(ioc);
ASSERT(size>0);
ASSERT(size<=DMA_CHUNK_SIZE);
ASSERT(((u8*)pdir_start)[7]==0);
ASSERT(dev->coherent_dma_mask);
ASSERT(pdirp);
ASSERT(startsg->length<=DMA_CHUNK_SIZE);
ASSERT(dma_len<=DMA_CHUNK_SIZE);
ASSERT(coalesced==filled);
ASSERT(ALIGN((unsignedlong)ioc->pdir_base,4*1024)==(unsignedlong)ioc->pdir_base);
ASSERT(v->vcpu_info_mfn==INVALID_MFN);
ASSERT(mfn!=INVALID_MFN);
ASSERT(v->arch.paging.shadow.guest_vtable);
ASSERT((mfn&~(PADDR_MASK>>PAGE_SHIFT))==0);
ASSERT((_d)->arch.paging.log_dirty.locker==-1);
ASSERT((_d)->arch.paging.log_dirty.locker==current->processor);
ASSERT(d->arch.paging.log_dirty.bitmap==NULL);
ASSERT(d->arch.paging.log_dirty.bitmap!=NULL);
ASSERT(spin_is_locked(&h->lock));
ASSERT(spin_is_locked(&pit->lock));
ASSERT(pt->vcpu==v);
ASSERT(tmp_base==__vsa_base);
ASSERT(v->vcpu_id==0);
ASSERT((delivery_mode==dest_Fixed)||(delivery_mode==dest_LowestPrio));
ASSERT(!(initial_images_start&~PAGE_MASK));
ASSERT(!(initial_images_end&~PAGE_MASK));
ASSERT((page->u.inuse.type_info&PGT_type_mask)!=PGT_writable_page||(page->u.inuse.type_info&PGT_count_mask)==0||v->domain->is_shutting_down);
ASSERT(v->arch.hvm_vmx.active_cpu==smp_processor_id());
ASSERT(this_cpu(host_vmcs)==NULL);
ASSERT(vmcs==this_cpu(host_vmcs));
ASSERT(!list_empty(&d->arch.paging.hap.freelist));
ASSERT(l4e!=NULL);
ASSERT(l2e!=NULL);
ASSERT(!guest_op||shadow_locked_by_me(d));
ASSERT(v->arch.guest_table.pfn==d->arch.paging.shadow.unpaged_pagetable.pfn);
ASSERT(pagetable_get_pfn(v->arch.guest_table));
ASSERT(mfn_valid(mfn)||!p2m_is_ram(*t));
ASSERT(mfn_valid(omfn));
ASSERT(mfn_valid(gw->l3mfn));
ASSERT(mfn_valid(gw->l2mfn));
ASSERT(mfn_valid(gw->l1mfn));
ASSERT(gfn<(RO_MPT_VIRT_END-RO_MPT_VIRT_START);/sizeof(l1_pgentry_t));
ASSERT(l1e_get_pfn(l1e)!=INVALID_MFN||!p2m_is_ram(*t));
ASSERT(num_online_cpus()==1);
ASSERT(mfn_valid(mfn)||!p2m_is_ram(*t));/sizeof(l1_pgentry_t));
ASSERT(l1e_get_pfn(l1e)!=INVALID_MFN||!p2m_is_ram(p2mt));
ASSERT((extra_space/sizeof(u32))<=TRACE_EXTRA_MAX);
ASSERT(extra_word<=TRACE_EXTRA_MAX);
ASSERT(bytes_to_wrap==calc_bytes_to_wrap(buf));
ASSERT(vlapic_enabled(vcpu_vlapic(v)));
ASSERT(l1e_get_pfn(dcache->l1tab[idx])==mfn);
ASSERT(l1e_get_pfn(dcache->l1tab[hashent->idx])==hashent->mfn);
ASSERT(spin_is_locked(&s->lock));
ASSERT(spin_is_locked(&viosapic->lock));
ASSERT(tb_init_done);
ASSERT(tps64!=0);
ASSERT(order<=shadow_max_order(d));
ASSERT(type!=SH_type_p2m_table);
ASSERT(!list_empty(&d->arch.paging.shadow.freelists[order]));
ASSERT(level<CONFIG_PAGING_LEVELS);
ASSERT(!(*ar&_SEGMENT_DPL));
ASSERT(opnd_sel);
ASSERT((opnd_sel&~3)==regs->error_code);
ASSERT(spin_is_locked(&console_lock));
ASSERT(!v->arch.hvm_vcpu.flag_dr_dirty);
ASSERT(!shadow_op||shadow_locked_by_me(d));
ASSERT(guest_l2e_get_flags(gw->l2e)&_PAGE_PSE);
ASSERT(d->is_dying);
ASSERT(mfn_valid(mfn));
ASSERT((v==current)||spin_is_locked(&d->arch.vmx_platform.ioreq.lock));
ASSERT(d->arch.vmx_platform.ioreq.va!=NULL);
ASSERT(d->arch.paging.log_dirty.allocs==0);
ASSERT(mfn_valid(d->arch.paging.log_dirty.top));
ASSERT(regs==guest_cpu_user_regs());
ASSERT(isairq<NR_ISAIRQS);
ASSERT(pt->source!=0);
ASSERT(mfn_valid(sh_ctxt->mfn1));
ASSERT(!mfn_valid(sh_ctxt->mfn2));
ASSERT(b2<bytes);
ASSERT(((unsignedlong)addr&PAGE_MASK)==LDT_VIRT_START(v));
ASSERT(!strncmp(nodename,"/local/domain/",14));
ASSERT(!(aiocbp->aio_offset&(dev->sector_size-1)));
ASSERT(!(aiocbp->aio_nbytes&(dev->sector_size-1)));
ASSERT(n<=BLKIF_MAX_SEGMENTS_PER_REQUEST);
ASSERT(n==1||(stride==0&&increment==1));
ASSERT(id==DOMID_SELF);
ASSERT(prot==0);
ASSERT(mbox->reader==mbox->writer);
ASSERT(mbox->reader!=mbox->writer);ASSERT(FS_RING_FREE_REQUESTS(&import->ring,idx));
ASSERT(read_cr0()&X86_CR0_TS);
ASSERT(v->arch.hvm_vmx.host_cr0&X86_CR0_TS);
ASSERT(!v->fpu_dirtied);
ASSERT(is_x86_user_segment(seg));
ASSERT(seg==x86_seg_cs);
ASSERT(x>=0);
ASSERT(x<=data_size);
ASSERT(x>0);
ASSERT(x<data_size);
ASSERT(next>=0);
ASSERT(next<2*data_size);
ASSERT(l4e_get_flags(l4e[linear_slot])&_PAGE_PRESENT);
ASSERT(l3e_get_flags(l3e[0])&_PAGE_PRESENT);
ASSERT(l4e_get_flags(ml4e[linear_slot])&_PAGE_PRESENT);
ASSERT(l3e_get_flags(ml3e[0])&_PAGE_PRESENT);
ASSERT(!start);
ASSERT(prot==(PROT_READ|PROT_WRITE));
ASSERT(flags==(MAP_SHARED|MAP_ANON)||flags==(MAP_PRIVATE|MAP_ANON));
ASSERT(fd==-1);
ASSERT(offset==0);
ASSERT(!((unsignedlong)start&~PAGE_MASK));
ASSERT(!(length&~PAGE_MASK));
ASSERT(current==main_thread);
ASSERT(!((unsignedlong)data&~PAGE_MASK));
ASSERT(blkif->pending_list[idx].secs_pending==0);
ASSERT(!(aiocbp->aio_offset&(dev->info.sector_size-1)));
ASSERT(!(aiocbp->aio_nbytes&(dev->info.sector_size-1)));
ASSERT((_p2m)->locker==-1);
ASSERT((_p2m)->locker==current->processor);
ASSERT(d->arch.p2m->alloc_page);/sizeof(l1_pgentry_t));/sizeof(l1_pgentry_t));
ASSERT(hd->pgd_maddr!=0);
ASSERT(gla_validity==EPT_GLA_VALIDITY_MATCH);
ASSERT(p2m_locked_by_me(d->arch.p2m));
ASSERT(domain_is_locked(d));
ASSERT((val==NULL)||((dir==IOREQ_READ)&&!value_is_ptr));
ASSERT(spin_is_locked(&d->arch.irq_lock));
ASSERT(d->dirty_vram->sl1ma[i]==sl1ma);
ASSERT(irqs_disabled());
ASSERT(table!=NULL);
ASSERT(l1e_get_flags(*p2m_entry)&_PAGE_PRESENT);
ASSERT(l2e_get_pfn(l2e)!=INVALID_MFN||!p2m_is_ram(p2mt));/sizeof(l1_pgentry_t));
ASSERT(!(*ar&_SEGMENT_DPL));/sizeof(l1_pgentry_t));
ASSERT(0);
ASSERT((fd==-1&&(flags==(MAP_SHARED|MAP_ANON)||flags==(MAP_PRIVATE|MAP_ANON)));||(fd!=-1&&flags==MAP_SHARED));||(fd!=-1&&flags==MAP_SHARED));
ASSERT(!aiocbp->aio_cb);
ASSERT(source_pfn<start_info.nr_pages);
ASSERT(mfn_is_out_of_sync(gmfn));
ASSERT(page_is_out_of_sync(pg));
ASSERT(!(mfn_to_page(gmfn)->shadow_flags&SHF_page_type_mask&~SHF_L1_ANY));
ASSERT(!sh_page_has_multiple_shadows(mfn_to_page(gmfn)));
ASSERT(do_locking||shadow_locked_by_me(v->domain));
ASSERT(mfn_valid(sl1mfn));
ASSERT(!(rc&SHADOW_SET_FLUSH));
ASSERT(mfn_valid(snpmfn));
ASSERT(p_data!=NULL);
ASSERT(spin_is_locked(&irq_desc[vector].lock));
ASSERT(spin_is_locked(&desc->lock));
ASSERT(spin_is_locked(&irq_desc[irq].lock));
ASSERT(len>0);
ASSERT(FSIF_NR_READ_GNTS==FSIF_NR_WRITE_GNTS);
ASSERT(!(addr&(~PAGE_MASK_4K)));
ASSERT(pages>0);
ASSERT(spin_is_locked(&irq_desc[msi->vector].lock));
ASSERT(!reverse);
ASSERT(offset>=((*reps-1)*bytes_per_rep));
ASSERT(t->status==TIMER_STATUS_inactive);
ASSERT(nr<NR_SOFTIRQS);
ASSERT((status==not_parsed)&&(smp_processor_id()==0));
ASSERT(page->nr_validated_ptes);
ASSERT((page->u.inuse.type_info&(PGT_count_mask|PGT_validated|PGT_partial))==1);
ASSERT(rc<0);
ASSERT(!(page->u.inuse.type_info&(PGT_count_mask|PGT_validated|PGT_partial)));
ASSERT((x&PGT_count_mask)==1);
ASSERT(rc==0);
ASSERT(rc==-EINVAL);
ASSERT(spin_is_locked(&d->evtchn_lock));
ASSERT(d->is_dying==DOMDYING_dying);
ASSERT(dpci);
ASSERT(spin_is_locked(&irq_desc[domain_irq_to_vector(d,mirq)].lock));
ASSERT(spin_is_locked(&d->event_lock));
ASSERT((memory_size_mb&~0x7fff)==0);
ASSERT(is_viridian_domain(d));
ASSERT(is_viridian_domain(current->domain));
ASSERT(size==PAGE_SIZE);
ASSERT((align&(align-1))==0);
ASSERT(q>(char*)p);
ASSERT(((unsignedlong)p&(align-1))==0);
ASSERT(!(b->size&1));
ASSERT(rmrr->base_address<rmrr->end_address);
ASSERT(_raw_spin_is_locked(lock));
ASSERT(lock->recurse_cnt<0xfu);
ASSERT(opt_allow_hugepage&&!(mfn&(L1_PAGETABLE_ENTRIES-1)));
ASSERT(mfn_valid(mfn_x(gw->l3mfn)));
ASSERT(mfn_valid(mfn_x(gw->l2mfn)));
ASSERT(mfn_valid(mfn_x(gw->l1mfn)));
ASSERT(mfn_valid(mfn_x(top_mfn)));
ASSERT(!test_bit(irq,d->pirq_mask));
ASSERT(spin_is_locked(&pcidevs_lock));
ASSERT(desc);
ASSERT(spin_is_locked(&iommu->lock));
ASSERT(spin_is_locked(&hd->mapping_lock));
ASSERT(spin_is_locked(&bus2bridge_lock));
ASSERT(cpus_weight(cmd->mask)==1);
ASSERT(rw_is_locked(&pcidevs_lock));
ASSERT(desc->msi_desc==entry);
ASSERT(l1e_get_flags(*p2m_entry)&(_PAGE_PRESENT|_PAGE_PSE));
ASSERT(page!=NULL);
ASSERT(pod_target>p2md->pod.count);
ASSERT(!(mfn&(L1_PAGETABLE_ENTRIES-1)));
ASSERT(!(mfn&((1UL<<(L3_PAGETABLE_SHIFT-PAGE_SHIFT))-1)));
ASSERT((page->count_info&(PGC_allocated|PGC_count_mask))==0);
ASSERT(!(initial_images_base&~PAGE_MASK));
ASSERT(offset>=MEMBLK_HEADER_SIZE,continue);
ASSERT(memblk_is_inuse(mb),returnNULL);
ASSERT((page->count_info&~PGC_xen_heap)==0);
ASSERT(!l2_table_offset(va));
ASSERT(!l1_table_offset(v));
ASSERT(pg);
ASSERT(sp);
ASSERT(x->u.sh.type<=15);
ASSERT(callbacks[x->u.sh.type]!=NULL);
ASSERT(sp->u.sh.type>0);
ASSERT(sp->u.sh.type<SH_type_max_shadow);
ASSERT(sp->u.sh.type!=SH_type_l2_32_shadow);
ASSERT(sp->u.sh.type!=SH_type_l2_pae_shadow);
ASSERT(sp->u.sh.type!=SH_type_l2h_pae_shadow);
ASSERT(sp->u.sh.type!=SH_type_l4_64_shadow);
ASSERT(mfn_to_shadow_page(_sl1mfn)->u.sh.type==SH_type_l1_shadow||mfn_to_shadow_page(_sl1mfn)->u.sh.type==SH_type_fl1_shadow);
ASSERT(mfn_to_shadow_page(_sl2mfn)->u.sh.type==SH_type_l2_32_shadow);
ASSERT(mfn_to_shadow_page(_sl2mfn)->u.sh.type==SH_type_l2_pae_shadow||mfn_to_shadow_page(_sl2mfn)->u.sh.type==SH_type_l2h_pae_shadow);
ASSERT(mfn_to_shadow_page(_sl2mfn)->u.sh.type==SH_type_l2_64_shadow||mfn_to_shadow_page(_sl2mfn)->u.sh.type==SH_type_l2h_64_shadow);
ASSERT(mfn_to_shadow_page(_sl3mfn)->u.sh.type==SH_type_l3_64_shadow);
ASSERT(mfn_to_shadow_page(_sl4mfn)->u.sh.type==SH_type_l4_64_shadow);
ASSERT(mfn_to_shadow_page(mmfn)->u.sh.type==SH_type_monitor_table);
ASSERT(sp->count_info==0);
ASSERT(sh_type_is_pinnable(v,sp->u.sh.type));
ASSERT(mfn_to_page(_sl1mfn)->u.sh.type==SH_type_l1_shadow||mfn_to_page(_sl1mfn)->u.sh.type==SH_type_fl1_shadow);
ASSERT(mfn_to_page(_sl2mfn)->u.sh.type==SH_type_l2_32_shadow);
ASSERT(mfn_to_page(_sl2mfn)->u.sh.type==SH_type_l2_pae_shadow||mfn_to_page(_sl2mfn)->u.sh.type==SH_type_l2h_pae_shadow);
ASSERT(mfn_to_page(_sl2mfn)->u.sh.type==SH_type_l2_64_shadow||mfn_to_page(_sl2mfn)->u.sh.type==SH_type_l2h_64_shadow);
ASSERT(mfn_to_page(_sl3mfn)->u.sh.type==SH_type_l3_64_shadow);
ASSERT(mfn_to_page(_sl4mfn)->u.sh.type==SH_type_l4_64_shadow);
ASSERT(mfn_to_page(mmfn)->u.sh.type==SH_type_monitor_table);
ASSERT(!((unsignedlong)va&~PAGE_MASK));
ASSERT((page->count_info&PGC_count_mask)!=0);
ASSERT(!(sp->count_info&PGC_count_mask));
ASSERT(spin_is_locked(&heap_lock));
ASSERT(!(pg[i].count_info&PGC_offlined));
ASSERT(page_is_ram_type(page_to_mfn(pg),RAM_TYPE_CONVENTIONAL));
ASSERT((y&PGC_count_mask)!=0);
ASSERT(ioapic_pin<MAX_IOAPIC_PIN_NUM);
ASSERT(ecap_queued_inval(iommu->ecap)&&iommu_qinval);
ASSERT(va>=DIRECTMAP_VIRT_START&&va<DIRECTMAP_VIRT_END);
ASSERT(ma<DIRECTMAP_VIRT_END-DIRECTMAP_VIRT_START);
ASSERT(_x->sentinel!=~_y##_SENTINEL);ASSERT(_x->sentinel==_y##_SENTINEL);
ASSERT(_atomic_read(_c)>=0);
ASSERT(pfp);
ASSERT(obj!=NULL);
ASSERT(obj->pool!=NULL);
ASSERT(pgp->obj!=NULL);
ASSERT(list_empty(&pgp->global_eph_pages));
ASSERT(list_empty(&pgp->client_eph_pages));
ASSERT(pgp_lookup_in_obj(pgp->obj,pgp->index)==NULL);
ASSERT(pgp->obj->pool!=NULL);
ASSERT(pgp!=NULL);
ASSERT(pgp->obj->pool->client!=NULL);
ASSERT(pgp->obj->pool->client->eph_count>=0);
ASSERT(global_eph_count>=0);
ASSERT(pgp->obj->pgp_count>=0);
ASSERT(obj->pgp_count>=0);
ASSERT(rtn!=NULL);
ASSERT(rtn->slots[i]==NULL);
ASSERT(objnode->obj!=NULL);
ASSERT(pool!=NULL);
ASSERT(obj->pgp_count==0);
ASSERT((long)obj->objnode_count==0);
ASSERT(obj->tree_root.rnode==NULL);
ASSERT(pool->obj_count>=0);
ASSERT(obj->no_evict==0);
ASSERT(is_shared(pool));
ASSERT(pool->shared_count==0);
ASSERT(sl->client!=old_client);
ASSERT(poolid!=MAX_POOLS_PER_DOMAIN);
ASSERT(pool->client!=NULL);
ASSERT(client!=NULL);
ASSERT(pgp_del==pgp);
ASSERT(pgp->pfp!=NULL);
ASSERT(pgp->size!=-1);
ASSERT(pgpfound==pgp);
ASSERT((obj!=NULL)&&((objnew==obj)||(objfound==obj))&&(objnew!=objfound));
ASSERT(ret!=-EEXIST);
ASSERT(pgp->pfp==NULL);
ASSERT(((objnew==obj)||(objfound==obj))&&(objnew!=objfound));
ASSERT((obj!=NULL)&&(pgp!=NULL)&&(pgp->index!=-1));
ASSERT(pgp==pgpdel);
ASSERT(pfp!=NULL);
ASSERT(ret==LZO_E_OK);
ASSERT(out_len==PAGE_SIZE);
ASSERT(IS_VALID_PAGE(pi));
ASSERT(IS_PAGE_ALIGNED(page_va));
ASSERT(!pool->init_region);
ASSERT((pi==NULL)||IS_VALID_PAGE(pi));
ASSERT(size<tmh_mempool_maxalloc);
ASSERT(cmem_mempool!=NULL);
ASSERT((pi->count_info&~(PGC_allocated|1))==0);
ASSERT(size<PAGE_SIZE);
ASSERT(tmh_mempool!=NULL);
ASSERT(0);
ASSERT(!tx->closed);
ASSERT(!bitmap_in_use(lru));
ASSERT(!bitmap_locked(bm));
ASSERT(!bitmap_in_use(bm));
ASSERT(i<VHD_CACHE_SIZE);
ASSERT(bm&&bitmap_valid(bm));
ASSERT(req->treq.secs==0);
ASSERT(!test_vhd_flag(s->bat.status,VHD_FLAG_BAT_WRITE_STARTED));
ASSERT(bat_locked(s));
ASSERT(bat_entry(s,blk)==DD_BLK_UNUSED);
ASSERT(s->bat.pbw_blk==blk);
ASSERT(offset!=DD_BLK_UNUSED);
ASSERT(test_batmap(s,blk)||(bm&&bitmap_valid(bm)));
ASSERT(bm&&bitmap_valid(bm));
ASSERT(vhd_type_dynamic(&s->vhd));
ASSERT(!get_bitmap(s,blk));
ASSERT(bm&&bitmap_valid(bm)&&
!test_vhd_flag(bm->status,VHD_FLAG_BM_WRITE_PENDING));
ASSERT(bat_locked(s)&&s->bat.pbw_blk==blk);
ASSERT(bm&&test_vhd_flag(bm->status,VHD_FLAG_BM_READ_PENDING));
ASSERT(0);
ASSERT(bm->blk==s->bat.pbw_blk);
ASSERT(test_vhd_flag(s->bat.status,
VHD_FLAG_BAT_WRITE_STARTED));
ASSERT(bat_locked(s)&&
test_vhd_flag(s->bat.status,VHD_FLAG_BAT_WRITE_STARTED));
ASSERT(test_vhd_flag(tx->status,VHD_FLAG_TX_LIVE));
ASSERT(bm&&bitmap_valid(bm)&&bitmap_locked(bm));
ASSERT(tmp.op==VHD_OP_DATA_READ||
tmp.op==VHD_OP_DATA_WRITE);
ASSERT(tx->closed);
ASSERT(test_vhd_flag(bm->status,VHD_FLAG_BM_WRITE_PENDING));
ASSERT(bm&&bitmap_valid(bm)&&bitmap_locked(bm));
ASSERT(!req->next);
ASSERT(list_empty(&vreq->next));
ASSERT(vreq->secs_pending==0);
ASSERT(dirty_vram->sl1ma[i]==sl1ma);
ASSERT(guest_kernel_mode(v,regs));
ASSERT(pt->source==PTSRC_isa);
ASSERT(!page_state_is(&pg[i],offlined));
ASSERT(cpu_isset(nxt,per_cpu(cpu_core_map,cpu)));
ASSERT(!cpu_isset(nxt,per_cpu(cpu_core_map,cpu)));
ASSERT(rc<=0);
ASSERT(rc<n);
ASSERT(i<count);
ASSERT(!guest_handle_is_null(cnt_uop));
ASSERT(rc<count);
ASSERT(!p2m_is_valid(t)||mfn+i==mfn_x(mfn_return));
ASSERT(hvm_irq_dpci);
ASSERT(key_table[key]==NULL);
ASSERT(client->eph_count>=0);
ASSERT(client==NULL);
ASSERT(!test_bit(pirq,d->pirq_mask));
ASSERT(spin_is_locked(&irq_desc[domain_pirq_to_irq(d,mirq)].lock));
ASSERT(apic<nr_ioapics);
ASSERT(irq>0);
ASSERT(svc==CSCHED_VCPU(per_cpu(schedule_data,svc->vcpu->processor).curr));
ASSERT(order==0||ret==GUEST_TABLE_NORMAL_PAGE);
ASSERT(ret!=GUEST_TABLE_POD_PAGE||i!=walk_level);
ASSERT(i==1);
ASSERT(i==0);
ASSERT(spin_is_locked(&iommu->register_lock));
ASSERT(ivrs_mappings!=NULL);
ASSERT(bdf<ivrs_bdf_entries);
ASSERT(j);
ASSERT(va>=DIRECTMAP_VIRT_START);
ASSERT(va-DIRECTMAP_VIRT_START<DIRECTMAP_VIRT_END);
ASSERT((unsignedlong)pg-FRAMETABLE_VIRT_START<FRAMETABLE_VIRT_END);
ASSERT(va<XEN_VIRT_END);
ASSERT(!(s&((1<<L2_PAGETABLE_SHIFT)-1)));
ASSERT(MSI_IRQ(irq));
ASSERT(sizeof(grant_entry_v1_t)==8);
ASSERT(t->gt_version!=0);
ASSERT(gt->gt_version!=0);
ASSERT(pcpu.apic_id!=BAD_APICID);
ASSERT(g_info->apic_id!=BAD_APICID);
ASSERT((dirty_vram->sl1ma[i]&PAGE_MASK);==(sl1ma&PAGE_MASK));
ASSERT(tmh_page_list_pages==0);
ASSERT(scale.mul_frac!=0);
ASSERT(spin_is_locked(&ir_ctrl->iremap_lock));
ASSERT(trap<=VCPU_TRAP_LAST);
ASSERT(total_avail_pages>=0);
ASSERT(p2m_locked_by_me(p2md));
ASSERT((info->cur+(1UL<<PAGETABLE_ORDER)<info->epfn)&&info->cur>=info->spfn);
ASSERT(l3e_get_flags(l3_ro_mpt[l3_table_offset(va)])&_PAGE_PRESENT);
ASSERT(l4e_get_flags(idle_pg_table[l4_table_offset(RO_MPT_VIRT_START)]);&_PAGE_PRESENT);
ASSERT(!(l3e_get_flags(l3_ro_mpt[l3_table_offset(va)])&_PAGE_PSE));
ASSERT(l3e_get_flags(l3_ro_mpt[l3_table_offset(HIRO_COMPAT_MPT_VIRT_START)])&_PAGE_PRESENT);
ASSERT(l1e_get_flags(l2e_to_l1e(l2e)[l1_table_offset(sva)])&_PAGE_PRESENT);
ASSERT(!(e&((1<<L2_PAGETABLE_SHIFT)-1)));
ASSERT(pfn_to_pdx(epfn)<=(DIRECTMAP_SIZE>>PAGE_SHIFT)&&(pfn_to_pdx(epfn)<=FRAMETABLE_SIZE/sizeof(structpage_info)));
ASSERT(pod_target>=p2md->pod.count);
ASSERT((table!=NULL)&&(offset<INTREMAP_ENTRIES));
ASSERT(victim!=NULL);
ASSERT(page_get_owner(page)==dom_cow);
ASSERT(order==0);
ASSERT(v->domain->domain_id==d->domain_id);
ASSERT(page_make_private(d,page)==0);
ASSERT(set_shared_p2m_entry(d,gfn,page_to_mfn(page))!=0);
ASSERT(p2m_is_shared(ot));
ASSERT(gpfn!=SHARED_M2P_ENTRY);
ASSERT(gfn!=SHARED_M2P_ENTRY);
ASSERT(mfn_valid(mfn_x(*mfn)));
ASSERT(shr_lock.locker==-1);
ASSERT(shr_lock.locker==current->processor);
ASSERT(list_empty(&ce->gfns));
ASSERT(!(virt_to_page(rawbuf)->count_info&PGC_allocated));
ASSERT(sp<(NR_DYNAMIC_VECTORS-1));
ASSERT(d);
ASSERT(error!=-EBUSY);
ASSERT(l3e_get_pfn(l3e)!=INVALID_MFN||!p2m_is_ram(p2mt));
ASSERT(!(level>2&&(l1e_get_flags(*p)&_PAGE_PRESENT)&&(l1e_get_flags(*p)&_PAGE_PSE)));
ASSERT(tmh_dedup_enabled());
ASSERT(firstbyte!=NOT_SHAREABLE);
ASSERT(firstbyte<256);
ASSERT(list_empty(&pcd->pgp_list));
ASSERT(!pgp->obj->pool->persistent);
ASSERT(pfp_size<=PAGE_SIZE);
ASSERT(pcd->pfp!=NULL);
ASSERT(tmh_tze_enabled());
ASSERT(pgp->pcd->pgp_ref_count==1||pgp->eviction_attempted);
ASSERT(len<=PAGE_SIZE);
ASSERT(len>0||tmem_va==NULL);
ASSERT(p1!=NULL);
ASSERT(p2!=NULL);
ASSERT(len1<=PAGE_SIZE);
ASSERT(len2<=PAGE_SIZE);
ASSERT(len1==len2);
ASSERT(pfp_len<=PAGE_SIZE);
ASSERT(tze_len<=PAGE_SIZE);
ASSERT(pfp_len==tze_len);
ASSERT(spin_is_locked(per_cpu(schedule_data,v->processor).schedule_lock));
ASSERT(spin_is_locked(per_cpu(schedule_data,cpu).schedule_lock));
ASSERT(vmce);
ASSERT(vmce&&vmce->mci_ctl);
ASSERT(mig);
ASSERT(spin_is_locked(&ch->lock));
ASSERT(ch==per_cpu(cpu_bc_channel,cpu));
ASSERT((cpu!=0)&&cpu_online(0));
ASSERT(pagetable_get_pfn(p2m_get_pagetable(hostp2m))!=0);
ASSERT(pagetable_get_pfn(p2m_get_pagetable(p2m_get_hostp2m(d)))!=0);
ASSERT(opt_allow_superpage);
ASSERT(t->status==TIMER_STATUS_invalid);
ASSERT(timer->status==TIMER_STATUS_inactive);
ASSERT(timer->status>=TIMER_STATUS_inactive);
ASSERT(timer->status<=TIMER_STATUS_in_list);
ASSERT(cpu_isset(cpu,timer_valid_cpumask));
ASSERT(cpu_isset(old_cpu,timer_valid_cpumask));
ASSERT(cpu_isset(new_cpu,timer_valid_cpumask));
ASSERT(handler_num);
ASSERT(i!=handler_num);
ASSERT(tmh->domain->is_dying);
ASSERT(paging_mode_shadow(d));
ASSERT((target==2&&hvm_hap_has_1gb(d))||(target==1&&hvm_hap_has_2mb(d))||(target==0));
ASSERT(ret!=GUEST_TABLE_POD_PAGE||i!=target);
ASSERT(is_epte_superpage(ept_entry));
ASSERT(is_epte_superpage(epte));
ASSERT(index<EPT_PAGETABLE_ENTRIES);
ASSERT(i==target);
ASSERT(x2apic_enabled);
ASSERT(smp_processor_id()==0);
ASSERT(smp_processor_id()!=0);
ASSERT(rings!=NULL);
ASSERT(len<=XENSTORE_PAYLOAD_MAX);
ASSERT(cpumask_weight(cmd->mask)==1);
ASSERT(!nodemask_retry);
ASSERT(p2m_locked_by_me(p2m_get_hostp2m(d)));
ASSERT(set_shared_p2m_entry(p2m,gfn,page_to_mfn(page))!=0);
ASSERT(p2m);
ASSERT(p2m->alloc_page);
ASSERT(p2m_locked_by_me(p2m));
ASSERT(pod_target>=p2m->pod.count);
ASSERT(paging_mode_translate(p2m->domain));
ASSERT(sp->u.sh.head||(shadow_type>SH_type_max_shadow));
ASSERT(!mfn_valid(smfn)||mfn_to_page(smfn)->u.sh.head);
ASSERT(mfn_to_page(smfn)->u.sh.head);
ASSERT(mfn_to_page(sl1mfn)->u.sh.head);
ASSERT(sp->u.sh.head);
ASSERT(mfn_to_page(sl2mfn)->u.sh.head);
ASSERT(mfn_to_page(sl3mfn)->u.sh.head);
ASSERT(mfn_to_page(sl4mfn)->u.sh.head);
ASSERT(p&&p->u.sh.type==SH_type_l2_32_shadow);
ASSERT(!p||p->u.sh.head);
ASSERT(h.tail->u.sh.type==SH_type_l2_32_shadow);
ASSERT(h.next->list.prev==PAGE_LIST_NULL);
ASSERT(h.tail->list.next==PAGE_LIST_NULL);
ASSERT(pg->u.sh.type==SH_type_l1_32_shadow||pg->u.sh.type==SH_type_fl1_32_shadow||pg->u.sh.type==SH_type_l2_32_shadow);
ASSERT(pg->u.sh.type==SH_type_l2_32_shadow||pg->u.sh.head);
ASSERT(pg->list.next!=PAGE_LIST_NULL);
ASSERT(mfn_to_page(next)->u.sh.type==pg->u.sh.type);
ASSERT(!mfn_to_page(next)->u.sh.head);
ASSERT(pgp->us.obj!=NULL);
ASSERT(pgp->us.obj->pool!=NULL);
ASSERT(!pgp->us.obj->pool->persistent);
ASSERT(pgp->us.obj->pool->client!=NULL);
ASSERT(pgp_lookup_in_obj(pgp->us.obj,pgp->index)==NULL);
ASSERT(list_empty(&pgp->us.client_eph_pages));
ASSERT(pgp->us.obj->pgp_count>=0);
ASSERT(mfn_x(r_mfn)==mfn_x(mfn));
ASSERT(dir==IOREQ_READ);
ASSERT(!mfn_valid(mfn)||p2mt!=p2m_mmio_direct);
ASSERT(!dev->msix_used_entries);
ASSERT(!in_atomic());
ASSERT(list_empty(&wqv->list));
ASSERT(p2m->domain);
ASSERT(p2m->domain->arch.paging.alloc_page);
ASSERT(spin_is_locked(&cpupool_lock));
ASSERT(is_idle_vcpu(current));
ASSERT(paging_mode_log_dirty(d));
ASSERT(is_hvm_domain(d)&&d->arch.hvm_domain.hap_enabled);
ASSERT(!cpu_online(old_cpu)&&cpu_online(new_cpu));ASSERT(FS_RING_FREE_REQUESTS(&import->ring,idx));ASSERT(FS_RING_FREE_REQUESTS(&import->ring,idx));
ASSERT(!is_idle_vcpu(v));
ASSERT((unsignedlong)v!=0xfffff000);
ASSERT(p2m->domain->arch.paging.free_page);
ASSERT(spin_is_locked(&hd->mapping_lock)&&is_hvm_domain(d));
ASSERT(xsave_cntxt_size>=XSAVE_AREA_MIN_SIZE);
ASSERT(v->arch.xsave_area);
ASSERT(cpumask_empty(n->vcpu_dirty_cpumask));
ASSERT(nv->nv_vvmcx!=NULL);
ASSERT(nv->nv_vvmcxaddr!=VMCX_EADDR);
ASSERT(n1vmcb!=NULL);
ASSERT(n2vmcb!=NULL);
ASSERT(ns_viomap!=NULL);
ASSERT(ns_vmcb!=NULL);
ASSERT(nv->nv_n2vmcx!=NULL);
ASSERT(nv->nv_n2vmcx_pa!=VMCX_EADDR);
ASSERT(vcpu_nestedhvm(v).nv_vvmcx!=NULL);
ASSERT(regs!=NULL);
ASSERT(nv->nv_vmexit_pending==0);
ASSERT(vcpu_nestedhvm(v).nv_vmswitch_in_progress);
ASSERT(nestedhvm_vcpu_in_guestmode(v));
ASSERT(!nestedhvm_vcpu_in_guestmode(v));
ASSERT(v->arch.hvm_svm.vmcb!=NULL);
ASSERT(nv->nv_n1vmcx!=NULL);
ASSERT(nv->nv_n1vmcx_pa!=VMCX_EADDR);
ASSERT(!nv->nv_vmexit_pending);
ASSERT(gvmcb!=NULL);
ASSERT(nestedhvm_enabled(v->domain));
ASSERT(svm->ns_gif==0);
ASSERT(vvmcb!=NULL);
ASSERT(nestedhvm_enabled(v->domain)&&nestedhvm_vcpu_in_guestmode(v));
ASSERT(p2m->set_entry);
ASSERT(lru_index>=0);
ASSERT(v->domain==d);
ASSERT((_domain)->arch.nested_p2m_locker==-1);
ASSERT(nestedp2m_locked_by_me(_domain));
ASSERT(vcpu_nestedhvm(v).nv_vmexit_pending==0);
ASSERT(boot_cpu_has(X86_FEATURE_TSC_RELIABLE));
ASSERT(cpu_has_svm_nrips);
ASSERT(!pirq->masked);
ASSERT(MSI_IRQ(desc-irq_desc));
ASSERT(pirq_dpci->flags&HVM_IRQ_DPCI_GUEST_MSI);
ASSERT(pirq==pirq_info(d,domain_irq_to_pirq(d,irq)));
ASSERT(irq==pirq->arch.irq);
ASSERT(d->arch.hvm_domain.irq.dpci);
ASSERT((val<=(LONG_MAX>>2))&&(val>=(LONG_MIN>>2)));
ASSERT(((long)ptr&0x3)==0x2);
ASSERT(xsave_cntxt_size>=XSTATE_AREA_MIN_SIZE);
ASSERT((_ptr>>2)==val);
ASSERT(!boot_cpu_has(X86_FEATURE_TSC_RELIABLE));
ASSERT(!(mfn_to_page(mfn)->count_info&PGC_allocated));
ASSERT(info->tables_nr<MAX_TABLES);/sizeof(l1_pgentry_t));/sizeof(l1_pgentry_t));
ASSERT(!p2m_is_nestedp2m(p2m));
ASSERT(shr_locked_by_me());
ASSERT(l->locker==-1);
ASSERT(l->locker==current->processor);
ASSERT(paging_locked_by_me(d));
ASSERT(paging_locked_by_me(v->domain));
ASSERT(!paging_locked_by_me(v->domain));
ASSERT(pfn_to_pdx(ma>>PAGE_SHIFT)<(DIRECTMAP_SIZE>>PAGE_SHIFT));
ASSERT(p2m_is_nestedp2m(p2m));
ASSERT(page_list_empty(&p2m->pod.super));
ASSERT(page_list_empty(&p2m->pod.single));
ASSERT(!list_empty(lru_list));
ASSERT(v->domain==p2m->domain);
ASSERT(test_bit(vector,cfg->used_vectors));
ASSERT(!test_bit(vector,cfg->used_vectors));
ASSERT(spin_is_locked(&hd->mapping_lock)&&pt_mfn);
ASSERT(!test_bit(vector,ret));
ASSERT((cfg->used_vectors==NULL);||(cfg->used_vectors==irq_used_vectors));
ASSERT(!test_bit(vector,desc->chip_data->used_vectors));
ASSERT(per_cpu(vector_irq,cpu)[cfg->old_vector]==irq);
ASSERT(guest_l1e_get_flags(gw->l1e)&_PAGE_PRESENT);
ASSERT(seg!=-1||bus==-1);
ASSERT(bus!=-1||devfn==-1);
ASSERT(per_cpu(vector_irq,cpu)[vector]==irq);
ASSERT(per_cpu(vector_irq,cpu)[old_vector]==irq);
ASSERT(test_bit(old_vector,cfg->used_vectors));
ASSERT(!test_bit(vector,desc->arch.used_vectors));
ASSERT(test_bit(vector,desc->arch.used_vectors));
ASSERT(d->processor<nr_cpu_ids);
ASSERT(cpu<nr_cpu_ids);
ASSERT(!cpumask_empty(&cpus)&&cpumask_test_cpu(cpu,&cpus));
ASSERT(cpumask_test_cpu(nxt,&per_cpu(cpu_core_map,cpu)));
ASSERT(!cpumask_test_cpu(nxt,&per_cpu(cpu_core_map,cpu)));
ASSERT(cpumask_empty(action->cpu_eoi_map));
ASSERT(cpumask_test_cpu(nxt,per_cpu(cpu_core_mask,cpu)));
ASSERT(!cpumask_test_cpu(nxt,per_cpu(cpu_core_mask,cpu)));
ASSERT(test_bit(old_vector,desc->arch.used_vectors));||(cfg->used_vectors==irq_used_vectors));
ASSERT((desc->arch.used_vectors==NULL);||(desc->arch.used_vectors==irq_used_vectors));
ASSERT(cpumask_weight(&dirty_mask)<=1);
ASSERT(pdev!=NULL);
ASSERT(iommu->mmio_base);ASSERT(order==0||order==9||order==18);ASSERT(order==0||order==9||order==18);ASSERT(order==0||order==9||order==18);ASSERT(order==0||order==9||order==18);
ASSERT(wqv->esp==0);
ASSERT(gpfn==gfn);
ASSERT((((unsignedlong)va)>=MAPCACHE_VIRT_START)&&(((unsignedlong)va)<=MAPCACHE_VIRT_END));
ASSERT(!(req->flags&MEM_EVENT_FLAG_VCPU_PAUSED));
ASSERT(consumer_is_xen(lchn));
ASSERT(access_w||access_r||access_x);
ASSERT((!writeable)||((page_type_count(page)!=0)&&((page->flags&PG_type_mask)==PGT_writeable_page)));((page_type_count(page)!=0)&&(((page_type_count(page)&~REFCNT_PIN_BIT)!=0)&&
ASSERT((!writeable)||((page->flags&PG_type_mask)==PGT_writeable_page)&&((page->flags&PG_need_flush)==PG_need_flush)));(((page_type_count(page)&~REFCNT_PIN_BIT)!=0)&&((page_type_count(page)!=0)&&
ASSERT((!writeable)||((page->flags&PG_type_mask)==PGT_writeable_page)&&((page->flags&PG_need_flush)==PG_need_flush)));
ASSERT(((void*)ch->next<(void*)&_end)||memguard_is_guarded(ch->next))
ASSERT((_p)->u.domain==(_d))void*memguard_init(void*heap_start);
ASSERT((_p)->u.domain==(_d))void*memguard_init(void*heap_start)
ASSERT(((_p)->u.inuse.type_info&PGT_type_mask)==(_t))
ASSERT((_p)->u.inuse.domain==(_d))frame_table[mfn].type_and_flags);
ASSERT((_p)->u.inuse.domain==(_d))frame_table[mfn].u.inuse.type_info);
ASSERT((sizeof(structpfn_info)<<20)<=add_to_domain_alloc_list(dom0_memory_end,max_page<<PAGE_SHIFT);--a/xen/include/asm-x86/page.hTueJul2714:55:172004+0000++b/xen/include/asm-x86/page.hTueJul2719:37:362004+0000--a/xen/include/xen/mm.hTueJul2714:55:172004+0000++b/xen/include/xen/mm.hTueJul2719:37:362004+0000/*page_alloc.c*/
ASSERT((_p)->u.inuse.domain==(_d))diff-r9975cd31ac46-r613602e2d771xen/include/asm-x86/page.hdiff-r9975cd31ac46-r613602e2d771xen/include/xen/mm.h#ifndef__XEN_MM_H__voidinit_page_allocator(unsignedlongmin,unsignedlongmax);
ASSERT((_p)->u.inuse.domain==(_d))diff-r9975cd31ac46-r613602e2d771xen/include/asm-x86/page.hdiff-r9975cd31ac46-r613602e2d771xen/include/xen/mm.h#ifndef__XEN_MM_H__unsignedlongbitmap_start,unsignedlongmax_pages);
ASSERT((sizeof(structpfn_info)<<20)<=add_to_domain_alloc_list(dom0_memory_end,max_page<<PAGE_SHIFT);--a/xen/include/asm-x86/page.hTueJul2715:04:592004+0000++b/xen/include/asm-x86/page.hTueJul2719:37:432004+0000--a/xen/include/xen/mm.hTueJul2715:04:592004+0000++b/xen/include/xen/mm.hTueJul2719:37:432004+0000/*page_alloc.c*/
ASSERT((_p)->u.inuse.domain==(_d))diff-r9711b428cf6a-r1e13ae874e9cxen/include/asm-x86/page.hdiff-r9711b428cf6a-r1e13ae874e9cxen/include/xen/mm.h#ifndef__XEN_MM_H__voidinit_page_allocator(unsignedlongmin,unsignedlongmax);
ASSERT((_p)->u.inuse.domain==(_d))diff-r9711b428cf6a-r1e13ae874e9cxen/include/asm-x86/page.hdiff-r9711b428cf6a-r1e13ae874e9cxen/include/xen/mm.h#ifndef__XEN_MM_H__unsignedlongbitmap_start,unsignedlongmax_pages);
ASSERT((sizeof(structpfn_info)<<20)<=add_to_domain_alloc_list(dom0_memory_end,max_page<<PAGE_SHIFT);
ASSERT((_p)->u.inuse.domain==(_d))rc=gnttab_try_map(e,d,page,l1v&_PAGE_RW);
ASSERT((_p)->u.inuse.domain==(_d))e,d,pfn,(l1v&_PAGE_RW)?GNTTAB_MAP_RW:GNTTAB_MAP_RO);K
ASSERT(vm_map_pmap(&l->l_proc->p_vmspace->vm_map)!=pmap_kernel());K
ASSERT(vm_map_pmap(&l->l_proc->p_vmspace->vm_map)!=ci->ci_pmap||ci->ci_tlbstate!=TLBSTATE_VALID);KD
ASSERT((opte&PG_FRAME)!=(KERNTEXTOFF-KERNBASE_LOCORE));/*KD
ASSERT(sc->sc_net_idx->tx_req_prod==*//*TX_RING_ADD(sc->sc_net_idx->tx_resp_prod,sc->sc_tx_entries));*/K
ASSERT(sc->sc_net_idx->tx_req_prod==*//*TX_RING_ADD(sc->sc_net_idx->tx_resp_prod,sc->sc_tx_entries));*/
ASSERT(((page->u.inuse.type_info&PGT_va_mask)>>PGT_va_shift)<(PAGE_OFFSET>>L2_PAGETABLE_SHIFT));
ASSERT((x&PGT_validated)||test_bit(DF_DYING,&page->u.inuse.domain->d_flags));
ASSERT(virt_to_machine(MMAP_VADDR(pending_idx,i))==buffer_mach+i<<PAGE_SHIFT);
ASSERT((x&PGT_validated)||test_bit(DF_DYING,&page_get_owner(page)->d_flags))
ASSERT(((_p)->count_info&PGC_count_mask)!=0)
ASSERT(page_get_owner(_p)==(_d))unsignedlongflags);
ASSERT(page_get_owner(_p)==(_d))externvoidshadow_l2_normal_pt_update(unsignedlongpa,unsignedlonggpte);
ASSERT(page_get_owner(_p)==(_d))externvoidshadow_l2_normal_pt_update(unsignedlongpa,unsignedlonggpde);
ASSERT(virt_to_machine(MMAP_VADDR(pending_idx,i))==buffer_mach+i<<PAGE_SHIFT);K
ASSERT(page_get_owner(_p)==(_d))voidmemguard_guard_stack(void*p);
ASSERT(((_p)->u.inuse.type_info&PGT_count_mask)!=0)voidpropagate_page_fault(unsignedlongaddr,u16error_code);
ASSERT(((_p)->u.inuse.type_info&PGT_count_mask)!=0)voidaudit_domain(structdomain*d);--a/xen/include/asm-x86/shadow.hTueMar1508:15:002005+0000++b/xen/include/asm-x86/shadow.hTueMar1510:12:392005+0000
ASSERT(((_p)->u.inuse.type_info&PGT_count_mask)!=0)diff-r2d50ee7a068d-r5f0125b2f3a9xen/include/asm-x86/shadow.hexternvoidvmx_shadow_clear_state(structdomain*);--a/xen/include/asm-x86/shadow.hMonMar1422:10:102005+0000++b/xen/include/asm-x86/shadow.hTueMar1512:31:322005+0000
ASSERT(((_p)->u.inuse.type_info&PGT_count_mask)!=0)diff-rdff04529e881-r4ff298f651dexen/include/asm-x86/shadow.hexternvoidvmx_shadow_clear_state(structdomain*);
ASSERT(((_p)->u.inuse.type_info&PGT_count_mask)!=0)voidaudit_domain(structdomain*d);
ASSERT(d==page_get_owner(&frame_table[pagetable_val(d->arch.phys_table)>>PAGE_SHIFT]));K
ASSERT(!(trig==INTR_TRIGGER_CONFORM||pol==INTR_POLARITY_CONFORM),("%s:Conformingtriggerorpolarityn",__func__));K
ASSERT(!(trig==INTR_TRIGGER_CONFORM||pol==INTR_POLARITY_CONFORM),("%s:Conformingtriggerorpolaritytrig==INTR_TRIGGER_EDGE?"edge":"level");K
ASSERT(trunc_page(addr)==addr,("localAPICnotalignedonapageboundary"));K
ASSERT(!lapics[apic_id].la_present,("duplicatelocalAPIC%u",apic_id));K
ASSERT(lapics[apic_id].la_present,("%s:APIC%udoesn'texist",__func__,apic_id));K
ASSERT(cluster<=APIC_MAX_CLUSTER,("%s:cluster%utoobig",__func__,cluster));K
ASSERT(cluster_id<=APIC_MAX_INTRACLUSTER_ID,return(EINVAL);K
ASSERT(lapics[apic_id].la_present,("%s:missingAPIC%u",__func__,apic_id));K
ASSERT(vector>=APIC_IO_INTS&&vector!=IDT_SYSCALL&&vector<=APIC_IO_INTS+NUM_IO_INTS,("Vector%udoesnotmaptoanIRQline",vector));K
ASSERT((dest&~(APIC_ID_MASK>>APIC_ID_SHIFT))==0,("%s:invaliddestfield",__func__));K
ASSERT((icrlo&APIC_ICRLO_RESV_MASK)==0,("%s:reservedbitssetinICRLOregister",__func__));K
ASSERT((vector&~APIC_VECTOR_MASK)==0,("%s:invalidvector%d",__func__,vector));K
ASSERT((dest&~(APIC_ID_MASK>>APIC_ID_SHIFT))==0,("%s:invaliddestination0x%x",__func__,dest));K
ASSERT(cpu_info[apic_id].cpu_present==0,("CPU%daddedtwice",apic_id));K
ASSERT(boot_cpu_id==-1,("CPU%dclaimstobeBSP,butCPU%dalreadyis",apic_id,boot_cpu_id));K
ASSERT(boot_cpu_id==PCPU_GET(apic_id),("BSP'sAPICIDdoesn'tmatchboot_cpu_id"));K
ASSERT(i<mp_ncpus,("mp_ncpusandactualcpusareoutofwhack"));K
ASSERT(cpu_apic_ids[cpu]!=-1,("IPItonon-existentCPU%d",cpu));K
ASSERT(args->bus<=mptable_maxbusid,("bus%distoobig",args->bus));n",K
ASSERT(args->vector==-1,args->bus,args->irq>>2,'A'+(args->irq&0x3),args->vector,vector));K
ASSERT(((vm_offset_t)pmap->pm_pdpt&((NPGPTD*sizeof(pdpt_entry_t))-1))==0,("pmap_pinit:pdptmisaligned"));K
ASSERT(pmap_kextract((vm_offset_t)pmap->pm_pdpt)<(4ULL<<30),("pmap_pinit:pdptabove4g"));K
ASSERT((flags&(M_NOWAIT|M_WAITOK))==M_NOWAIT||(flags&(M_NOWAIT|M_WAITOK))==M_WAITOK,("_pmap_allocpte:flagsisneitherM_NOWAITnorM_WAITOK"));K
ASSERT((flags&(M_NOWAIT|M_WAITOK))==M_NOWAIT||(flags&(M_NOWAIT|M_WAITOK))==M_WAITOK,("pmap_allocpte:flagsisneitherM_NOWAITnorM_WAITOK"));K
ASSERT(pmap->pm_stats.resident_count==0,("pmap_release:pmapresidentcount%ld!=0",pmap->pm_stats.resident_count));K
ASSERT(VM_PAGE_TO_PHYS(m)==(pmap->pm_pdpt[i]&PG_FRAME),("pmap_release:gotwrongptdpage"));K
ASSERT(object->type==OBJT_DEVICE,("pmap_object_init_pt:non-deviceobject"));K
ASSERT(m<&vm_page_array[vm_page_array_size],pte_clear(pte);K
ASSERT(cold||td->td_ucred!=NULL,("kerneltrapdoesn'thaveucred"));K
ASSERT((buffer_ma&(XBD_SECTOR_SIZE-1))==0,("XENbuffermustbesectoraligned"));K
ASSERT(lsect<=7,("XENdiskdriverdatacannotcrossapageboundary"));K
ASSERT(id!=0,("alloc_rx_buffers:foundfreereceiveindexof0n"))
K
ASSERT(i,("nombufsprocessed"));K
ASSERT(rx->id!=0,("xn_rxeof:foundfreereceiveindexof0n"));K
ASSERT(p1->p_tracecred!=NULL,("ktracevnodewithnocred"));K
ASSERT(id!=0,("alloc_rx_buffers:foundfreereceiveindexof0n"));K
ASSERT(p1->p_tracecred!=NULL,("ktracevnodewithnocred"));
ASSERT((sizeof(structpfn_info)<<20)<=(FRAMETABLE_VIRT_END-FRAMETABLE_VIRT_START));K
ASSERT(id!=0,("alloc_rx_buffers:foundfreereceiveindexof0xn_rx_mcl[i].args[0]=(unsignedlong)mtod(m_new,vm_offset_t);K
ASSERT(rx->id!=0,("xn_rxeof:foundfreereceiveindexof0n",rx->status);K
ASSERT((inf->period<ULONG_MAX)&&(inf->slice_orig<ULONG_MAX));
ASSERT((WEIGHT_PERIOD<ULONG_MAX)&&(DOM_INFO(p)->slice_orig<ULONG_MAX));
ASSERT(VM_PAGE_TO_PHYS(m)==(pmap->pm_pdpt[i]&PG_FRAME),("pmap_release:gotwrongptdpage"));
ASSERT(((pg[i].u.inuse.type_info&PGT_count_mask)==0)||shadow_lock(d);
ASSERT((WEIGHT_PERIOD<ULONG_MAX)&&(EDOM_INFO(p)->slice_orig<ULONG_MAX));
ASSERT((x&PGT_validated)||test_bit(DF_DYING,&page_get_owner(page)->flags));
ASSERT(virt_to_mfn(MMAP_VADDR(pending_idx,i))==((buffer_mach>>PAGE_SHIFT)+i));
ASSERT(virt_to_mfn(MMAP_VADDR(pending_idx,i))==((buffer_mach>>PAGE_SHIFT)+i))
ASSERT(VM_ASSIST(d,VMASST_TYPE_writable_pagetables)||shadow_mode_write_all(d))
ASSERT(shadow_mode_write_l1(d)||shadow_mode_write_all(d)||shadow_mode_wr_pt_pte(d));K
ASSERT(d==page_get_owner(mfn_to_page(pagetable_get_pfn(page=list_entry(list_ent,structpfn_info,list);
ASSERT((x&PGT_validated)||test_bit(_DOMF_dying,&page_get_owner(page)->domain_flags));diff-rdc50cdd66c5c-r0ed4a312765btools/xm-test/tests/sedf/Makefile.am--a/tools/xm-test/tests/sedf/Makefile.amTueMar1413:10:212006-0700SUBDIRS=TESTS=01_sedf_multi_pos.testXFAIL_TESTS=diff-rdc50cdd66c5c-r0ed4a312765bxen/Makefile--a/xen/MakefileTueMar1413:10:212006-0700#Allotherplacesthisisstored(eg.compile.h)shouldbeautogenerated.exportXEN_VERSION=3exportXEN_SUBVERSION=0exportXEN_EXTRAVERSION=.0exportXEN_FULLVERSION=$(XEN_VERSION).$(XEN_SUBVERSION)$(XEN_EXTRAVERSION)exportBASEDIR:=$(CURDIR)diff-rdc50cdd66c5c-r0ed4a312765bxen/Rules.mk--a/xen/Rules.mkTueMar1413:10:212006-0700#'makeclean'beforerebuilding.#verbose?=ndebug?=nperfc?=nperfc_arrays?=ncrash_debug?=nCFLAGS+=-g-D__XEN__ifneq($(debug),y)CFLAGS+=-DNDEBUGifeq($(verbose),y)CFLAGS+=-DVERBOSEendifelseCFLAGS+=-DVERBOSEendifdiff-rdc50cdd66c5c-r0ed4a312765bxen/arch/ia64/Rules.mk--a/xen/arch/ia64/Rules.mkTueMar1413:10:212006-0700I$(BASEDIR)/include/asm-ia64/linux-nullI$(BASEDIR)/arch/ia64/linux-I$(BASEDIR)/arch/ia64/linux-xenCFLAGS:=-nostdinc-fno-builtin-fno-common-fno-strict-aliasing#CFLAGS+=-O3#-O3over-inlinesmakingdebuggingtough!CFLAGS+=-O2#butnooptimizationcausescompileerrors!#CFLAGS+=-iwithprefixinclude-Wall-DMONITOR_BASE=$(MONITOR_BASE)diff-rdc50cdd66c5c-r0ed4a312765bxen/arch/ia64/vmx/vmx_hypercall.c--a/xen/arch/ia64/vmx/vmx_hypercall.cTueMar1413:10:212006-0700#include<xen/config.h>#include<xen/errno.h>#include<asm/vmx_vcpu.h>#include<public/xen.h>#include<public/event_channel.h>#include<asm/vmmu.h>#include<asm/tlb.h>#
ASSERT(extratime=1,slice=0)#attempttodisableextratimewithoutsettingsliceextratime="0"opts="%s-e%s"%(domain.getName(),extratime)(status,output)=traceCommand("xmsched-sedf%s"%(opts))#weshouldseethisoutputfromxmeyecatcher="Failedtosetsedfparameters"#checkforfailureifoutput.find(eyecatcher)>=0:FAIL("sched-sedfletmedisableextratimewithoutanon-zeroslice")#Stopthedomain(niceshutdown)domain.stop()++b/tools/xm-test/tests/sedf/Makefile.amTueMar1413:50:352006-0700TESTS=01_sedf_period_slice_pos.test02_sedf_period_lower_neg.test03_sedf_slice_lower_neg.test04_sedf_slice_upper_neg.test05_sedf_extratime_pos.test06_sedf_extratime_disable_neg.test++b/xen/MakefileTueMar1413:50:352006-0700exportXEN_EXTRAVERSION=-unstable++b/xen/Rules.mkTueMar1413:50:352006-0700ifneq($(debug)$(verbose),nn)++b/xen/arch/ia64/Rules.mkTueMar1413:50:352006-0700CFLAGS+=-nostdinc-fno-builtin-fno-common-fno-strict-aliasing++b/xen/arch/ia64/vmx/vmx_hypercall.cTueMar1413:50:352006-0700#include<xen/guest_access.h>VCPU*vcpu=current;#
ASSERT(extratime=1,slice=0)#attempttodisableextratimewithoutsettingsliceextratime="0"opts="%s-e%s"%(domain.getName(),extratime)(status,output)=traceCommand("xmsched-sedf%s"%(opts))#weshouldseethisoutputfromxmeyecatcher="Failedtosetsedfparameters"#checkforfailureifoutput.find(eyecatcher)>=0:FAIL("sched-sedfletmedisableextratimewithoutanon-zeroslice")#Stopthedomain(niceshutdown)domain.stop()++b/tools/xm-test/tests/sedf/Makefile.amTueMar1413:50:352006-0700TESTS=01_sedf_period_slice_pos.test02_sedf_period_lower_neg.test03_sedf_slice_lower_neg.test04_sedf_slice_upper_neg.test05_sedf_extratime_pos.test06_sedf_extratime_disable_neg.test++b/xen/MakefileTueMar1413:50:352006-0700exportXEN_EXTRAVERSION=-unstable++b/xen/Rules.mkTueMar1413:50:352006-0700ifneq($(debug)$(verbose),nn)++b/xen/arch/ia64/Rules.mkTueMar1413:50:352006-0700CFLAGS+=-nostdinc-fno-builtin-fno-common-fno-strict-aliasing++b/xen/arch/ia64/vmx/vmx_hypercall.cTueMar1413:50:352006-0700#include<xen/guest_access.h>u64r32,ret;
ASSERT((x&PGT_validated)||ia64_fph_enable();
ASSERT(t==PGC_SH2_fl1_32_shadow||t==PGC_SH2_fl1_pae_shadow||t==PGC_SH2_fl1_64_shadow||t==PGC_SH2_monitor_table||(page_get_owner(mfn_to_page(_mfn(pg->u.inuse.type_info)))==v->domain));
ASSERT(valid_mfn(gmfn)&&(sh2_mfn_is_a_page_table(gmfn)||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask)==0)));
ASSERT(t==PGC_SH_fl1_32_shadow||t==PGC_SH_fl1_pae_shadow||t==PGC_SH_fl1_64_shadow||t==PGC_SH_monitor_table||(page_get_owner(mfn_to_page(_mfn(pg->u.inuse.type_info)))==v->domain));
ASSERT(valid_mfn(gmfn)&&(sh_mfn_is_a_page_table(gmfn)||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask)==0)));
ASSERT(valid_mfn(gmfn)if(unlikely(GUEST_PAGING_LEVELS==3&&level==3))returnflags;
ASSERT((mfn_to_page(smfn)->count_info&PGC_SH_type_mask)==PGC_SH_l3_pae_shadow);
ASSERT((diff!=0)||vm86_mode(r)||((r->cs&3)>=GUEST_KERNEL_RPL)||(r->cs==0)||is_hvm_vcpu(current));
ASSERT(t==SH_type_fl1_32_shadow||t==SH_type_fl1_pae_shadow||t==SH_type_fl1_64_shadow||t==SH_type_monitor_table||==v->domain));/*Thedown-shiftsherearesothattheswitchstatementisonnice*smallnumbersthatthecompilerwillenjoy*/switch(t>>PGC_SH_type_shift){#ifCONFIG_PAGING_LEVELS==2casePGC_SH_l1_32_shadow>>PGC_SH_type_shift:casePGC_SH_fl1_32_shadow>>PGC_SH_type_shift:
ASSERT(t==SH_type_fl1_32_shadow||t==SH_type_fl1_pae_shadow||t==SH_type_fl1_64_shadow||t==SH_type_monitor_table||switch(t)caseSH_type_l1_32_shadow:caseSH_type_fl1_32_shadow:SHADOW_INTERNAL_NAME(sh_destroy_l1_shadow,2,2)(v,smfn);
ASSERT((devfn!=PCI_ISA_DEVFN)||((vendor_id==0x8086)&&(device_id==0x7000)));&&(sh_mfn_is_a_page_table(gmfn)||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask)
ASSERT(mfn_valid(gmfn)==0)));/*Wedon'tshadowPAEl3s*/
ASSERT(t==SH_type_fl1_32_shadow||t==SH_type_fl1_pae_shadow||t==SH_type_fl1_64_shadow||t==SH_type_monitor_table||switch(t)caseSH_type_l1_32_shadow:caseSH_type_fl1_32_shadow:SHADOW_INTERNAL_NAME(sh_destroy_l1_shadow,2,2)(v,smfn)
ASSERT(ep&&!(((unsignedlong)ep)&((sizeof*ep)-1)));&&(sh_mfn_is_a_page_table(gmfn)||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask)
ASSERT(mfn_valid(gmfn)==0)))
ASSERT(mfn_valid(gmfn)&&(sh_mfn_is_a_page_table(gmfn)||((mfn_to_page(gmfn)->u.inuse.type_info&PGT_count_mask)==0)));
ASSERT((page->shadow_flags&(SHF_L4_64|SHF_L3_64|SHF_L2H_64|SHF_L2_64|SHF_L1_64))==0);
ASSERT((fd==-1&&(flags==(MAP_SHARED|MAP_ANON)||flags==(MAP_PRIVATE|MAP_ANON)))||(fd!=-1&&flags==MAP_SHARED));
ASSERT((page->u.inuse.type_info&PGT_type_mask)!=PGT_writable_page||(page->u.inuse.type_info&PGT_count_mask)==0clear_bit(type,&page->shadow_flags);
ASSERT((dirty_vram->sl1ma[i]&PAGE_MASK)==(sl1ma&PAGE_MASK));
ASSERT(l4e_get_flags(idle_pg_table[l4_table_offset(RO_MPT_VIRT_START)])&_PAGE_PRESENT);
ASSERT(pg->u.sh.type==SH_type_l1_32_shadow||pg->u.sh.type==SH_type_fl1_32_shadow||pg->u.sh.type==SH_type_l2_32_shadow);*anddoingsotriggersthe
ASSERT(va>=XEN_VIRT_START)*in__virt_to_maddr()**Soasacompromisepre-allocatethemwhenxenboots.*Thisfunctionmustbecalledfromwithinstart_xen()when*itisvalidtouse_xmalloc()*//*shadowI/Opermissionbitmaps*/if(boot_cpu_data.x86_vendor==X86_VENDOR_INTEL){/*Sameformatashvm_io_bitmap*/shadow_io_bitmap[0]=_xmalloc(IOBITMAP_VMX_SIZE,PAGE_SIZE);
ASSERT(!(mfn_to_page(gmfn)->shadow_flags&SHF_page_type_maskSHADOW_PRINTK("d=%d,v=%dn",v->domain->domain_id,v->vcpu_id);
ASSERT((cfg->used_vectors==NULL)||(cfg->used_vectors==irq_used_vectors));
ASSERT((cfg->used_vectors==NULL)ret=__assign_irq_vector(irq,cfg,TARGET_CPUS);
ASSERT((desc->arch.used_vectors==NULL)||(desc->arch.used_vectors==irq_used_vectors));
ASSERT((((unsignedlong)va)>=MAPCACHE_VIRT_START)&&(((unsignedlong)va)<=MAPCACHE_VIRT_END))
